<?xml version="1.0" encoding="utf-8"?>
<root>
  <assemblies>
    <assembly name="Microsoft.CodeAnalysis, Version=2.3.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35">
      <attributes>
        <attribute>AssemblyCompany("Microsoft Corporation")</attribute>
        <attribute>AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</attribute>
        <attribute>AssemblyFileVersion("2.3.0.61908")</attribute>
        <attribute>AssemblyInformationalVersion("2.3.0-beta4-61908-01. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c")</attribute>
        <attribute>AssemblyMetadata("Serviceable", "True")</attribute>
        <attribute>RuntimeCompatibility(WrapNonExceptionThrows = true)</attribute>
        <attribute>TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")</attribute>
      </attributes>
    </assembly>
    <assembly name="Microsoft.CodeAnalysis.CSharp, Version=2.3.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35">
      <attributes>
        <attribute>AssemblyCompany("Microsoft Corporation")</attribute>
        <attribute>AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</attribute>
        <attribute>AssemblyFileVersion("2.3.0.61908")</attribute>
        <attribute>AssemblyInformationalVersion("2.3.0-beta4-61908-01. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c")</attribute>
        <attribute>AssemblyMetadata("Serviceable", "True")</attribute>
        <attribute>CommitHash("281ac90b8b5dd9fd923a353afd4af74f3246ca5c")</attribute>
        <attribute>RuntimeCompatibility(WrapNonExceptionThrows = true)</attribute>
        <attribute>TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")</attribute>
      </attributes>
    </assembly>
    <assembly name="Microsoft.CodeAnalysis.CSharp.Workspaces, Version=2.3.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35">
      <attributes>
        <attribute>AssemblyCompany("Microsoft Corporation")</attribute>
        <attribute>AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</attribute>
        <attribute>AssemblyFileVersion("2.3.0.61908")</attribute>
        <attribute>AssemblyInformationalVersion("2.3.0-beta4-61908-01. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c")</attribute>
        <attribute>AssemblyMetadata("Serviceable", "True")</attribute>
        <attribute>RuntimeCompatibility(WrapNonExceptionThrows = true)</attribute>
        <attribute>TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")</attribute>
      </attributes>
    </assembly>
    <assembly name="Microsoft.CodeAnalysis.Workspaces, Version=2.3.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35">
      <attributes>
        <attribute>AssemblyCompany("Microsoft Corporation")</attribute>
        <attribute>AssemblyCopyright("© Microsoft Corporation. All rights reserved.")</attribute>
        <attribute>AssemblyFileVersion("2.3.0.61908")</attribute>
        <attribute>AssemblyInformationalVersion("2.3.0-beta4-61908-01. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c")</attribute>
        <attribute>AssemblyMetadata("Serviceable", "True")</attribute>
        <attribute>RuntimeCompatibility(WrapNonExceptionThrows = true)</attribute>
        <attribute>TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")</attribute>
      </attributes>
    </assembly>
    <assembly name="Roslynator.Core, Version=1.0.0.10, Culture=neutral, PublicKeyToken=3aeedfaf14b2cebf">
      <attributes>
        <attribute>AssemblyCompany("Josef Pihrt")</attribute>
        <attribute>AssemblyConfiguration("Debug")</attribute>
        <attribute>AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")</attribute>
        <attribute>AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.Common.")</attribute>
        <attribute>AssemblyFileVersion("1.0.0.10")</attribute>
        <attribute>AssemblyInformationalVersion("1.0.0.10")</attribute>
        <attribute>AssemblyProduct("Roslynator.Core")</attribute>
        <attribute>AssemblyTitle("Roslynator.Core")</attribute>
        <attribute>AssemblyVersion("1.0.0.10")</attribute>
        <attribute>TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")</attribute>
      </attributes>
    </assembly>
    <assembly name="Roslynator.CSharp, Version=1.0.0.10, Culture=neutral, PublicKeyToken=390be46f77b79f52">
      <attributes>
        <attribute>AssemblyCompany("Josef Pihrt")</attribute>
        <attribute>AssemblyConfiguration("Debug")</attribute>
        <attribute>AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")</attribute>
        <attribute>AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.CSharp\n\nCommonly Used Types:\nRoslynator.CSharp.CSharpFactory\nRoslynator.CSharp.CSharpFacts\nRoslynator.CSharp.SyntaxInfo\nRoslynator.NameGenerator")</attribute>
        <attribute>AssemblyFileVersion("1.0.0.10")</attribute>
        <attribute>AssemblyInformationalVersion("1.0.0.10")</attribute>
        <attribute>AssemblyProduct("Roslynator.CSharp")</attribute>
        <attribute>AssemblyTitle("Roslynator.CSharp")</attribute>
        <attribute>AssemblyVersion("1.0.0.10")</attribute>
        <attribute>TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")</attribute>
      </attributes>
    </assembly>
    <assembly name="Roslynator.CSharp.Workspaces, Version=1.0.0.10, Culture=neutral, PublicKeyToken=ec3f0c29a7973f23">
      <attributes>
        <attribute>AssemblyCompany("Josef Pihrt")</attribute>
        <attribute>AssemblyConfiguration("Debug")</attribute>
        <attribute>AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")</attribute>
        <attribute>AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.CSharp.Workspaces\n\nCommonly Used Types:\nRoslynator.CSharp.CSharpFactory\nRoslynator.CSharp.CSharpFacts\nRoslynator.CSharp.SyntaxInfo\nRoslynator.NameGenerator")</attribute>
        <attribute>AssemblyFileVersion("1.0.0.10")</attribute>
        <attribute>AssemblyInformationalVersion("1.0.0.10")</attribute>
        <attribute>AssemblyProduct("Roslynator.CSharp.Workspaces")</attribute>
        <attribute>AssemblyTitle("Roslynator.CSharp.Workspaces")</attribute>
        <attribute>AssemblyVersion("1.0.0.10")</attribute>
        <attribute>TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")</attribute>
      </attributes>
    </assembly>
    <assembly name="Roslynator.Workspaces.Core, Version=1.0.0.10, Culture=neutral, PublicKeyToken=be1ec334fe31b7bb">
      <attributes>
        <attribute>AssemblyCompany("Josef Pihrt")</attribute>
        <attribute>AssemblyConfiguration("Debug")</attribute>
        <attribute>AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")</attribute>
        <attribute>AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.Workspaces.Common.")</attribute>
        <attribute>AssemblyFileVersion("1.0.0.10")</attribute>
        <attribute>AssemblyInformationalVersion("1.0.0.10")</attribute>
        <attribute>AssemblyProduct("Roslynator.Workspaces.Core")</attribute>
        <attribute>AssemblyTitle("Roslynator.Workspaces.Core")</attribute>
        <attribute>AssemblyVersion("1.0.0.10")</attribute>
        <attribute>TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")</attribute>
      </attributes>
    </assembly>
  </assemblies>
  <types>
    <type def="public class System.Object">
      <type def="public abstract class System.Attribute">
        <type def="public class System.Composition.ExportAttribute : Attribute">
          <type def="public sealed class Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute : ExportAttribute">
            <members>
              <member def="public ExportCodeFixProviderAttribute(string firstLanguage, params string[] additionalLanguages)" />
              <member def="public string[] Languages { get; }" />
              <member def="public string Name { get; set; }" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute : ExportAttribute">
            <members>
              <member def="public ExportCodeRefactoringProviderAttribute(string firstLanguage, params string[] additionalLanguages)" />
              <member def="public string[] Languages { get; }" />
              <member def="public string Name { get; set; }" />
            </members>
          </type>
          <type def="public class Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute : ExportAttribute">
            <members>
              <member def="public ExportLanguageServiceAttribute(Type type, string language, string layer = &quot;Default&quot;)" />
              <member def="public string Language { get; }" />
              <member def="public string Layer { get; }" />
              <member def="public string ServiceType { get; }" />
            </members>
          </type>
          <type def="public class Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute : ExportAttribute">
            <members>
              <member def="public ExportLanguageServiceFactoryAttribute(Type type, string language, string layer = &quot;Default&quot;)" />
              <member def="public string Language { get; }" />
              <member def="public string Layer { get; }" />
              <member def="public string ServiceType { get; }" />
            </members>
          </type>
          <type def="public class Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute : ExportAttribute">
            <members>
              <member def="public ExportWorkspaceServiceAttribute(Type serviceType, string layer = &quot;Default&quot;)" />
              <member def="public string Layer { get; }" />
              <member def="public string ServiceType { get; }" />
            </members>
          </type>
          <type def="public class Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute : ExportAttribute">
            <members>
              <member def="public ExportWorkspaceServiceFactoryAttribute(Type serviceType, string layer = &quot;Default&quot;)" />
              <member def="public string Layer { get; }" />
              <member def="public string ServiceType { get; }" />
            </members>
          </type>
        </type>
        <type def="public sealed class Microsoft.CodeAnalysis.ExtensionOrderAttribute : Attribute">
          <members>
            <member def="public ExtensionOrderAttribute()" />
            <member def="public string After { get; set; }" />
            <member def="public string Before { get; set; }" />
          </members>
        </type>
        <type def="public sealed class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerAttribute : Attribute">
          <members>
            <member def="public DiagnosticAnalyzerAttribute(string firstLanguage, params string[] additionalLanguages)" />
            <member def="public string[] Languages { get; }" />
          </members>
        </type>
      </type>
      <type def="public abstract class System.Delegate">
        <type def="public abstract class System.MulticastDelegate : Delegate">
          <type def="public delegate Task Microsoft.CodeAnalysis.Editing.SymbolEditor.AsyncDeclarationEditAction(DocumentEditor editor, SyntaxNode declaration, CancellationToken cancellationToken)" />
          <type def="public delegate void Microsoft.CodeAnalysis.Editing.SymbolEditor.DeclarationEditAction(DocumentEditor editor, SyntaxNode declaration)" />
          <type def="public delegate bool Microsoft.CodeAnalysis.Host.HostWorkspaceServices.MetadataFilter(IReadOnlyDictionary&lt;string, object&gt; metadata)" />
        </type>
      </type>
      <type def="public class System.EventArgs">
        <type def="public sealed class Microsoft.CodeAnalysis.DocumentActiveContextChangedEventArgs : EventArgs">
          <members>
            <member def="public DocumentActiveContextChangedEventArgs(Solution solution, SourceTextContainer sourceTextContainer, DocumentId oldActiveContextDocumentId, DocumentId newActiveContextDocumentId)" />
            <member def="public DocumentId NewActiveContextDocumentId { get; }" />
            <member def="public DocumentId OldActiveContextDocumentId { get; }" />
            <member def="public Solution Solution { get; }" />
            <member def="public SourceTextContainer SourceTextContainer { get; }" />
          </members>
        </type>
        <type def="public class Microsoft.CodeAnalysis.DocumentEventArgs : EventArgs">
          <members>
            <member def="public DocumentEventArgs(Document document)" />
            <member def="public Document Document { get; }" />
          </members>
        </type>
        <type def="public class Microsoft.CodeAnalysis.WorkspaceChangeEventArgs : EventArgs">
          <members>
            <member def="public WorkspaceChangeEventArgs(WorkspaceChangeKind kind, Solution oldSolution, Solution newSolution, ProjectId projectId = null, DocumentId documentId = null)" />
            <member def="public DocumentId DocumentId { get; }" />
            <member def="public WorkspaceChangeKind Kind { get; }" />
            <member def="public Solution NewSolution { get; }" />
            <member def="public Solution OldSolution { get; }" />
            <member def="public ProjectId ProjectId { get; }" />
          </members>
        </type>
        <type def="public class Microsoft.CodeAnalysis.WorkspaceDiagnosticEventArgs : EventArgs">
          <members>
            <member def="public WorkspaceDiagnosticEventArgs(WorkspaceDiagnostic diagnostic)" />
            <member def="public WorkspaceDiagnostic Diagnostic { get; }" />
          </members>
        </type>
        <type def="public sealed class Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs : EventArgs">
          <members>
            <member def="public AnalyzerLoadFailureEventArgs(AnalyzerLoadFailureEventArgs.FailureErrorCode errorCode, string message, Exception exceptionOpt = null, string typeNameOpt = null)" />
            <member def="public AnalyzerLoadFailureEventArgs.FailureErrorCode ErrorCode { get; }" />
            <member def="public Exception Exception { get; }" />
            <member def="public string Message { get; }" />
            <member def="public string TypeName { get; }" />
          </members>
        </type>
        <type def="public class Microsoft.CodeAnalysis.Text.TextChangeEventArgs : EventArgs">
          <members>
            <member def="public TextChangeEventArgs(SourceText oldText, SourceText newText, IEnumerable&lt;TextChangeRange&gt; changes)" />
            <member def="public TextChangeEventArgs(SourceText oldText, SourceText newText, params TextChangeRange[] changes)" />
            <member def="public IReadOnlyList&lt;TextChangeRange&gt; Changes { get; }" />
            <member def="public SourceText NewText { get; }" />
            <member def="public SourceText OldText { get; }" />
          </members>
        </type>
      </type>
      <type def="public abstract class System.ValueType">
        <type def="public abstract class System.Enum : ValueType, IComparable, IConvertible, IFormattable">
          <type def="public enum Microsoft.CodeAnalysis.Accessibility">
            <members>
              <member def="NotApplicable = 0" />
              <member def="Private = 1" />
              <member def="ProtectedAndInternal = 2" />
              <member def="ProtectedAndFriend = 2" />
              <member def="Protected = 3" />
              <member def="Internal = 4" />
              <member def="Friend = 4" />
              <member def="ProtectedOrInternal = 5" />
              <member def="ProtectedOrFriend = 5" />
              <member def="Public = 6" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.ApplyChangesKind">
            <members>
              <member def="AddProject = 0" />
              <member def="RemoveProject = 1" />
              <member def="AddProjectReference = 2" />
              <member def="RemoveProjectReference = 3" />
              <member def="AddMetadataReference = 4" />
              <member def="RemoveMetadataReference = 5" />
              <member def="AddDocument = 6" />
              <member def="RemoveDocument = 7" />
              <member def="ChangeDocument = 8" />
              <member def="AddAnalyzerReference = 9" />
              <member def="RemoveAnalyzerReference = 10" />
              <member def="AddAdditionalDocument = 11" />
              <member def="RemoveAdditionalDocument = 12" />
              <member def="ChangeAdditionalDocument = 13" />
              <member def="ChangeCompilationOptions = 14" />
              <member def="ChangeParseOptions = 15" />
              <member def="ChangeDocumentInfo = 16" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.AssemblyIdentityComparer.ComparisonResult">
            <members>
              <member def="NotEquivalent = 0" />
              <member def="Equivalent = 1" />
              <member def="EquivalentIgnoringVersion = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.AssemblyIdentityParts">
            <members>
              <member def="Name = 1" />
              <member def="Version = VersionMajor | VersionMinor | VersionBuild | VersionRevision" />
              <member def="VersionMajor = 2" />
              <member def="VersionMinor = 4" />
              <member def="VersionBuild = 8" />
              <member def="VersionRevision = 16" />
              <member def="Culture = 32" />
              <member def="PublicKey = 64" />
              <member def="PublicKeyToken = 128" />
              <member def="PublicKeyOrToken = PublicKey | PublicKeyToken" />
              <member def="Retargetability = 256" />
              <member def="ContentType = 512" />
              <member def="Unknown = 1024" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.CandidateReason">
            <members>
              <member def="None = 0" />
              <member def="NotATypeOrNamespace = 1" />
              <member def="NotAnEvent = 2" />
              <member def="NotAWithEventsMember = 3" />
              <member def="NotAnAttributeType = 4" />
              <member def="WrongArity = 5" />
              <member def="NotCreatable = 6" />
              <member def="NotReferencable = 7" />
              <member def="Inaccessible = 8" />
              <member def="NotAValue = 9" />
              <member def="NotAVariable = 10" />
              <member def="NotInvocable = 11" />
              <member def="StaticInstanceMismatch = 12" />
              <member def="OverloadResolutionFailure = 13" />
              <member def="LateBound = 14" />
              <member def="Ambiguous = 15" />
              <member def="MemberGroup = 16" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.DiagnosticSeverity">
            <members>
              <member def="Hidden = 0" />
              <member def="Info = 1" />
              <member def="Warning = 2" />
              <member def="Error = 3" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.DocumentationMode">
            <members>
              <member def="None = 0" />
              <member def="Parse = 1" />
              <member def="Diagnose = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.LineVisibility">
            <members>
              <member def="BeforeFirstLineDirective = 0" />
              <member def="Hidden = 1" />
              <member def="Visible = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.LocationKind">
            <members>
              <member def="None = 0" />
              <member def="SourceFile = 1" />
              <member def="MetadataFile = 2" />
              <member def="XmlFile = 3" />
              <member def="ExternalFile = 4" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.MetadataImageKind">
            <members>
              <member def="Assembly = 0" />
              <member def="Module = 1" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.MethodKind">
            <members>
              <member def="AnonymousFunction = 0" />
              <member def="LambdaMethod = 0" />
              <member def="Constructor = 1" />
              <member def="Conversion = 2" />
              <member def="DelegateInvoke = 3" />
              <member def="Destructor = 4" />
              <member def="EventAdd = 5" />
              <member def="EventRaise = 6" />
              <member def="EventRemove = 7" />
              <member def="ExplicitInterfaceImplementation = 8" />
              <member def="UserDefinedOperator = 9" />
              <member def="Ordinary = 10" />
              <member def="PropertyGet = 11" />
              <member def="PropertySet = 12" />
              <member def="ReducedExtension = 13" />
              <member def="StaticConstructor = 14" />
              <member def="SharedConstructor = 14" />
              <member def="BuiltinOperator = 15" />
              <member def="DeclareMethod = 16" />
              <member def="LocalFunction = 17" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.NamespaceKind">
            <members>
              <member def="Module = 1" />
              <member def="Assembly = 2" />
              <member def="Compilation = 3" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.OperationKind">
            <members>
              <member def="None = 0" />
              <member def="InvalidStatement = 1" />
              <member def="BlockStatement = 2" />
              <member def="VariableDeclarationStatement = 3" />
              <member def="SwitchStatement = 4" />
              <member def="IfStatement = 5" />
              <member def="LoopStatement = 6" />
              <member def="LabelStatement = 7" />
              <member def="BranchStatement = 8" />
              <member def="EmptyStatement = 9" />
              <member def="ThrowStatement = 10" />
              <member def="ReturnStatement = 11" />
              <member def="YieldBreakStatement = 12" />
              <member def="LockStatement = 13" />
              <member def="TryStatement = 14" />
              <member def="UsingStatement = 15" />
              <member def="YieldReturnStatement = 16" />
              <member def="ExpressionStatement = 17" />
              <member def="FixedStatement = 48" />
              <member def="LocalFunctionStatement = 49" />
              <member def="StopStatement = 80" />
              <member def="EndStatement = 81" />
              <member def="WithStatement = 82" />
              <member def="InvalidExpression = 256" />
              <member def="LiteralExpression = 257" />
              <member def="ConversionExpression = 258" />
              <member def="InvocationExpression = 259" />
              <member def="ArrayElementReferenceExpression = 260" />
              <member def="LocalReferenceExpression = 261" />
              <member def="ParameterReferenceExpression = 262" />
              <member def="SyntheticLocalReferenceExpression = 263" />
              <member def="FieldReferenceExpression = 264" />
              <member def="MethodBindingExpression = 265" />
              <member def="PropertyReferenceExpression = 266" />
              <member def="IndexedPropertyReferenceExpression = 267" />
              <member def="EventReferenceExpression = 268" />
              <member def="UnaryOperatorExpression = 269" />
              <member def="BinaryOperatorExpression = 270" />
              <member def="ConditionalChoiceExpression = 271" />
              <member def="NullCoalescingExpression = 272" />
              <member def="LambdaExpression = 273" />
              <member def="ObjectCreationExpression = 274" />
              <member def="TypeParameterObjectCreationExpression = 275" />
              <member def="ArrayCreationExpression = 276" />
              <member def="InstanceReferenceExpression = 277" />
              <member def="IsTypeExpression = 278" />
              <member def="AwaitExpression = 279" />
              <member def="AssignmentExpression = 280" />
              <member def="CompoundAssignmentExpression = 281" />
              <member def="ParenthesizedExpression = 282" />
              <member def="EventAssignmentExpression = 283" />
              <member def="ConditionalAccessExpression = 284" />
              <member def="ConditionalAccessInstanceExpression = 285" />
              <member def="DefaultValueExpression = 512" />
              <member def="TypeOfExpression = 513" />
              <member def="SizeOfExpression = 514" />
              <member def="AddressOfExpression = 515" />
              <member def="PointerIndirectionReferenceExpression = 516" />
              <member def="UnboundLambdaExpression = 517" />
              <member def="IncrementExpression = 518" />
              <member def="OmittedArgumentExpression = 768" />
              <member def="LateBoundMemberReferenceExpression = 769" />
              <member def="PlaceholderExpression = 770" />
              <member def="FieldInitializerInCreation = 1024" />
              <member def="FieldInitializerAtDeclaration = 1025" />
              <member def="PropertyInitializerInCreation = 1026" />
              <member def="PropertyInitializerAtDeclaration = 1027" />
              <member def="ParameterInitializerAtDeclaration = 1028" />
              <member def="ArrayInitializer = 1029" />
              <member def="VariableDeclaration = 1030" />
              <member def="Argument = 1031" />
              <member def="CatchClause = 1032" />
              <member def="SwitchCase = 1033" />
              <member def="SingleValueCaseClause = 1034" />
              <member def="RelationalCaseClause = 1035" />
              <member def="RangeCaseClause = 1036" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.OptimizationLevel">
            <members>
              <member def="Debug = 0" />
              <member def="Release = 1" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.OutputKind">
            <members>
              <member def="ConsoleApplication = 0" />
              <member def="WindowsApplication = 1" />
              <member def="DynamicallyLinkedLibrary = 2" />
              <member def="NetModule = 3" />
              <member def="WindowsRuntimeMetadata = 4" />
              <member def="WindowsRuntimeApplication = 5" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Platform">
            <members>
              <member def="AnyCpu = 0" />
              <member def="X86 = 1" />
              <member def="X64 = 2" />
              <member def="Itanium = 3" />
              <member def="AnyCpu32BitPreferred = 4" />
              <member def="Arm = 5" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.PreservationMode">
            <members>
              <member def="PreserveValue = 0" />
              <member def="PreserveIdentity = 1" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.RefKind">
            <members>
              <member def="None = 0" />
              <member def="Ref = 1" />
              <member def="Out = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.ReportDiagnostic">
            <members>
              <member def="Default = 0" />
              <member def="Error = 1" />
              <member def="Warn = 2" />
              <member def="Info = 3" />
              <member def="Hidden = 4" />
              <member def="Suppress = 5" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SourceCodeKind">
            <members>
              <member def="Regular = 0" />
              <member def="Script = 1" />
              <member def="Interactive = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SpecialType">
            <members>
              <member def="None = 0" />
              <member def="System_Object = 1" />
              <member def="System_Enum = 2" />
              <member def="System_MulticastDelegate = 3" />
              <member def="System_Delegate = 4" />
              <member def="System_ValueType = 5" />
              <member def="System_Void = 6" />
              <member def="System_Boolean = 7" />
              <member def="System_Char = 8" />
              <member def="System_SByte = 9" />
              <member def="System_Byte = 10" />
              <member def="System_Int16 = 11" />
              <member def="System_UInt16 = 12" />
              <member def="System_Int32 = 13" />
              <member def="System_UInt32 = 14" />
              <member def="System_Int64 = 15" />
              <member def="System_UInt64 = 16" />
              <member def="System_Decimal = 17" />
              <member def="System_Single = 18" />
              <member def="System_Double = 19" />
              <member def="System_String = 20" />
              <member def="System_IntPtr = 21" />
              <member def="System_UIntPtr = 22" />
              <member def="System_Array = 23" />
              <member def="System_Collections_IEnumerable = 24" />
              <member def="System_Collections_Generic_IEnumerable_T = 25" />
              <member def="System_Collections_Generic_IList_T = 26" />
              <member def="System_Collections_Generic_ICollection_T = 27" />
              <member def="System_Collections_IEnumerator = 28" />
              <member def="System_Collections_Generic_IEnumerator_T = 29" />
              <member def="System_Collections_Generic_IReadOnlyList_T = 30" />
              <member def="System_Collections_Generic_IReadOnlyCollection_T = 31" />
              <member def="System_Nullable_T = 32" />
              <member def="System_DateTime = 33" />
              <member def="System_Runtime_CompilerServices_IsVolatile = 34" />
              <member def="System_IDisposable = 35" />
              <member def="System_TypedReference = 36" />
              <member def="System_ArgIterator = 37" />
              <member def="System_RuntimeArgumentHandle = 38" />
              <member def="System_RuntimeFieldHandle = 39" />
              <member def="System_RuntimeMethodHandle = 40" />
              <member def="System_RuntimeTypeHandle = 41" />
              <member def="System_IAsyncResult = 42" />
              <member def="System_AsyncCallback = 43" />
              <member def="Count = 43" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SpeculativeBindingOption">
            <members>
              <member def="BindAsExpression = 0" />
              <member def="BindAsTypeOrNamespace = 1" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle">
            <members>
              <member def="NameOnly = 0" />
              <member def="NameAndParameters = 1" />
              <member def="NameAndSignature = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle">
            <members>
              <member def="Default = 0" />
              <member def="InstanceMethod = 1" />
              <member def="StaticMethod = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions">
            <members>
              <member def="None = 0" />
              <member def="IncludeTypeParameters = 1" />
              <member def="IncludeTypeConstraints = 2" />
              <member def="IncludeVariance = 4" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle">
            <members>
              <member def="Omitted = 0" />
              <member def="OmittedAsContaining = 1" />
              <member def="Included = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SymbolDisplayKindOptions">
            <members>
              <member def="None = 0" />
              <member def="IncludeNamespaceKeyword = 1" />
              <member def="IncludeTypeKeyword = 2" />
              <member def="IncludeMemberKeyword = 4" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SymbolDisplayLocalOptions">
            <members>
              <member def="None = 0" />
              <member def="IncludeType = 1" />
              <member def="IncludeConstantValue = 2" />
              <member def="IncludeRef = 4" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SymbolDisplayMemberOptions">
            <members>
              <member def="None = 0" />
              <member def="IncludeType = 1" />
              <member def="IncludeModifiers = 2" />
              <member def="IncludeAccessibility = 4" />
              <member def="IncludeExplicitInterface = 8" />
              <member def="IncludeParameters = 16" />
              <member def="IncludeContainingType = 32" />
              <member def="IncludeConstantValue = 64" />
              <member def="IncludeRef = 128" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions">
            <members>
              <member def="None = 0" />
              <member def="UseSpecialTypes = 1" />
              <member def="EscapeKeywordIdentifiers = 2" />
              <member def="UseAsterisksInMultiDimensionalArrays = 4" />
              <member def="UseErrorTypeSymbolName = 8" />
              <member def="RemoveAttributeSuffix = 16" />
              <member def="ExpandNullable = 32" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SymbolDisplayParameterOptions">
            <members>
              <member def="None = 0" />
              <member def="IncludeExtensionThis = 1" />
              <member def="IncludeParamsRefOut = 2" />
              <member def="IncludeType = 4" />
              <member def="IncludeName = 8" />
              <member def="IncludeDefaultValue = 16" />
              <member def="IncludeOptionalBrackets = 32" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SymbolDisplayPartKind">
            <members>
              <member def="AliasName = 0" />
              <member def="AssemblyName = 1" />
              <member def="ClassName = 2" />
              <member def="DelegateName = 3" />
              <member def="EnumName = 4" />
              <member def="ErrorTypeName = 5" />
              <member def="EventName = 6" />
              <member def="FieldName = 7" />
              <member def="InterfaceName = 8" />
              <member def="Keyword = 9" />
              <member def="LabelName = 10" />
              <member def="LineBreak = 11" />
              <member def="NumericLiteral = 12" />
              <member def="StringLiteral = 13" />
              <member def="LocalName = 14" />
              <member def="MethodName = 15" />
              <member def="ModuleName = 16" />
              <member def="NamespaceName = 17" />
              <member def="Operator = 18" />
              <member def="ParameterName = 19" />
              <member def="PropertyName = 20" />
              <member def="Punctuation = 21" />
              <member def="Space = 22" />
              <member def="StructName = 23" />
              <member def="AnonymousTypeIndicator = 24" />
              <member def="Text = 25" />
              <member def="TypeParameterName = 26" />
              <member def="RangeVariableName = 27" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle">
            <members>
              <member def="NameOnly = 0" />
              <member def="ShowReadWriteDescriptor = 1" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle">
            <members>
              <member def="NameOnly = 0" />
              <member def="NameAndContainingTypes = 1" />
              <member def="NameAndContainingTypesAndNamespaces = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SymbolFilter">
            <members>
              <member def="None = 0" />
              <member def="Namespace = 1" />
              <member def="Type = 2" />
              <member def="Member = 4" />
              <member def="TypeAndMember = Type | Member" />
              <member def="All = Namespace | TypeAndMember" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SymbolKind">
            <members>
              <member def="Alias = 0" />
              <member def="ArrayType = 1" />
              <member def="Assembly = 2" />
              <member def="DynamicType = 3" />
              <member def="ErrorType = 4" />
              <member def="Event = 5" />
              <member def="Field = 6" />
              <member def="Label = 7" />
              <member def="Local = 8" />
              <member def="Method = 9" />
              <member def="NetModule = 10" />
              <member def="NamedType = 11" />
              <member def="Namespace = 12" />
              <member def="Parameter = 13" />
              <member def="PointerType = 14" />
              <member def="Property = 15" />
              <member def="RangeVariable = 16" />
              <member def="TypeParameter = 17" />
              <member def="Preprocessing = 18" />
              <member def="Discard = 19" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SyntaxRemoveOptions">
            <members>
              <member def="KeepNoTrivia = 0" />
              <member def="KeepLeadingTrivia = 1" />
              <member def="KeepTrailingTrivia = 2" />
              <member def="KeepExteriorTrivia = KeepLeadingTrivia | KeepTrailingTrivia" />
              <member def="KeepUnbalancedDirectives = 4" />
              <member def="KeepDirectives = 8" />
              <member def="KeepEndOfLine = 16" />
              <member def="AddElasticMarker = 32" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.SyntaxWalkerDepth">
            <members>
              <member def="Node = 0" />
              <member def="Token = 1" />
              <member def="Trivia = 2" />
              <member def="StructuredTrivia = 3" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.TypeKind">
            <members>
              <member def="Unknown = 0" />
              <member def="Array = 1" />
              <member def="Class = 2" />
              <member def="Delegate = 3" />
              <member def="Dynamic = 4" />
              <member def="Enum = 5" />
              <member def="Error = 6" />
              <member def="Interface = 7" />
              <member def="Module = 8" />
              <member def="Pointer = 9" />
              <member def="Struct = 10" />
              <member def="Structure = 10" />
              <member def="TypeParameter = 11" />
              <member def="Submission = 12" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.TypeParameterKind">
            <members>
              <member def="Type = 0" />
              <member def="Method = 1" />
              <member def="Cref = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.TypedConstantKind">
            <members>
              <member def="Error = 0" />
              <member def="Primitive = 1" />
              <member def="Enum = 2" />
              <member def="Type = 3" />
              <member def="Array = 4" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.VarianceKind">
            <members>
              <member def="None = 0" />
              <member def="Out = 1" />
              <member def="In = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.WorkspaceChangeKind">
            <members>
              <member def="SolutionChanged = 0" />
              <member def="SolutionAdded = 1" />
              <member def="SolutionRemoved = 2" />
              <member def="SolutionCleared = 3" />
              <member def="SolutionReloaded = 4" />
              <member def="ProjectAdded = 5" />
              <member def="ProjectRemoved = 6" />
              <member def="ProjectChanged = 7" />
              <member def="ProjectReloaded = 8" />
              <member def="DocumentAdded = 9" />
              <member def="DocumentRemoved = 10" />
              <member def="DocumentReloaded = 11" />
              <member def="DocumentChanged = 12" />
              <member def="AdditionalDocumentAdded = 13" />
              <member def="AdditionalDocumentRemoved = 14" />
              <member def="AdditionalDocumentReloaded = 15" />
              <member def="AdditionalDocumentChanged = 16" />
              <member def="DocumentInfoChanged = 17" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.WorkspaceDiagnosticKind">
            <members>
              <member def="Failure = 0" />
              <member def="Warning = 1" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.CSharp.LanguageVersion">
            <members>
              <member def="Default = 0" />
              <member def="CSharp1 = 1" />
              <member def="CSharp2 = 2" />
              <member def="CSharp3 = 3" />
              <member def="CSharp4 = 4" />
              <member def="CSharp5 = 5" />
              <member def="CSharp6 = 6" />
              <member def="CSharp7 = 7" />
              <member def="CSharp7_1 = 701" />
              <member def="Latest = 2147483647" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.CSharp.SyntaxKind">
            <members>
              <member def="None = 0" />
              <member def="List = 1" />
              <member def="TildeToken = 8193" />
              <member def="ExclamationToken = 8194" />
              <member def="DollarToken = 8195" />
              <member def="PercentToken = 8196" />
              <member def="CaretToken = 8197" />
              <member def="AmpersandToken = 8198" />
              <member def="AsteriskToken = 8199" />
              <member def="OpenParenToken = 8200" />
              <member def="CloseParenToken = 8201" />
              <member def="MinusToken = 8202" />
              <member def="PlusToken = 8203" />
              <member def="EqualsToken = 8204" />
              <member def="OpenBraceToken = 8205" />
              <member def="CloseBraceToken = 8206" />
              <member def="OpenBracketToken = 8207" />
              <member def="CloseBracketToken = 8208" />
              <member def="BarToken = 8209" />
              <member def="BackslashToken = 8210" />
              <member def="ColonToken = 8211" />
              <member def="SemicolonToken = 8212" />
              <member def="DoubleQuoteToken = 8213" />
              <member def="SingleQuoteToken = 8214" />
              <member def="LessThanToken = 8215" />
              <member def="CommaToken = 8216" />
              <member def="GreaterThanToken = 8217" />
              <member def="DotToken = 8218" />
              <member def="QuestionToken = 8219" />
              <member def="HashToken = 8220" />
              <member def="SlashToken = 8221" />
              <member def="SlashGreaterThanToken = 8232" />
              <member def="LessThanSlashToken = 8233" />
              <member def="XmlCommentStartToken = 8234" />
              <member def="XmlCommentEndToken = 8235" />
              <member def="XmlCDataStartToken = 8236" />
              <member def="XmlCDataEndToken = 8237" />
              <member def="XmlProcessingInstructionStartToken = 8238" />
              <member def="XmlProcessingInstructionEndToken = 8239" />
              <member def="BarBarToken = 8260" />
              <member def="AmpersandAmpersandToken = 8261" />
              <member def="MinusMinusToken = 8262" />
              <member def="PlusPlusToken = 8263" />
              <member def="ColonColonToken = 8264" />
              <member def="QuestionQuestionToken = 8265" />
              <member def="MinusGreaterThanToken = 8266" />
              <member def="ExclamationEqualsToken = 8267" />
              <member def="EqualsEqualsToken = 8268" />
              <member def="EqualsGreaterThanToken = 8269" />
              <member def="LessThanEqualsToken = 8270" />
              <member def="LessThanLessThanToken = 8271" />
              <member def="LessThanLessThanEqualsToken = 8272" />
              <member def="GreaterThanEqualsToken = 8273" />
              <member def="GreaterThanGreaterThanToken = 8274" />
              <member def="GreaterThanGreaterThanEqualsToken = 8275" />
              <member def="SlashEqualsToken = 8276" />
              <member def="AsteriskEqualsToken = 8277" />
              <member def="BarEqualsToken = 8278" />
              <member def="AmpersandEqualsToken = 8279" />
              <member def="PlusEqualsToken = 8280" />
              <member def="MinusEqualsToken = 8281" />
              <member def="CaretEqualsToken = 8282" />
              <member def="PercentEqualsToken = 8283" />
              <member def="BoolKeyword = 8304" />
              <member def="ByteKeyword = 8305" />
              <member def="SByteKeyword = 8306" />
              <member def="ShortKeyword = 8307" />
              <member def="UShortKeyword = 8308" />
              <member def="IntKeyword = 8309" />
              <member def="UIntKeyword = 8310" />
              <member def="LongKeyword = 8311" />
              <member def="ULongKeyword = 8312" />
              <member def="DoubleKeyword = 8313" />
              <member def="FloatKeyword = 8314" />
              <member def="DecimalKeyword = 8315" />
              <member def="StringKeyword = 8316" />
              <member def="CharKeyword = 8317" />
              <member def="VoidKeyword = 8318" />
              <member def="ObjectKeyword = 8319" />
              <member def="TypeOfKeyword = 8320" />
              <member def="SizeOfKeyword = 8321" />
              <member def="NullKeyword = 8322" />
              <member def="TrueKeyword = 8323" />
              <member def="FalseKeyword = 8324" />
              <member def="IfKeyword = 8325" />
              <member def="ElseKeyword = 8326" />
              <member def="WhileKeyword = 8327" />
              <member def="ForKeyword = 8328" />
              <member def="ForEachKeyword = 8329" />
              <member def="DoKeyword = 8330" />
              <member def="SwitchKeyword = 8331" />
              <member def="CaseKeyword = 8332" />
              <member def="DefaultKeyword = 8333" />
              <member def="TryKeyword = 8334" />
              <member def="CatchKeyword = 8335" />
              <member def="FinallyKeyword = 8336" />
              <member def="LockKeyword = 8337" />
              <member def="GotoKeyword = 8338" />
              <member def="BreakKeyword = 8339" />
              <member def="ContinueKeyword = 8340" />
              <member def="ReturnKeyword = 8341" />
              <member def="ThrowKeyword = 8342" />
              <member def="PublicKeyword = 8343" />
              <member def="PrivateKeyword = 8344" />
              <member def="InternalKeyword = 8345" />
              <member def="ProtectedKeyword = 8346" />
              <member def="StaticKeyword = 8347" />
              <member def="ReadOnlyKeyword = 8348" />
              <member def="SealedKeyword = 8349" />
              <member def="ConstKeyword = 8350" />
              <member def="FixedKeyword = 8351" />
              <member def="StackAllocKeyword = 8352" />
              <member def="VolatileKeyword = 8353" />
              <member def="NewKeyword = 8354" />
              <member def="OverrideKeyword = 8355" />
              <member def="AbstractKeyword = 8356" />
              <member def="VirtualKeyword = 8357" />
              <member def="EventKeyword = 8358" />
              <member def="ExternKeyword = 8359" />
              <member def="RefKeyword = 8360" />
              <member def="OutKeyword = 8361" />
              <member def="InKeyword = 8362" />
              <member def="IsKeyword = 8363" />
              <member def="AsKeyword = 8364" />
              <member def="ParamsKeyword = 8365" />
              <member def="ArgListKeyword = 8366" />
              <member def="MakeRefKeyword = 8367" />
              <member def="RefTypeKeyword = 8368" />
              <member def="RefValueKeyword = 8369" />
              <member def="ThisKeyword = 8370" />
              <member def="BaseKeyword = 8371" />
              <member def="NamespaceKeyword = 8372" />
              <member def="UsingKeyword = 8373" />
              <member def="ClassKeyword = 8374" />
              <member def="StructKeyword = 8375" />
              <member def="InterfaceKeyword = 8376" />
              <member def="EnumKeyword = 8377" />
              <member def="DelegateKeyword = 8378" />
              <member def="CheckedKeyword = 8379" />
              <member def="UncheckedKeyword = 8380" />
              <member def="UnsafeKeyword = 8381" />
              <member def="OperatorKeyword = 8382" />
              <member def="ExplicitKeyword = 8383" />
              <member def="ImplicitKeyword = 8384" />
              <member def="YieldKeyword = 8405" />
              <member def="PartialKeyword = 8406" />
              <member def="AliasKeyword = 8407" />
              <member def="GlobalKeyword = 8408" />
              <member def="AssemblyKeyword = 8409" />
              <member def="ModuleKeyword = 8410" />
              <member def="TypeKeyword = 8411" />
              <member def="FieldKeyword = 8412" />
              <member def="MethodKeyword = 8413" />
              <member def="ParamKeyword = 8414" />
              <member def="PropertyKeyword = 8415" />
              <member def="TypeVarKeyword = 8416" />
              <member def="GetKeyword = 8417" />
              <member def="SetKeyword = 8418" />
              <member def="AddKeyword = 8419" />
              <member def="RemoveKeyword = 8420" />
              <member def="WhereKeyword = 8421" />
              <member def="FromKeyword = 8422" />
              <member def="GroupKeyword = 8423" />
              <member def="JoinKeyword = 8424" />
              <member def="IntoKeyword = 8425" />
              <member def="LetKeyword = 8426" />
              <member def="ByKeyword = 8427" />
              <member def="SelectKeyword = 8428" />
              <member def="OrderByKeyword = 8429" />
              <member def="OnKeyword = 8430" />
              <member def="EqualsKeyword = 8431" />
              <member def="AscendingKeyword = 8432" />
              <member def="DescendingKeyword = 8433" />
              <member def="NameOfKeyword = 8434" />
              <member def="AsyncKeyword = 8435" />
              <member def="AwaitKeyword = 8436" />
              <member def="WhenKeyword = 8437" />
              <member def="ElifKeyword = 8467" />
              <member def="EndIfKeyword = 8468" />
              <member def="RegionKeyword = 8469" />
              <member def="EndRegionKeyword = 8470" />
              <member def="DefineKeyword = 8471" />
              <member def="UndefKeyword = 8472" />
              <member def="WarningKeyword = 8473" />
              <member def="ErrorKeyword = 8474" />
              <member def="LineKeyword = 8475" />
              <member def="PragmaKeyword = 8476" />
              <member def="HiddenKeyword = 8477" />
              <member def="ChecksumKeyword = 8478" />
              <member def="DisableKeyword = 8479" />
              <member def="RestoreKeyword = 8480" />
              <member def="ReferenceKeyword = 8481" />
              <member def="LoadKeyword = 8485" />
              <member def="InterpolatedStringStartToken = 8482" />
              <member def="InterpolatedStringEndToken = 8483" />
              <member def="InterpolatedVerbatimStringStartToken = 8484" />
              <member def="UnderscoreToken = 8491" />
              <member def="OmittedTypeArgumentToken = 8492" />
              <member def="OmittedArraySizeExpressionToken = 8493" />
              <member def="EndOfDirectiveToken = 8494" />
              <member def="EndOfDocumentationCommentToken = 8495" />
              <member def="EndOfFileToken = 8496" />
              <member def="BadToken = 8507" />
              <member def="IdentifierToken = 8508" />
              <member def="NumericLiteralToken = 8509" />
              <member def="CharacterLiteralToken = 8510" />
              <member def="StringLiteralToken = 8511" />
              <member def="XmlEntityLiteralToken = 8512" />
              <member def="XmlTextLiteralToken = 8513" />
              <member def="XmlTextLiteralNewLineToken = 8514" />
              <member def="InterpolatedStringToken = 8515" />
              <member def="InterpolatedStringTextToken = 8517" />
              <member def="EndOfLineTrivia = 8539" />
              <member def="WhitespaceTrivia = 8540" />
              <member def="SingleLineCommentTrivia = 8541" />
              <member def="MultiLineCommentTrivia = 8542" />
              <member def="DocumentationCommentExteriorTrivia = 8543" />
              <member def="SingleLineDocumentationCommentTrivia = 8544" />
              <member def="MultiLineDocumentationCommentTrivia = 8545" />
              <member def="DisabledTextTrivia = 8546" />
              <member def="PreprocessingMessageTrivia = 8547" />
              <member def="IfDirectiveTrivia = 8548" />
              <member def="ElifDirectiveTrivia = 8549" />
              <member def="ElseDirectiveTrivia = 8550" />
              <member def="EndIfDirectiveTrivia = 8551" />
              <member def="RegionDirectiveTrivia = 8552" />
              <member def="EndRegionDirectiveTrivia = 8553" />
              <member def="DefineDirectiveTrivia = 8554" />
              <member def="UndefDirectiveTrivia = 8555" />
              <member def="ErrorDirectiveTrivia = 8556" />
              <member def="WarningDirectiveTrivia = 8557" />
              <member def="LineDirectiveTrivia = 8558" />
              <member def="PragmaWarningDirectiveTrivia = 8559" />
              <member def="PragmaChecksumDirectiveTrivia = 8560" />
              <member def="ReferenceDirectiveTrivia = 8561" />
              <member def="BadDirectiveTrivia = 8562" />
              <member def="SkippedTokensTrivia = 8563" />
              <member def="ConflictMarkerTrivia = 8564" />
              <member def="XmlElement = 8574" />
              <member def="XmlElementStartTag = 8575" />
              <member def="XmlElementEndTag = 8576" />
              <member def="XmlEmptyElement = 8577" />
              <member def="XmlTextAttribute = 8578" />
              <member def="XmlCrefAttribute = 8579" />
              <member def="XmlNameAttribute = 8580" />
              <member def="XmlName = 8581" />
              <member def="XmlPrefix = 8582" />
              <member def="XmlText = 8583" />
              <member def="XmlCDataSection = 8584" />
              <member def="XmlComment = 8585" />
              <member def="XmlProcessingInstruction = 8586" />
              <member def="TypeCref = 8597" />
              <member def="QualifiedCref = 8598" />
              <member def="NameMemberCref = 8599" />
              <member def="IndexerMemberCref = 8600" />
              <member def="OperatorMemberCref = 8601" />
              <member def="ConversionOperatorMemberCref = 8602" />
              <member def="CrefParameterList = 8603" />
              <member def="CrefBracketedParameterList = 8604" />
              <member def="CrefParameter = 8605" />
              <member def="IdentifierName = 8616" />
              <member def="QualifiedName = 8617" />
              <member def="GenericName = 8618" />
              <member def="TypeArgumentList = 8619" />
              <member def="AliasQualifiedName = 8620" />
              <member def="PredefinedType = 8621" />
              <member def="ArrayType = 8622" />
              <member def="ArrayRankSpecifier = 8623" />
              <member def="PointerType = 8624" />
              <member def="NullableType = 8625" />
              <member def="OmittedTypeArgument = 8626" />
              <member def="ParenthesizedExpression = 8632" />
              <member def="ConditionalExpression = 8633" />
              <member def="InvocationExpression = 8634" />
              <member def="ElementAccessExpression = 8635" />
              <member def="ArgumentList = 8636" />
              <member def="BracketedArgumentList = 8637" />
              <member def="Argument = 8638" />
              <member def="NameColon = 8639" />
              <member def="CastExpression = 8640" />
              <member def="AnonymousMethodExpression = 8641" />
              <member def="SimpleLambdaExpression = 8642" />
              <member def="ParenthesizedLambdaExpression = 8643" />
              <member def="ObjectInitializerExpression = 8644" />
              <member def="CollectionInitializerExpression = 8645" />
              <member def="ArrayInitializerExpression = 8646" />
              <member def="AnonymousObjectMemberDeclarator = 8647" />
              <member def="ComplexElementInitializerExpression = 8648" />
              <member def="ObjectCreationExpression = 8649" />
              <member def="AnonymousObjectCreationExpression = 8650" />
              <member def="ArrayCreationExpression = 8651" />
              <member def="ImplicitArrayCreationExpression = 8652" />
              <member def="StackAllocArrayCreationExpression = 8653" />
              <member def="OmittedArraySizeExpression = 8654" />
              <member def="InterpolatedStringExpression = 8655" />
              <member def="ImplicitElementAccess = 8656" />
              <member def="IsPatternExpression = 8657" />
              <member def="AddExpression = 8668" />
              <member def="SubtractExpression = 8669" />
              <member def="MultiplyExpression = 8670" />
              <member def="DivideExpression = 8671" />
              <member def="ModuloExpression = 8672" />
              <member def="LeftShiftExpression = 8673" />
              <member def="RightShiftExpression = 8674" />
              <member def="LogicalOrExpression = 8675" />
              <member def="LogicalAndExpression = 8676" />
              <member def="BitwiseOrExpression = 8677" />
              <member def="BitwiseAndExpression = 8678" />
              <member def="ExclusiveOrExpression = 8679" />
              <member def="EqualsExpression = 8680" />
              <member def="NotEqualsExpression = 8681" />
              <member def="LessThanExpression = 8682" />
              <member def="LessThanOrEqualExpression = 8683" />
              <member def="GreaterThanExpression = 8684" />
              <member def="GreaterThanOrEqualExpression = 8685" />
              <member def="IsExpression = 8686" />
              <member def="AsExpression = 8687" />
              <member def="CoalesceExpression = 8688" />
              <member def="SimpleMemberAccessExpression = 8689" />
              <member def="PointerMemberAccessExpression = 8690" />
              <member def="ConditionalAccessExpression = 8691" />
              <member def="MemberBindingExpression = 8707" />
              <member def="ElementBindingExpression = 8708" />
              <member def="SimpleAssignmentExpression = 8714" />
              <member def="AddAssignmentExpression = 8715" />
              <member def="SubtractAssignmentExpression = 8716" />
              <member def="MultiplyAssignmentExpression = 8717" />
              <member def="DivideAssignmentExpression = 8718" />
              <member def="ModuloAssignmentExpression = 8719" />
              <member def="AndAssignmentExpression = 8720" />
              <member def="ExclusiveOrAssignmentExpression = 8721" />
              <member def="OrAssignmentExpression = 8722" />
              <member def="LeftShiftAssignmentExpression = 8723" />
              <member def="RightShiftAssignmentExpression = 8724" />
              <member def="UnaryPlusExpression = 8730" />
              <member def="UnaryMinusExpression = 8731" />
              <member def="BitwiseNotExpression = 8732" />
              <member def="LogicalNotExpression = 8733" />
              <member def="PreIncrementExpression = 8734" />
              <member def="PreDecrementExpression = 8735" />
              <member def="PointerIndirectionExpression = 8736" />
              <member def="AddressOfExpression = 8737" />
              <member def="PostIncrementExpression = 8738" />
              <member def="PostDecrementExpression = 8739" />
              <member def="AwaitExpression = 8740" />
              <member def="ThisExpression = 8746" />
              <member def="BaseExpression = 8747" />
              <member def="ArgListExpression = 8748" />
              <member def="NumericLiteralExpression = 8749" />
              <member def="StringLiteralExpression = 8750" />
              <member def="CharacterLiteralExpression = 8751" />
              <member def="TrueLiteralExpression = 8752" />
              <member def="FalseLiteralExpression = 8753" />
              <member def="NullLiteralExpression = 8754" />
              <member def="DefaultLiteralExpression = 8755" />
              <member def="TypeOfExpression = 8760" />
              <member def="SizeOfExpression = 8761" />
              <member def="CheckedExpression = 8762" />
              <member def="UncheckedExpression = 8763" />
              <member def="DefaultExpression = 8764" />
              <member def="MakeRefExpression = 8765" />
              <member def="RefValueExpression = 8766" />
              <member def="RefTypeExpression = 8767" />
              <member def="QueryExpression = 8774" />
              <member def="QueryBody = 8775" />
              <member def="FromClause = 8776" />
              <member def="LetClause = 8777" />
              <member def="JoinClause = 8778" />
              <member def="JoinIntoClause = 8779" />
              <member def="WhereClause = 8780" />
              <member def="OrderByClause = 8781" />
              <member def="AscendingOrdering = 8782" />
              <member def="DescendingOrdering = 8783" />
              <member def="SelectClause = 8784" />
              <member def="GroupClause = 8785" />
              <member def="QueryContinuation = 8786" />
              <member def="Block = 8792" />
              <member def="LocalDeclarationStatement = 8793" />
              <member def="VariableDeclaration = 8794" />
              <member def="VariableDeclarator = 8795" />
              <member def="EqualsValueClause = 8796" />
              <member def="ExpressionStatement = 8797" />
              <member def="EmptyStatement = 8798" />
              <member def="LabeledStatement = 8799" />
              <member def="GotoStatement = 8800" />
              <member def="GotoCaseStatement = 8801" />
              <member def="GotoDefaultStatement = 8802" />
              <member def="BreakStatement = 8803" />
              <member def="ContinueStatement = 8804" />
              <member def="ReturnStatement = 8805" />
              <member def="YieldReturnStatement = 8806" />
              <member def="YieldBreakStatement = 8807" />
              <member def="ThrowStatement = 8808" />
              <member def="WhileStatement = 8809" />
              <member def="DoStatement = 8810" />
              <member def="ForStatement = 8811" />
              <member def="ForEachStatement = 8812" />
              <member def="UsingStatement = 8813" />
              <member def="FixedStatement = 8814" />
              <member def="CheckedStatement = 8815" />
              <member def="UncheckedStatement = 8816" />
              <member def="UnsafeStatement = 8817" />
              <member def="LockStatement = 8818" />
              <member def="IfStatement = 8819" />
              <member def="ElseClause = 8820" />
              <member def="SwitchStatement = 8821" />
              <member def="SwitchSection = 8822" />
              <member def="CaseSwitchLabel = 8823" />
              <member def="DefaultSwitchLabel = 8824" />
              <member def="TryStatement = 8825" />
              <member def="CatchClause = 8826" />
              <member def="CatchDeclaration = 8827" />
              <member def="CatchFilterClause = 8828" />
              <member def="FinallyClause = 8829" />
              <member def="LocalFunctionStatement = 8830" />
              <member def="CompilationUnit = 8840" />
              <member def="GlobalStatement = 8841" />
              <member def="NamespaceDeclaration = 8842" />
              <member def="UsingDirective = 8843" />
              <member def="ExternAliasDirective = 8844" />
              <member def="AttributeList = 8847" />
              <member def="AttributeTargetSpecifier = 8848" />
              <member def="Attribute = 8849" />
              <member def="AttributeArgumentList = 8850" />
              <member def="AttributeArgument = 8851" />
              <member def="NameEquals = 8852" />
              <member def="ClassDeclaration = 8855" />
              <member def="StructDeclaration = 8856" />
              <member def="InterfaceDeclaration = 8857" />
              <member def="EnumDeclaration = 8858" />
              <member def="DelegateDeclaration = 8859" />
              <member def="BaseList = 8864" />
              <member def="SimpleBaseType = 8865" />
              <member def="TypeParameterConstraintClause = 8866" />
              <member def="ConstructorConstraint = 8867" />
              <member def="ClassConstraint = 8868" />
              <member def="StructConstraint = 8869" />
              <member def="TypeConstraint = 8870" />
              <member def="ExplicitInterfaceSpecifier = 8871" />
              <member def="EnumMemberDeclaration = 8872" />
              <member def="FieldDeclaration = 8873" />
              <member def="EventFieldDeclaration = 8874" />
              <member def="MethodDeclaration = 8875" />
              <member def="OperatorDeclaration = 8876" />
              <member def="ConversionOperatorDeclaration = 8877" />
              <member def="ConstructorDeclaration = 8878" />
              <member def="BaseConstructorInitializer = 8889" />
              <member def="ThisConstructorInitializer = 8890" />
              <member def="DestructorDeclaration = 8891" />
              <member def="PropertyDeclaration = 8892" />
              <member def="EventDeclaration = 8893" />
              <member def="IndexerDeclaration = 8894" />
              <member def="AccessorList = 8895" />
              <member def="GetAccessorDeclaration = 8896" />
              <member def="SetAccessorDeclaration = 8897" />
              <member def="AddAccessorDeclaration = 8898" />
              <member def="RemoveAccessorDeclaration = 8899" />
              <member def="UnknownAccessorDeclaration = 8900" />
              <member def="ParameterList = 8906" />
              <member def="BracketedParameterList = 8907" />
              <member def="Parameter = 8908" />
              <member def="TypeParameterList = 8909" />
              <member def="TypeParameter = 8910" />
              <member def="IncompleteMember = 8916" />
              <member def="ArrowExpressionClause = 8917" />
              <member def="Interpolation = 8918" />
              <member def="InterpolatedStringText = 8919" />
              <member def="InterpolationAlignmentClause = 8920" />
              <member def="InterpolationFormatClause = 8921" />
              <member def="ShebangDirectiveTrivia = 8922" />
              <member def="LoadDirectiveTrivia = 8923" />
              <member def="TupleType = 8924" />
              <member def="TupleElement = 8925" />
              <member def="TupleExpression = 8926" />
              <member def="SingleVariableDesignation = 8927" />
              <member def="ParenthesizedVariableDesignation = 8928" />
              <member def="ForEachVariableStatement = 8929" />
              <member def="DeclarationPattern = 9000" />
              <member def="ConstantPattern = 9002" />
              <member def="CasePatternSwitchLabel = 9009" />
              <member def="WhenClause = 9013" />
              <member def="DiscardDesignation = 9014" />
              <member def="DeclarationExpression = 9040" />
              <member def="RefExpression = 9050" />
              <member def="RefType = 9051" />
              <member def="ThrowExpression = 9052" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.CSharp.Formatting.BinaryOperatorSpacingOptions">
            <members>
              <member def="Single = 0" />
              <member def="Ignore = 1" />
              <member def="Remove = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.CSharp.Formatting.LabelPositionOptions">
            <members>
              <member def="LeftMost = 0" />
              <member def="OneLess = 1" />
              <member def="NoIndent = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeElementKind">
            <members>
              <member def="Parameter = 0" />
              <member def="ParameterReference = 1" />
              <member def="TypeParameter = 2" />
              <member def="TypeParameterReference = 3" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.CodeFixes.FixAllScope">
            <members>
              <member def="Document = 0" />
              <member def="Project = 1" />
              <member def="Solution = 2" />
              <member def="Custom = 3" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs.FailureErrorCode">
            <members>
              <member def="None = 0" />
              <member def="UnableToLoadAnalyzer = 1" />
              <member def="UnableToCreateAnalyzer = 2" />
              <member def="NoAnalyzers = 3" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Diagnostics.GeneratedCodeAnalysisFlags">
            <members>
              <member def="None = 0" />
              <member def="Analyze = 1" />
              <member def="ReportDiagnostics = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Differencing.EditKind">
            <members>
              <member def="None = 0" />
              <member def="Update = 1" />
              <member def="Insert = 2" />
              <member def="Delete = 3" />
              <member def="Move = 4" />
              <member def="Reorder = 5" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Editing.DeclarationKind">
            <members>
              <member def="None = 0" />
              <member def="CompilationUnit = 1" />
              <member def="Class = 2" />
              <member def="Struct = 3" />
              <member def="Interface = 4" />
              <member def="Enum = 5" />
              <member def="Delegate = 6" />
              <member def="Method = 7" />
              <member def="Operator = 8" />
              <member def="ConversionOperator = 9" />
              <member def="Constructor = 10" />
              <member def="Destructor = 11" />
              <member def="Field = 12" />
              <member def="Property = 13" />
              <member def="Indexer = 14" />
              <member def="EnumMember = 15" />
              <member def="Event = 16" />
              <member def="CustomEvent = 17" />
              <member def="Namespace = 18" />
              <member def="NamespaceImport = 19" />
              <member def="Parameter = 20" />
              <member def="Variable = 21" />
              <member def="Attribute = 22" />
              <member def="LambdaExpression = 23" />
              <member def="GetAccessor = 24" />
              <member def="SetAccessor = 25" />
              <member def="AddAccessor = 26" />
              <member def="RemoveAccessor = 27" />
              <member def="RaiseAccessor = 28" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Editing.OperatorKind">
            <members>
              <member def="ImplicitConversion = 0" />
              <member def="ExplicitConversion = 1" />
              <member def="Addition = 2" />
              <member def="BitwiseAnd = 3" />
              <member def="BitwiseOr = 4" />
              <member def="Decrement = 5" />
              <member def="Division = 6" />
              <member def="Equality = 7" />
              <member def="ExclusiveOr = 8" />
              <member def="False = 9" />
              <member def="GreaterThan = 10" />
              <member def="GreaterThanOrEqual = 11" />
              <member def="Increment = 12" />
              <member def="Inequality = 13" />
              <member def="LeftShift = 14" />
              <member def="LessThan = 15" />
              <member def="LessThanOrEqual = 16" />
              <member def="LogicalNot = 17" />
              <member def="Modulus = 18" />
              <member def="Multiply = 19" />
              <member def="OnesComplement = 20" />
              <member def="RightShift = 21" />
              <member def="Subtraction = 22" />
              <member def="True = 23" />
              <member def="UnaryNegation = 24" />
              <member def="UnaryPlus = 25" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind">
            <members>
              <member def="None = 0" />
              <member def="ReferenceType = 1" />
              <member def="ValueType = 2" />
              <member def="Constructor = 4" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Emit.DebugInformationFormat">
            <members>
              <member def="Pdb = 1" />
              <member def="PortablePdb = 2" />
              <member def="Embedded = 3" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Emit.InstrumentationKind">
            <members>
              <member def="None = 0" />
              <member def="TestCoverage = 1" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Emit.SemanticEditKind">
            <members>
              <member def="None = 0" />
              <member def="Update = 1" />
              <member def="Insert = 2" />
              <member def="Delete = 3" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Formatting.FormattingOptions.IndentStyle">
            <members>
              <member def="None = 0" />
              <member def="Block = 1" />
              <member def="Smart = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Rename.RenameEntityKind">
            <members>
              <member def="BaseSymbol = 0" />
              <member def="OverloadedSymbols = 1" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Semantics.ArgumentKind">
            <members>
              <member def="None = 0" />
              <member def="Explicit = 1" />
              <member def="ParamArray = 2" />
              <member def="DefaultValue = 3" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Semantics.BinaryOperandsKind">
            <members>
              <member def="None = 0" />
              <member def="OperatorMethod = 256" />
              <member def="Integer = 512" />
              <member def="Unsigned = 768" />
              <member def="Floating = 1024" />
              <member def="Decimal = 1280" />
              <member def="Boolean = 1536" />
              <member def="Enum = 1792" />
              <member def="Dynamic = 2048" />
              <member def="Object = 2304" />
              <member def="Pointer = 2560" />
              <member def="PointerInteger = 2816" />
              <member def="IntegerPointer = 3072" />
              <member def="String = 3328" />
              <member def="Delegate = 3584" />
              <member def="Nullable = 3840" />
              <member def="Invalid = 65280" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Semantics.BinaryOperationKind">
            <members>
              <member def="None = 0" />
              <member def="OperatorMethodAdd = 257" />
              <member def="OperatorMethodSubtract = 258" />
              <member def="OperatorMethodMultiply = 259" />
              <member def="OperatorMethodDivide = 260" />
              <member def="OperatorMethodIntegerDivide = 261" />
              <member def="OperatorMethodRemainder = 262" />
              <member def="OperatorMethodLeftShift = 264" />
              <member def="OperatorMethodRightShift = 265" />
              <member def="OperatorMethodAnd = 266" />
              <member def="OperatorMethodOr = 267" />
              <member def="OperatorMethodExclusiveOr = 268" />
              <member def="OperatorMethodConditionalAnd = 269" />
              <member def="OperatorMethodConditionalOr = 270" />
              <member def="IntegerAdd = 513" />
              <member def="IntegerSubtract = 514" />
              <member def="IntegerMultiply = 515" />
              <member def="IntegerDivide = 516" />
              <member def="IntegerRemainder = 518" />
              <member def="IntegerLeftShift = 520" />
              <member def="IntegerRightShift = 521" />
              <member def="IntegerAnd = 522" />
              <member def="IntegerOr = 523" />
              <member def="IntegerExclusiveOr = 524" />
              <member def="UnsignedAdd = 769" />
              <member def="UnsignedSubtract = 770" />
              <member def="UnsignedMultiply = 771" />
              <member def="UnsignedDivide = 772" />
              <member def="UnsignedRemainder = 774" />
              <member def="UnsignedLeftShift = 776" />
              <member def="UnsignedRightShift = 777" />
              <member def="UnsignedAnd = 778" />
              <member def="UnsignedOr = 779" />
              <member def="UnsignedExclusiveOr = 780" />
              <member def="FloatingAdd = 1025" />
              <member def="FloatingSubtract = 1026" />
              <member def="FloatingMultiply = 1027" />
              <member def="FloatingDivide = 1028" />
              <member def="FloatingRemainder = 1030" />
              <member def="FloatingPower = 1031" />
              <member def="DecimalAdd = 1281" />
              <member def="DecimalSubtract = 1282" />
              <member def="DecimalMultiply = 1283" />
              <member def="DecimalDivide = 1284" />
              <member def="BooleanAnd = 1546" />
              <member def="BooleanOr = 1547" />
              <member def="BooleanExclusiveOr = 1548" />
              <member def="BooleanConditionalAnd = 1549" />
              <member def="BooleanConditionalOr = 1550" />
              <member def="EnumAdd = 1793" />
              <member def="EnumSubtract = 1794" />
              <member def="EnumAnd = 1802" />
              <member def="EnumOr = 1803" />
              <member def="EnumExclusiveOr = 1804" />
              <member def="PointerIntegerAdd = 2817" />
              <member def="IntegerPointerAdd = 3073" />
              <member def="PointerIntegerSubtract = 2818" />
              <member def="PointerSubtract = 2562" />
              <member def="DynamicAdd = 2049" />
              <member def="DynamicSubtract = 2050" />
              <member def="DynamicMultiply = 2051" />
              <member def="DynamicDivide = 2052" />
              <member def="DynamicRemainder = 2054" />
              <member def="DynamicLeftShift = 2056" />
              <member def="DynamicRightShift = 2057" />
              <member def="DynamicAnd = 2058" />
              <member def="DynamicOr = 2059" />
              <member def="DynamicExclusiveOr = 2060" />
              <member def="ObjectAdd = 2305" />
              <member def="ObjectSubtract = 2306" />
              <member def="ObjectMultiply = 2307" />
              <member def="ObjectDivide = 2308" />
              <member def="ObjectIntegerDivide = 2309" />
              <member def="ObjectRemainder = 2310" />
              <member def="ObjectPower = 2311" />
              <member def="ObjectLeftShift = 2312" />
              <member def="ObjectRightShift = 2313" />
              <member def="ObjectAnd = 2314" />
              <member def="ObjectOr = 2315" />
              <member def="ObjectExclusiveOr = 2316" />
              <member def="ObjectConditionalAnd = 2317" />
              <member def="ObjectConditionalOr = 2318" />
              <member def="ObjectConcatenate = 2319" />
              <member def="StringConcatenate = 3343" />
              <member def="OperatorMethodEquals = 272" />
              <member def="OperatorMethodNotEquals = 274" />
              <member def="OperatorMethodLessThan = 276" />
              <member def="OperatorMethodLessThanOrEqual = 277" />
              <member def="OperatorMethodGreaterThanOrEqual = 278" />
              <member def="OperatorMethodGreaterThan = 279" />
              <member def="OperatorMethodPower = 263" />
              <member def="IntegerEquals = 528" />
              <member def="IntegerNotEquals = 530" />
              <member def="IntegerLessThan = 532" />
              <member def="IntegerLessThanOrEqual = 533" />
              <member def="IntegerGreaterThanOrEqual = 534" />
              <member def="IntegerGreaterThan = 535" />
              <member def="UnsignedLessThan = 788" />
              <member def="UnsignedLessThanOrEqual = 789" />
              <member def="UnsignedGreaterThanOrEqual = 790" />
              <member def="UnsignedGreaterThan = 791" />
              <member def="FloatingEquals = 1040" />
              <member def="FloatingNotEquals = 1042" />
              <member def="FloatingLessThan = 1044" />
              <member def="FloatingLessThanOrEqual = 1045" />
              <member def="FloatingGreaterThanOrEqual = 1046" />
              <member def="FloatingGreaterThan = 1047" />
              <member def="DecimalEquals = 1296" />
              <member def="DecimalNotEquals = 1298" />
              <member def="DecimalLessThan = 1300" />
              <member def="DecimalLessThanOrEqual = 1301" />
              <member def="DecimalGreaterThanOrEqual = 1302" />
              <member def="DecimalGreaterThan = 1303" />
              <member def="BooleanEquals = 1552" />
              <member def="BooleanNotEquals = 1554" />
              <member def="StringEquals = 3344" />
              <member def="StringNotEquals = 3346" />
              <member def="StringLike = 3352" />
              <member def="DelegateEquals = 3600" />
              <member def="DelegateNotEquals = 3602" />
              <member def="NullableEquals = 3856" />
              <member def="NullableNotEquals = 3858" />
              <member def="ObjectEquals = 2320" />
              <member def="ObjectNotEquals = 2322" />
              <member def="ObjectVBEquals = 2321" />
              <member def="ObjectVBNotEquals = 2323" />
              <member def="ObjectLike = 2328" />
              <member def="ObjectLessThan = 2324" />
              <member def="ObjectLessThanOrEqual = 2325" />
              <member def="ObjectGreaterThanOrEqual = 2326" />
              <member def="ObjectGreaterThan = 2327" />
              <member def="EnumEquals = 1808" />
              <member def="EnumNotEquals = 1810" />
              <member def="EnumLessThan = 1812" />
              <member def="EnumLessThanOrEqual = 1813" />
              <member def="EnumGreaterThanOrEqual = 1814" />
              <member def="EnumGreaterThan = 1815" />
              <member def="PointerEquals = 2576" />
              <member def="PointerNotEquals = 2578" />
              <member def="PointerLessThan = 2580" />
              <member def="PointerLessThanOrEqual = 2581" />
              <member def="PointerGreaterThanOrEqual = 2582" />
              <member def="PointerGreaterThan = 2583" />
              <member def="DynamicEquals = 2064" />
              <member def="DynamicNotEquals = 2066" />
              <member def="DynamicLessThan = 2068" />
              <member def="DynamicLessThanOrEqual = 2069" />
              <member def="DynamicGreaterThanOrEqual = 2070" />
              <member def="DynamicGreaterThan = 2071" />
              <member def="Invalid = 65535" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Semantics.BranchKind">
            <members>
              <member def="None = 0" />
              <member def="Continue = 1" />
              <member def="Break = 2" />
              <member def="GoTo = 3" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Semantics.CaseKind">
            <members>
              <member def="None = 0" />
              <member def="SingleValue = 1" />
              <member def="Relational = 2" />
              <member def="Range = 3" />
              <member def="Default = 4" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Semantics.ConversionKind">
            <members>
              <member def="None = 0" />
              <member def="Cast = 1" />
              <member def="TryCast = 2" />
              <member def="Basic = 3" />
              <member def="CSharp = 4" />
              <member def="OperatorMethod = 5" />
              <member def="Invalid = 15" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Semantics.InstanceReferenceKind">
            <members>
              <member def="None = 0" />
              <member def="Implicit = 1" />
              <member def="Explicit = 2" />
              <member def="BaseClass = 3" />
              <member def="ThisClass = 4" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Semantics.LoopKind">
            <members>
              <member def="None = 0" />
              <member def="WhileUntil = 1" />
              <member def="For = 2" />
              <member def="ForEach = 3" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Semantics.SimpleBinaryOperationKind">
            <members>
              <member def="None = 0" />
              <member def="Add = 1" />
              <member def="Subtract = 2" />
              <member def="Multiply = 3" />
              <member def="Divide = 4" />
              <member def="IntegerDivide = 5" />
              <member def="Remainder = 6" />
              <member def="Power = 7" />
              <member def="LeftShift = 8" />
              <member def="RightShift = 9" />
              <member def="And = 10" />
              <member def="Or = 11" />
              <member def="ExclusiveOr = 12" />
              <member def="ConditionalAnd = 13" />
              <member def="ConditionalOr = 14" />
              <member def="Concatenate = 15" />
              <member def="Equals = 16" />
              <member def="ObjectValueEquals = 17" />
              <member def="NotEquals = 18" />
              <member def="ObjectValueNotEquals = 19" />
              <member def="LessThan = 20" />
              <member def="LessThanOrEqual = 21" />
              <member def="GreaterThanOrEqual = 22" />
              <member def="GreaterThan = 23" />
              <member def="Like = 24" />
              <member def="Invalid = 255" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Semantics.SimpleUnaryOperationKind">
            <members>
              <member def="None = 0" />
              <member def="BitwiseNegation = 1" />
              <member def="LogicalNot = 2" />
              <member def="PostfixIncrement = 3" />
              <member def="PostfixDecrement = 4" />
              <member def="PrefixIncrement = 5" />
              <member def="PrefixDecrement = 6" />
              <member def="Plus = 7" />
              <member def="Minus = 8" />
              <member def="True = 9" />
              <member def="False = 10" />
              <member def="BitwiseOrLogicalNot = 11" />
              <member def="Invalid = 255" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Semantics.SyntheticLocalKind">
            <members>
              <member def="None = 0" />
              <member def="ForLoopStepValue = 1" />
              <member def="ForLoopLimitValue = 2" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Semantics.UnaryOperandKind">
            <members>
              <member def="None = 0" />
              <member def="OperatorMethod = 256" />
              <member def="Integer = 512" />
              <member def="Unsigned = 768" />
              <member def="Floating = 1024" />
              <member def="Decimal = 1280" />
              <member def="Boolean = 1536" />
              <member def="Enum = 1792" />
              <member def="Dynamic = 2048" />
              <member def="Object = 2304" />
              <member def="Pointer = 2560" />
              <member def="Invalid = 65280" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Semantics.UnaryOperationKind">
            <members>
              <member def="None = 0" />
              <member def="OperatorMethodBitwiseNegation = 257" />
              <member def="OperatorMethodLogicalNot = 258" />
              <member def="OperatorMethodPostfixIncrement = 259" />
              <member def="OperatorMethodPostfixDecrement = 260" />
              <member def="OperatorMethodPrefixIncrement = 261" />
              <member def="OperatorMethodPrefixDecrement = 262" />
              <member def="OperatorMethodPlus = 263" />
              <member def="OperatorMethodMinus = 264" />
              <member def="OperatorMethodTrue = 265" />
              <member def="OperatorMethodFalse = 266" />
              <member def="IntegerBitwiseNegation = 513" />
              <member def="IntegerPlus = 519" />
              <member def="IntegerMinus = 520" />
              <member def="IntegerPostfixIncrement = 515" />
              <member def="IntegerPostfixDecrement = 516" />
              <member def="IntegerPrefixIncrement = 517" />
              <member def="IntegerPrefixDecrement = 518" />
              <member def="UnsignedPostfixIncrement = 771" />
              <member def="UnsignedPostfixDecrement = 772" />
              <member def="UnsignedPrefixIncrement = 773" />
              <member def="UnsignedPrefixDecrement = 774" />
              <member def="FloatingPlus = 1031" />
              <member def="FloatingMinus = 1032" />
              <member def="FloatingPostfixIncrement = 1027" />
              <member def="FloatingPostfixDecrement = 1028" />
              <member def="FloatingPrefixIncrement = 1029" />
              <member def="FloatingPrefixDecrement = 1030" />
              <member def="DecimalPlus = 1287" />
              <member def="DecimalMinus = 1288" />
              <member def="DecimalPostfixIncrement = 1283" />
              <member def="DecimalPostfixDecrement = 1284" />
              <member def="DecimalPrefixIncrement = 1285" />
              <member def="DecimalPrefixDecrement = 1286" />
              <member def="BooleanBitwiseNegation = 1537" />
              <member def="BooleanLogicalNot = 1538" />
              <member def="EnumPostfixIncrement = 1795" />
              <member def="EnumPostfixDecrement = 1796" />
              <member def="EnumPrefixIncrement = 1797" />
              <member def="EnumPrefixDecrement = 1798" />
              <member def="PointerPostfixIncrement = 2563" />
              <member def="PointerPostfixDecrement = 2564" />
              <member def="PointerPrefixIncrement = 2565" />
              <member def="PointerPrefixDecrement = 2566" />
              <member def="DynamicBitwiseNegation = 2049" />
              <member def="DynamicLogicalNot = 2050" />
              <member def="DynamicTrue = 2057" />
              <member def="DynamicFalse = 2058" />
              <member def="DynamicPlus = 2055" />
              <member def="DynamicMinus = 2056" />
              <member def="DynamicPostfixIncrement = 2051" />
              <member def="DynamicPostfixDecrement = 2052" />
              <member def="DynamicPrefixIncrement = 2053" />
              <member def="DynamicPrefixDecrement = 2054" />
              <member def="ObjectPlus = 2311" />
              <member def="ObjectMinus = 2312" />
              <member def="ObjectNot = 2315" />
              <member def="Invalid = 65535" />
            </members>
          </type>
          <type def="public enum Microsoft.CodeAnalysis.Text.SourceHashAlgorithm">
            <members>
              <member def="None = 0" />
              <member def="Sha1 = 1" />
              <member def="Sha256 = 2" />
            </members>
          </type>
          <type def="public enum Roslynator.Visibility">
            <members>
              <member def="NotApplicable = 0" />
              <member def="Private = 1" />
              <member def="Internal = 2" />
              <member def="Public = 3" />
            </members>
          </type>
          <type def="public enum Roslynator.CSharp.CommentKinds">
            <members>
              <member def="None = 0" />
              <member def="SingleLine = 1" />
              <member def="MultiLine = 2" />
              <member def="NonDocumentation = SingleLine | MultiLine" />
              <member def="SingleLineDocumentation = 4" />
              <member def="MultiLineDocumentation = 8" />
              <member def="Documentation = SingleLineDocumentation | MultiLineDocumentation" />
              <member def="All = NonDocumentation | Documentation" />
            </members>
          </type>
          <type def="public enum Roslynator.CSharp.ModifierKinds">
            <members>
              <member def="None = 0" />
              <member def="New = 1" />
              <member def="Public = 2" />
              <member def="Private = 4" />
              <member def="Protected = 8" />
              <member def="Internal = 16" />
              <member def="Accessibility = Public | Private | Protected | Internal" />
              <member def="Const = 32" />
              <member def="Static = 64" />
              <member def="Virtual = 128" />
              <member def="Sealed = 256" />
              <member def="Override = 512" />
              <member def="Abstract = 1024" />
              <member def="AbstractVirtualOverride = Virtual | Override | Abstract" />
              <member def="ReadOnly = 2048" />
              <member def="Extern = 4096" />
              <member def="Unsafe = 8192" />
              <member def="Volatile = 16384" />
              <member def="Async = 32768" />
              <member def="Partial = 65536" />
              <member def="Ref = 131072" />
              <member def="Out = 262144" />
              <member def="In = 524288" />
              <member def="Params = 1048576" />
              <member def="This = 2097152" />
            </members>
          </type>
          <type def="public enum Roslynator.CSharp.NullCheckStyles">
            <members>
              <member def="None = 0" />
              <member def="EqualsToNull = 1" />
              <member def="NotEqualsToNull = 2" />
              <member def="ComparisonToNull = EqualsToNull | NotEqualsToNull" />
              <member def="IsNull = 4" />
              <member def="NotIsNull = 8" />
              <member def="IsPattern = IsNull | NotIsNull" />
              <member def="NotHasValue = 16" />
              <member def="CheckingNull = EqualsToNull | IsNull | NotHasValue" />
              <member def="HasValue = 32" />
              <member def="CheckingNotNull = NotEqualsToNull | NotIsNull | HasValue" />
              <member def="HasValueProperty = NotHasValue | HasValue" />
              <member def="All = ComparisonToNull | IsPattern | HasValueProperty" />
            </members>
          </type>
          <type def="public enum Roslynator.CSharp.PreprocessorDirectiveKinds">
            <members>
              <member def="None = 0" />
              <member def="If = 1" />
              <member def="Elif = 2" />
              <member def="Else = 4" />
              <member def="EndIf = 8" />
              <member def="Region = 16" />
              <member def="EndRegion = 32" />
              <member def="Define = 64" />
              <member def="Undef = 128" />
              <member def="Error = 256" />
              <member def="Warning = 512" />
              <member def="Line = 1024" />
              <member def="PragmaWarning = 2048" />
              <member def="PragmaChecksum = 4096" />
              <member def="Pragma = PragmaWarning | PragmaChecksum" />
              <member def="Reference = 8192" />
              <member def="Load = 16384" />
              <member def="Bad = 32768" />
              <member def="Shebang = 65536" />
              <member def="All = If | Elif | Else | EndIf | Region | EndRegion | Define | Undef | Error | Warning | Line | Pragma | Reference | Load | Bad | Shebang" />
            </members>
          </type>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.ChildSyntaxList : IEquatable&lt;ChildSyntaxList&gt;, IEnumerable&lt;SyntaxNodeOrToken&gt;, IReadOnlyCollection&lt;SyntaxNodeOrToken&gt;, IReadOnlyList&lt;SyntaxNodeOrToken&gt;">
          <members>
            <member def="public int Count { get; }" />
            <member def="public SyntaxNodeOrToken this[int index] { get; }" />
            <member def="public bool Any()" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(ChildSyntaxList other)" />
            <member def="public SyntaxNodeOrToken First()" />
            <member def="public ChildSyntaxList.Enumerator GetEnumerator()" />
            <member def="public override int GetHashCode()" />
            <member def="public SyntaxNodeOrToken Last()" />
            <member def="public ChildSyntaxList.Reversed Reverse()" />
            <member def="public static bool operator ==(ChildSyntaxList list1, ChildSyntaxList list2)" />
            <member def="public static bool operator !=(ChildSyntaxList list1, ChildSyntaxList list2)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.ChildSyntaxList.Enumerator">
          <members>
            <member def="public SyntaxNodeOrToken Current { get; }" />
            <member def="public bool MoveNext()" />
            <member def="public void Reset()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.ChildSyntaxList.Reversed : IEquatable&lt;ChildSyntaxList.Reversed&gt;, IEnumerable&lt;SyntaxNodeOrToken&gt;">
          <members>
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(ChildSyntaxList.Reversed other)" />
            <member def="public ChildSyntaxList.Reversed.Enumerator GetEnumerator()" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.ChildSyntaxList.Reversed.Enumerator">
          <members>
            <member def="public SyntaxNodeOrToken Current { get; }" />
            <member def="public bool MoveNext()" />
            <member def="public void Reset()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.CommandLineAnalyzerReference : IEquatable&lt;CommandLineAnalyzerReference&gt;">
          <members>
            <member def="public CommandLineAnalyzerReference(string path)" />
            <member def="public string FilePath { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(CommandLineAnalyzerReference other)" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.CommandLineReference : IEquatable&lt;CommandLineReference&gt;">
          <members>
            <member def="public CommandLineReference(string reference, MetadataReferenceProperties properties)" />
            <member def="public MetadataReferenceProperties Properties { get; }" />
            <member def="public string Reference { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(CommandLineReference other)" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.CommandLineSourceFile">
          <members>
            <member def="public CommandLineSourceFile(string path, bool isScript)" />
            <member def="public bool IsScript { get; }" />
            <member def="public string Path { get; }" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.FileLinePositionSpan : IEquatable&lt;FileLinePositionSpan&gt;">
          <members>
            <member def="public FileLinePositionSpan(string path, LinePositionSpan span)" />
            <member def="public FileLinePositionSpan(string path, LinePosition start, LinePosition end)" />
            <member def="public LinePosition EndLinePosition { get; }" />
            <member def="public bool HasMappedPath { get; }" />
            <member def="public bool IsValid { get; }" />
            <member def="public string Path { get; }" />
            <member def="public LinePositionSpan Span { get; }" />
            <member def="public LinePosition StartLinePosition { get; }" />
            <member def="public bool Equals(FileLinePositionSpan other)" />
            <member def="public override bool Equals(object other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.MetadataReferenceProperties : IEquatable&lt;MetadataReferenceProperties&gt;">
          <members>
            <member def="public MetadataReferenceProperties(MetadataImageKind kind = Assembly, ImmutableArray&lt;string&gt; aliases = default, bool embedInteropTypes = false)" />
            <member def="public ImmutableArray&lt;string&gt; Aliases { get; }" />
            <member def="public static MetadataReferenceProperties Assembly { get; }" />
            <member def="public bool EmbedInteropTypes { get; }" />
            <member def="public static string GlobalAlias { get; }" />
            <member def="public MetadataImageKind Kind { get; }" />
            <member def="public static MetadataReferenceProperties Module { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(MetadataReferenceProperties other)" />
            <member def="public override int GetHashCode()" />
            <member def="public MetadataReferenceProperties WithAliases(IEnumerable&lt;string&gt; aliases)" />
            <member def="public MetadataReferenceProperties WithAliases(ImmutableArray&lt;string&gt; aliases)" />
            <member def="public MetadataReferenceProperties WithEmbedInteropTypes(bool embedInteropTypes)" />
            <member def="public static bool operator ==(MetadataReferenceProperties left, MetadataReferenceProperties right)" />
            <member def="public static bool operator !=(MetadataReferenceProperties left, MetadataReferenceProperties right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Optional&lt;T&gt;">
          <members>
            <member def="public Optional(T value)" />
            <member def="public bool HasValue { get; }" />
            <member def="public T Value { get; }" />
            <member def="public static implicit operator Optional&lt;T&gt;(T value)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.PreprocessingSymbolInfo : IEquatable&lt;PreprocessingSymbolInfo&gt;">
          <members>
            <member def="public bool IsDefined { get; }" />
            <member def="public IPreprocessingSymbol Symbol { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(PreprocessingSymbolInfo other)" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.ProjectChanges">
          <members>
            <member def="public Project NewProject { get; }" />
            <member def="public Project OldProject { get; }" />
            <member def="public ProjectId ProjectId { get; }" />
            <member def="public IEnumerable&lt;DocumentId&gt; GetAddedAdditionalDocuments()" />
            <member def="public IEnumerable&lt;AnalyzerReference&gt; GetAddedAnalyzerReferences()" />
            <member def="public IEnumerable&lt;DocumentId&gt; GetAddedDocuments()" />
            <member def="public IEnumerable&lt;MetadataReference&gt; GetAddedMetadataReferences()" />
            <member def="public IEnumerable&lt;ProjectReference&gt; GetAddedProjectReferences()" />
            <member def="public IEnumerable&lt;DocumentId&gt; GetChangedAdditionalDocuments()" />
            <member def="public IEnumerable&lt;DocumentId&gt; GetChangedDocuments()" />
            <member def="public IEnumerable&lt;DocumentId&gt; GetRemovedAdditionalDocuments()" />
            <member def="public IEnumerable&lt;AnalyzerReference&gt; GetRemovedAnalyzerReferences()" />
            <member def="public IEnumerable&lt;DocumentId&gt; GetRemovedDocuments()" />
            <member def="public IEnumerable&lt;MetadataReference&gt; GetRemovedMetadataReferences()" />
            <member def="public IEnumerable&lt;ProjectReference&gt; GetRemovedProjectReferences()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt; : IEquatable&lt;SeparatedSyntaxList&lt;TNode&gt;&gt;, IEnumerable&lt;TNode&gt;, IReadOnlyCollection&lt;TNode&gt;, IReadOnlyList&lt;TNode&gt; where TNode : SyntaxNode">
          <members>
            <member def="public int Count { get; }" />
            <member def="public TextSpan FullSpan { get; }" />
            <member def="public int SeparatorCount { get; }" />
            <member def="public TextSpan Span { get; }" />
            <member def="public TNode this[int index] { get; }" />
            <member def="public SeparatedSyntaxList&lt;TNode&gt; Add(TNode node)" />
            <member def="public SeparatedSyntaxList&lt;TNode&gt; AddRange(IEnumerable&lt;TNode&gt; nodes)" />
            <member def="public bool Any()" />
            <member def="public bool Contains(TNode node)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SeparatedSyntaxList&lt;TNode&gt; other)" />
            <member def="public TNode First()" />
            <member def="public TNode FirstOrDefault()" />
            <member def="public SeparatedSyntaxList&lt;TNode&gt;.Enumerator GetEnumerator()" />
            <member def="public override int GetHashCode()" />
            <member def="public SyntaxToken GetSeparator(int index)" />
            <member def="public IEnumerable&lt;SyntaxToken&gt; GetSeparators()" />
            <member def="public SyntaxNodeOrTokenList GetWithSeparators()" />
            <member def="public int IndexOf(TNode node)" />
            <member def="public int IndexOf(Func&lt;TNode, bool&gt; predicate)" />
            <member def="public SeparatedSyntaxList&lt;TNode&gt; Insert(int index, TNode node)" />
            <member def="public SeparatedSyntaxList&lt;TNode&gt; InsertRange(int index, IEnumerable&lt;TNode&gt; nodes)" />
            <member def="public TNode Last()" />
            <member def="public int LastIndexOf(TNode node)" />
            <member def="public int LastIndexOf(Func&lt;TNode, bool&gt; predicate)" />
            <member def="public TNode LastOrDefault()" />
            <member def="public SeparatedSyntaxList&lt;TNode&gt; Remove(TNode node)" />
            <member def="public SeparatedSyntaxList&lt;TNode&gt; RemoveAt(int index)" />
            <member def="public SeparatedSyntaxList&lt;TNode&gt; Replace(TNode nodeInList, TNode newNode)" />
            <member def="public SeparatedSyntaxList&lt;TNode&gt; ReplaceRange(TNode nodeInList, IEnumerable&lt;TNode&gt; newNodes)" />
            <member def="public SeparatedSyntaxList&lt;TNode&gt; ReplaceSeparator(SyntaxToken separatorToken, SyntaxToken newSeparator)" />
            <member def="public string ToFullString()" />
            <member def="public override string ToString()" />
            <member def="public static implicit operator SeparatedSyntaxList&lt;SyntaxNode&gt;(SeparatedSyntaxList&lt;TNode&gt; nodes)" />
            <member def="public static implicit operator SeparatedSyntaxList&lt;TNode&gt;(SeparatedSyntaxList&lt;SyntaxNode&gt; nodes)" />
            <member def="public static bool operator ==(SeparatedSyntaxList&lt;TNode&gt; left, SeparatedSyntaxList&lt;TNode&gt; right)" />
            <member def="public static bool operator !=(SeparatedSyntaxList&lt;TNode&gt; left, SeparatedSyntaxList&lt;TNode&gt; right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;TNode&gt;.Enumerator">
          <members>
            <member def="public TNode Current { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public override int GetHashCode()" />
            <member def="public bool MoveNext()" />
            <member def="public void Reset()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SolutionChanges">
          <members>
            <member def="public IEnumerable&lt;Project&gt; GetAddedProjects()" />
            <member def="public IEnumerable&lt;ProjectChanges&gt; GetProjectChanges()" />
            <member def="public IEnumerable&lt;Project&gt; GetRemovedProjects()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SubsystemVersion : IEquatable&lt;SubsystemVersion&gt;">
          <members>
            <member def="public bool IsValid { get; }" />
            <member def="public int Major { get; }" />
            <member def="public int Minor { get; }" />
            <member def="public static SubsystemVersion None { get; }" />
            <member def="public static SubsystemVersion Windows2000 { get; }" />
            <member def="public static SubsystemVersion Windows7 { get; }" />
            <member def="public static SubsystemVersion Windows8 { get; }" />
            <member def="public static SubsystemVersion WindowsVista { get; }" />
            <member def="public static SubsystemVersion WindowsXP { get; }" />
            <member def="public static SubsystemVersion Create(int major, int minor)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SubsystemVersion other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool TryParse(string str, out SubsystemVersion version)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SymbolDisplayPart">
          <members>
            <member def="public SymbolDisplayPart(SymbolDisplayPartKind kind, ISymbol symbol, string text)" />
            <member def="public SymbolDisplayPartKind Kind { get; }" />
            <member def="public ISymbol Symbol { get; }" />
            <member def="public override string ToString()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SymbolInfo : IEquatable&lt;SymbolInfo&gt;">
          <members>
            <member def="public CandidateReason CandidateReason { get; }" />
            <member def="public ImmutableArray&lt;ISymbol&gt; CandidateSymbols { get; }" />
            <member def="public ISymbol Symbol { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SymbolInfo other)" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt; : IEquatable&lt;SyntaxList&lt;TNode&gt;&gt;, IEnumerable&lt;TNode&gt;, IReadOnlyCollection&lt;TNode&gt;, IReadOnlyList&lt;TNode&gt; where TNode : SyntaxNode">
          <members>
            <member def="public int Count { get; }" />
            <member def="public TextSpan FullSpan { get; }" />
            <member def="public TextSpan Span { get; }" />
            <member def="public TNode this[int index] { get; }" />
            <member def="public SyntaxList&lt;TNode&gt; Add(TNode node)" />
            <member def="public SyntaxList&lt;TNode&gt; AddRange(IEnumerable&lt;TNode&gt; nodes)" />
            <member def="public bool Any()" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SyntaxList&lt;TNode&gt; other)" />
            <member def="public TNode First()" />
            <member def="public TNode FirstOrDefault()" />
            <member def="public SyntaxList&lt;TNode&gt;.Enumerator GetEnumerator()" />
            <member def="public override int GetHashCode()" />
            <member def="public int IndexOf(TNode node)" />
            <member def="public int IndexOf(Func&lt;TNode, bool&gt; predicate)" />
            <member def="public SyntaxList&lt;TNode&gt; Insert(int index, TNode node)" />
            <member def="public SyntaxList&lt;TNode&gt; InsertRange(int index, IEnumerable&lt;TNode&gt; nodes)" />
            <member def="public TNode Last()" />
            <member def="public int LastIndexOf(TNode node)" />
            <member def="public int LastIndexOf(Func&lt;TNode, bool&gt; predicate)" />
            <member def="public TNode LastOrDefault()" />
            <member def="public SyntaxList&lt;TNode&gt; Remove(TNode node)" />
            <member def="public SyntaxList&lt;TNode&gt; RemoveAt(int index)" />
            <member def="public SyntaxList&lt;TNode&gt; Replace(TNode nodeInList, TNode newNode)" />
            <member def="public SyntaxList&lt;TNode&gt; ReplaceRange(TNode nodeInList, IEnumerable&lt;TNode&gt; newNodes)" />
            <member def="public string ToFullString()" />
            <member def="public override string ToString()" />
            <member def="public static implicit operator SyntaxList&lt;TNode&gt;(SyntaxList&lt;SyntaxNode&gt; nodes)" />
            <member def="public static implicit operator SyntaxList&lt;SyntaxNode&gt;(SyntaxList&lt;TNode&gt; nodes)" />
            <member def="public static bool operator ==(SyntaxList&lt;TNode&gt; left, SyntaxList&lt;TNode&gt; right)" />
            <member def="public static bool operator !=(SyntaxList&lt;TNode&gt; left, SyntaxList&lt;TNode&gt; right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SyntaxList&lt;TNode&gt;.Enumerator">
          <members>
            <member def="public TNode Current { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public override int GetHashCode()" />
            <member def="public bool MoveNext()" />
            <member def="public void Reset()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SyntaxNodeOrToken : IEquatable&lt;SyntaxNodeOrToken&gt;">
          <members>
            <member def="public bool ContainsAnnotations { get; }" />
            <member def="public bool ContainsDiagnostics { get; }" />
            <member def="public bool ContainsDirectives { get; }" />
            <member def="public TextSpan FullSpan { get; }" />
            <member def="public bool HasLeadingTrivia { get; }" />
            <member def="public bool HasTrailingTrivia { get; }" />
            <member def="public bool IsMissing { get; }" />
            <member def="public bool IsNode { get; }" />
            <member def="public bool IsToken { get; }" />
            <member def="public string Language { get; }" />
            <member def="public SyntaxNode Parent { get; }" />
            <member def="public int RawKind { get; }" />
            <member def="public TextSpan Span { get; }" />
            <member def="public int SpanStart { get; }" />
            <member def="public SyntaxTree SyntaxTree { get; }" />
            <member def="public SyntaxNode AsNode()" />
            <member def="public SyntaxToken AsToken()" />
            <member def="public ChildSyntaxList ChildNodesAndTokens()" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SyntaxNodeOrToken other)" />
            <member def="public IEnumerable&lt;SyntaxAnnotation&gt; GetAnnotations(string annotationKind)" />
            <member def="public IEnumerable&lt;SyntaxAnnotation&gt; GetAnnotations(IEnumerable&lt;string&gt; annotationKinds)" />
            <member def="public IEnumerable&lt;Diagnostic&gt; GetDiagnostics()" />
            <member def="public static int GetFirstChildIndexSpanningPosition(SyntaxNode node, int position)" />
            <member def="public override int GetHashCode()" />
            <member def="public SyntaxTriviaList GetLeadingTrivia()" />
            <member def="public Location GetLocation()" />
            <member def="public SyntaxNodeOrToken GetNextSibling()" />
            <member def="public SyntaxNodeOrToken GetPreviousSibling()" />
            <member def="public SyntaxTriviaList GetTrailingTrivia()" />
            <member def="public bool HasAnnotation(SyntaxAnnotation annotation)" />
            <member def="public bool HasAnnotations(string annotationKind)" />
            <member def="public bool HasAnnotations(IEnumerable&lt;string&gt; annotationKinds)" />
            <member def="public bool IsEquivalentTo(SyntaxNodeOrToken other)" />
            <member def="public string ToFullString()" />
            <member def="public override string ToString()" />
            <member def="public SyntaxNodeOrToken WithAdditionalAnnotations(params SyntaxAnnotation[] annotations)" />
            <member def="public SyntaxNodeOrToken WithAdditionalAnnotations(IEnumerable&lt;SyntaxAnnotation&gt; annotations)" />
            <member def="public SyntaxNodeOrToken WithLeadingTrivia(IEnumerable&lt;SyntaxTrivia&gt; trivia)" />
            <member def="public SyntaxNodeOrToken WithLeadingTrivia(params SyntaxTrivia[] trivia)" />
            <member def="public SyntaxNodeOrToken WithTrailingTrivia(IEnumerable&lt;SyntaxTrivia&gt; trivia)" />
            <member def="public SyntaxNodeOrToken WithTrailingTrivia(params SyntaxTrivia[] trivia)" />
            <member def="public SyntaxNodeOrToken WithoutAnnotations(string annotationKind)" />
            <member def="public SyntaxNodeOrToken WithoutAnnotations(params SyntaxAnnotation[] annotations)" />
            <member def="public SyntaxNodeOrToken WithoutAnnotations(IEnumerable&lt;SyntaxAnnotation&gt; annotations)" />
            <member def="public void WriteTo(TextWriter writer)" />
            <member def="public static explicit operator SyntaxToken(SyntaxNodeOrToken nodeOrToken)" />
            <member def="public static explicit operator SyntaxNode(SyntaxNodeOrToken nodeOrToken)" />
            <member def="public static implicit operator SyntaxNodeOrToken(SyntaxToken token)" />
            <member def="public static implicit operator SyntaxNodeOrToken(SyntaxNode node)" />
            <member def="public static bool operator ==(SyntaxNodeOrToken left, SyntaxNodeOrToken right)" />
            <member def="public static bool operator !=(SyntaxNodeOrToken left, SyntaxNodeOrToken right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SyntaxNodeOrTokenList : IEquatable&lt;SyntaxNodeOrTokenList&gt;, IEnumerable&lt;SyntaxNodeOrToken&gt;, IReadOnlyCollection&lt;SyntaxNodeOrToken&gt;">
          <members>
            <member def="public int Count { get; }" />
            <member def="public TextSpan FullSpan { get; }" />
            <member def="public TextSpan Span { get; }" />
            <member def="public SyntaxNodeOrToken this[int index] { get; }" />
            <member def="public SyntaxNodeOrTokenList Add(SyntaxNodeOrToken nodeOrToken)" />
            <member def="public SyntaxNodeOrTokenList AddRange(IEnumerable&lt;SyntaxNodeOrToken&gt; nodesOrTokens)" />
            <member def="public bool Any()" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SyntaxNodeOrTokenList other)" />
            <member def="public SyntaxNodeOrToken First()" />
            <member def="public SyntaxNodeOrToken FirstOrDefault()" />
            <member def="public SyntaxNodeOrTokenList.Enumerator GetEnumerator()" />
            <member def="public override int GetHashCode()" />
            <member def="public int IndexOf(SyntaxNodeOrToken nodeOrToken)" />
            <member def="public SyntaxNodeOrTokenList Insert(int index, SyntaxNodeOrToken nodeOrToken)" />
            <member def="public SyntaxNodeOrTokenList InsertRange(int index, IEnumerable&lt;SyntaxNodeOrToken&gt; nodesAndTokens)" />
            <member def="public SyntaxNodeOrToken Last()" />
            <member def="public SyntaxNodeOrToken LastOrDefault()" />
            <member def="public SyntaxNodeOrTokenList Remove(SyntaxNodeOrToken nodeOrTokenInList)" />
            <member def="public SyntaxNodeOrTokenList RemoveAt(int index)" />
            <member def="public SyntaxNodeOrTokenList Replace(SyntaxNodeOrToken nodeOrTokenInList, SyntaxNodeOrToken newNodeOrToken)" />
            <member def="public SyntaxNodeOrTokenList ReplaceRange(SyntaxNodeOrToken nodeOrTokenInList, IEnumerable&lt;SyntaxNodeOrToken&gt; newNodesAndTokens)" />
            <member def="public string ToFullString()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(SyntaxNodeOrTokenList left, SyntaxNodeOrTokenList right)" />
            <member def="public static bool operator !=(SyntaxNodeOrTokenList left, SyntaxNodeOrTokenList right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator : IDisposable, IEnumerator, IEnumerator&lt;SyntaxNodeOrToken&gt;">
          <members>
            <member def="public SyntaxNodeOrToken Current { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public override int GetHashCode()" />
            <member def="public bool MoveNext()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SyntaxToken : IEquatable&lt;SyntaxToken&gt;">
          <members>
            <member def="public bool ContainsAnnotations { get; }" />
            <member def="public bool ContainsDiagnostics { get; }" />
            <member def="public bool ContainsDirectives { get; }" />
            <member def="public TextSpan FullSpan { get; }" />
            <member def="public bool HasLeadingTrivia { get; }" />
            <member def="public bool HasStructuredTrivia { get; }" />
            <member def="public bool HasTrailingTrivia { get; }" />
            <member def="public bool IsMissing { get; }" />
            <member def="public string Language { get; }" />
            <member def="public SyntaxTriviaList LeadingTrivia { get; }" />
            <member def="public SyntaxNode Parent { get; }" />
            <member def="public int RawKind { get; }" />
            <member def="public TextSpan Span { get; }" />
            <member def="public int SpanStart { get; }" />
            <member def="public SyntaxTree SyntaxTree { get; }" />
            <member def="public string Text { get; }" />
            <member def="public SyntaxTriviaList TrailingTrivia { get; }" />
            <member def="public object Value { get; }" />
            <member def="public string ValueText { get; }" />
            <member def="public SyntaxToken CopyAnnotationsTo(SyntaxToken token)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SyntaxToken other)" />
            <member def="public IEnumerable&lt;SyntaxTrivia&gt; GetAllTrivia()" />
            <member def="public IEnumerable&lt;SyntaxAnnotation&gt; GetAnnotations(string annotationKind)" />
            <member def="public IEnumerable&lt;SyntaxAnnotation&gt; GetAnnotations(params string[] annotationKinds)" />
            <member def="public IEnumerable&lt;SyntaxAnnotation&gt; GetAnnotations(IEnumerable&lt;string&gt; annotationKinds)" />
            <member def="public IEnumerable&lt;Diagnostic&gt; GetDiagnostics()" />
            <member def="public override int GetHashCode()" />
            <member def="public Location GetLocation()" />
            <member def="public SyntaxToken GetNextToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false)" />
            <member def="public SyntaxToken GetPreviousToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false)" />
            <member def="public bool HasAnnotation(SyntaxAnnotation annotation)" />
            <member def="public bool HasAnnotations(string annotationKind)" />
            <member def="public bool HasAnnotations(params string[] annotationKinds)" />
            <member def="public bool IsEquivalentTo(SyntaxToken token)" />
            <member def="public bool IsPartOfStructuredTrivia()" />
            <member def="public string ToFullString()" />
            <member def="public override string ToString()" />
            <member def="public SyntaxToken WithAdditionalAnnotations(params SyntaxAnnotation[] annotations)" />
            <member def="public SyntaxToken WithAdditionalAnnotations(IEnumerable&lt;SyntaxAnnotation&gt; annotations)" />
            <member def="public SyntaxToken WithLeadingTrivia(SyntaxTriviaList trivia)" />
            <member def="public SyntaxToken WithLeadingTrivia(params SyntaxTrivia[] trivia)" />
            <member def="public SyntaxToken WithLeadingTrivia(IEnumerable&lt;SyntaxTrivia&gt; trivia)" />
            <member def="public SyntaxToken WithTrailingTrivia(SyntaxTriviaList trivia)" />
            <member def="public SyntaxToken WithTrailingTrivia(params SyntaxTrivia[] trivia)" />
            <member def="public SyntaxToken WithTrailingTrivia(IEnumerable&lt;SyntaxTrivia&gt; trivia)" />
            <member def="public SyntaxToken WithTriviaFrom(SyntaxToken token)" />
            <member def="public SyntaxToken WithoutAnnotations(string annotationKind)" />
            <member def="public SyntaxToken WithoutAnnotations(params SyntaxAnnotation[] annotations)" />
            <member def="public SyntaxToken WithoutAnnotations(IEnumerable&lt;SyntaxAnnotation&gt; annotations)" />
            <member def="public void WriteTo(TextWriter writer)" />
            <member def="public static bool operator ==(SyntaxToken left, SyntaxToken right)" />
            <member def="public static bool operator !=(SyntaxToken left, SyntaxToken right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SyntaxTokenList : IEquatable&lt;SyntaxTokenList&gt;, IEnumerable&lt;SyntaxToken&gt;, IReadOnlyCollection&lt;SyntaxToken&gt;, IReadOnlyList&lt;SyntaxToken&gt;">
          <members>
            <member def="public int Count { get; }" />
            <member def="public TextSpan FullSpan { get; }" />
            <member def="public TextSpan Span { get; }" />
            <member def="public SyntaxToken this[int index] { get; }" />
            <member def="public SyntaxTokenList Add(SyntaxToken token)" />
            <member def="public SyntaxTokenList AddRange(IEnumerable&lt;SyntaxToken&gt; tokens)" />
            <member def="public bool Any()" />
            <member def="public static SyntaxTokenList Create(SyntaxToken token)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SyntaxTokenList other)" />
            <member def="public SyntaxToken First()" />
            <member def="public SyntaxTokenList.Enumerator GetEnumerator()" />
            <member def="public override int GetHashCode()" />
            <member def="public int IndexOf(SyntaxToken tokenInList)" />
            <member def="public SyntaxTokenList Insert(int index, SyntaxToken token)" />
            <member def="public SyntaxTokenList InsertRange(int index, IEnumerable&lt;SyntaxToken&gt; tokens)" />
            <member def="public SyntaxToken Last()" />
            <member def="public SyntaxTokenList Remove(SyntaxToken tokenInList)" />
            <member def="public SyntaxTokenList RemoveAt(int index)" />
            <member def="public SyntaxTokenList Replace(SyntaxToken tokenInList, SyntaxToken newToken)" />
            <member def="public SyntaxTokenList ReplaceRange(SyntaxToken tokenInList, IEnumerable&lt;SyntaxToken&gt; newTokens)" />
            <member def="public SyntaxTokenList.Reversed Reverse()" />
            <member def="public string ToFullString()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(SyntaxTokenList left, SyntaxTokenList right)" />
            <member def="public static bool operator !=(SyntaxTokenList left, SyntaxTokenList right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SyntaxTokenList.Enumerator">
          <members>
            <member def="public SyntaxToken Current { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public override int GetHashCode()" />
            <member def="public bool MoveNext()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SyntaxTokenList.Reversed : IEquatable&lt;SyntaxTokenList.Reversed&gt;, IEnumerable&lt;SyntaxToken&gt;">
          <members>
            <member def="public Reversed(SyntaxTokenList list)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SyntaxTokenList.Reversed other)" />
            <member def="public SyntaxTokenList.Reversed.Enumerator GetEnumerator()" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SyntaxTokenList.Reversed.Enumerator">
          <members>
            <member def="public Enumerator(ref SyntaxTokenList list)" />
            <member def="public SyntaxToken Current { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public override int GetHashCode()" />
            <member def="public bool MoveNext()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SyntaxTrivia : IEquatable&lt;SyntaxTrivia&gt;">
          <members>
            <member def="public bool ContainsDiagnostics { get; }" />
            <member def="public TextSpan FullSpan { get; }" />
            <member def="public bool HasStructure { get; }" />
            <member def="public bool IsDirective { get; }" />
            <member def="public string Language { get; }" />
            <member def="public int RawKind { get; }" />
            <member def="public TextSpan Span { get; }" />
            <member def="public int SpanStart { get; }" />
            <member def="public SyntaxTree SyntaxTree { get; }" />
            <member def="public SyntaxToken Token { get; }" />
            <member def="public SyntaxTrivia CopyAnnotationsTo(SyntaxTrivia trivia)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SyntaxTrivia other)" />
            <member def="public IEnumerable&lt;SyntaxAnnotation&gt; GetAnnotations(string annotationKind)" />
            <member def="public IEnumerable&lt;SyntaxAnnotation&gt; GetAnnotations(params string[] annotationKinds)" />
            <member def="public IEnumerable&lt;Diagnostic&gt; GetDiagnostics()" />
            <member def="public override int GetHashCode()" />
            <member def="public Location GetLocation()" />
            <member def="public SyntaxNode GetStructure()" />
            <member def="public bool HasAnnotation(SyntaxAnnotation annotation)" />
            <member def="public bool HasAnnotations(string annotationKind)" />
            <member def="public bool HasAnnotations(params string[] annotationKinds)" />
            <member def="public bool IsEquivalentTo(SyntaxTrivia trivia)" />
            <member def="public bool IsPartOfStructuredTrivia()" />
            <member def="public string ToFullString()" />
            <member def="public override string ToString()" />
            <member def="public SyntaxTrivia WithAdditionalAnnotations(params SyntaxAnnotation[] annotations)" />
            <member def="public SyntaxTrivia WithAdditionalAnnotations(IEnumerable&lt;SyntaxAnnotation&gt; annotations)" />
            <member def="public SyntaxTrivia WithoutAnnotations(string annotationKind)" />
            <member def="public SyntaxTrivia WithoutAnnotations(params SyntaxAnnotation[] annotations)" />
            <member def="public SyntaxTrivia WithoutAnnotations(IEnumerable&lt;SyntaxAnnotation&gt; annotations)" />
            <member def="public void WriteTo(TextWriter writer)" />
            <member def="public static bool operator ==(SyntaxTrivia left, SyntaxTrivia right)" />
            <member def="public static bool operator !=(SyntaxTrivia left, SyntaxTrivia right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SyntaxTriviaList : IEquatable&lt;SyntaxTriviaList&gt;, IEnumerable&lt;SyntaxTrivia&gt;, IReadOnlyCollection&lt;SyntaxTrivia&gt;, IReadOnlyList&lt;SyntaxTrivia&gt;">
          <members>
            <member def="public int Count { get; }" />
            <member def="public static SyntaxTriviaList Empty { get; }" />
            <member def="public TextSpan FullSpan { get; }" />
            <member def="public TextSpan Span { get; }" />
            <member def="public SyntaxTrivia this[int index] { get; }" />
            <member def="public SyntaxTriviaList Add(SyntaxTrivia trivia)" />
            <member def="public SyntaxTriviaList AddRange(IEnumerable&lt;SyntaxTrivia&gt; trivia)" />
            <member def="public bool Any()" />
            <member def="public static SyntaxTriviaList Create(SyntaxTrivia trivia)" />
            <member def="public SyntaxTrivia ElementAt(int index)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SyntaxTriviaList other)" />
            <member def="public SyntaxTrivia First()" />
            <member def="public SyntaxTriviaList.Enumerator GetEnumerator()" />
            <member def="public override int GetHashCode()" />
            <member def="public int IndexOf(SyntaxTrivia triviaInList)" />
            <member def="public SyntaxTriviaList Insert(int index, SyntaxTrivia trivia)" />
            <member def="public SyntaxTriviaList InsertRange(int index, IEnumerable&lt;SyntaxTrivia&gt; trivia)" />
            <member def="public SyntaxTrivia Last()" />
            <member def="public SyntaxTriviaList Remove(SyntaxTrivia triviaInList)" />
            <member def="public SyntaxTriviaList RemoveAt(int index)" />
            <member def="public SyntaxTriviaList Replace(SyntaxTrivia triviaInList, SyntaxTrivia newTrivia)" />
            <member def="public SyntaxTriviaList ReplaceRange(SyntaxTrivia triviaInList, IEnumerable&lt;SyntaxTrivia&gt; newTrivia)" />
            <member def="public SyntaxTriviaList.Reversed Reverse()" />
            <member def="public string ToFullString()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(SyntaxTriviaList left, SyntaxTriviaList right)" />
            <member def="public static bool operator !=(SyntaxTriviaList left, SyntaxTriviaList right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SyntaxTriviaList.Enumerator">
          <members>
            <member def="public SyntaxTrivia Current { get; }" />
            <member def="public bool MoveNext()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SyntaxTriviaList.Reversed : IEquatable&lt;SyntaxTriviaList.Reversed&gt;, IEnumerable&lt;SyntaxTrivia&gt;">
          <members>
            <member def="public Reversed(SyntaxTriviaList list)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SyntaxTriviaList.Reversed other)" />
            <member def="public SyntaxTriviaList.Reversed.Enumerator GetEnumerator()" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.SyntaxTriviaList.Reversed.Enumerator">
          <members>
            <member def="public Enumerator(ref SyntaxTriviaList list)" />
            <member def="public SyntaxTrivia Current { get; }" />
            <member def="public bool MoveNext()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.TypeInfo : IEquatable&lt;TypeInfo&gt;">
          <members>
            <member def="public ITypeSymbol ConvertedType { get; }" />
            <member def="public ITypeSymbol Type { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(TypeInfo other)" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.TypedConstant : IEquatable&lt;TypedConstant&gt;">
          <members>
            <member def="public bool IsNull { get; }" />
            <member def="public TypedConstantKind Kind { get; }" />
            <member def="public ITypeSymbol Type { get; }" />
            <member def="public object Value { get; }" />
            <member def="public ImmutableArray&lt;TypedConstant&gt; Values { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(TypedConstant other)" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.VersionStamp : IEquatable&lt;VersionStamp&gt;, IObjectWritable">
          <members>
            <member def="public static VersionStamp Default { get; }" />
            <member def="public static VersionStamp Create()" />
            <member def="public static VersionStamp Create(DateTime utcTimeLastModified)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(VersionStamp version)" />
            <member def="public override int GetHashCode()" />
            <member def="public VersionStamp GetNewerVersion()" />
            <member def="public VersionStamp GetNewerVersion(VersionStamp version)" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(VersionStamp left, VersionStamp right)" />
            <member def="public static bool operator !=(VersionStamp left, VersionStamp right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo : IEquatable&lt;AwaitExpressionInfo&gt;">
          <members>
            <member def="public IMethodSymbol GetAwaiterMethod { get; }" />
            <member def="public IMethodSymbol GetResultMethod { get; }" />
            <member def="public IPropertySymbol IsCompletedProperty { get; }" />
            <member def="public bool IsDynamic { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(AwaitExpressionInfo other)" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.CSharp.Conversion : IEquatable&lt;Conversion&gt;">
          <members>
            <member def="public bool Exists { get; }" />
            <member def="public bool IsAnonymousFunction { get; }" />
            <member def="public bool IsBoxing { get; }" />
            <member def="public bool IsConstantExpression { get; }" />
            <member def="public bool IsDynamic { get; }" />
            <member def="public bool IsEnumeration { get; }" />
            <member def="public bool IsExplicit { get; }" />
            <member def="public bool IsIdentity { get; }" />
            <member def="public bool IsImplicit { get; }" />
            <member def="public bool IsIntPtr { get; }" />
            <member def="public bool IsInterpolatedString { get; }" />
            <member def="public bool IsMethodGroup { get; }" />
            <member def="public bool IsNullLiteral { get; }" />
            <member def="public bool IsNullable { get; }" />
            <member def="public bool IsNumeric { get; }" />
            <member def="public bool IsPointer { get; }" />
            <member def="public bool IsReference { get; }" />
            <member def="public bool IsThrow { get; }" />
            <member def="public bool IsTupleConversion { get; }" />
            <member def="public bool IsTupleLiteralConversion { get; }" />
            <member def="public bool IsUnboxing { get; }" />
            <member def="public bool IsUserDefined { get; }" />
            <member def="public IMethodSymbol MethodSymbol { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(Conversion other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(Conversion left, Conversion right)" />
            <member def="public static bool operator !=(Conversion left, Conversion right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo : IEquatable&lt;ForEachStatementInfo&gt;">
          <members>
            <member def="public Conversion CurrentConversion { get; }" />
            <member def="public IPropertySymbol CurrentProperty { get; }" />
            <member def="public IMethodSymbol DisposeMethod { get; }" />
            <member def="public Conversion ElementConversion { get; }" />
            <member def="public ITypeSymbol ElementType { get; }" />
            <member def="public IMethodSymbol GetEnumeratorMethod { get; }" />
            <member def="public IMethodSymbol MoveNextMethod { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(ForEachStatementInfo other)" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.CSharp.QueryClauseInfo : IEquatable&lt;QueryClauseInfo&gt;">
          <members>
            <member def="public SymbolInfo CastInfo { get; }" />
            <member def="public SymbolInfo OperationInfo { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(QueryClauseInfo other)" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Classification.ClassifiedSpan : IEquatable&lt;ClassifiedSpan&gt;">
          <members>
            <member def="public ClassifiedSpan(string classificationType, TextSpan textSpan)" />
            <member def="public ClassifiedSpan(TextSpan textSpan, string classificationType)" />
            <member def="public string ClassificationType { get; }" />
            <member def="public TextSpan TextSpan { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(ClassifiedSpan other)" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.CodeFixes.CodeFixContext">
          <members>
            <member def="public CodeFixContext(Document document, Diagnostic diagnostic, Action&lt;CodeAction, ImmutableArray&lt;Diagnostic&gt;&gt; registerCodeFix, CancellationToken cancellationToken)" />
            <member def="public CodeFixContext(Document document, TextSpan span, ImmutableArray&lt;Diagnostic&gt; diagnostics, Action&lt;CodeAction, ImmutableArray&lt;Diagnostic&gt;&gt; registerCodeFix, CancellationToken cancellationToken)" />
            <member def="public CancellationToken CancellationToken { get; }" />
            <member def="public ImmutableArray&lt;Diagnostic&gt; Diagnostics { get; }" />
            <member def="public Document Document { get; }" />
            <member def="public TextSpan Span { get; }" />
            <member def="public void RegisterCodeFix(CodeAction action, Diagnostic diagnostic)" />
            <member def="public void RegisterCodeFix(CodeAction action, IEnumerable&lt;Diagnostic&gt; diagnostics)" />
            <member def="public void RegisterCodeFix(CodeAction action, ImmutableArray&lt;Diagnostic&gt; diagnostics)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext">
          <members>
            <member def="public CodeRefactoringContext(Document document, TextSpan span, Action&lt;CodeAction&gt; registerRefactoring, CancellationToken cancellationToken)" />
            <member def="public CancellationToken CancellationToken { get; }" />
            <member def="public Document Document { get; }" />
            <member def="public TextSpan Span { get; }" />
            <member def="public void RegisterRefactoring(CodeAction action)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext">
          <members>
            <member def="public CodeBlockAnalysisContext(SyntaxNode codeBlock, ISymbol owningSymbol, SemanticModel semanticModel, AnalyzerOptions options, Action&lt;Diagnostic&gt; reportDiagnostic, Func&lt;Diagnostic, bool&gt; isSupportedDiagnostic, CancellationToken cancellationToken)" />
            <member def="public CancellationToken CancellationToken { get; }" />
            <member def="public SyntaxNode CodeBlock { get; }" />
            <member def="public AnalyzerOptions Options { get; }" />
            <member def="public ISymbol OwningSymbol { get; }" />
            <member def="public SemanticModel SemanticModel { get; }" />
            <member def="public void ReportDiagnostic(Diagnostic diagnostic)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext">
          <members>
            <member def="public CompilationAnalysisContext(Compilation compilation, AnalyzerOptions options, Action&lt;Diagnostic&gt; reportDiagnostic, Func&lt;Diagnostic, bool&gt; isSupportedDiagnostic, CancellationToken cancellationToken)" />
            <member def="public CancellationToken CancellationToken { get; }" />
            <member def="public Compilation Compilation { get; }" />
            <member def="public AnalyzerOptions Options { get; }" />
            <member def="public void ReportDiagnostic(Diagnostic diagnostic)" />
            <member def="public bool TryGetValue&lt;TValue&gt;(SourceText text, SourceTextValueProvider&lt;TValue&gt; valueProvider, out TValue value)" />
            <member def="public bool TryGetValue&lt;TValue&gt;(SyntaxTree tree, SyntaxTreeValueProvider&lt;TValue&gt; valueProvider, out TValue value)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext">
          <members>
            <member def="public OperationAnalysisContext(IOperation operation, ISymbol containingSymbol, Compilation compilation, AnalyzerOptions options, Action&lt;Diagnostic&gt; reportDiagnostic, Func&lt;Diagnostic, bool&gt; isSupportedDiagnostic, CancellationToken cancellationToken)" />
            <member def="public CancellationToken CancellationToken { get; }" />
            <member def="public Compilation Compilation { get; }" />
            <member def="public ISymbol ContainingSymbol { get; }" />
            <member def="public IOperation Operation { get; }" />
            <member def="public AnalyzerOptions Options { get; }" />
            <member def="public void ReportDiagnostic(Diagnostic diagnostic)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext">
          <members>
            <member def="public OperationBlockAnalysisContext(ImmutableArray&lt;IOperation&gt; operationBlocks, ISymbol owningSymbol, Compilation compilation, AnalyzerOptions options, Action&lt;Diagnostic&gt; reportDiagnostic, Func&lt;Diagnostic, bool&gt; isSupportedDiagnostic, CancellationToken cancellationToken)" />
            <member def="public CancellationToken CancellationToken { get; }" />
            <member def="public Compilation Compilation { get; }" />
            <member def="public ImmutableArray&lt;IOperation&gt; OperationBlocks { get; }" />
            <member def="public AnalyzerOptions Options { get; }" />
            <member def="public ISymbol OwningSymbol { get; }" />
            <member def="public void ReportDiagnostic(Diagnostic diagnostic)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext">
          <members>
            <member def="public SemanticModelAnalysisContext(SemanticModel semanticModel, AnalyzerOptions options, Action&lt;Diagnostic&gt; reportDiagnostic, Func&lt;Diagnostic, bool&gt; isSupportedDiagnostic, CancellationToken cancellationToken)" />
            <member def="public CancellationToken CancellationToken { get; }" />
            <member def="public AnalyzerOptions Options { get; }" />
            <member def="public SemanticModel SemanticModel { get; }" />
            <member def="public void ReportDiagnostic(Diagnostic diagnostic)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext">
          <members>
            <member def="public SymbolAnalysisContext(ISymbol symbol, Compilation compilation, AnalyzerOptions options, Action&lt;Diagnostic&gt; reportDiagnostic, Func&lt;Diagnostic, bool&gt; isSupportedDiagnostic, CancellationToken cancellationToken)" />
            <member def="public CancellationToken CancellationToken { get; }" />
            <member def="public Compilation Compilation { get; }" />
            <member def="public AnalyzerOptions Options { get; }" />
            <member def="public ISymbol Symbol { get; }" />
            <member def="public void ReportDiagnostic(Diagnostic diagnostic)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext">
          <members>
            <member def="public SyntaxNodeAnalysisContext(SyntaxNode node, SemanticModel semanticModel, AnalyzerOptions options, Action&lt;Diagnostic&gt; reportDiagnostic, Func&lt;Diagnostic, bool&gt; isSupportedDiagnostic, CancellationToken cancellationToken)" />
            <member def="public SyntaxNodeAnalysisContext(SyntaxNode node, ISymbol containingSymbol, SemanticModel semanticModel, AnalyzerOptions options, Action&lt;Diagnostic&gt; reportDiagnostic, Func&lt;Diagnostic, bool&gt; isSupportedDiagnostic, CancellationToken cancellationToken)" />
            <member def="public CancellationToken CancellationToken { get; }" />
            <member def="public Compilation Compilation { get; }" />
            <member def="public ISymbol ContainingSymbol { get; }" />
            <member def="public SyntaxNode Node { get; }" />
            <member def="public AnalyzerOptions Options { get; }" />
            <member def="public SemanticModel SemanticModel { get; }" />
            <member def="public void ReportDiagnostic(Diagnostic diagnostic)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext">
          <members>
            <member def="public SyntaxTreeAnalysisContext(SyntaxTree tree, AnalyzerOptions options, Action&lt;Diagnostic&gt; reportDiagnostic, Func&lt;Diagnostic, bool&gt; isSupportedDiagnostic, CancellationToken cancellationToken)" />
            <member def="public CancellationToken CancellationToken { get; }" />
            <member def="public AnalyzerOptions Options { get; }" />
            <member def="public SyntaxTree Tree { get; }" />
            <member def="public void ReportDiagnostic(Diagnostic diagnostic)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Differencing.Edit&lt;TNode&gt; : IEquatable&lt;Edit&lt;TNode&gt;&gt;">
          <members>
            <member def="public EditKind Kind { get; }" />
            <member def="public TNode NewNode { get; }" />
            <member def="public TNode OldNode { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(Edit&lt;TNode&gt; other)" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Editing.DeclarationModifiers : IEquatable&lt;DeclarationModifiers&gt;">
          <members>
            <member def="public static DeclarationModifiers Abstract { get; }" />
            <member def="public static DeclarationModifiers Async { get; }" />
            <member def="public static DeclarationModifiers Const { get; }" />
            <member def="public bool IsAbstract { get; }" />
            <member def="public bool IsAsync { get; }" />
            <member def="public bool IsConst { get; }" />
            <member def="public bool IsNew { get; }" />
            <member def="public bool IsOverride { get; }" />
            <member def="public bool IsPartial { get; }" />
            <member def="public bool IsReadOnly { get; }" />
            <member def="public bool IsSealed { get; }" />
            <member def="public bool IsStatic { get; }" />
            <member def="public bool IsUnsafe { get; }" />
            <member def="public bool IsVirtual { get; }" />
            <member def="public bool IsWithEvents { get; }" />
            <member def="public bool IsWriteOnly { get; }" />
            <member def="public static DeclarationModifiers New { get; }" />
            <member def="public static DeclarationModifiers None { get; }" />
            <member def="public static DeclarationModifiers Override { get; }" />
            <member def="public static DeclarationModifiers Partial { get; }" />
            <member def="public static DeclarationModifiers ReadOnly { get; }" />
            <member def="public static DeclarationModifiers Sealed { get; }" />
            <member def="public static DeclarationModifiers Static { get; }" />
            <member def="public static DeclarationModifiers Unsafe { get; }" />
            <member def="public static DeclarationModifiers Virtual { get; }" />
            <member def="public static DeclarationModifiers WithEvents { get; }" />
            <member def="public static DeclarationModifiers WriteOnly { get; }" />
            <member def="public bool Equals(DeclarationModifiers modifiers)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public static DeclarationModifiers From(ISymbol symbol)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool TryParse(string value, out DeclarationModifiers modifiers)" />
            <member def="public DeclarationModifiers WithAsync(bool isAsync)" />
            <member def="public DeclarationModifiers WithIsAbstract(bool isAbstract)" />
            <member def="public DeclarationModifiers WithIsConst(bool isConst)" />
            <member def="public DeclarationModifiers WithIsNew(bool isNew)" />
            <member def="public DeclarationModifiers WithIsOverride(bool isOverride)" />
            <member def="public DeclarationModifiers WithIsReadOnly(bool isReadOnly)" />
            <member def="public DeclarationModifiers WithIsSealed(bool isSealed)" />
            <member def="public DeclarationModifiers WithIsStatic(bool isStatic)" />
            <member def="public DeclarationModifiers WithIsUnsafe(bool isUnsafe)" />
            <member def="public DeclarationModifiers WithIsVirtual(bool isVirtual)" />
            <member def="public DeclarationModifiers WithIsWriteOnly(bool isWriteOnly)" />
            <member def="public DeclarationModifiers WithPartial(bool isPartial)" />
            <member def="public DeclarationModifiers WithWithEvents(bool withEvents)" />
            <member def="public static DeclarationModifiers operator +(DeclarationModifiers left, DeclarationModifiers right)" />
            <member def="public static DeclarationModifiers operator &amp;(DeclarationModifiers left, DeclarationModifiers right)" />
            <member def="public static DeclarationModifiers operator |(DeclarationModifiers left, DeclarationModifiers right)" />
            <member def="public static bool operator ==(DeclarationModifiers left, DeclarationModifiers right)" />
            <member def="public static bool operator !=(DeclarationModifiers left, DeclarationModifiers right)" />
            <member def="public static DeclarationModifiers operator -(DeclarationModifiers left, DeclarationModifiers right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation">
          <members>
            <member def="public static EditAndContinueMethodDebugInformation Create(ImmutableArray&lt;byte&gt; compressedSlotMap, ImmutableArray&lt;byte&gt; compressedLambdaMap)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Emit.SemanticEdit : IEquatable&lt;SemanticEdit&gt;">
          <members>
            <member def="public SemanticEdit(SemanticEditKind kind, ISymbol oldSymbol, ISymbol newSymbol, Func&lt;SyntaxNode, SyntaxNode&gt; syntaxMap = null, bool preserveLocalVariables = false)" />
            <member def="public SemanticEditKind Kind { get; }" />
            <member def="public ISymbol NewSymbol { get; }" />
            <member def="public ISymbol OldSymbol { get; }" />
            <member def="public bool PreserveLocalVariables { get; }" />
            <member def="public Func&lt;SyntaxNode, SyntaxNode&gt; SyntaxMap { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SemanticEdit other)" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation : IComparable&lt;ReferenceLocation&gt;, IEquatable&lt;ReferenceLocation&gt;">
          <members>
            <member def="public IAliasSymbol Alias { get; }" />
            <member def="public CandidateReason CandidateReason { get; }" />
            <member def="public Document Document { get; }" />
            <member def="public bool IsCandidateLocation { get; }" />
            <member def="public bool IsImplicit { get; }" />
            <member def="public Location Location { get; }" />
            <member def="public int CompareTo(ReferenceLocation other)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(ReferenceLocation other)" />
            <member def="public override int GetHashCode()" />
            <member def="public static bool operator ==(ReferenceLocation left, ReferenceLocation right)" />
            <member def="public static bool operator !=(ReferenceLocation left, ReferenceLocation right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo">
          <members>
            <member def="public ISymbol CalledSymbol { get; }" />
            <member def="public ISymbol CallingSymbol { get; }" />
            <member def="public bool IsDirect { get; }" />
            <member def="public IEnumerable&lt;Location&gt; Locations { get; }" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Options.OptionKey : IEquatable&lt;OptionKey&gt;">
          <members>
            <member def="public OptionKey(IOption option, string language = null)" />
            <member def="public string Language { get; }" />
            <member def="public IOption Option { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(OptionKey other)" />
            <member def="public override int GetHashCode()" />
            <member def="public static bool operator ==(OptionKey left, OptionKey right)" />
            <member def="public static bool operator !=(OptionKey left, OptionKey right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Text.LinePosition : IComparable&lt;LinePosition&gt;, IEquatable&lt;LinePosition&gt;">
          <members>
            <member def="public LinePosition(int line, int character)" />
            <member def="public int Character { get; }" />
            <member def="public int Line { get; }" />
            <member def="public static LinePosition Zero { get; }" />
            <member def="public int CompareTo(LinePosition other)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(LinePosition other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(LinePosition left, LinePosition right)" />
            <member def="public static bool operator &gt;(LinePosition left, LinePosition right)" />
            <member def="public static bool operator &gt;=(LinePosition left, LinePosition right)" />
            <member def="public static bool operator !=(LinePosition left, LinePosition right)" />
            <member def="public static bool operator &lt;(LinePosition left, LinePosition right)" />
            <member def="public static bool operator &lt;=(LinePosition left, LinePosition right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Text.LinePositionSpan : IEquatable&lt;LinePositionSpan&gt;">
          <members>
            <member def="public LinePositionSpan(LinePosition start, LinePosition end)" />
            <member def="public LinePosition End { get; }" />
            <member def="public LinePosition Start { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(LinePositionSpan other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(LinePositionSpan left, LinePositionSpan right)" />
            <member def="public static bool operator !=(LinePositionSpan left, LinePositionSpan right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Text.TextChange : IEquatable&lt;TextChange&gt;">
          <members>
            <member def="public TextChange(TextSpan span, string newText)" />
            <member def="public string NewText { get; }" />
            <member def="public static IReadOnlyList&lt;TextChange&gt; NoChanges { get; }" />
            <member def="public TextSpan Span { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(TextChange other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static implicit operator TextChangeRange(TextChange change)" />
            <member def="public static bool operator ==(TextChange left, TextChange right)" />
            <member def="public static bool operator !=(TextChange left, TextChange right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Text.TextChangeRange : IEquatable&lt;TextChangeRange&gt;">
          <members>
            <member def="public TextChangeRange(TextSpan span, int newLength)" />
            <member def="public int NewLength { get; }" />
            <member def="public static IReadOnlyList&lt;TextChangeRange&gt; NoChanges { get; }" />
            <member def="public TextSpan Span { get; }" />
            <member def="public static TextChangeRange Collapse(IEnumerable&lt;TextChangeRange&gt; changes)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(TextChangeRange other)" />
            <member def="public override int GetHashCode()" />
            <member def="public static bool operator ==(TextChangeRange left, TextChangeRange right)" />
            <member def="public static bool operator !=(TextChangeRange left, TextChangeRange right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Text.TextLine : IEquatable&lt;TextLine&gt;">
          <members>
            <member def="public int End { get; }" />
            <member def="public int EndIncludingLineBreak { get; }" />
            <member def="public int LineNumber { get; }" />
            <member def="public TextSpan Span { get; }" />
            <member def="public TextSpan SpanIncludingLineBreak { get; }" />
            <member def="public int Start { get; }" />
            <member def="public SourceText Text { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(TextLine other)" />
            <member def="public static TextLine FromSpan(SourceText text, TextSpan span)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(TextLine left, TextLine right)" />
            <member def="public static bool operator !=(TextLine left, TextLine right)" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Text.TextLineCollection.Enumerator : IDisposable, IEnumerator, IEnumerator&lt;TextLine&gt;">
          <members>
            <member def="public TextLine Current { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public override int GetHashCode()" />
            <member def="public bool MoveNext()" />
          </members>
        </type>
        <type def="public struct Microsoft.CodeAnalysis.Text.TextSpan : IComparable&lt;TextSpan&gt;, IEquatable&lt;TextSpan&gt;">
          <members>
            <member def="public TextSpan(int start, int length)" />
            <member def="public int End { get; }" />
            <member def="public bool IsEmpty { get; }" />
            <member def="public int Length { get; }" />
            <member def="public int Start { get; }" />
            <member def="public int CompareTo(TextSpan other)" />
            <member def="public bool Contains(int position)" />
            <member def="public bool Contains(TextSpan span)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(TextSpan other)" />
            <member def="public static TextSpan FromBounds(int start, int end)" />
            <member def="public override int GetHashCode()" />
            <member def="public TextSpan? Intersection(TextSpan span)" />
            <member def="public bool IntersectsWith(int position)" />
            <member def="public bool IntersectsWith(TextSpan span)" />
            <member def="public TextSpan? Overlap(TextSpan span)" />
            <member def="public bool OverlapsWith(TextSpan span)" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(TextSpan left, TextSpan right)" />
            <member def="public static bool operator !=(TextSpan left, TextSpan right)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.ExtensionMethodSymbolInfo : IEquatable&lt;ExtensionMethodSymbolInfo&gt;">
          <members>
            <member def="public bool IsReduced { get; }" />
            <member def="public IMethodSymbol ReducedSymbol { get; }" />
            <member def="public IMethodSymbol ReducedSymbolOrSymbol { get; }" />
            <member def="public IMethodSymbol Symbol { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(ExtensionMethodSymbolInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public static bool operator ==(in ExtensionMethodSymbolInfo info1, in ExtensionMethodSymbolInfo info2)" />
            <member def="public static bool operator !=(in ExtensionMethodSymbolInfo info1, in ExtensionMethodSymbolInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.MetadataName : IEquatable&lt;MetadataName&gt;">
          <members>
            <member def="public MetadataName(IEnumerable&lt;string&gt; containingNamespaces, string name)" />
            <member def="public MetadataName(ImmutableArray&lt;string&gt; containingNamespaces, string name)" />
            <member def="public MetadataName(IEnumerable&lt;string&gt; containingNamespaces, IEnumerable&lt;string&gt; containingTypes, string name)" />
            <member def="public MetadataName(ImmutableArray&lt;string&gt; containingNamespaces, ImmutableArray&lt;string&gt; containingTypes, string name)" />
            <member def="public ImmutableArray&lt;string&gt; ContainingNamespaces { get; }" />
            <member def="public ImmutableArray&lt;string&gt; ContainingTypes { get; }" />
            <member def="public bool IsDefault { get; }" />
            <member def="public string Name { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(MetadataName other)" />
            <member def="public override int GetHashCode()" />
            <member def="public static MetadataName Parse(string name)" />
            <member def="public override string ToString()" />
            <member def="public static bool TryParse(string name, out MetadataName metadataName)" />
            <member def="public static bool operator ==(in MetadataName metadataName1, in MetadataName metadataName2)" />
            <member def="public static bool operator !=(in MetadataName metadataName1, in MetadataName metadataName2)" />
          </members>
        </type>
        <type def="public struct Roslynator.SeparatedSyntaxListSelection&lt;TNode&gt;.Enumerator">
          <members>
            <member def="public TNode Current { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public override int GetHashCode()" />
            <member def="public bool MoveNext()" />
            <member def="public void Reset()" />
          </members>
        </type>
        <type def="public struct Roslynator.SyntaxListSelection&lt;TNode&gt;.Enumerator">
          <members>
            <member def="public TNode Current { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public override int GetHashCode()" />
            <member def="public bool MoveNext()" />
            <member def="public void Reset()" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.ExpressionChain : IEquatable&lt;ExpressionChain&gt;, IEnumerable&lt;ExpressionSyntax&gt;">
          <members>
            <member def="public BinaryExpressionSyntax BinaryExpression { get; }" />
            <member def="public TextSpan? Span { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(ExpressionChain other)" />
            <member def="public ExpressionChain.Enumerator GetEnumerator()" />
            <member def="public override int GetHashCode()" />
            <member def="public ExpressionChain.Reversed Reverse()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in ExpressionChain info1, in ExpressionChain info2)" />
            <member def="public static bool operator !=(in ExpressionChain info1, in ExpressionChain info2)" />
          </members>
        </type>
        <type def="public struct Roslynator.CSharp.ExpressionChain.Enumerator">
          <members>
            <member def="public ExpressionSyntax Current { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public override int GetHashCode()" />
            <member def="public bool MoveNext()" />
            <member def="public void Reset()" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.ExpressionChain.Reversed : IEquatable&lt;ExpressionChain.Reversed&gt;, IEnumerable&lt;ExpressionSyntax&gt;">
          <members>
            <member def="public Reversed(in ExpressionChain chain)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(ExpressionChain.Reversed other)" />
            <member def="public ExpressionChain.Reversed.Enumerator GetEnumerator()" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in ExpressionChain.Reversed reversed1, in ExpressionChain.Reversed reversed2)" />
            <member def="public static bool operator !=(in ExpressionChain.Reversed reversed1, in ExpressionChain.Reversed reversed2)" />
          </members>
        </type>
        <type def="public struct Roslynator.CSharp.ExpressionChain.Reversed.Enumerator">
          <members>
            <member def="public ExpressionSyntax Current { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public override int GetHashCode()" />
            <member def="public bool MoveNext()" />
            <member def="public void Reset()" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.IfStatementCascade : IEquatable&lt;IfStatementCascade&gt;, IEnumerable&lt;IfStatementOrElseClause&gt;">
          <members>
            <member def="public IfStatementSyntax IfStatement { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(IfStatementCascade other)" />
            <member def="public IfStatementCascade.Enumerator GetEnumerator()" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in IfStatementCascade cascade1, in IfStatementCascade cascade2)" />
            <member def="public static bool operator !=(in IfStatementCascade cascade1, in IfStatementCascade cascade2)" />
          </members>
        </type>
        <type def="public struct Roslynator.CSharp.IfStatementCascade.Enumerator">
          <members>
            <member def="public IfStatementOrElseClause Current { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public override int GetHashCode()" />
            <member def="public bool MoveNext()" />
            <member def="public void Reset()" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.IfStatementCascadeInfo : IEquatable&lt;IfStatementCascadeInfo&gt;">
          <members>
            <member def="public IfStatementCascadeInfo(IfStatementSyntax ifStatement)" />
            <member def="public int Count { get; }" />
            <member def="public bool EndsWithElse { get; }" />
            <member def="public bool EndsWithIf { get; }" />
            <member def="public IfStatementSyntax IfStatement { get; }" />
            <member def="public bool IsSimpleIf { get; }" />
            <member def="public bool IsSimpleIfElse { get; }" />
            <member def="public IfStatementOrElseClause Last { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(IfStatementCascadeInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in IfStatementCascadeInfo info1, in IfStatementCascadeInfo info2)" />
            <member def="public static bool operator !=(in IfStatementCascadeInfo info1, in IfStatementCascadeInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.IfStatementOrElseClause : IEquatable&lt;IfStatementOrElseClause&gt;">
          <members>
            <member def="public IfStatementOrElseClause(ElseClauseSyntax elseClause)" />
            <member def="public IfStatementOrElseClause(IfStatementSyntax ifStatement)" />
            <member def="public TextSpan FullSpan { get; }" />
            <member def="public bool IsElse { get; }" />
            <member def="public bool IsIf { get; }" />
            <member def="public SyntaxKind Kind { get; }" />
            <member def="public SyntaxNode Parent { get; }" />
            <member def="public TextSpan Span { get; }" />
            <member def="public StatementSyntax Statement { get; }" />
            <member def="public ElseClauseSyntax AsElse()" />
            <member def="public IfStatementSyntax AsIf()" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(IfStatementOrElseClause other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static implicit operator IfStatementOrElseClause(IfStatementSyntax ifStatement)" />
            <member def="public static implicit operator IfStatementSyntax(in IfStatementOrElseClause ifOrElse)" />
            <member def="public static implicit operator IfStatementOrElseClause(ElseClauseSyntax elseClause)" />
            <member def="public static implicit operator ElseClauseSyntax(in IfStatementOrElseClause ifOrElse)" />
            <member def="public static bool operator ==(in IfStatementOrElseClause left, in IfStatementOrElseClause right)" />
            <member def="public static bool operator !=(in IfStatementOrElseClause left, in IfStatementOrElseClause right)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.AsExpressionInfo : IEquatable&lt;AsExpressionInfo&gt;">
          <members>
            <member def="public BinaryExpressionSyntax AsExpression { get; }" />
            <member def="public ExpressionSyntax Expression { get; }" />
            <member def="public SyntaxToken OperatorToken { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public TypeSyntax Type { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(AsExpressionInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in AsExpressionInfo info1, in AsExpressionInfo info2)" />
            <member def="public static bool operator !=(in AsExpressionInfo info1, in AsExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.AssignmentExpressionInfo : IEquatable&lt;AssignmentExpressionInfo&gt;">
          <members>
            <member def="public AssignmentExpressionSyntax AssignmentExpression { get; }" />
            <member def="public SyntaxKind Kind { get; }" />
            <member def="public ExpressionSyntax Left { get; }" />
            <member def="public SyntaxToken OperatorToken { get; }" />
            <member def="public ExpressionSyntax Right { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(AssignmentExpressionInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in AssignmentExpressionInfo info1, in AssignmentExpressionInfo info2)" />
            <member def="public static bool operator !=(in AssignmentExpressionInfo info1, in AssignmentExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.BinaryExpressionInfo : IEquatable&lt;BinaryExpressionInfo&gt;">
          <members>
            <member def="public BinaryExpressionSyntax BinaryExpression { get; }" />
            <member def="public SyntaxKind Kind { get; }" />
            <member def="public ExpressionSyntax Left { get; }" />
            <member def="public SyntaxToken OperatorToken { get; }" />
            <member def="public ExpressionSyntax Right { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public ExpressionChain AsChain()" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(BinaryExpressionInfo other)" />
            <member def="public IEnumerable&lt;ExpressionSyntax&gt; Expressions(bool leftToRight = false)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in BinaryExpressionInfo info1, in BinaryExpressionInfo info2)" />
            <member def="public static bool operator !=(in BinaryExpressionInfo info1, in BinaryExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.ConditionalExpressionInfo : IEquatable&lt;ConditionalExpressionInfo&gt;">
          <members>
            <member def="public SyntaxToken ColonToken { get; }" />
            <member def="public ExpressionSyntax Condition { get; }" />
            <member def="public ConditionalExpressionSyntax ConditionalExpression { get; }" />
            <member def="public SyntaxToken QuestionToken { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public ExpressionSyntax WhenFalse { get; }" />
            <member def="public ExpressionSyntax WhenTrue { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(ConditionalExpressionInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in ConditionalExpressionInfo info1, in ConditionalExpressionInfo info2)" />
            <member def="public static bool operator !=(in ConditionalExpressionInfo info1, in ConditionalExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.GenericInfo : IEquatable&lt;GenericInfo&gt;">
          <members>
            <member def="public SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; ConstraintClauses { get; }" />
            <member def="public SyntaxKind Kind { get; }" />
            <member def="public SyntaxNode Node { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public TypeParameterListSyntax TypeParameterList { get; }" />
            <member def="public SeparatedSyntaxList&lt;TypeParameterSyntax&gt; TypeParameters { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(GenericInfo other)" />
            <member def="public TypeParameterConstraintClauseSyntax FindConstraintClause(string typeParameterName)" />
            <member def="public TypeParameterSyntax FindTypeParameter(string name)" />
            <member def="public override int GetHashCode()" />
            <member def="public GenericInfo RemoveAllConstraintClauses()" />
            <member def="public GenericInfo RemoveConstraintClause(TypeParameterConstraintClauseSyntax constraintClause)" />
            <member def="public GenericInfo RemoveTypeParameter(TypeParameterSyntax typeParameter)" />
            <member def="public override string ToString()" />
            <member def="public GenericInfo WithConstraintClauses(SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses)" />
            <member def="public GenericInfo WithTypeParameterList(TypeParameterListSyntax typeParameterList)" />
            <member def="public static bool operator ==(in GenericInfo info1, in GenericInfo info2)" />
            <member def="public static bool operator !=(in GenericInfo info1, in GenericInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.IsExpressionInfo : IEquatable&lt;IsExpressionInfo&gt;">
          <members>
            <member def="public ExpressionSyntax Expression { get; }" />
            <member def="public BinaryExpressionSyntax IsExpression { get; }" />
            <member def="public SyntaxToken OperatorToken { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public TypeSyntax Type { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(IsExpressionInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in IsExpressionInfo info1, in IsExpressionInfo info2)" />
            <member def="public static bool operator !=(in IsExpressionInfo info1, in IsExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.LocalDeclarationStatementInfo : IEquatable&lt;LocalDeclarationStatementInfo&gt;">
          <members>
            <member def="public VariableDeclarationSyntax Declaration { get; }" />
            <member def="public SyntaxTokenList Modifiers { get; }" />
            <member def="public SyntaxToken SemicolonToken { get; }" />
            <member def="public LocalDeclarationStatementSyntax Statement { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public TypeSyntax Type { get; }" />
            <member def="public SeparatedSyntaxList&lt;VariableDeclaratorSyntax&gt; Variables { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(LocalDeclarationStatementInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in LocalDeclarationStatementInfo info1, in LocalDeclarationStatementInfo info2)" />
            <member def="public static bool operator !=(in LocalDeclarationStatementInfo info1, in LocalDeclarationStatementInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.MemberDeclarationListInfo : IEquatable&lt;MemberDeclarationListInfo&gt;, IReadOnlyList&lt;MemberDeclarationSyntax&gt;">
          <members>
            <member def="public int Count { get; }" />
            <member def="public SyntaxList&lt;MemberDeclarationSyntax&gt; Members { get; }" />
            <member def="public SyntaxNode Parent { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public MemberDeclarationSyntax this[int index] { get; }" />
            <member def="public MemberDeclarationListInfo Add(MemberDeclarationSyntax member)" />
            <member def="public MemberDeclarationListInfo AddRange(IEnumerable&lt;MemberDeclarationSyntax&gt; members)" />
            <member def="public bool Any()" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(MemberDeclarationListInfo other)" />
            <member def="public MemberDeclarationSyntax First()" />
            <member def="public MemberDeclarationSyntax FirstOrDefault()" />
            <member def="public SyntaxList&lt;MemberDeclarationSyntax&gt;.Enumerator GetEnumerator()" />
            <member def="public override int GetHashCode()" />
            <member def="public int IndexOf(MemberDeclarationSyntax member)" />
            <member def="public int IndexOf(Func&lt;MemberDeclarationSyntax, bool&gt; predicate)" />
            <member def="public MemberDeclarationListInfo Insert(int index, MemberDeclarationSyntax member)" />
            <member def="public MemberDeclarationListInfo InsertRange(int index, IEnumerable&lt;MemberDeclarationSyntax&gt; members)" />
            <member def="public MemberDeclarationSyntax Last()" />
            <member def="public int LastIndexOf(MemberDeclarationSyntax member)" />
            <member def="public int LastIndexOf(Func&lt;MemberDeclarationSyntax, bool&gt; predicate)" />
            <member def="public MemberDeclarationSyntax LastOrDefault()" />
            <member def="public MemberDeclarationListInfo Remove(MemberDeclarationSyntax member)" />
            <member def="public MemberDeclarationListInfo RemoveAt(int index)" />
            <member def="public MemberDeclarationListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options)" />
            <member def="public MemberDeclarationListInfo Replace(MemberDeclarationSyntax memberInList, MemberDeclarationSyntax newMember)" />
            <member def="public MemberDeclarationListInfo ReplaceAt(int index, MemberDeclarationSyntax newMember)" />
            <member def="public MemberDeclarationListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode)" />
            <member def="public MemberDeclarationListInfo ReplaceRange(MemberDeclarationSyntax memberInList, IEnumerable&lt;MemberDeclarationSyntax&gt; newMembers)" />
            <member def="public override string ToString()" />
            <member def="public MemberDeclarationListInfo WithMembers(IEnumerable&lt;MemberDeclarationSyntax&gt; members)" />
            <member def="public MemberDeclarationListInfo WithMembers(SyntaxList&lt;MemberDeclarationSyntax&gt; members)" />
            <member def="public static bool operator ==(in MemberDeclarationListInfo info1, in MemberDeclarationListInfo info2)" />
            <member def="public static bool operator !=(in MemberDeclarationListInfo info1, in MemberDeclarationListInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.ModifierListInfo : IEquatable&lt;ModifierListInfo&gt;">
          <members>
            <member def="public Accessibility ExplicitAccessibility { get; }" />
            <member def="public bool IsAbstract { get; }" />
            <member def="public bool IsAsync { get; }" />
            <member def="public bool IsConst { get; }" />
            <member def="public bool IsExtern { get; }" />
            <member def="public bool IsIn { get; }" />
            <member def="public bool IsNew { get; }" />
            <member def="public bool IsOut { get; }" />
            <member def="public bool IsOverride { get; }" />
            <member def="public bool IsParams { get; }" />
            <member def="public bool IsPartial { get; }" />
            <member def="public bool IsReadOnly { get; }" />
            <member def="public bool IsRef { get; }" />
            <member def="public bool IsSealed { get; }" />
            <member def="public bool IsStatic { get; }" />
            <member def="public bool IsUnsafe { get; }" />
            <member def="public bool IsVirtual { get; }" />
            <member def="public bool IsVolatile { get; }" />
            <member def="public SyntaxTokenList Modifiers { get; }" />
            <member def="public SyntaxNode Parent { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(ModifierListInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public ModifierKinds GetKinds()" />
            <member def="public override string ToString()" />
            <member def="public ModifierListInfo WithExplicitAccessibility(Accessibility newAccessibility, IComparer&lt;SyntaxKind&gt; comparer = null)" />
            <member def="public ModifierListInfo WithModifiers(SyntaxTokenList modifiers)" />
            <member def="public ModifierListInfo WithoutExplicitAccessibility()" />
            <member def="public static bool operator ==(in ModifierListInfo info1, in ModifierListInfo info2)" />
            <member def="public static bool operator !=(in ModifierListInfo info1, in ModifierListInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.NullCheckExpressionInfo : IEquatable&lt;NullCheckExpressionInfo&gt;">
          <members>
            <member def="public ExpressionSyntax Expression { get; }" />
            <member def="public bool IsCheckingNotNull { get; }" />
            <member def="public bool IsCheckingNull { get; }" />
            <member def="public ExpressionSyntax NullCheckExpression { get; }" />
            <member def="public NullCheckStyles Style { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(NullCheckExpressionInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in NullCheckExpressionInfo info1, in NullCheckExpressionInfo info2)" />
            <member def="public static bool operator !=(in NullCheckExpressionInfo info1, in NullCheckExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.RegionInfo : IEquatable&lt;RegionInfo&gt;">
          <members>
            <member def="public RegionDirectiveTriviaSyntax Directive { get; }" />
            <member def="public EndRegionDirectiveTriviaSyntax EndDirective { get; }" />
            <member def="public TextSpan FullSpan { get; }" />
            <member def="public bool IsEmpty { get; }" />
            <member def="public TextSpan Span { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(RegionInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in RegionInfo info1, in RegionInfo info2)" />
            <member def="public static bool operator !=(in RegionInfo info1, in RegionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.SimpleAssignmentExpressionInfo : IEquatable&lt;SimpleAssignmentExpressionInfo&gt;">
          <members>
            <member def="public AssignmentExpressionSyntax AssignmentExpression { get; }" />
            <member def="public ExpressionSyntax Left { get; }" />
            <member def="public SyntaxToken OperatorToken { get; }" />
            <member def="public ExpressionSyntax Right { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SimpleAssignmentExpressionInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in SimpleAssignmentExpressionInfo info1, in SimpleAssignmentExpressionInfo info2)" />
            <member def="public static bool operator !=(in SimpleAssignmentExpressionInfo info1, in SimpleAssignmentExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.SimpleAssignmentStatementInfo : IEquatable&lt;SimpleAssignmentStatementInfo&gt;">
          <members>
            <member def="public AssignmentExpressionSyntax AssignmentExpression { get; }" />
            <member def="public ExpressionSyntax Left { get; }" />
            <member def="public SyntaxToken OperatorToken { get; }" />
            <member def="public ExpressionSyntax Right { get; }" />
            <member def="public ExpressionStatementSyntax Statement { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SimpleAssignmentStatementInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in SimpleAssignmentStatementInfo info1, in SimpleAssignmentStatementInfo info2)" />
            <member def="public static bool operator !=(in SimpleAssignmentStatementInfo info1, in SimpleAssignmentStatementInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.SimpleIfElseInfo : IEquatable&lt;SimpleIfElseInfo&gt;">
          <members>
            <member def="public ExpressionSyntax Condition { get; }" />
            <member def="public ElseClauseSyntax Else { get; }" />
            <member def="public IfStatementSyntax IfStatement { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public StatementSyntax WhenFalse { get; }" />
            <member def="public StatementSyntax WhenTrue { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SimpleIfElseInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in SimpleIfElseInfo info1, in SimpleIfElseInfo info2)" />
            <member def="public static bool operator !=(in SimpleIfElseInfo info1, in SimpleIfElseInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.SimpleIfStatementInfo : IEquatable&lt;SimpleIfStatementInfo&gt;">
          <members>
            <member def="public ExpressionSyntax Condition { get; }" />
            <member def="public IfStatementSyntax IfStatement { get; }" />
            <member def="public StatementSyntax Statement { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SimpleIfStatementInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in SimpleIfStatementInfo info1, in SimpleIfStatementInfo info2)" />
            <member def="public static bool operator !=(in SimpleIfStatementInfo info1, in SimpleIfStatementInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.SimpleMemberInvocationExpressionInfo : IEquatable&lt;SimpleMemberInvocationExpressionInfo&gt;">
          <members>
            <member def="public ArgumentListSyntax ArgumentList { get; }" />
            <member def="public SeparatedSyntaxList&lt;ArgumentSyntax&gt; Arguments { get; }" />
            <member def="public ExpressionSyntax Expression { get; }" />
            <member def="public InvocationExpressionSyntax InvocationExpression { get; }" />
            <member def="public MemberAccessExpressionSyntax MemberAccessExpression { get; }" />
            <member def="public SimpleNameSyntax Name { get; }" />
            <member def="public string NameText { get; }" />
            <member def="public SyntaxToken OperatorToken { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SimpleMemberInvocationExpressionInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in SimpleMemberInvocationExpressionInfo info1, in SimpleMemberInvocationExpressionInfo info2)" />
            <member def="public static bool operator !=(in SimpleMemberInvocationExpressionInfo info1, in SimpleMemberInvocationExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.SimpleMemberInvocationStatementInfo : IEquatable&lt;SimpleMemberInvocationStatementInfo&gt;">
          <members>
            <member def="public ArgumentListSyntax ArgumentList { get; }" />
            <member def="public SeparatedSyntaxList&lt;ArgumentSyntax&gt; Arguments { get; }" />
            <member def="public ExpressionSyntax Expression { get; }" />
            <member def="public InvocationExpressionSyntax InvocationExpression { get; }" />
            <member def="public MemberAccessExpressionSyntax MemberAccessExpression { get; }" />
            <member def="public SimpleNameSyntax Name { get; }" />
            <member def="public string NameText { get; }" />
            <member def="public ExpressionStatementSyntax Statement { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SimpleMemberInvocationStatementInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in SimpleMemberInvocationStatementInfo info1, in SimpleMemberInvocationStatementInfo info2)" />
            <member def="public static bool operator !=(in SimpleMemberInvocationStatementInfo info1, in SimpleMemberInvocationStatementInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.SingleLocalDeclarationStatementInfo : IEquatable&lt;SingleLocalDeclarationStatementInfo&gt;">
          <members>
            <member def="public VariableDeclarationSyntax Declaration { get; }" />
            <member def="public VariableDeclaratorSyntax Declarator { get; }" />
            <member def="public SyntaxToken EqualsToken { get; }" />
            <member def="public SyntaxToken Identifier { get; }" />
            <member def="public string IdentifierText { get; }" />
            <member def="public EqualsValueClauseSyntax Initializer { get; }" />
            <member def="public SyntaxTokenList Modifiers { get; }" />
            <member def="public SyntaxToken SemicolonToken { get; }" />
            <member def="public LocalDeclarationStatementSyntax Statement { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public TypeSyntax Type { get; }" />
            <member def="public ExpressionSyntax Value { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SingleLocalDeclarationStatementInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in SingleLocalDeclarationStatementInfo info1, in SingleLocalDeclarationStatementInfo info2)" />
            <member def="public static bool operator !=(in SingleLocalDeclarationStatementInfo info1, in SingleLocalDeclarationStatementInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.SingleParameterLambdaExpressionInfo : IEquatable&lt;SingleParameterLambdaExpressionInfo&gt;">
          <members>
            <member def="public CSharpSyntaxNode Body { get; }" />
            <member def="public bool IsParenthesizedLambda { get; }" />
            <member def="public bool IsSimpleLambda { get; }" />
            <member def="public LambdaExpressionSyntax LambdaExpression { get; }" />
            <member def="public ParameterSyntax Parameter { get; }" />
            <member def="public ParameterListSyntax ParameterList { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SingleParameterLambdaExpressionInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in SingleParameterLambdaExpressionInfo info1, in SingleParameterLambdaExpressionInfo info2)" />
            <member def="public static bool operator !=(in SingleParameterLambdaExpressionInfo info1, in SingleParameterLambdaExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.StatementListInfo : IEquatable&lt;StatementListInfo&gt;, IReadOnlyList&lt;StatementSyntax&gt;">
          <members>
            <member def="public int Count { get; }" />
            <member def="public bool IsParentBlock { get; }" />
            <member def="public bool IsParentSwitchSection { get; }" />
            <member def="public SyntaxNode Parent { get; }" />
            <member def="public BlockSyntax ParentAsBlock { get; }" />
            <member def="public SwitchSectionSyntax ParentAsSwitchSection { get; }" />
            <member def="public SyntaxList&lt;StatementSyntax&gt; Statements { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public StatementSyntax this[int index] { get; }" />
            <member def="public StatementListInfo Add(StatementSyntax statement)" />
            <member def="public StatementListInfo AddRange(IEnumerable&lt;StatementSyntax&gt; statements)" />
            <member def="public bool Any()" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(StatementListInfo other)" />
            <member def="public StatementSyntax First()" />
            <member def="public StatementSyntax FirstOrDefault()" />
            <member def="public SyntaxList&lt;StatementSyntax&gt;.Enumerator GetEnumerator()" />
            <member def="public override int GetHashCode()" />
            <member def="public int IndexOf(Func&lt;StatementSyntax, bool&gt; predicate)" />
            <member def="public int IndexOf(StatementSyntax statement)" />
            <member def="public StatementListInfo Insert(int index, StatementSyntax statement)" />
            <member def="public StatementListInfo InsertRange(int index, IEnumerable&lt;StatementSyntax&gt; statements)" />
            <member def="public StatementSyntax Last()" />
            <member def="public int LastIndexOf(Func&lt;StatementSyntax, bool&gt; predicate)" />
            <member def="public int LastIndexOf(StatementSyntax statement)" />
            <member def="public StatementSyntax LastOrDefault()" />
            <member def="public StatementListInfo Remove(StatementSyntax statement)" />
            <member def="public StatementListInfo RemoveAt(int index)" />
            <member def="public StatementListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options)" />
            <member def="public StatementListInfo Replace(StatementSyntax statementInList, StatementSyntax newStatement)" />
            <member def="public StatementListInfo ReplaceAt(int index, StatementSyntax newStatement)" />
            <member def="public StatementListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode)" />
            <member def="public StatementListInfo ReplaceRange(StatementSyntax statementInList, IEnumerable&lt;StatementSyntax&gt; newStatements)" />
            <member def="public override string ToString()" />
            <member def="public StatementListInfo WithStatements(IEnumerable&lt;StatementSyntax&gt; statements)" />
            <member def="public StatementListInfo WithStatements(SyntaxList&lt;StatementSyntax&gt; statements)" />
            <member def="public static bool operator ==(in StatementListInfo info1, in StatementListInfo info2)" />
            <member def="public static bool operator !=(in StatementListInfo info1, in StatementListInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.StringConcatenationExpressionInfo : IEquatable&lt;StringConcatenationExpressionInfo&gt;">
          <members>
            <member def="public BinaryExpressionSyntax BinaryExpression { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public ExpressionChain AsChain()" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(StringConcatenationExpressionInfo other)" />
            <member def="public IEnumerable&lt;ExpressionSyntax&gt; Expressions(bool leftToRight = false)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in StringConcatenationExpressionInfo info1, in StringConcatenationExpressionInfo info2)" />
            <member def="public static bool operator !=(in StringConcatenationExpressionInfo info1, in StringConcatenationExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.StringLiteralExpressionInfo : IEquatable&lt;StringLiteralExpressionInfo&gt;">
          <members>
            <member def="public bool ContainsEscapeSequence { get; }" />
            <member def="public bool ContainsLinefeed { get; }" />
            <member def="public LiteralExpressionSyntax Expression { get; }" />
            <member def="public string InnerText { get; }" />
            <member def="public bool IsRegular { get; }" />
            <member def="public bool IsVerbatim { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public string Text { get; }" />
            <member def="public SyntaxToken Token { get; }" />
            <member def="public string ValueText { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(StringLiteralExpressionInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in StringLiteralExpressionInfo info1, in StringLiteralExpressionInfo info2)" />
            <member def="public static bool operator !=(in StringLiteralExpressionInfo info1, in StringLiteralExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.UsingDirectiveListInfo : IEquatable&lt;UsingDirectiveListInfo&gt;, IReadOnlyList&lt;UsingDirectiveSyntax&gt;">
          <members>
            <member def="public int Count { get; }" />
            <member def="public SyntaxNode Parent { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public SyntaxList&lt;UsingDirectiveSyntax&gt; Usings { get; }" />
            <member def="public UsingDirectiveSyntax this[int index] { get; }" />
            <member def="public UsingDirectiveListInfo Add(UsingDirectiveSyntax usingDirective)" />
            <member def="public UsingDirectiveListInfo AddRange(IEnumerable&lt;UsingDirectiveSyntax&gt; usings)" />
            <member def="public bool Any()" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(UsingDirectiveListInfo other)" />
            <member def="public UsingDirectiveSyntax First()" />
            <member def="public UsingDirectiveSyntax FirstOrDefault()" />
            <member def="public SyntaxList&lt;UsingDirectiveSyntax&gt;.Enumerator GetEnumerator()" />
            <member def="public override int GetHashCode()" />
            <member def="public int IndexOf(Func&lt;UsingDirectiveSyntax, bool&gt; predicate)" />
            <member def="public int IndexOf(UsingDirectiveSyntax usingDirective)" />
            <member def="public UsingDirectiveListInfo Insert(int index, UsingDirectiveSyntax usingDirective)" />
            <member def="public UsingDirectiveListInfo InsertRange(int index, IEnumerable&lt;UsingDirectiveSyntax&gt; usings)" />
            <member def="public UsingDirectiveSyntax Last()" />
            <member def="public int LastIndexOf(Func&lt;UsingDirectiveSyntax, bool&gt; predicate)" />
            <member def="public int LastIndexOf(UsingDirectiveSyntax usingDirective)" />
            <member def="public UsingDirectiveSyntax LastOrDefault()" />
            <member def="public UsingDirectiveListInfo Remove(UsingDirectiveSyntax usingDirective)" />
            <member def="public UsingDirectiveListInfo RemoveAt(int index)" />
            <member def="public UsingDirectiveListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options)" />
            <member def="public UsingDirectiveListInfo Replace(UsingDirectiveSyntax usingInLine, UsingDirectiveSyntax newUsingDirective)" />
            <member def="public UsingDirectiveListInfo ReplaceAt(int index, UsingDirectiveSyntax newUsingDirective)" />
            <member def="public UsingDirectiveListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode)" />
            <member def="public UsingDirectiveListInfo ReplaceRange(UsingDirectiveSyntax usingInLine, IEnumerable&lt;UsingDirectiveSyntax&gt; newUsingDirectives)" />
            <member def="public override string ToString()" />
            <member def="public UsingDirectiveListInfo WithUsings(IEnumerable&lt;UsingDirectiveSyntax&gt; usings)" />
            <member def="public UsingDirectiveListInfo WithUsings(SyntaxList&lt;UsingDirectiveSyntax&gt; usings)" />
            <member def="public static bool operator ==(in UsingDirectiveListInfo info1, in UsingDirectiveListInfo info2)" />
            <member def="public static bool operator !=(in UsingDirectiveListInfo info1, in UsingDirectiveListInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct Roslynator.CSharp.Syntax.XmlElementInfo : IEquatable&lt;XmlElementInfo&gt;">
          <members>
            <member def="public XmlNodeSyntax Element { get; }" />
            <member def="public bool IsEmptyElement { get; }" />
            <member def="public SyntaxKind Kind { get; }" />
            <member def="public string LocalName { get; }" />
            <member def="public bool Success { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(XmlElementInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string ToString()" />
            <member def="public static bool operator ==(in XmlElementInfo info1, in XmlElementInfo info2)" />
            <member def="public static bool operator !=(in XmlElementInfo info1, in XmlElementInfo info2)" />
          </members>
        </type>
        <type def="public struct Roslynator.Text.TextLineCollectionSelection.Enumerator">
          <members>
            <member def="public TextLine Current { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public override int GetHashCode()" />
            <member def="public bool MoveNext()" />
            <member def="public void Reset()" />
          </members>
        </type>
      </type>
      <type def="public abstract class System.Collections.Generic.EqualityComparer&lt;T&gt; : IEqualityComparer, IEqualityComparer&lt;T&gt;">
        <type def="public sealed class Roslynator.MetadataNameEqualityComparer&lt;TSymbol&gt; : EqualityComparer&lt;TSymbol&gt; where TSymbol : ISymbol">
          <members>
            <member def="public static MetadataNameEqualityComparer&lt;TSymbol&gt; Instance { get; }" />
            <member def="public override bool Equals(TSymbol x, TSymbol y)" />
            <member def="public override int GetHashCode(TSymbol obj)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.AdditionalText">
        <members>
          <member def="protected AdditionalText()" />
          <member def="public abstract string Path { get; }" />
          <member def="public abstract SourceText GetText(CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.AssemblyIdentity : IEquatable&lt;AssemblyIdentity&gt;">
        <members>
          <member def="public AssemblyIdentity(string name, Version version = null, string cultureName = null, ImmutableArray&lt;byte&gt; publicKeyOrToken = default, bool hasPublicKey = false, bool isRetargetable = false, AssemblyContentType contentType = Default)" />
          <member def="public AssemblyContentType ContentType { get; }" />
          <member def="public string CultureName { get; }" />
          <member def="public AssemblyNameFlags Flags { get; }" />
          <member def="public bool HasPublicKey { get; }" />
          <member def="public bool IsRetargetable { get; }" />
          <member def="public bool IsStrongName { get; }" />
          <member def="public string Name { get; }" />
          <member def="public ImmutableArray&lt;byte&gt; PublicKey { get; }" />
          <member def="public ImmutableArray&lt;byte&gt; PublicKeyToken { get; }" />
          <member def="public Version Version { get; }" />
          <member def="public bool Equals(AssemblyIdentity obj)" />
          <member def="public override bool Equals(object obj)" />
          <member def="public static AssemblyIdentity FromAssemblyDefinition(Assembly assembly)" />
          <member def="public string GetDisplayName(bool fullKey = false)" />
          <member def="public override int GetHashCode()" />
          <member def="public override string ToString()" />
          <member def="public static bool TryParseDisplayName(string displayName, out AssemblyIdentity identity)" />
          <member def="public static bool TryParseDisplayName(string displayName, out AssemblyIdentity identity, out AssemblyIdentityParts parts)" />
          <member def="public static bool operator ==(AssemblyIdentity left, AssemblyIdentity right)" />
          <member def="public static bool operator !=(AssemblyIdentity left, AssemblyIdentity right)" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.AssemblyIdentityComparer">
        <members>
          <member def="public static StringComparer CultureComparer { get; }" />
          <member def="public static AssemblyIdentityComparer Default { get; }" />
          <member def="public static StringComparer SimpleNameComparer { get; }" />
          <member def="public AssemblyIdentityComparer.ComparisonResult Compare(AssemblyIdentity reference, AssemblyIdentity definition)" />
          <member def="public bool ReferenceMatchesDefinition(AssemblyIdentity reference, AssemblyIdentity definition)" />
          <member def="public bool ReferenceMatchesDefinition(string referenceDisplayName, AssemblyIdentity definition)" />
        </members>
        <type def="public sealed class Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer : AssemblyIdentityComparer">
          <members>
            <member def="public static DesktopAssemblyIdentityComparer Default { get; }" />
            <member def="public static DesktopAssemblyIdentityComparer LoadFromXml(Stream input)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.AttributeData">
        <members>
          <member def="protected AttributeData()" />
          <member def="public SyntaxReference ApplicationSyntaxReference { get; }" />
          <member def="public INamedTypeSymbol AttributeClass { get; }" />
          <member def="public IMethodSymbol AttributeConstructor { get; }" />
          <member def="protected abstract SyntaxReference CommonApplicationSyntaxReference { get; }" />
          <member def="protected abstract INamedTypeSymbol CommonAttributeClass { get; }" />
          <member def="protected abstract IMethodSymbol CommonAttributeConstructor { get; }" />
          <member def="protected internal abstract ImmutableArray&lt;TypedConstant&gt; CommonConstructorArguments { get; }" />
          <member def="protected internal abstract ImmutableArray&lt;KeyValuePair&lt;string, TypedConstant&gt;&gt; CommonNamedArguments { get; }" />
          <member def="public ImmutableArray&lt;TypedConstant&gt; ConstructorArguments { get; }" />
          <member def="public ImmutableArray&lt;KeyValuePair&lt;string, TypedConstant&gt;&gt; NamedArguments { get; }" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.CommandLineArguments">
        <members>
          <member def="public ImmutableArray&lt;CommandLineSourceFile&gt; AdditionalFiles { get; }" />
          <member def="public ImmutableArray&lt;CommandLineAnalyzerReference&gt; AnalyzerReferences { get; }" />
          <member def="public string AppConfigPath { get; }" />
          <member def="public string BaseDirectory { get; }" />
          <member def="public SourceHashAlgorithm ChecksumAlgorithm { get; }" />
          <member def="public string CompilationName { get; }" />
          <member def="public CompilationOptions CompilationOptions { get; }" />
          <member def="protected abstract CompilationOptions CompilationOptionsCore { get; }" />
          <member def="public bool DisplayHelp { get; }" />
          <member def="public bool DisplayLogo { get; }" />
          <member def="public bool DisplayVersion { get; }" />
          <member def="public string DocumentationPath { get; }" />
          <member def="public ImmutableArray&lt;CommandLineSourceFile&gt; EmbeddedFiles { get; }" />
          <member def="public EmitOptions EmitOptions { get; }" />
          <member def="public bool EmitPdb { get; }" />
          <member def="public Encoding Encoding { get; }" />
          <member def="public string ErrorLogPath { get; }" />
          <member def="public ImmutableArray&lt;Diagnostic&gt; Errors { get; }" />
          <member def="public bool InteractiveMode { get; }" />
          <member def="public ImmutableArray&lt;string&gt; KeyFileSearchPaths { get; }" />
          <member def="public ImmutableArray&lt;ResourceDescription&gt; ManifestResources { get; }" />
          <member def="public ImmutableArray&lt;CommandLineReference&gt; MetadataReferences { get; }" />
          <member def="public bool NoWin32Manifest { get; }" />
          <member def="public string OutputDirectory { get; }" />
          <member def="public string OutputFileName { get; }" />
          <member def="public string OutputRefFilePath { get; }" />
          <member def="public ParseOptions ParseOptions { get; }" />
          <member def="protected abstract ParseOptions ParseOptionsCore { get; }" />
          <member def="public ImmutableArray&lt;KeyValuePair&lt;string, string&gt;&gt; PathMap { get; }" />
          <member def="public string PdbPath { get; }" />
          <member def="public CultureInfo PreferredUILang { get; }" />
          <member def="public bool PrintFullPaths { get; }" />
          <member def="public ImmutableArray&lt;string&gt; ReferencePaths { get; }" />
          <member def="public bool ReportAnalyzer { get; }" />
          <member def="public string RuleSetPath { get; }" />
          <member def="public ImmutableArray&lt;string&gt; ScriptArguments { get; }" />
          <member def="public ImmutableArray&lt;CommandLineSourceFile&gt; SourceFiles { get; }" />
          <member def="public string SourceLink { get; }" />
          <member def="public ImmutableArray&lt;string&gt; SourcePaths { get; }" />
          <member def="public string TouchedFilesPath { get; }" />
          <member def="public bool Utf8Output { get; }" />
          <member def="public string Win32Icon { get; }" />
          <member def="public string Win32Manifest { get; }" />
          <member def="public string Win32ResourceFile { get; }" />
          <member def="public IEnumerable&lt;AnalyzerReference&gt; ResolveAnalyzerReferences(IAnalyzerAssemblyLoader analyzerLoader)" />
          <member def="public IEnumerable&lt;MetadataReference&gt; ResolveMetadataReferences(MetadataReferenceResolver metadataResolver)" />
        </members>
        <type def="public sealed class Microsoft.CodeAnalysis.CSharp.CSharpCommandLineArguments : CommandLineArguments">
          <members>
            <member def="public CSharpCompilationOptions CompilationOptions { get; }" />
            <member def="protected override CompilationOptions CompilationOptionsCore { get; }" />
            <member def="public CSharpParseOptions ParseOptions { get; }" />
            <member def="protected override ParseOptions ParseOptionsCore { get; }" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.CommandLineParser">
        <members>
          <member def="protected abstract string RegularFileExtension { get; }" />
          <member def="protected abstract string ScriptFileExtension { get; }" />
          <member def="public CommandLineArguments Parse(IEnumerable&lt;string&gt; args, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories)" />
          <member def="protected ImmutableArray&lt;KeyValuePair&lt;string, string&gt;&gt; ParsePathMap(string pathMap, IList&lt;Diagnostic&gt; errors)" />
          <member def="public static IEnumerable&lt;string&gt; SplitCommandLineIntoArguments(string commandLine, bool removeHashComments)" />
        </members>
        <type def="public class Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParser : CommandLineParser">
          <members>
            <member def="public static CSharpCommandLineParser Default { get; }" />
            <member def="protected override string RegularFileExtension { get; }" />
            <member def="protected override string ScriptFileExtension { get; }" />
            <member def="public CSharpCommandLineArguments Parse(IEnumerable&lt;string&gt; args, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories = null)" />
            <member def="public static IEnumerable&lt;string&gt; ParseConditionalCompilationSymbols(string value, out IEnumerable&lt;Diagnostic&gt; diagnostics)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Compilation">
        <members>
          <member def="public IAssemblySymbol Assembly { get; }" />
          <member def="public string AssemblyName { get; }" />
          <member def="protected abstract IAssemblySymbol CommonAssembly { get; }" />
          <member def="protected abstract ITypeSymbol CommonDynamicType { get; }" />
          <member def="protected abstract INamespaceSymbol CommonGlobalNamespace { get; }" />
          <member def="protected abstract INamedTypeSymbol CommonObjectType { get; }" />
          <member def="protected abstract CompilationOptions CommonOptions { get; }" />
          <member def="protected abstract INamedTypeSymbol CommonScriptClass { get; }" />
          <member def="protected abstract IModuleSymbol CommonSourceModule { get; }" />
          <member def="protected abstract IEnumerable&lt;SyntaxTree&gt; CommonSyntaxTrees { get; }" />
          <member def="public abstract ImmutableArray&lt;MetadataReference&gt; DirectiveReferences { get; }" />
          <member def="public ITypeSymbol DynamicType { get; }" />
          <member def="public ImmutableArray&lt;MetadataReference&gt; ExternalReferences { get; }" />
          <member def="public INamespaceSymbol GlobalNamespace { get; }" />
          <member def="public abstract bool IsCaseSensitive { get; }" />
          <member def="public abstract string Language { get; }" />
          <member def="public INamedTypeSymbol ObjectType { get; }" />
          <member def="public CompilationOptions Options { get; }" />
          <member def="public abstract IEnumerable&lt;AssemblyIdentity&gt; ReferencedAssemblyNames { get; }" />
          <member def="public IEnumerable&lt;MetadataReference&gt; References { get; }" />
          <member def="public INamedTypeSymbol ScriptClass { get; }" />
          <member def="public ScriptCompilationInfo ScriptCompilationInfo { get; }" />
          <member def="public IModuleSymbol SourceModule { get; }" />
          <member def="public IEnumerable&lt;SyntaxTree&gt; SyntaxTrees { get; }" />
          <member def="public Compilation AddReferences(params MetadataReference[] references)" />
          <member def="public Compilation AddReferences(IEnumerable&lt;MetadataReference&gt; references)" />
          <member def="public Compilation AddSyntaxTrees(params SyntaxTree[] trees)" />
          <member def="public Compilation AddSyntaxTrees(IEnumerable&lt;SyntaxTree&gt; trees)" />
          <member def="protected abstract void AppendDefaultVersionResource(Stream resourceStream)" />
          <member def="protected static void CheckTupleElementLocations(int cardinality, ImmutableArray&lt;Location&gt; elementLocations)" />
          <member def="protected static ImmutableArray&lt;string&gt; CheckTupleElementNames(int cardinality, ImmutableArray&lt;string&gt; elementNames)" />
          <member def="public Compilation Clone()" />
          <member def="protected abstract Compilation CommonAddSyntaxTrees(IEnumerable&lt;SyntaxTree&gt; trees)" />
          <member def="protected INamedTypeSymbol CommonBindScriptClass()" />
          <member def="protected abstract Compilation CommonClone()" />
          <member def="protected abstract bool CommonContainsSyntaxTree(SyntaxTree syntaxTree)" />
          <member def="protected abstract INamedTypeSymbol CommonCreateAnonymousTypeSymbol(ImmutableArray&lt;ITypeSymbol&gt; memberTypes, ImmutableArray&lt;string&gt; memberNames, ImmutableArray&lt;Location&gt; memberLocations, ImmutableArray&lt;bool&gt; memberIsReadOnly)" />
          <member def="protected abstract IArrayTypeSymbol CommonCreateArrayTypeSymbol(ITypeSymbol elementType, int rank)" />
          <member def="protected abstract INamespaceSymbol CommonCreateErrorNamespaceSymbol(INamespaceSymbol container, string name)" />
          <member def="protected abstract INamedTypeSymbol CommonCreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity)" />
          <member def="protected abstract IPointerTypeSymbol CommonCreatePointerTypeSymbol(ITypeSymbol elementType)" />
          <member def="protected abstract INamedTypeSymbol CommonCreateTupleTypeSymbol(ImmutableArray&lt;ITypeSymbol&gt; elementTypes, ImmutableArray&lt;string&gt; elementNames, ImmutableArray&lt;Location&gt; elementLocations)" />
          <member def="protected abstract INamedTypeSymbol CommonCreateTupleTypeSymbol(INamedTypeSymbol underlyingType, ImmutableArray&lt;string&gt; elementNames, ImmutableArray&lt;Location&gt; elementLocations)" />
          <member def="protected abstract ISymbol CommonGetAssemblyOrModuleSymbol(MetadataReference reference)" />
          <member def="protected abstract INamespaceSymbol CommonGetCompilationNamespace(INamespaceSymbol namespaceSymbol)" />
          <member def="protected abstract IMethodSymbol CommonGetEntryPoint(CancellationToken cancellationToken)" />
          <member def="protected abstract SemanticModel CommonGetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility)" />
          <member def="protected abstract INamedTypeSymbol CommonGetSpecialType(SpecialType specialType)" />
          <member def="protected abstract INamedTypeSymbol CommonGetTypeByMetadataName(string metadataName)" />
          <member def="protected abstract Compilation CommonRemoveAllSyntaxTrees()" />
          <member def="protected abstract Compilation CommonRemoveSyntaxTrees(IEnumerable&lt;SyntaxTree&gt; trees)" />
          <member def="protected abstract Compilation CommonReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree)" />
          <member def="protected abstract Compilation CommonWithAssemblyName(string outputName)" />
          <member def="protected abstract Compilation CommonWithOptions(CompilationOptions options)" />
          <member def="protected abstract Compilation CommonWithReferences(IEnumerable&lt;MetadataReference&gt; newReferences)" />
          <member def="protected abstract Compilation CommonWithScriptCompilationInfo(ScriptCompilationInfo info)" />
          <member def="public abstract bool ContainsSymbolsWithName(Func&lt;string, bool&gt; predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default)" />
          <member def="public bool ContainsSyntaxTree(SyntaxTree syntaxTree)" />
          <member def="public INamedTypeSymbol CreateAnonymousTypeSymbol(ImmutableArray&lt;ITypeSymbol&gt; memberTypes, ImmutableArray&lt;string&gt; memberNames, ImmutableArray&lt;bool&gt; memberIsReadOnly = default, ImmutableArray&lt;Location&gt; memberLocations = default)" />
          <member def="public IArrayTypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank = 1)" />
          <member def="public Stream CreateDefaultWin32Resources(bool versionResource, bool noManifest, Stream manifestContents, Stream iconInIcoFormat)" />
          <member def="public INamespaceSymbol CreateErrorNamespaceSymbol(INamespaceSymbol container, string name)" />
          <member def="public INamedTypeSymbol CreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity)" />
          <member def="public IPointerTypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType)" />
          <member def="public INamedTypeSymbol CreateTupleTypeSymbol(ImmutableArray&lt;ITypeSymbol&gt; elementTypes, ImmutableArray&lt;string&gt; elementNames = default, ImmutableArray&lt;Location&gt; elementLocations = default)" />
          <member def="public INamedTypeSymbol CreateTupleTypeSymbol(INamedTypeSymbol underlyingType, ImmutableArray&lt;string&gt; elementNames = default, ImmutableArray&lt;Location&gt; elementLocations = default)" />
          <member def="public EmitResult Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable&lt;ResourceDescription&gt; manifestResources, EmitOptions options, CancellationToken cancellationToken)" />
          <member def="public EmitResult Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable&lt;ResourceDescription&gt; manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, CancellationToken cancellationToken)" />
          <member def="public EmitResult Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable&lt;ResourceDescription&gt; manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable&lt;EmbeddedText&gt; embeddedTexts, CancellationToken cancellationToken)" />
          <member def="public EmitResult Emit(Stream peStream, Stream pdbStream = null, Stream xmlDocumentationStream = null, Stream win32Resources = null, IEnumerable&lt;ResourceDescription&gt; manifestResources = null, EmitOptions options = null, IMethodSymbol debugEntryPoint = null, Stream sourceLinkStream = null, IEnumerable&lt;EmbeddedText&gt; embeddedTexts = null, Stream metadataPEStream = null, CancellationToken cancellationToken = default)" />
          <member def="public EmitDifferenceResult EmitDifference(EmitBaseline baseline, IEnumerable&lt;SemanticEdit&gt; edits, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection&lt;MethodDefinitionHandle&gt; updatedMethods, CancellationToken cancellationToken = default)" />
          <member def="public EmitDifferenceResult EmitDifference(EmitBaseline baseline, IEnumerable&lt;SemanticEdit&gt; edits, Func&lt;ISymbol, bool&gt; isAddedSymbol, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection&lt;MethodDefinitionHandle&gt; updatedMethods, CancellationToken cancellationToken = default)" />
          <member def="public ISymbol GetAssemblyOrModuleSymbol(MetadataReference reference)" />
          <member def="public INamespaceSymbol GetCompilationNamespace(INamespaceSymbol namespaceSymbol)" />
          <member def="public abstract ImmutableArray&lt;Diagnostic&gt; GetDeclarationDiagnostics(CancellationToken cancellationToken = default)" />
          <member def="public abstract ImmutableArray&lt;Diagnostic&gt; GetDiagnostics(CancellationToken cancellationToken = default)" />
          <member def="public IMethodSymbol GetEntryPoint(CancellationToken cancellationToken)" />
          <member def="public MetadataReference GetMetadataReference(IAssemblySymbol assemblySymbol)" />
          <member def="public abstract ImmutableArray&lt;Diagnostic&gt; GetMethodBodyDiagnostics(CancellationToken cancellationToken = default)" />
          <member def="public abstract ImmutableArray&lt;Diagnostic&gt; GetParseDiagnostics(CancellationToken cancellationToken = default)" />
          <member def="public static string GetRequiredLanguageVersion(Diagnostic diagnostic)" />
          <member def="public SemanticModel GetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility = false)" />
          <member def="public INamedTypeSymbol GetSpecialType(SpecialType specialType)" />
          <member def="public abstract IEnumerable&lt;ISymbol&gt; GetSymbolsWithName(Func&lt;string, bool&gt; predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default)" />
          <member def="public INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName)" />
          <member def="public ImmutableArray&lt;AssemblyIdentity&gt; GetUnreferencedAssemblyIdentities(Diagnostic diagnostic)" />
          <member def="public Compilation RemoveAllReferences()" />
          <member def="public Compilation RemoveAllSyntaxTrees()" />
          <member def="public Compilation RemoveReferences(params MetadataReference[] references)" />
          <member def="public Compilation RemoveReferences(IEnumerable&lt;MetadataReference&gt; references)" />
          <member def="public Compilation RemoveSyntaxTrees(params SyntaxTree[] trees)" />
          <member def="public Compilation RemoveSyntaxTrees(IEnumerable&lt;SyntaxTree&gt; trees)" />
          <member def="public Compilation ReplaceReference(MetadataReference oldReference, MetadataReference newReference)" />
          <member def="public Compilation ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree)" />
          <member def="protected static IReadOnlyDictionary&lt;string, string&gt; SyntaxTreeCommonFeatures(IEnumerable&lt;SyntaxTree&gt; trees)" />
          <member def="public abstract CompilationReference ToMetadataReference(ImmutableArray&lt;string&gt; aliases = default, bool embedInteropTypes = false)" />
          <member def="public Compilation WithAssemblyName(string assemblyName)" />
          <member def="public Compilation WithOptions(CompilationOptions options)" />
          <member def="public Compilation WithReferences(IEnumerable&lt;MetadataReference&gt; newReferences)" />
          <member def="public Compilation WithReferences(params MetadataReference[] newReferences)" />
          <member def="public Compilation WithScriptCompilationInfo(ScriptCompilationInfo info)" />
        </members>
        <type def="public sealed class Microsoft.CodeAnalysis.CSharp.CSharpCompilation : Compilation">
          <members>
            <member def="protected override IAssemblySymbol CommonAssembly { get; }" />
            <member def="protected override ITypeSymbol CommonDynamicType { get; }" />
            <member def="protected override INamespaceSymbol CommonGlobalNamespace { get; }" />
            <member def="protected override INamedTypeSymbol CommonObjectType { get; }" />
            <member def="protected override CompilationOptions CommonOptions { get; }" />
            <member def="protected override INamedTypeSymbol CommonScriptClass { get; }" />
            <member def="protected override IModuleSymbol CommonSourceModule { get; }" />
            <member def="protected override IEnumerable&lt;SyntaxTree&gt; CommonSyntaxTrees { get; }" />
            <member def="public override ImmutableArray&lt;MetadataReference&gt; DirectiveReferences { get; }" />
            <member def="public override bool IsCaseSensitive { get; }" />
            <member def="public override string Language { get; }" />
            <member def="public LanguageVersion LanguageVersion { get; }" />
            <member def="public CSharpCompilationOptions Options { get; }" />
            <member def="public override IEnumerable&lt;AssemblyIdentity&gt; ReferencedAssemblyNames { get; }" />
            <member def="public CSharpScriptCompilationInfo ScriptCompilationInfo { get; }" />
            <member def="public ImmutableArray&lt;SyntaxTree&gt; SyntaxTrees { get; }" />
            <member def="public CSharpCompilation AddReferences(params MetadataReference[] references)" />
            <member def="public CSharpCompilation AddReferences(IEnumerable&lt;MetadataReference&gt; references)" />
            <member def="public CSharpCompilation AddSyntaxTrees(params SyntaxTree[] trees)" />
            <member def="public CSharpCompilation AddSyntaxTrees(IEnumerable&lt;SyntaxTree&gt; trees)" />
            <member def="protected override void AppendDefaultVersionResource(Stream resourceStream)" />
            <member def="public Conversion ClassifyConversion(ITypeSymbol source, ITypeSymbol destination)" />
            <member def="public CSharpCompilation Clone()" />
            <member def="protected override Compilation CommonAddSyntaxTrees(IEnumerable&lt;SyntaxTree&gt; trees)" />
            <member def="protected override Compilation CommonClone()" />
            <member def="protected override bool CommonContainsSyntaxTree(SyntaxTree syntaxTree)" />
            <member def="protected override INamedTypeSymbol CommonCreateAnonymousTypeSymbol(ImmutableArray&lt;ITypeSymbol&gt; memberTypes, ImmutableArray&lt;string&gt; memberNames, ImmutableArray&lt;Location&gt; memberLocations, ImmutableArray&lt;bool&gt; memberIsReadOnly)" />
            <member def="protected override IArrayTypeSymbol CommonCreateArrayTypeSymbol(ITypeSymbol elementType, int rank)" />
            <member def="protected override INamespaceSymbol CommonCreateErrorNamespaceSymbol(INamespaceSymbol container, string name)" />
            <member def="protected override INamedTypeSymbol CommonCreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity)" />
            <member def="protected override IPointerTypeSymbol CommonCreatePointerTypeSymbol(ITypeSymbol elementType)" />
            <member def="protected override INamedTypeSymbol CommonCreateTupleTypeSymbol(ImmutableArray&lt;ITypeSymbol&gt; elementTypes, ImmutableArray&lt;string&gt; elementNames, ImmutableArray&lt;Location&gt; elementLocations)" />
            <member def="protected override INamedTypeSymbol CommonCreateTupleTypeSymbol(INamedTypeSymbol underlyingType, ImmutableArray&lt;string&gt; elementNames, ImmutableArray&lt;Location&gt; elementLocations)" />
            <member def="protected override ISymbol CommonGetAssemblyOrModuleSymbol(MetadataReference reference)" />
            <member def="protected override INamespaceSymbol CommonGetCompilationNamespace(INamespaceSymbol namespaceSymbol)" />
            <member def="protected override IMethodSymbol CommonGetEntryPoint(CancellationToken cancellationToken)" />
            <member def="protected override SemanticModel CommonGetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility)" />
            <member def="protected override INamedTypeSymbol CommonGetSpecialType(SpecialType specialType)" />
            <member def="protected override INamedTypeSymbol CommonGetTypeByMetadataName(string metadataName)" />
            <member def="protected override Compilation CommonRemoveAllSyntaxTrees()" />
            <member def="protected override Compilation CommonRemoveSyntaxTrees(IEnumerable&lt;SyntaxTree&gt; trees)" />
            <member def="protected override Compilation CommonReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree)" />
            <member def="protected override Compilation CommonWithAssemblyName(string assemblyName)" />
            <member def="protected override Compilation CommonWithOptions(CompilationOptions options)" />
            <member def="protected override Compilation CommonWithReferences(IEnumerable&lt;MetadataReference&gt; newReferences)" />
            <member def="protected override Compilation CommonWithScriptCompilationInfo(ScriptCompilationInfo info)" />
            <member def="public override bool ContainsSymbolsWithName(Func&lt;string, bool&gt; predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default)" />
            <member def="public bool ContainsSyntaxTree(SyntaxTree syntaxTree)" />
            <member def="public static CSharpCompilation Create(string assemblyName, IEnumerable&lt;SyntaxTree&gt; syntaxTrees = null, IEnumerable&lt;MetadataReference&gt; references = null, CSharpCompilationOptions options = null)" />
            <member def="public static CSharpCompilation CreateScriptCompilation(string assemblyName, SyntaxTree syntaxTree = null, IEnumerable&lt;MetadataReference&gt; references = null, CSharpCompilationOptions options = null, CSharpCompilation previousScriptCompilation = null, Type returnType = null, Type globalsType = null)" />
            <member def="public override ImmutableArray&lt;Diagnostic&gt; GetDeclarationDiagnostics(CancellationToken cancellationToken = default)" />
            <member def="public override ImmutableArray&lt;Diagnostic&gt; GetDiagnostics(CancellationToken cancellationToken = default)" />
            <member def="public MetadataReference GetDirectiveReference(ReferenceDirectiveTriviaSyntax directive)" />
            <member def="public MetadataReference GetMetadataReference(IAssemblySymbol assemblySymbol)" />
            <member def="public override ImmutableArray&lt;Diagnostic&gt; GetMethodBodyDiagnostics(CancellationToken cancellationToken = default)" />
            <member def="public override ImmutableArray&lt;Diagnostic&gt; GetParseDiagnostics(CancellationToken cancellationToken = default)" />
            <member def="public SemanticModel GetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility)" />
            <member def="public override IEnumerable&lt;ISymbol&gt; GetSymbolsWithName(Func&lt;string, bool&gt; predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default)" />
            <member def="public CSharpCompilation RemoveAllReferences()" />
            <member def="public CSharpCompilation RemoveAllSyntaxTrees()" />
            <member def="public CSharpCompilation RemoveReferences(params MetadataReference[] references)" />
            <member def="public CSharpCompilation RemoveReferences(IEnumerable&lt;MetadataReference&gt; references)" />
            <member def="public CSharpCompilation RemoveSyntaxTrees(params SyntaxTree[] trees)" />
            <member def="public CSharpCompilation RemoveSyntaxTrees(IEnumerable&lt;SyntaxTree&gt; trees)" />
            <member def="public CSharpCompilation ReplaceReference(MetadataReference oldReference, MetadataReference newReference)" />
            <member def="public CSharpCompilation ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree)" />
            <member def="public override CompilationReference ToMetadataReference(ImmutableArray&lt;string&gt; aliases = default, bool embedInteropTypes = false)" />
            <member def="public CSharpCompilation WithAssemblyName(string assemblyName)" />
            <member def="public CSharpCompilation WithOptions(CSharpCompilationOptions options)" />
            <member def="public CSharpCompilation WithReferences(IEnumerable&lt;MetadataReference&gt; references)" />
            <member def="public CSharpCompilation WithReferences(params MetadataReference[] references)" />
            <member def="public CSharpCompilation WithScriptCompilationInfo(CSharpScriptCompilationInfo info)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.CompilationOptions">
        <members>
          <member def="public AssemblyIdentityComparer AssemblyIdentityComparer { get; protected set; }" />
          <member def="public bool CheckOverflow { get; protected set; }" />
          <member def="public bool ConcurrentBuild { get; protected set; }" />
          <member def="public string CryptoKeyContainer { get; protected set; }" />
          <member def="public string CryptoKeyFile { get; protected set; }" />
          <member def="public ImmutableArray&lt;byte&gt; CryptoPublicKey { get; protected set; }" />
          <member def="public bool? DelaySign { get; protected set; }" />
          <member def="public bool Deterministic { get; protected set; }" />
          <member def="public ImmutableArray&lt;Diagnostic&gt; Errors { get; }" />
          <member def="protected internal ImmutableArray&lt;string&gt; Features { get; protected set; }" />
          <member def="public ReportDiagnostic GeneralDiagnosticOption { get; protected set; }" />
          <member def="public abstract string Language { get; }" />
          <member def="public string MainTypeName { get; protected set; }" />
          <member def="public MetadataReferenceResolver MetadataReferenceResolver { get; protected set; }" />
          <member def="public string ModuleName { get; protected set; }" />
          <member def="public OptimizationLevel OptimizationLevel { get; protected set; }" />
          <member def="public OutputKind OutputKind { get; protected set; }" />
          <member def="public Platform Platform { get; protected set; }" />
          <member def="public bool PublicSign { get; protected set; }" />
          <member def="public bool ReportSuppressedDiagnostics { get; protected set; }" />
          <member def="public string ScriptClassName { get; protected set; }" />
          <member def="public SourceReferenceResolver SourceReferenceResolver { get; protected set; }" />
          <member def="public ImmutableDictionary&lt;string, ReportDiagnostic&gt; SpecificDiagnosticOptions { get; protected set; }" />
          <member def="public StrongNameProvider StrongNameProvider { get; protected set; }" />
          <member def="public int WarningLevel { get; protected set; }" />
          <member def="public XmlReferenceResolver XmlReferenceResolver { get; protected set; }" />
          <member def="protected abstract CompilationOptions CommonWithAssemblyIdentityComparer(AssemblyIdentityComparer comparer)" />
          <member def="protected abstract CompilationOptions CommonWithCheckOverflow(bool checkOverflow)" />
          <member def="protected abstract CompilationOptions CommonWithConcurrentBuild(bool concurrent)" />
          <member def="protected abstract CompilationOptions CommonWithCryptoKeyContainer(string cryptoKeyContainer)" />
          <member def="protected abstract CompilationOptions CommonWithCryptoKeyFile(string cryptoKeyFile)" />
          <member def="protected abstract CompilationOptions CommonWithCryptoPublicKey(ImmutableArray&lt;byte&gt; cryptoPublicKey)" />
          <member def="protected abstract CompilationOptions CommonWithDelaySign(bool? delaySign)" />
          <member def="protected abstract CompilationOptions CommonWithDeterministic(bool deterministic)" />
          <member def="protected abstract CompilationOptions CommonWithFeatures(ImmutableArray&lt;string&gt; features)" />
          <member def="protected abstract CompilationOptions CommonWithGeneralDiagnosticOption(ReportDiagnostic generalDiagnosticOption)" />
          <member def="protected abstract CompilationOptions CommonWithMainTypeName(string mainTypeName)" />
          <member def="protected abstract CompilationOptions CommonWithMetadataReferenceResolver(MetadataReferenceResolver resolver)" />
          <member def="protected abstract CompilationOptions CommonWithModuleName(string moduleName)" />
          <member def="protected abstract CompilationOptions CommonWithOptimizationLevel(OptimizationLevel value)" />
          <member def="protected abstract CompilationOptions CommonWithOutputKind(OutputKind kind)" />
          <member def="protected abstract CompilationOptions CommonWithPlatform(Platform platform)" />
          <member def="protected abstract CompilationOptions CommonWithPublicSign(bool publicSign)" />
          <member def="protected abstract CompilationOptions CommonWithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics)" />
          <member def="protected abstract CompilationOptions CommonWithScriptClassName(string scriptClassName)" />
          <member def="protected abstract CompilationOptions CommonWithSourceReferenceResolver(SourceReferenceResolver resolver)" />
          <member def="protected abstract CompilationOptions CommonWithSpecificDiagnosticOptions(ImmutableDictionary&lt;string, ReportDiagnostic&gt; specificDiagnosticOptions)" />
          <member def="protected abstract CompilationOptions CommonWithSpecificDiagnosticOptions(IEnumerable&lt;KeyValuePair&lt;string, ReportDiagnostic&gt;&gt; specificDiagnosticOptions)" />
          <member def="protected abstract CompilationOptions CommonWithStrongNameProvider(StrongNameProvider provider)" />
          <member def="protected abstract CompilationOptions CommonWithXmlReferenceResolver(XmlReferenceResolver resolver)" />
          <member def="public override abstract bool Equals(object obj)" />
          <member def="protected bool EqualsHelper(CompilationOptions other)" />
          <member def="public override abstract int GetHashCode()" />
          <member def="protected int GetHashCodeHelper()" />
          <member def="public CompilationOptions WithAssemblyIdentityComparer(AssemblyIdentityComparer comparer)" />
          <member def="public CompilationOptions WithConcurrentBuild(bool concurrent)" />
          <member def="public CompilationOptions WithCryptoKeyContainer(string cryptoKeyContainer)" />
          <member def="public CompilationOptions WithCryptoKeyFile(string cryptoKeyFile)" />
          <member def="public CompilationOptions WithCryptoPublicKey(ImmutableArray&lt;byte&gt; cryptoPublicKey)" />
          <member def="public CompilationOptions WithDelaySign(bool? delaySign)" />
          <member def="public CompilationOptions WithDeterministic(bool deterministic)" />
          <member def="public CompilationOptions WithGeneralDiagnosticOption(ReportDiagnostic value)" />
          <member def="public CompilationOptions WithMainTypeName(string mainTypeName)" />
          <member def="public CompilationOptions WithMetadataReferenceResolver(MetadataReferenceResolver resolver)" />
          <member def="public CompilationOptions WithModuleName(string moduleName)" />
          <member def="public CompilationOptions WithOptimizationLevel(OptimizationLevel value)" />
          <member def="public CompilationOptions WithOutputKind(OutputKind kind)" />
          <member def="public CompilationOptions WithOverflowChecks(bool checkOverflow)" />
          <member def="public CompilationOptions WithPlatform(Platform platform)" />
          <member def="public CompilationOptions WithPublicSign(bool publicSign)" />
          <member def="public CompilationOptions WithReportSuppressedDiagnostics(bool value)" />
          <member def="public CompilationOptions WithScriptClassName(string scriptClassName)" />
          <member def="public CompilationOptions WithSourceReferenceResolver(SourceReferenceResolver resolver)" />
          <member def="public CompilationOptions WithSpecificDiagnosticOptions(ImmutableDictionary&lt;string, ReportDiagnostic&gt; value)" />
          <member def="public CompilationOptions WithSpecificDiagnosticOptions(IEnumerable&lt;KeyValuePair&lt;string, ReportDiagnostic&gt;&gt; value)" />
          <member def="public CompilationOptions WithStrongNameProvider(StrongNameProvider provider)" />
          <member def="public CompilationOptions WithXmlReferenceResolver(XmlReferenceResolver resolver)" />
          <member def="public static bool operator ==(CompilationOptions left, CompilationOptions right)" />
          <member def="public static bool operator !=(CompilationOptions left, CompilationOptions right)" />
        </members>
        <type def="public sealed class Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions : CompilationOptions, IEquatable&lt;CSharpCompilationOptions&gt;">
          <members>
            <member def="public CSharpCompilationOptions(OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, IEnumerable&lt;string&gt; usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray&lt;byte&gt; cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable&lt;KeyValuePair&lt;string, ReportDiagnostic&gt;&gt; specificDiagnosticOptions, bool concurrentBuild, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider)" />
            <member def="public CSharpCompilationOptions(OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, IEnumerable&lt;string&gt; usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray&lt;byte&gt; cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable&lt;KeyValuePair&lt;string, ReportDiagnostic&gt;&gt; specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider)" />
            <member def="public CSharpCompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics, string moduleName, string mainTypeName, string scriptClassName, IEnumerable&lt;string&gt; usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray&lt;byte&gt; cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable&lt;KeyValuePair&lt;string, ReportDiagnostic&gt;&gt; specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider)" />
            <member def="public CSharpCompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics = false, string moduleName = null, string mainTypeName = null, string scriptClassName = null, IEnumerable&lt;string&gt; usings = null, OptimizationLevel optimizationLevel = Debug, bool checkOverflow = false, bool allowUnsafe = false, string cryptoKeyContainer = null, string cryptoKeyFile = null, ImmutableArray&lt;byte&gt; cryptoPublicKey = default, bool? delaySign = null, Platform platform = AnyCpu, ReportDiagnostic generalDiagnosticOption = Default, int warningLevel = 4, IEnumerable&lt;KeyValuePair&lt;string, ReportDiagnostic&gt;&gt; specificDiagnosticOptions = null, bool concurrentBuild = true, bool deterministic = false, XmlReferenceResolver xmlReferenceResolver = null, SourceReferenceResolver sourceReferenceResolver = null, MetadataReferenceResolver metadataReferenceResolver = null, AssemblyIdentityComparer assemblyIdentityComparer = null, StrongNameProvider strongNameProvider = null, bool publicSign = false)" />
            <member def="public bool AllowUnsafe { get; }" />
            <member def="public override string Language { get; }" />
            <member def="public ImmutableArray&lt;string&gt; Usings { get; }" />
            <member def="protected override CompilationOptions CommonWithAssemblyIdentityComparer(AssemblyIdentityComparer comparer)" />
            <member def="protected override CompilationOptions CommonWithCheckOverflow(bool checkOverflow)" />
            <member def="protected override CompilationOptions CommonWithConcurrentBuild(bool concurrent)" />
            <member def="protected override CompilationOptions CommonWithCryptoKeyContainer(string cryptoKeyContainer)" />
            <member def="protected override CompilationOptions CommonWithCryptoKeyFile(string cryptoKeyFile)" />
            <member def="protected override CompilationOptions CommonWithCryptoPublicKey(ImmutableArray&lt;byte&gt; cryptoPublicKey)" />
            <member def="protected override CompilationOptions CommonWithDelaySign(bool? delaySign)" />
            <member def="protected override CompilationOptions CommonWithDeterministic(bool deterministic)" />
            <member def="protected override CompilationOptions CommonWithFeatures(ImmutableArray&lt;string&gt; features)" />
            <member def="protected override CompilationOptions CommonWithGeneralDiagnosticOption(ReportDiagnostic value)" />
            <member def="protected override CompilationOptions CommonWithMainTypeName(string mainTypeName)" />
            <member def="protected override CompilationOptions CommonWithMetadataReferenceResolver(MetadataReferenceResolver resolver)" />
            <member def="protected override CompilationOptions CommonWithModuleName(string moduleName)" />
            <member def="protected override CompilationOptions CommonWithOptimizationLevel(OptimizationLevel value)" />
            <member def="protected override CompilationOptions CommonWithOutputKind(OutputKind kind)" />
            <member def="protected override CompilationOptions CommonWithPlatform(Platform platform)" />
            <member def="protected override CompilationOptions CommonWithPublicSign(bool publicSign)" />
            <member def="protected override CompilationOptions CommonWithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics)" />
            <member def="protected override CompilationOptions CommonWithScriptClassName(string scriptClassName)" />
            <member def="protected override CompilationOptions CommonWithSourceReferenceResolver(SourceReferenceResolver resolver)" />
            <member def="protected override CompilationOptions CommonWithSpecificDiagnosticOptions(ImmutableDictionary&lt;string, ReportDiagnostic&gt; specificDiagnosticOptions)" />
            <member def="protected override CompilationOptions CommonWithSpecificDiagnosticOptions(IEnumerable&lt;KeyValuePair&lt;string, ReportDiagnostic&gt;&gt; specificDiagnosticOptions)" />
            <member def="protected override CompilationOptions CommonWithStrongNameProvider(StrongNameProvider provider)" />
            <member def="protected override CompilationOptions CommonWithXmlReferenceResolver(XmlReferenceResolver resolver)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(CSharpCompilationOptions other)" />
            <member def="public override int GetHashCode()" />
            <member def="public CSharpCompilationOptions WithAllowUnsafe(bool enabled)" />
            <member def="public CSharpCompilationOptions WithAssemblyIdentityComparer(AssemblyIdentityComparer comparer)" />
            <member def="public CSharpCompilationOptions WithConcurrentBuild(bool concurrentBuild)" />
            <member def="public CSharpCompilationOptions WithCryptoKeyContainer(string name)" />
            <member def="public CSharpCompilationOptions WithCryptoKeyFile(string path)" />
            <member def="public CSharpCompilationOptions WithCryptoPublicKey(ImmutableArray&lt;byte&gt; value)" />
            <member def="public CSharpCompilationOptions WithDelaySign(bool? value)" />
            <member def="public CSharpCompilationOptions WithDeterministic(bool deterministic)" />
            <member def="public CSharpCompilationOptions WithGeneralDiagnosticOption(ReportDiagnostic value)" />
            <member def="public CSharpCompilationOptions WithMainTypeName(string name)" />
            <member def="public CSharpCompilationOptions WithMetadataReferenceResolver(MetadataReferenceResolver resolver)" />
            <member def="public CSharpCompilationOptions WithModuleName(string moduleName)" />
            <member def="public CSharpCompilationOptions WithOptimizationLevel(OptimizationLevel value)" />
            <member def="public CSharpCompilationOptions WithOutputKind(OutputKind kind)" />
            <member def="public CSharpCompilationOptions WithOverflowChecks(bool enabled)" />
            <member def="public CSharpCompilationOptions WithPlatform(Platform platform)" />
            <member def="public CSharpCompilationOptions WithPublicSign(bool publicSign)" />
            <member def="public CSharpCompilationOptions WithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics)" />
            <member def="public CSharpCompilationOptions WithScriptClassName(string name)" />
            <member def="public CSharpCompilationOptions WithSourceReferenceResolver(SourceReferenceResolver resolver)" />
            <member def="public CSharpCompilationOptions WithSpecificDiagnosticOptions(ImmutableDictionary&lt;string, ReportDiagnostic&gt; values)" />
            <member def="public CSharpCompilationOptions WithSpecificDiagnosticOptions(IEnumerable&lt;KeyValuePair&lt;string, ReportDiagnostic&gt;&gt; values)" />
            <member def="public CSharpCompilationOptions WithStrongNameProvider(StrongNameProvider provider)" />
            <member def="public CSharpCompilationOptions WithUsings(ImmutableArray&lt;string&gt; usings)" />
            <member def="public CSharpCompilationOptions WithUsings(IEnumerable&lt;string&gt; usings)" />
            <member def="public CSharpCompilationOptions WithUsings(params string[] usings)" />
            <member def="public CSharpCompilationOptions WithWarningLevel(int warningLevel)" />
            <member def="public CSharpCompilationOptions WithXmlReferenceResolver(XmlReferenceResolver resolver)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.ControlFlowAnalysis">
        <members>
          <member def="protected ControlFlowAnalysis()" />
          <member def="public abstract bool EndPointIsReachable { get; }" />
          <member def="public abstract ImmutableArray&lt;SyntaxNode&gt; EntryPoints { get; }" />
          <member def="public abstract ImmutableArray&lt;SyntaxNode&gt; ExitPoints { get; }" />
          <member def="public abstract ImmutableArray&lt;SyntaxNode&gt; ReturnStatements { get; }" />
          <member def="public abstract bool StartPointIsReachable { get; }" />
          <member def="public abstract bool Succeeded { get; }" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.CustomModifier : ICustomModifier">
        <members>
          <member def="protected CustomModifier()" />
          <member def="public abstract bool IsOptional { get; }" />
          <member def="public abstract INamedTypeSymbol Modifier { get; }" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.DataFlowAnalysis">
        <members>
          <member def="protected DataFlowAnalysis()" />
          <member def="public abstract ImmutableArray&lt;ISymbol&gt; AlwaysAssigned { get; }" />
          <member def="public abstract ImmutableArray&lt;ISymbol&gt; Captured { get; }" />
          <member def="public abstract ImmutableArray&lt;ISymbol&gt; DataFlowsIn { get; }" />
          <member def="public abstract ImmutableArray&lt;ISymbol&gt; DataFlowsOut { get; }" />
          <member def="public abstract ImmutableArray&lt;ISymbol&gt; ReadInside { get; }" />
          <member def="public abstract ImmutableArray&lt;ISymbol&gt; ReadOutside { get; }" />
          <member def="public abstract bool Succeeded { get; }" />
          <member def="public abstract ImmutableArray&lt;ISymbol&gt; UnsafeAddressTaken { get; }" />
          <member def="public abstract ImmutableArray&lt;ISymbol&gt; VariablesDeclared { get; }" />
          <member def="public abstract ImmutableArray&lt;ISymbol&gt; WrittenInside { get; }" />
          <member def="public abstract ImmutableArray&lt;ISymbol&gt; WrittenOutside { get; }" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Diagnostic : IEquatable&lt;Diagnostic&gt;, IFormattable">
        <members>
          <member def="protected Diagnostic()" />
          <member def="public abstract IReadOnlyList&lt;Location&gt; AdditionalLocations { get; }" />
          <member def="public virtual DiagnosticSeverity DefaultSeverity { get; }" />
          <member def="public abstract DiagnosticDescriptor Descriptor { get; }" />
          <member def="public abstract string Id { get; }" />
          <member def="public abstract bool IsSuppressed { get; }" />
          <member def="public bool IsWarningAsError { get; }" />
          <member def="public abstract Location Location { get; }" />
          <member def="public virtual ImmutableDictionary&lt;string, string&gt; Properties { get; }" />
          <member def="public abstract DiagnosticSeverity Severity { get; }" />
          <member def="public abstract int WarningLevel { get; }" />
          <member def="public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, params object[] messageArgs)" />
          <member def="public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, IEnumerable&lt;Location&gt; additionalLocations, params object[] messageArgs)" />
          <member def="public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, ImmutableDictionary&lt;string, string&gt; properties, params object[] messageArgs)" />
          <member def="public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, IEnumerable&lt;Location&gt; additionalLocations, ImmutableDictionary&lt;string, string&gt; properties, params object[] messageArgs)" />
          <member def="public static Diagnostic Create(string id, string category, LocalizableString message, DiagnosticSeverity severity, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, LocalizableString title = null, LocalizableString description = null, string helpLink = null, Location location = null, IEnumerable&lt;Location&gt; additionalLocations = null, IEnumerable&lt;string&gt; customTags = null, ImmutableDictionary&lt;string, string&gt; properties = null)" />
          <member def="public static Diagnostic Create(string id, string category, LocalizableString message, DiagnosticSeverity severity, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, bool isSuppressed, LocalizableString title = null, LocalizableString description = null, string helpLink = null, Location location = null, IEnumerable&lt;Location&gt; additionalLocations = null, IEnumerable&lt;string&gt; customTags = null, ImmutableDictionary&lt;string, string&gt; properties = null)" />
          <member def="public override abstract bool Equals(object obj)" />
          <member def="public abstract bool Equals(Diagnostic obj)" />
          <member def="public override abstract int GetHashCode()" />
          <member def="public abstract string GetMessage(IFormatProvider formatProvider = null)" />
          <member def="public SuppressionInfo GetSuppressionInfo(Compilation compilation)" />
          <member def="public override string ToString()" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.DiagnosticDescriptor : IEquatable&lt;DiagnosticDescriptor&gt;">
        <members>
          <member def="public DiagnosticDescriptor(string id, string title, string messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, string description = null, string helpLinkUri = null, params string[] customTags)" />
          <member def="public DiagnosticDescriptor(string id, LocalizableString title, LocalizableString messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, LocalizableString description = null, string helpLinkUri = null, params string[] customTags)" />
          <member def="public string Category { get; }" />
          <member def="public IEnumerable&lt;string&gt; CustomTags { get; }" />
          <member def="public DiagnosticSeverity DefaultSeverity { get; }" />
          <member def="public LocalizableString Description { get; }" />
          <member def="public string HelpLinkUri { get; }" />
          <member def="public string Id { get; }" />
          <member def="public bool IsEnabledByDefault { get; }" />
          <member def="public LocalizableString MessageFormat { get; }" />
          <member def="public LocalizableString Title { get; }" />
          <member def="public override bool Equals(object obj)" />
          <member def="public bool Equals(DiagnosticDescriptor other)" />
          <member def="public ReportDiagnostic GetEffectiveSeverity(CompilationOptions compilationOptions)" />
          <member def="public override int GetHashCode()" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.DiagnosticFormatter">
        <members>
          <member def="public DiagnosticFormatter()" />
          <member def="public virtual string Format(Diagnostic diagnostic, IFormatProvider formatter = null)" />
        </members>
        <type def="public class Microsoft.CodeAnalysis.CSharp.CSharpDiagnosticFormatter : DiagnosticFormatter">
          <members>
            <member def="public static CSharpDiagnosticFormatter Instance { get; }" />
          </members>
        </type>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.DllImportData : IPlatformInvokeInformation">
        <members>
          <member def="public bool? BestFitMapping { get; }" />
          <member def="public CallingConvention CallingConvention { get; }" />
          <member def="public CharSet CharacterSet { get; }" />
          <member def="public string EntryPointName { get; }" />
          <member def="public bool ExactSpelling { get; }" />
          <member def="public string ModuleName { get; }" />
          <member def="public bool SetLastError { get; }" />
          <member def="public bool? ThrowOnUnmappableCharacter { get; }" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.DocumentId : IEquatable&lt;DocumentId&gt;, IObjectWritable">
        <members>
          <member def="public Guid Id { get; }" />
          <member def="public ProjectId ProjectId { get; }" />
          <member def="public static DocumentId CreateFromSerialized(ProjectId projectId, Guid id, string debugName = null)" />
          <member def="public static DocumentId CreateNewId(ProjectId projectId, string debugName = null)" />
          <member def="public override bool Equals(object obj)" />
          <member def="public bool Equals(DocumentId other)" />
          <member def="public override int GetHashCode()" />
          <member def="public override string ToString()" />
          <member def="public static bool operator ==(DocumentId left, DocumentId right)" />
          <member def="public static bool operator !=(DocumentId left, DocumentId right)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.DocumentInfo">
        <members>
          <member def="public string FilePath { get; }" />
          <member def="public IReadOnlyList&lt;string&gt; Folders { get; }" />
          <member def="public DocumentId Id { get; }" />
          <member def="public bool IsGenerated { get; }" />
          <member def="public string Name { get; }" />
          <member def="public SourceCodeKind SourceCodeKind { get; }" />
          <member def="public TextLoader TextLoader { get; }" />
          <member def="public static DocumentInfo Create(DocumentId id, string name, IEnumerable&lt;string&gt; folders = null, SourceCodeKind sourceCodeKind = Regular, TextLoader loader = null, string filePath = null, bool isGenerated = false)" />
          <member def="public DocumentInfo WithFilePath(string filePath)" />
          <member def="public DocumentInfo WithFolders(IEnumerable&lt;string&gt; folders)" />
          <member def="public DocumentInfo WithId(DocumentId id)" />
          <member def="public DocumentInfo WithName(string name)" />
          <member def="public DocumentInfo WithSourceCodeKind(SourceCodeKind kind)" />
          <member def="public DocumentInfo WithTextLoader(TextLoader loader)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.DocumentationProvider">
        <members>
          <member def="protected DocumentationProvider()" />
          <member def="public static DocumentationProvider Default { get; }" />
          <member def="public override abstract bool Equals(object obj)" />
          <member def="protected internal abstract string GetDocumentationForSymbol(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken = default)" />
          <member def="public override abstract int GetHashCode()" />
        </members>
        <type def="public abstract class Microsoft.CodeAnalysis.XmlDocumentationProvider : DocumentationProvider">
          <members>
            <member def="protected XmlDocumentationProvider()" />
            <member def="public static XmlDocumentationProvider CreateFromBytes(byte[] xmlDocCommentBytes)" />
            <member def="public static XmlDocumentationProvider CreateFromFile(string xmlDocCommentFilePath)" />
            <member def="protected override string GetDocumentationForSymbol(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken = default)" />
            <member def="protected abstract Stream GetSourceStream(CancellationToken cancellationToken)" />
          </members>
        </type>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.EmbeddedText">
        <members>
          <member def="public ImmutableArray&lt;byte&gt; Checksum { get; }" />
          <member def="public SourceHashAlgorithm ChecksumAlgorithm { get; }" />
          <member def="public string FilePath { get; }" />
          <member def="public static EmbeddedText FromBytes(string filePath, ArraySegment&lt;byte&gt; bytes, SourceHashAlgorithm checksumAlgorithm = Sha1)" />
          <member def="public static EmbeddedText FromSource(string filePath, SourceText text)" />
          <member def="public static EmbeddedText FromStream(string filePath, Stream stream, SourceHashAlgorithm checksumAlgorithm = Sha1)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.LocalizableString : IEquatable&lt;LocalizableString&gt;, IFormattable">
        <members>
          <member def="protected LocalizableString()" />
          <member def="public event EventHandler&lt;Exception&gt; OnException" />
          <member def="protected abstract bool AreEqual(object other)" />
          <member def="public override sealed bool Equals(object other)" />
          <member def="public bool Equals(LocalizableString other)" />
          <member def="protected abstract int GetHash()" />
          <member def="public override sealed int GetHashCode()" />
          <member def="protected abstract string GetText(IFormatProvider formatProvider)" />
          <member def="public override sealed string ToString()" />
          <member def="public string ToString(IFormatProvider formatProvider)" />
          <member def="public static explicit operator string(LocalizableString localizableResource)" />
          <member def="public static implicit operator LocalizableString(string fixedResource)" />
        </members>
        <type def="public sealed class Microsoft.CodeAnalysis.LocalizableResourceString : LocalizableString, IObjectWritable">
          <members>
            <member def="public LocalizableResourceString(string nameOfLocalizableResource, ResourceManager resourceManager, Type resourceSource)" />
            <member def="public LocalizableResourceString(string nameOfLocalizableResource, ResourceManager resourceManager, Type resourceSource, params string[] formatArguments)" />
            <member def="protected override bool AreEqual(object other)" />
            <member def="protected override int GetHash()" />
            <member def="protected override string GetText(IFormatProvider formatProvider)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Location">
        <members>
          <member def="public bool IsInMetadata { get; }" />
          <member def="public bool IsInSource { get; }" />
          <member def="public abstract LocationKind Kind { get; }" />
          <member def="public virtual IModuleSymbol MetadataModule { get; }" />
          <member def="public static Location None { get; }" />
          <member def="public virtual TextSpan SourceSpan { get; }" />
          <member def="public virtual SyntaxTree SourceTree { get; }" />
          <member def="public static Location Create(SyntaxTree syntaxTree, TextSpan textSpan)" />
          <member def="public static Location Create(string filePath, TextSpan textSpan, LinePositionSpan lineSpan)" />
          <member def="public override abstract bool Equals(object obj)" />
          <member def="protected virtual string GetDebuggerDisplay()" />
          <member def="public override abstract int GetHashCode()" />
          <member def="public virtual FileLinePositionSpan GetLineSpan()" />
          <member def="public virtual FileLinePositionSpan GetMappedLineSpan()" />
          <member def="public override string ToString()" />
          <member def="public static bool operator ==(Location left, Location right)" />
          <member def="public static bool operator !=(Location left, Location right)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Metadata : IDisposable">
        <members>
          <member def="public MetadataId Id { get; }" />
          <member def="public abstract MetadataImageKind Kind { get; }" />
          <member def="protected abstract Metadata CommonCopy()" />
          <member def="public Metadata Copy()" />
          <member def="public abstract void Dispose()" />
        </members>
        <type def="public sealed class Microsoft.CodeAnalysis.AssemblyMetadata : Metadata">
          <members>
            <member def="public override MetadataImageKind Kind { get; }" />
            <member def="protected override Metadata CommonCopy()" />
            <member def="public static AssemblyMetadata Create(ModuleMetadata module)" />
            <member def="public static AssemblyMetadata Create(ImmutableArray&lt;ModuleMetadata&gt; modules)" />
            <member def="public static AssemblyMetadata Create(IEnumerable&lt;ModuleMetadata&gt; modules)" />
            <member def="public static AssemblyMetadata Create(params ModuleMetadata[] modules)" />
            <member def="public static AssemblyMetadata CreateFromFile(string path)" />
            <member def="public static AssemblyMetadata CreateFromImage(ImmutableArray&lt;byte&gt; peImage)" />
            <member def="public static AssemblyMetadata CreateFromImage(IEnumerable&lt;byte&gt; peImage)" />
            <member def="public static AssemblyMetadata CreateFromStream(Stream peStream, bool leaveOpen = false)" />
            <member def="public static AssemblyMetadata CreateFromStream(Stream peStream, PEStreamOptions options)" />
            <member def="public override void Dispose()" />
            <member def="public ImmutableArray&lt;ModuleMetadata&gt; GetModules()" />
            <member def="public PortableExecutableReference GetReference(DocumentationProvider documentation = null, ImmutableArray&lt;string&gt; aliases = default, bool embedInteropTypes = false, string filePath = null, string display = null)" />
          </members>
        </type>
        <type def="public sealed class Microsoft.CodeAnalysis.ModuleMetadata : Metadata">
          <members>
            <member def="public override MetadataImageKind Kind { get; }" />
            <member def="public string Name { get; }" />
            <member def="protected override Metadata CommonCopy()" />
            <member def="public static ModuleMetadata CreateFromFile(string path)" />
            <member def="public static ModuleMetadata CreateFromImage(IEnumerable&lt;byte&gt; peImage)" />
            <member def="public static ModuleMetadata CreateFromImage(ImmutableArray&lt;byte&gt; peImage)" />
            <member def="public static ModuleMetadata CreateFromImage(IntPtr peImage, int size)" />
            <member def="public static ModuleMetadata CreateFromMetadata(IntPtr metadata, int size)" />
            <member def="public static ModuleMetadata CreateFromStream(Stream peStream, bool leaveOpen = false)" />
            <member def="public static ModuleMetadata CreateFromStream(Stream peStream, PEStreamOptions options)" />
            <member def="public override void Dispose()" />
            <member def="public MetadataReader GetMetadataReader()" />
            <member def="public ImmutableArray&lt;string&gt; GetModuleNames()" />
            <member def="public Guid GetModuleVersionId()" />
            <member def="public PortableExecutableReference GetReference(DocumentationProvider documentation = null, string filePath = null, string display = null)" />
          </members>
        </type>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.MetadataId" />
      <type def="public abstract class Microsoft.CodeAnalysis.MetadataReference">
        <members>
          <member def="protected MetadataReference(MetadataReferenceProperties properties)" />
          <member def="public virtual string Display { get; }" />
          <member def="public MetadataReferenceProperties Properties { get; }" />
          <member def="public static MetadataReference CreateFromAssembly(Assembly assembly)" />
          <member def="public static MetadataReference CreateFromAssembly(Assembly assembly, MetadataReferenceProperties properties, DocumentationProvider documentation = null)" />
          <member def="public static PortableExecutableReference CreateFromFile(string path, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null)" />
          <member def="public static PortableExecutableReference CreateFromImage(ImmutableArray&lt;byte&gt; peImage, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null, string filePath = null)" />
          <member def="public static PortableExecutableReference CreateFromImage(IEnumerable&lt;byte&gt; peImage, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null, string filePath = null)" />
          <member def="public static PortableExecutableReference CreateFromStream(Stream peStream, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null, string filePath = null)" />
          <member def="public MetadataReference WithAliases(IEnumerable&lt;string&gt; aliases)" />
          <member def="public MetadataReference WithAliases(ImmutableArray&lt;string&gt; aliases)" />
          <member def="public MetadataReference WithEmbedInteropTypes(bool value)" />
          <member def="public MetadataReference WithProperties(MetadataReferenceProperties properties)" />
        </members>
        <type def="public abstract class Microsoft.CodeAnalysis.CompilationReference : MetadataReference, IEquatable&lt;CompilationReference&gt;">
          <members>
            <member def="public Compilation Compilation { get; }" />
            <member def="public override string Display { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(CompilationReference other)" />
            <member def="public override int GetHashCode()" />
            <member def="public CompilationReference WithAliases(IEnumerable&lt;string&gt; aliases)" />
            <member def="public CompilationReference WithAliases(ImmutableArray&lt;string&gt; aliases)" />
            <member def="public CompilationReference WithEmbedInteropTypes(bool value)" />
            <member def="public CompilationReference WithProperties(MetadataReferenceProperties properties)" />
          </members>
        </type>
        <type def="public abstract class Microsoft.CodeAnalysis.PortableExecutableReference : MetadataReference">
          <members>
            <member def="protected PortableExecutableReference(MetadataReferenceProperties properties, string fullPath = null, DocumentationProvider initialDocumentation = null)" />
            <member def="public override string Display { get; }" />
            <member def="public string FilePath { get; }" />
            <member def="protected abstract DocumentationProvider CreateDocumentationProvider()" />
            <member def="public Metadata GetMetadata()" />
            <member def="public MetadataId GetMetadataId()" />
            <member def="protected abstract Metadata GetMetadataImpl()" />
            <member def="public PortableExecutableReference WithAliases(IEnumerable&lt;string&gt; aliases)" />
            <member def="public PortableExecutableReference WithAliases(ImmutableArray&lt;string&gt; aliases)" />
            <member def="public PortableExecutableReference WithEmbedInteropTypes(bool value)" />
            <member def="public PortableExecutableReference WithProperties(MetadataReferenceProperties properties)" />
            <member def="protected abstract PortableExecutableReference WithPropertiesImpl(MetadataReferenceProperties properties)" />
          </members>
        </type>
        <type def="public sealed class Microsoft.CodeAnalysis.UnresolvedMetadataReference : MetadataReference">
          <members>
            <member def="public override string Display { get; }" />
            <member def="public string Reference { get; }" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.MetadataReferenceResolver">
        <members>
          <member def="protected MetadataReferenceResolver()" />
          <member def="public virtual bool ResolveMissingAssemblies { get; }" />
          <member def="public override abstract bool Equals(object other)" />
          <member def="public override abstract int GetHashCode()" />
          <member def="public virtual PortableExecutableReference ResolveMissingAssembly(MetadataReference definition, AssemblyIdentity referenceIdentity)" />
          <member def="public abstract ImmutableArray&lt;PortableExecutableReference&gt; ResolveReference(string reference, string baseFilePath, MetadataReferenceProperties properties)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.ParseOptions">
        <members>
          <member def="public DocumentationMode DocumentationMode { get; protected set; }" />
          <member def="public ImmutableArray&lt;Diagnostic&gt; Errors { get; }" />
          <member def="public abstract IReadOnlyDictionary&lt;string, string&gt; Features { get; }" />
          <member def="public SourceCodeKind Kind { get; protected set; }" />
          <member def="public abstract string Language { get; }" />
          <member def="public abstract IEnumerable&lt;string&gt; PreprocessorSymbolNames { get; }" />
          <member def="public SourceCodeKind SpecifiedKind { get; protected set; }" />
          <member def="protected abstract ParseOptions CommonWithDocumentationMode(DocumentationMode documentationMode)" />
          <member def="protected abstract ParseOptions CommonWithFeatures(IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; features)" />
          <member def="public abstract ParseOptions CommonWithKind(SourceCodeKind kind)" />
          <member def="public override abstract bool Equals(object obj)" />
          <member def="protected bool EqualsHelper(ParseOptions other)" />
          <member def="public override abstract int GetHashCode()" />
          <member def="protected int GetHashCodeHelper()" />
          <member def="public ParseOptions WithDocumentationMode(DocumentationMode documentationMode)" />
          <member def="public ParseOptions WithFeatures(IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; features)" />
          <member def="public ParseOptions WithKind(SourceCodeKind kind)" />
          <member def="public static bool operator ==(ParseOptions left, ParseOptions right)" />
          <member def="public static bool operator !=(ParseOptions left, ParseOptions right)" />
        </members>
        <type def="public sealed class Microsoft.CodeAnalysis.CSharp.CSharpParseOptions : ParseOptions, IEquatable&lt;CSharpParseOptions&gt;">
          <members>
            <member def="public CSharpParseOptions(LanguageVersion languageVersion = Default, DocumentationMode documentationMode = Parse, SourceCodeKind kind = Regular, IEnumerable&lt;string&gt; preprocessorSymbols = null)" />
            <member def="public static CSharpParseOptions Default { get; }" />
            <member def="public override IReadOnlyDictionary&lt;string, string&gt; Features { get; }" />
            <member def="public override string Language { get; }" />
            <member def="public LanguageVersion LanguageVersion { get; }" />
            <member def="public override IEnumerable&lt;string&gt; PreprocessorSymbolNames { get; }" />
            <member def="public LanguageVersion SpecifiedLanguageVersion { get; }" />
            <member def="protected override ParseOptions CommonWithDocumentationMode(DocumentationMode documentationMode)" />
            <member def="protected override ParseOptions CommonWithFeatures(IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; features)" />
            <member def="public override ParseOptions CommonWithKind(SourceCodeKind kind)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(CSharpParseOptions other)" />
            <member def="public override int GetHashCode()" />
            <member def="public CSharpParseOptions WithDocumentationMode(DocumentationMode documentationMode)" />
            <member def="public CSharpParseOptions WithFeatures(IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; features)" />
            <member def="public CSharpParseOptions WithKind(SourceCodeKind kind)" />
            <member def="public CSharpParseOptions WithLanguageVersion(LanguageVersion version)" />
            <member def="public CSharpParseOptions WithPreprocessorSymbols(IEnumerable&lt;string&gt; preprocessorSymbols)" />
            <member def="public CSharpParseOptions WithPreprocessorSymbols(params string[] preprocessorSymbols)" />
            <member def="public CSharpParseOptions WithPreprocessorSymbols(ImmutableArray&lt;string&gt; symbols)" />
          </members>
        </type>
      </type>
      <type def="public class Microsoft.CodeAnalysis.Project">
        <members>
          <member def="public IReadOnlyList&lt;DocumentId&gt; AdditionalDocumentIds { get; }" />
          <member def="public IEnumerable&lt;TextDocument&gt; AdditionalDocuments { get; }" />
          <member def="public IReadOnlyList&lt;ProjectReference&gt; AllProjectReferences { get; }" />
          <member def="public AnalyzerOptions AnalyzerOptions { get; }" />
          <member def="public IReadOnlyList&lt;AnalyzerReference&gt; AnalyzerReferences { get; }" />
          <member def="public string AssemblyName { get; }" />
          <member def="public CompilationOptions CompilationOptions { get; }" />
          <member def="public IReadOnlyList&lt;DocumentId&gt; DocumentIds { get; }" />
          <member def="public IEnumerable&lt;Document&gt; Documents { get; }" />
          <member def="public string FilePath { get; }" />
          <member def="public bool HasDocuments { get; }" />
          <member def="public ProjectId Id { get; }" />
          <member def="public bool IsSubmission { get; }" />
          <member def="public string Language { get; }" />
          <member def="public HostLanguageServices LanguageServices { get; }" />
          <member def="public IReadOnlyList&lt;MetadataReference&gt; MetadataReferences { get; }" />
          <member def="public string Name { get; }" />
          <member def="public string OutputFilePath { get; }" />
          <member def="public ParseOptions ParseOptions { get; }" />
          <member def="public IEnumerable&lt;ProjectReference&gt; ProjectReferences { get; }" />
          <member def="public Solution Solution { get; }" />
          <member def="public bool SupportsCompilation { get; }" />
          <member def="public VersionStamp Version { get; }" />
          <member def="public TextDocument AddAdditionalDocument(string name, SourceText text, IEnumerable&lt;string&gt; folders = null, string filePath = null)" />
          <member def="public TextDocument AddAdditionalDocument(string name, string text, IEnumerable&lt;string&gt; folders = null, string filePath = null)" />
          <member def="public Project AddAnalyzerReference(AnalyzerReference analyzerReference)" />
          <member def="public Project AddAnalyzerReferences(IEnumerable&lt;AnalyzerReference&gt; analyzerReferences)" />
          <member def="public Document AddDocument(string name, SyntaxNode syntaxRoot, IEnumerable&lt;string&gt; folders = null, string filePath = null)" />
          <member def="public Document AddDocument(string name, SourceText text, IEnumerable&lt;string&gt; folders = null, string filePath = null)" />
          <member def="public Document AddDocument(string name, string text, IEnumerable&lt;string&gt; folders = null, string filePath = null)" />
          <member def="public Project AddMetadataReference(MetadataReference metadataReference)" />
          <member def="public Project AddMetadataReferences(IEnumerable&lt;MetadataReference&gt; metadataReferences)" />
          <member def="public Project AddProjectReference(ProjectReference projectReference)" />
          <member def="public Project AddProjectReferences(IEnumerable&lt;ProjectReference&gt; projectReferences)" />
          <member def="public bool ContainsAdditionalDocument(DocumentId documentId)" />
          <member def="public bool ContainsDocument(DocumentId documentId)" />
          <member def="public TextDocument GetAdditionalDocument(DocumentId documentId)" />
          <member def="public ProjectChanges GetChanges(Project oldProject)" />
          <member def="public Task&lt;Compilation&gt; GetCompilationAsync(CancellationToken cancellationToken = default)" />
          <member def="public Task&lt;VersionStamp&gt; GetDependentSemanticVersionAsync(CancellationToken cancellationToken = default)" />
          <member def="public Task&lt;VersionStamp&gt; GetDependentVersionAsync(CancellationToken cancellationToken = default)" />
          <member def="public Document GetDocument(DocumentId documentId)" />
          <member def="public Document GetDocument(SyntaxTree syntaxTree)" />
          <member def="public DocumentId GetDocumentId(SyntaxTree syntaxTree)" />
          <member def="public Task&lt;VersionStamp&gt; GetLatestDocumentVersionAsync(CancellationToken cancellationToken = default)" />
          <member def="public Task&lt;VersionStamp&gt; GetSemanticVersionAsync(CancellationToken cancellationToken = default)" />
          <member def="public Project RemoveAdditionalDocument(DocumentId documentId)" />
          <member def="public Project RemoveAnalyzerReference(AnalyzerReference analyzerReference)" />
          <member def="public Project RemoveDocument(DocumentId documentId)" />
          <member def="public Project RemoveMetadataReference(MetadataReference metadataReference)" />
          <member def="public Project RemoveProjectReference(ProjectReference projectReference)" />
          <member def="public bool TryGetCompilation(out Compilation compilation)" />
          <member def="public Project WithAnalyzerReferences(IEnumerable&lt;AnalyzerReference&gt; analyzerReferencs)" />
          <member def="public Project WithAssemblyName(string assemblyName)" />
          <member def="public Project WithCompilationOptions(CompilationOptions options)" />
          <member def="public Project WithMetadataReferences(IEnumerable&lt;MetadataReference&gt; metadataReferences)" />
          <member def="public Project WithParseOptions(ParseOptions options)" />
          <member def="public Project WithProjectReferences(IEnumerable&lt;ProjectReference&gt; projectReferences)" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.ProjectDependencyGraph">
        <members>
          <member def="public IEnumerable&lt;IEnumerable&lt;ProjectId&gt;&gt; GetDependencySets(CancellationToken cancellationToken = default)" />
          <member def="public IImmutableSet&lt;ProjectId&gt; GetProjectsThatDirectlyDependOnThisProject(ProjectId projectId)" />
          <member def="public IImmutableSet&lt;ProjectId&gt; GetProjectsThatThisProjectDirectlyDependsOn(ProjectId projectId)" />
          <member def="public IImmutableSet&lt;ProjectId&gt; GetProjectsThatThisProjectTransitivelyDependsOn(ProjectId projectId)" />
          <member def="public IEnumerable&lt;ProjectId&gt; GetProjectsThatTransitivelyDependOnThisProject(ProjectId projectId)" />
          <member def="public IEnumerable&lt;ProjectId&gt; GetTopologicallySortedProjects(CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.ProjectId : IEquatable&lt;ProjectId&gt;, IObjectWritable">
        <members>
          <member def="public Guid Id { get; }" />
          <member def="public static ProjectId CreateFromSerialized(Guid id, string debugName = null)" />
          <member def="public static ProjectId CreateNewId(string debugName = null)" />
          <member def="public override bool Equals(object obj)" />
          <member def="public bool Equals(ProjectId other)" />
          <member def="public override int GetHashCode()" />
          <member def="public override string ToString()" />
          <member def="public static bool operator ==(ProjectId left, ProjectId right)" />
          <member def="public static bool operator !=(ProjectId left, ProjectId right)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.ProjectInfo">
        <members>
          <member def="public IReadOnlyList&lt;DocumentInfo&gt; AdditionalDocuments { get; }" />
          <member def="public IReadOnlyList&lt;AnalyzerReference&gt; AnalyzerReferences { get; }" />
          <member def="public string AssemblyName { get; }" />
          <member def="public CompilationOptions CompilationOptions { get; }" />
          <member def="public IReadOnlyList&lt;DocumentInfo&gt; Documents { get; }" />
          <member def="public string FilePath { get; }" />
          <member def="public Type HostObjectType { get; }" />
          <member def="public ProjectId Id { get; }" />
          <member def="public bool IsSubmission { get; }" />
          <member def="public string Language { get; }" />
          <member def="public IReadOnlyList&lt;MetadataReference&gt; MetadataReferences { get; }" />
          <member def="public string Name { get; }" />
          <member def="public string OutputFilePath { get; }" />
          <member def="public ParseOptions ParseOptions { get; }" />
          <member def="public IReadOnlyList&lt;ProjectReference&gt; ProjectReferences { get; }" />
          <member def="public VersionStamp Version { get; }" />
          <member def="public static ProjectInfo Create(ProjectId id, VersionStamp version, string name, string assemblyName, string language, string filePath = null, string outputFilePath = null, CompilationOptions compilationOptions = null, ParseOptions parseOptions = null, IEnumerable&lt;DocumentInfo&gt; documents = null, IEnumerable&lt;ProjectReference&gt; projectReferences = null, IEnumerable&lt;MetadataReference&gt; metadataReferences = null, IEnumerable&lt;AnalyzerReference&gt; analyzerReferences = null, IEnumerable&lt;DocumentInfo&gt; additionalDocuments = null, bool isSubmission = false, Type hostObjectType = null)" />
          <member def="public ProjectInfo WithAdditionalDocuments(IEnumerable&lt;DocumentInfo&gt; additionalDocuments)" />
          <member def="public ProjectInfo WithAnalyzerReferences(IEnumerable&lt;AnalyzerReference&gt; analyzerReferences)" />
          <member def="public ProjectInfo WithAssemblyName(string assemblyName)" />
          <member def="public ProjectInfo WithCompilationOptions(CompilationOptions compilationOptions)" />
          <member def="public ProjectInfo WithDocuments(IEnumerable&lt;DocumentInfo&gt; documents)" />
          <member def="public ProjectInfo WithFilePath(string filePath)" />
          <member def="public ProjectInfo WithMetadataReferences(IEnumerable&lt;MetadataReference&gt; metadataReferences)" />
          <member def="public ProjectInfo WithName(string name)" />
          <member def="public ProjectInfo WithOutputFilePath(string outputFilePath)" />
          <member def="public ProjectInfo WithParseOptions(ParseOptions parseOptions)" />
          <member def="public ProjectInfo WithProjectReferences(IEnumerable&lt;ProjectReference&gt; projectReferences)" />
          <member def="public ProjectInfo WithVersion(VersionStamp version)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.ProjectReference : IEquatable&lt;ProjectReference&gt;">
        <members>
          <member def="public ProjectReference(ProjectId projectId, ImmutableArray&lt;string&gt; aliases = default, bool embedInteropTypes = false)" />
          <member def="public ImmutableArray&lt;string&gt; Aliases { get; }" />
          <member def="public bool EmbedInteropTypes { get; }" />
          <member def="public ProjectId ProjectId { get; }" />
          <member def="public override bool Equals(object obj)" />
          <member def="public bool Equals(ProjectReference reference)" />
          <member def="public override int GetHashCode()" />
          <member def="public static bool operator ==(ProjectReference left, ProjectReference right)" />
          <member def="public static bool operator !=(ProjectReference left, ProjectReference right)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.ResourceDescription : IFileReference">
        <members>
          <member def="public ResourceDescription(string resourceName, Func&lt;Stream&gt; dataProvider, bool isPublic)" />
          <member def="public ResourceDescription(string resourceName, string fileName, Func&lt;Stream&gt; dataProvider, bool isPublic)" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.RuleSet">
        <members>
          <member def="public RuleSet(string filePath, ReportDiagnostic generalOption, ImmutableDictionary&lt;string, ReportDiagnostic&gt; specificOptions, ImmutableArray&lt;RuleSetInclude&gt; includes)" />
          <member def="public string FilePath { get; }" />
          <member def="public ReportDiagnostic GeneralDiagnosticOption { get; }" />
          <member def="public ImmutableArray&lt;RuleSetInclude&gt; Includes { get; }" />
          <member def="public ImmutableDictionary&lt;string, ReportDiagnostic&gt; SpecificDiagnosticOptions { get; }" />
          <member def="public static ReportDiagnostic GetDiagnosticOptionsFromRulesetFile(string rulesetFileFullPath, out Dictionary&lt;string, ReportDiagnostic&gt; specificDiagnosticOptions)" />
          <member def="public static ImmutableArray&lt;string&gt; GetEffectiveIncludesFromFile(string filePath)" />
          <member def="public static RuleSet LoadEffectiveRuleSetFromFile(string filePath)" />
          <member def="public RuleSet WithEffectiveAction(ReportDiagnostic action)" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.RuleSetInclude">
        <members>
          <member def="public RuleSetInclude(string includePath, ReportDiagnostic action)" />
          <member def="public ReportDiagnostic Action { get; }" />
          <member def="public string IncludePath { get; }" />
          <member def="public RuleSet LoadRuleSet(RuleSet parent)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.ScriptCompilationInfo">
        <members>
          <member def="public Type GlobalsType { get; }" />
          <member def="public Compilation PreviousScriptCompilation { get; }" />
          <member def="public Type ReturnType { get; }" />
          <member def="public ScriptCompilationInfo WithPreviousScriptCompilation(Compilation compilation)" />
        </members>
        <type def="public sealed class Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo : ScriptCompilationInfo">
          <members>
            <member def="public CSharpCompilation PreviousScriptCompilation { get; }" />
            <member def="public CSharpScriptCompilationInfo WithPreviousScriptCompilation(CSharpCompilation compilation)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.SemanticModel">
        <members>
          <member def="protected SemanticModel()" />
          <member def="public Compilation Compilation { get; }" />
          <member def="protected abstract Compilation CompilationCore { get; }" />
          <member def="public virtual bool IgnoresAccessibility { get; }" />
          <member def="public abstract bool IsSpeculativeSemanticModel { get; }" />
          <member def="public abstract string Language { get; }" />
          <member def="public abstract int OriginalPositionForSpeculation { get; }" />
          <member def="public SemanticModel ParentModel { get; }" />
          <member def="protected abstract SemanticModel ParentModelCore { get; }" />
          <member def="public SyntaxTree SyntaxTree { get; }" />
          <member def="protected abstract SyntaxTree SyntaxTreeCore { get; }" />
          <member def="protected abstract ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode statement)" />
          <member def="protected abstract ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement)" />
          <member def="protected abstract DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode statementOrExpression)" />
          <member def="protected abstract DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement)" />
          <member def="protected abstract IAliasSymbol GetAliasInfoCore(SyntaxNode nameSyntax, CancellationToken cancellationToken = default)" />
          <member def="public Optional&lt;object&gt; GetConstantValue(SyntaxNode node, CancellationToken cancellationToken = default)" />
          <member def="protected abstract Optional&lt;object&gt; GetConstantValueCore(SyntaxNode node, CancellationToken cancellationToken = default)" />
          <member def="public abstract ImmutableArray&lt;Diagnostic&gt; GetDeclarationDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default)" />
          <member def="protected abstract ISymbol GetDeclaredSymbolCore(SyntaxNode declaration, CancellationToken cancellationToken = default)" />
          <member def="protected abstract ImmutableArray&lt;ISymbol&gt; GetDeclaredSymbolsCore(SyntaxNode declaration, CancellationToken cancellationToken = default)" />
          <member def="public abstract ImmutableArray&lt;Diagnostic&gt; GetDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default)" />
          <member def="public ISymbol GetEnclosingSymbol(int position, CancellationToken cancellationToken = default)" />
          <member def="protected abstract ISymbol GetEnclosingSymbolCore(int position, CancellationToken cancellationToken = default)" />
          <member def="protected abstract ImmutableArray&lt;ISymbol&gt; GetMemberGroupCore(SyntaxNode node, CancellationToken cancellationToken = default)" />
          <member def="public abstract ImmutableArray&lt;Diagnostic&gt; GetMethodBodyDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default)" />
          <member def="public IOperation GetOperation(SyntaxNode node, CancellationToken cancellationToken = default)" />
          <member def="protected abstract IOperation GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)" />
          <member def="public PreprocessingSymbolInfo GetPreprocessingSymbolInfo(SyntaxNode nameSyntax)" />
          <member def="protected abstract PreprocessingSymbolInfo GetPreprocessingSymbolInfoCore(SyntaxNode nameSyntax)" />
          <member def="protected abstract IAliasSymbol GetSpeculativeAliasInfoCore(int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption)" />
          <member def="protected abstract SymbolInfo GetSpeculativeSymbolInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption)" />
          <member def="protected abstract TypeInfo GetSpeculativeTypeInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption)" />
          <member def="protected abstract SymbolInfo GetSymbolInfoCore(SyntaxNode node, CancellationToken cancellationToken = default)" />
          <member def="public abstract ImmutableArray&lt;Diagnostic&gt; GetSyntaxDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default)" />
          <member def="protected internal virtual SyntaxNode GetTopmostNodeForDiagnosticAnalysis(ISymbol symbol, SyntaxNode declaringSyntax)" />
          <member def="protected abstract TypeInfo GetTypeInfoCore(SyntaxNode node, CancellationToken cancellationToken = default)" />
          <member def="public bool IsAccessible(int position, ISymbol symbol)" />
          <member def="protected abstract bool IsAccessibleCore(int position, ISymbol symbol)" />
          <member def="public bool IsEventUsableAsField(int position, IEventSymbol eventSymbol)" />
          <member def="protected abstract bool IsEventUsableAsFieldCore(int position, IEventSymbol eventSymbol)" />
          <member def="public ImmutableArray&lt;ISymbol&gt; LookupBaseMembers(int position, string name = null)" />
          <member def="protected abstract ImmutableArray&lt;ISymbol&gt; LookupBaseMembersCore(int position, string name)" />
          <member def="public ImmutableArray&lt;ISymbol&gt; LookupLabels(int position, string name = null)" />
          <member def="protected abstract ImmutableArray&lt;ISymbol&gt; LookupLabelsCore(int position, string name)" />
          <member def="public ImmutableArray&lt;ISymbol&gt; LookupNamespacesAndTypes(int position, INamespaceOrTypeSymbol container = null, string name = null)" />
          <member def="protected abstract ImmutableArray&lt;ISymbol&gt; LookupNamespacesAndTypesCore(int position, INamespaceOrTypeSymbol container, string name)" />
          <member def="public ImmutableArray&lt;ISymbol&gt; LookupStaticMembers(int position, INamespaceOrTypeSymbol container = null, string name = null)" />
          <member def="protected abstract ImmutableArray&lt;ISymbol&gt; LookupStaticMembersCore(int position, INamespaceOrTypeSymbol container, string name)" />
          <member def="public ImmutableArray&lt;ISymbol&gt; LookupSymbols(int position, INamespaceOrTypeSymbol container = null, string name = null, bool includeReducedExtensionMethods = false)" />
          <member def="protected abstract ImmutableArray&lt;ISymbol&gt; LookupSymbolsCore(int position, INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods)" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.Solution">
        <members>
          <member def="public string FilePath { get; }" />
          <member def="public SolutionId Id { get; }" />
          <member def="public OptionSet Options { get; }" />
          <member def="public IReadOnlyList&lt;ProjectId&gt; ProjectIds { get; }" />
          <member def="public IEnumerable&lt;Project&gt; Projects { get; }" />
          <member def="public VersionStamp Version { get; }" />
          <member def="public Workspace Workspace { get; }" />
          <member def="public Solution AddAdditionalDocument(DocumentInfo documentInfo)" />
          <member def="public Solution AddAdditionalDocument(DocumentId documentId, string name, string text, IEnumerable&lt;string&gt; folders = null, string filePath = null)" />
          <member def="public Solution AddAdditionalDocument(DocumentId documentId, string name, SourceText text, IEnumerable&lt;string&gt; folders = null, string filePath = null)" />
          <member def="public Solution AddAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference)" />
          <member def="public Solution AddAnalyzerReferences(ProjectId projectId, IEnumerable&lt;AnalyzerReference&gt; analyzerReferences)" />
          <member def="public Solution AddDocument(DocumentInfo documentInfo)" />
          <member def="public Solution AddDocument(DocumentId documentId, string name, TextLoader loader, IEnumerable&lt;string&gt; folders = null)" />
          <member def="public Solution AddDocument(DocumentId documentId, string name, string text, IEnumerable&lt;string&gt; folders = null, string filePath = null)" />
          <member def="public Solution AddDocument(DocumentId documentId, string name, SourceText text, IEnumerable&lt;string&gt; folders = null, string filePath = null, bool isGenerated = false)" />
          <member def="public Solution AddDocument(DocumentId documentId, string name, SyntaxNode syntaxRoot, IEnumerable&lt;string&gt; folders = null, string filePath = null, bool isGenerated = false, PreservationMode preservationMode = PreserveValue)" />
          <member def="public Solution AddMetadataReference(ProjectId projectId, MetadataReference metadataReference)" />
          <member def="public Solution AddMetadataReferences(ProjectId projectId, IEnumerable&lt;MetadataReference&gt; metadataReferences)" />
          <member def="public Solution AddProject(ProjectInfo projectInfo)" />
          <member def="public Project AddProject(string name, string assemblyName, string language)" />
          <member def="public Solution AddProject(ProjectId projectId, string name, string assemblyName, string language)" />
          <member def="public Solution AddProjectReference(ProjectId projectId, ProjectReference projectReference)" />
          <member def="public Solution AddProjectReferences(ProjectId projectId, IEnumerable&lt;ProjectReference&gt; projectReferences)" />
          <member def="public bool ContainsAdditionalDocument(DocumentId documentId)" />
          <member def="public bool ContainsDocument(DocumentId documentId)" />
          <member def="public bool ContainsProject(ProjectId projectId)" />
          <member def="public TextDocument GetAdditionalDocument(DocumentId documentId)" />
          <member def="public SolutionChanges GetChanges(Solution oldSolution)" />
          <member def="public Document GetDocument(DocumentId documentId)" />
          <member def="public Document GetDocument(SyntaxTree syntaxTree)" />
          <member def="public DocumentId GetDocumentId(SyntaxTree syntaxTree)" />
          <member def="public DocumentId GetDocumentId(SyntaxTree syntaxTree, ProjectId projectId)" />
          <member def="public ImmutableArray&lt;DocumentId&gt; GetDocumentIdsWithFilePath(string filePath)" />
          <member def="public Solution GetIsolatedSolution()" />
          <member def="public VersionStamp GetLatestProjectVersion()" />
          <member def="public Project GetProject(ProjectId projectId)" />
          <member def="public Project GetProject(IAssemblySymbol assemblySymbol, CancellationToken cancellationToken = default)" />
          <member def="public ProjectDependencyGraph GetProjectDependencyGraph()" />
          <member def="public Solution RemoveAdditionalDocument(DocumentId documentId)" />
          <member def="public Solution RemoveAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference)" />
          <member def="public Solution RemoveDocument(DocumentId documentId)" />
          <member def="public Solution RemoveMetadataReference(ProjectId projectId, MetadataReference metadataReference)" />
          <member def="public Solution RemoveProject(ProjectId projectId)" />
          <member def="public Solution RemoveProjectReference(ProjectId projectId, ProjectReference projectReference)" />
          <member def="public Solution WithAdditionalDocumentText(DocumentId documentId, SourceText text, PreservationMode mode = PreserveValue)" />
          <member def="public Solution WithAdditionalDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode = PreserveValue)" />
          <member def="public Solution WithAdditionalDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode)" />
          <member def="public Solution WithDocumentFilePath(DocumentId documentId, string filePath)" />
          <member def="public Solution WithDocumentFolders(DocumentId documentId, IEnumerable&lt;string&gt; folders)" />
          <member def="public Solution WithDocumentName(DocumentId documentId, string name)" />
          <member def="public Solution WithDocumentSourceCodeKind(DocumentId documentId, SourceCodeKind sourceCodeKind)" />
          <member def="public Solution WithDocumentSyntaxRoot(DocumentId documentId, SyntaxNode root, PreservationMode mode = PreserveValue)" />
          <member def="public Solution WithDocumentText(DocumentId documentId, SourceText text, PreservationMode mode = PreserveValue)" />
          <member def="public Solution WithDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode = PreserveValue)" />
          <member def="public Solution WithDocumentText(IEnumerable&lt;DocumentId&gt; documentIds, SourceText text, PreservationMode mode = PreserveValue)" />
          <member def="public Solution WithDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode)" />
          <member def="public Solution WithProjectAnalyzerReferences(ProjectId projectId, IEnumerable&lt;AnalyzerReference&gt; analyzerReferences)" />
          <member def="public Solution WithProjectAssemblyName(ProjectId projectId, string assemblyName)" />
          <member def="public Solution WithProjectCompilationOptions(ProjectId projectId, CompilationOptions options)" />
          <member def="public Solution WithProjectFilePath(ProjectId projectId, string filePath)" />
          <member def="public Solution WithProjectMetadataReferences(ProjectId projectId, IEnumerable&lt;MetadataReference&gt; metadataReferences)" />
          <member def="public Solution WithProjectName(ProjectId projectId, string name)" />
          <member def="public Solution WithProjectOutputFilePath(ProjectId projectId, string outputFilePath)" />
          <member def="public Solution WithProjectParseOptions(ProjectId projectId, ParseOptions options)" />
          <member def="public Solution WithProjectReferences(ProjectId projectId, IEnumerable&lt;ProjectReference&gt; projectReferences)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.SolutionId : IEquatable&lt;SolutionId&gt;, IObjectWritable">
        <members>
          <member def="public Guid Id { get; }" />
          <member def="public static SolutionId CreateFromSerialized(Guid id, string debugName = null)" />
          <member def="public static SolutionId CreateNewId(string debugName = null)" />
          <member def="public override bool Equals(object obj)" />
          <member def="public bool Equals(SolutionId other)" />
          <member def="public override int GetHashCode()" />
          <member def="public static bool operator ==(SolutionId left, SolutionId right)" />
          <member def="public static bool operator !=(SolutionId left, SolutionId right)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.SolutionInfo">
        <members>
          <member def="public string FilePath { get; }" />
          <member def="public SolutionId Id { get; }" />
          <member def="public IReadOnlyList&lt;ProjectInfo&gt; Projects { get; }" />
          <member def="public VersionStamp Version { get; }" />
          <member def="public static SolutionInfo Create(SolutionId id, VersionStamp version, string filePath = null, IEnumerable&lt;ProjectInfo&gt; projects = null)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.SourceReferenceResolver">
        <members>
          <member def="protected SourceReferenceResolver()" />
          <member def="public override abstract bool Equals(object other)" />
          <member def="public override abstract int GetHashCode()" />
          <member def="public abstract string NormalizePath(string path, string baseFilePath)" />
          <member def="public abstract Stream OpenRead(string resolvedPath)" />
          <member def="public virtual SourceText ReadText(string resolvedPath)" />
          <member def="public abstract string ResolveReference(string path, string baseFilePath)" />
        </members>
        <type def="public class Microsoft.CodeAnalysis.SourceFileResolver : SourceReferenceResolver, IEquatable&lt;SourceFileResolver&gt;">
          <members>
            <member def="public SourceFileResolver(IEnumerable&lt;string&gt; searchPaths, string baseDirectory)" />
            <member def="public SourceFileResolver(ImmutableArray&lt;string&gt; searchPaths, string baseDirectory)" />
            <member def="public SourceFileResolver(ImmutableArray&lt;string&gt; searchPaths, string baseDirectory, ImmutableArray&lt;KeyValuePair&lt;string, string&gt;&gt; pathMap)" />
            <member def="public string BaseDirectory { get; }" />
            <member def="public static SourceFileResolver Default { get; }" />
            <member def="public ImmutableArray&lt;KeyValuePair&lt;string, string&gt;&gt; PathMap { get; }" />
            <member def="public ImmutableArray&lt;string&gt; SearchPaths { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(SourceFileResolver other)" />
            <member def="protected virtual bool FileExists(string resolvedPath)" />
            <member def="public override int GetHashCode()" />
            <member def="public override string NormalizePath(string path, string baseFilePath)" />
            <member def="public override Stream OpenRead(string resolvedPath)" />
            <member def="public override string ResolveReference(string path, string baseFilePath)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.StrongNameProvider">
        <members>
          <member def="protected StrongNameProvider()" />
          <member def="public override abstract bool Equals(object other)" />
          <member def="public override abstract int GetHashCode()" />
        </members>
        <type def="public class Microsoft.CodeAnalysis.DesktopStrongNameProvider : StrongNameProvider">
          <members>
            <member def="public DesktopStrongNameProvider(ImmutableArray&lt;string&gt; keyFileSearchPaths)" />
            <member def="public DesktopStrongNameProvider(ImmutableArray&lt;string&gt; keyFileSearchPaths = default, string tempPath = null)" />
            <member def="public override bool Equals(object obj)" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
      </type>
      <type def="public class Microsoft.CodeAnalysis.SymbolDisplayFormat">
        <members>
          <member def="public SymbolDisplayFormat(SymbolDisplayGlobalNamespaceStyle globalNamespaceStyle = Omitted, SymbolDisplayTypeQualificationStyle typeQualificationStyle = NameOnly, SymbolDisplayGenericsOptions genericsOptions = None, SymbolDisplayMemberOptions memberOptions = None, SymbolDisplayDelegateStyle delegateStyle = NameOnly, SymbolDisplayExtensionMethodStyle extensionMethodStyle = Default, SymbolDisplayParameterOptions parameterOptions = None, SymbolDisplayPropertyStyle propertyStyle = NameOnly, SymbolDisplayLocalOptions localOptions = None, SymbolDisplayKindOptions kindOptions = None, SymbolDisplayMiscellaneousOptions miscellaneousOptions = None)" />
          <member def="public static SymbolDisplayFormat CSharpErrorMessageFormat { get; }" />
          <member def="public static SymbolDisplayFormat CSharpShortErrorMessageFormat { get; }" />
          <member def="public SymbolDisplayDelegateStyle DelegateStyle { get; }" />
          <member def="public SymbolDisplayExtensionMethodStyle ExtensionMethodStyle { get; }" />
          <member def="public static SymbolDisplayFormat FullyQualifiedFormat { get; }" />
          <member def="public SymbolDisplayGenericsOptions GenericsOptions { get; }" />
          <member def="public SymbolDisplayGlobalNamespaceStyle GlobalNamespaceStyle { get; }" />
          <member def="public SymbolDisplayKindOptions KindOptions { get; }" />
          <member def="public SymbolDisplayLocalOptions LocalOptions { get; }" />
          <member def="public SymbolDisplayMemberOptions MemberOptions { get; }" />
          <member def="public static SymbolDisplayFormat MinimallyQualifiedFormat { get; }" />
          <member def="public SymbolDisplayMiscellaneousOptions MiscellaneousOptions { get; }" />
          <member def="public SymbolDisplayParameterOptions ParameterOptions { get; }" />
          <member def="public SymbolDisplayPropertyStyle PropertyStyle { get; }" />
          <member def="public SymbolDisplayTypeQualificationStyle TypeQualificationStyle { get; }" />
          <member def="public static SymbolDisplayFormat VisualBasicErrorMessageFormat { get; }" />
          <member def="public static SymbolDisplayFormat VisualBasicShortErrorMessageFormat { get; }" />
          <member def="public SymbolDisplayFormat AddGenericsOptions(SymbolDisplayGenericsOptions options)" />
          <member def="public SymbolDisplayFormat AddKindOptions(SymbolDisplayKindOptions options)" />
          <member def="public SymbolDisplayFormat AddLocalOptions(SymbolDisplayLocalOptions options)" />
          <member def="public SymbolDisplayFormat AddMemberOptions(SymbolDisplayMemberOptions options)" />
          <member def="public SymbolDisplayFormat AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options)" />
          <member def="public SymbolDisplayFormat AddParameterOptions(SymbolDisplayParameterOptions options)" />
          <member def="public SymbolDisplayFormat RemoveGenericsOptions(SymbolDisplayGenericsOptions options)" />
          <member def="public SymbolDisplayFormat RemoveKindOptions(SymbolDisplayKindOptions options)" />
          <member def="public SymbolDisplayFormat RemoveLocalOptions(SymbolDisplayLocalOptions options)" />
          <member def="public SymbolDisplayFormat RemoveMemberOptions(SymbolDisplayMemberOptions options)" />
          <member def="public SymbolDisplayFormat RemoveMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options)" />
          <member def="public SymbolDisplayFormat RemoveParameterOptions(SymbolDisplayParameterOptions options)" />
          <member def="public SymbolDisplayFormat WithGenericsOptions(SymbolDisplayGenericsOptions options)" />
          <member def="public SymbolDisplayFormat WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle style)" />
          <member def="public SymbolDisplayFormat WithKindOptions(SymbolDisplayKindOptions options)" />
          <member def="public SymbolDisplayFormat WithLocalOptions(SymbolDisplayLocalOptions options)" />
          <member def="public SymbolDisplayFormat WithMemberOptions(SymbolDisplayMemberOptions options)" />
          <member def="public SymbolDisplayFormat WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options)" />
          <member def="public SymbolDisplayFormat WithParameterOptions(SymbolDisplayParameterOptions options)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.SymbolVisitor">
        <members>
          <member def="protected SymbolVisitor()" />
          <member def="public virtual void DefaultVisit(ISymbol symbol)" />
          <member def="public virtual void Visit(ISymbol symbol)" />
          <member def="public virtual void VisitAlias(IAliasSymbol symbol)" />
          <member def="public virtual void VisitArrayType(IArrayTypeSymbol symbol)" />
          <member def="public virtual void VisitAssembly(IAssemblySymbol symbol)" />
          <member def="public virtual void VisitDiscard(IDiscardSymbol symbol)" />
          <member def="public virtual void VisitDynamicType(IDynamicTypeSymbol symbol)" />
          <member def="public virtual void VisitEvent(IEventSymbol symbol)" />
          <member def="public virtual void VisitField(IFieldSymbol symbol)" />
          <member def="public virtual void VisitLabel(ILabelSymbol symbol)" />
          <member def="public virtual void VisitLocal(ILocalSymbol symbol)" />
          <member def="public virtual void VisitMethod(IMethodSymbol symbol)" />
          <member def="public virtual void VisitModule(IModuleSymbol symbol)" />
          <member def="public virtual void VisitNamedType(INamedTypeSymbol symbol)" />
          <member def="public virtual void VisitNamespace(INamespaceSymbol symbol)" />
          <member def="public virtual void VisitParameter(IParameterSymbol symbol)" />
          <member def="public virtual void VisitPointerType(IPointerTypeSymbol symbol)" />
          <member def="public virtual void VisitProperty(IPropertySymbol symbol)" />
          <member def="public virtual void VisitRangeVariable(IRangeVariableSymbol symbol)" />
          <member def="public virtual void VisitTypeParameter(ITypeParameterSymbol symbol)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.SymbolVisitor&lt;TResult&gt;">
        <members>
          <member def="protected SymbolVisitor()" />
          <member def="public virtual TResult DefaultVisit(ISymbol symbol)" />
          <member def="public virtual TResult Visit(ISymbol symbol)" />
          <member def="public virtual TResult VisitAlias(IAliasSymbol symbol)" />
          <member def="public virtual TResult VisitArrayType(IArrayTypeSymbol symbol)" />
          <member def="public virtual TResult VisitAssembly(IAssemblySymbol symbol)" />
          <member def="public virtual TResult VisitDiscard(IDiscardSymbol symbol)" />
          <member def="public virtual TResult VisitDynamicType(IDynamicTypeSymbol symbol)" />
          <member def="public virtual TResult VisitEvent(IEventSymbol symbol)" />
          <member def="public virtual TResult VisitField(IFieldSymbol symbol)" />
          <member def="public virtual TResult VisitLabel(ILabelSymbol symbol)" />
          <member def="public virtual TResult VisitLocal(ILocalSymbol symbol)" />
          <member def="public virtual TResult VisitMethod(IMethodSymbol symbol)" />
          <member def="public virtual TResult VisitModule(IModuleSymbol symbol)" />
          <member def="public virtual TResult VisitNamedType(INamedTypeSymbol symbol)" />
          <member def="public virtual TResult VisitNamespace(INamespaceSymbol symbol)" />
          <member def="public virtual TResult VisitParameter(IParameterSymbol symbol)" />
          <member def="public virtual TResult VisitPointerType(IPointerTypeSymbol symbol)" />
          <member def="public virtual TResult VisitProperty(IPropertySymbol symbol)" />
          <member def="public virtual TResult VisitRangeVariable(IRangeVariableSymbol symbol)" />
          <member def="public virtual TResult VisitTypeParameter(ITypeParameterSymbol symbol)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.SyntaxAnnotation : IEquatable&lt;SyntaxAnnotation&gt;, IObjectWritable">
        <members>
          <member def="public SyntaxAnnotation()" />
          <member def="public SyntaxAnnotation(string kind)" />
          <member def="public SyntaxAnnotation(string kind, string data)" />
          <member def="public string Data { get; }" />
          <member def="public static SyntaxAnnotation ElasticAnnotation { get; }" />
          <member def="public string Kind { get; }" />
          <member def="public override bool Equals(object obj)" />
          <member def="public bool Equals(SyntaxAnnotation other)" />
          <member def="public override int GetHashCode()" />
          <member def="public static bool operator ==(SyntaxAnnotation left, SyntaxAnnotation right)" />
          <member def="public static bool operator !=(SyntaxAnnotation left, SyntaxAnnotation right)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.SyntaxNode">
        <members>
          <member def="public bool ContainsAnnotations { get; }" />
          <member def="public bool ContainsDiagnostics { get; }" />
          <member def="public bool ContainsDirectives { get; }" />
          <member def="public bool ContainsSkippedText { get; }" />
          <member def="public TextSpan FullSpan { get; }" />
          <member def="public bool HasLeadingTrivia { get; }" />
          <member def="public bool HasStructuredTrivia { get; }" />
          <member def="public bool HasTrailingTrivia { get; }" />
          <member def="public bool IsMissing { get; }" />
          <member def="public bool IsStructuredTrivia { get; }" />
          <member def="protected string KindText { get; }" />
          <member def="public abstract string Language { get; }" />
          <member def="public SyntaxNode Parent { get; }" />
          <member def="public virtual SyntaxTrivia ParentTrivia { get; }" />
          <member def="public int RawKind { get; }" />
          <member def="public TextSpan Span { get; }" />
          <member def="public int SpanStart { get; }" />
          <member def="public SyntaxTree SyntaxTree { get; }" />
          <member def="protected abstract SyntaxTree SyntaxTreeCore { get; }" />
          <member def="public IEnumerable&lt;SyntaxNode&gt; Ancestors(bool ascendOutOfTrivia = true)" />
          <member def="public IEnumerable&lt;SyntaxNode&gt; AncestorsAndSelf(bool ascendOutOfTrivia = true)" />
          <member def="public IEnumerable&lt;SyntaxNode&gt; ChildNodes()" />
          <member def="public ChildSyntaxList ChildNodesAndTokens()" />
          <member def="public virtual SyntaxNodeOrToken ChildThatContainsPosition(int position)" />
          <member def="public IEnumerable&lt;SyntaxToken&gt; ChildTokens()" />
          <member def="public bool Contains(SyntaxNode node)" />
          <member def="public T CopyAnnotationsTo&lt;T&gt;(T node) where T : SyntaxNode" />
          <member def="public IEnumerable&lt;SyntaxNode&gt; DescendantNodes(Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false)" />
          <member def="public IEnumerable&lt;SyntaxNode&gt; DescendantNodes(TextSpan span, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false)" />
          <member def="public IEnumerable&lt;SyntaxNode&gt; DescendantNodesAndSelf(Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false)" />
          <member def="public IEnumerable&lt;SyntaxNode&gt; DescendantNodesAndSelf(TextSpan span, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false)" />
          <member def="public IEnumerable&lt;SyntaxNodeOrToken&gt; DescendantNodesAndTokens(Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false)" />
          <member def="public IEnumerable&lt;SyntaxNodeOrToken&gt; DescendantNodesAndTokens(TextSpan span, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false)" />
          <member def="public IEnumerable&lt;SyntaxNodeOrToken&gt; DescendantNodesAndTokensAndSelf(Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false)" />
          <member def="public IEnumerable&lt;SyntaxNodeOrToken&gt; DescendantNodesAndTokensAndSelf(TextSpan span, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false)" />
          <member def="public IEnumerable&lt;SyntaxToken&gt; DescendantTokens(Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false)" />
          <member def="public IEnumerable&lt;SyntaxToken&gt; DescendantTokens(TextSpan span, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false)" />
          <member def="public IEnumerable&lt;SyntaxTrivia&gt; DescendantTrivia(Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false)" />
          <member def="public IEnumerable&lt;SyntaxTrivia&gt; DescendantTrivia(TextSpan span, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false)" />
          <member def="protected virtual bool EquivalentToCore(SyntaxNode other)" />
          <member def="public SyntaxNode FindNode(TextSpan span, bool findInsideTrivia = false, bool getInnermostNodeForTie = false)" />
          <member def="public SyntaxToken FindToken(int position, bool findInsideTrivia = false)" />
          <member def="protected virtual SyntaxToken FindTokenCore(int position, bool findInsideTrivia)" />
          <member def="protected virtual SyntaxToken FindTokenCore(int position, Func&lt;SyntaxTrivia, bool&gt; stepInto)" />
          <member def="public SyntaxTrivia FindTrivia(int position, bool findInsideTrivia = false)" />
          <member def="public SyntaxTrivia FindTrivia(int position, Func&lt;SyntaxTrivia, bool&gt; stepInto)" />
          <member def="protected virtual SyntaxTrivia FindTriviaCore(int position, bool findInsideTrivia)" />
          <member def="public TNode FirstAncestorOrSelf&lt;TNode&gt;(Func&lt;TNode, bool&gt; predicate = null, bool ascendOutOfTrivia = true) where TNode : SyntaxNode" />
          <member def="public IEnumerable&lt;SyntaxNode&gt; GetAnnotatedNodes(string annotationKind)" />
          <member def="public IEnumerable&lt;SyntaxNode&gt; GetAnnotatedNodes(SyntaxAnnotation syntaxAnnotation)" />
          <member def="public IEnumerable&lt;SyntaxNodeOrToken&gt; GetAnnotatedNodesAndTokens(SyntaxAnnotation annotation)" />
          <member def="public IEnumerable&lt;SyntaxNodeOrToken&gt; GetAnnotatedNodesAndTokens(string annotationKind)" />
          <member def="public IEnumerable&lt;SyntaxNodeOrToken&gt; GetAnnotatedNodesAndTokens(params string[] annotationKinds)" />
          <member def="public IEnumerable&lt;SyntaxToken&gt; GetAnnotatedTokens(string annotationKind)" />
          <member def="public IEnumerable&lt;SyntaxToken&gt; GetAnnotatedTokens(SyntaxAnnotation syntaxAnnotation)" />
          <member def="public IEnumerable&lt;SyntaxTrivia&gt; GetAnnotatedTrivia(SyntaxAnnotation annotation)" />
          <member def="public IEnumerable&lt;SyntaxTrivia&gt; GetAnnotatedTrivia(string annotationKind)" />
          <member def="public IEnumerable&lt;SyntaxTrivia&gt; GetAnnotatedTrivia(params string[] annotationKinds)" />
          <member def="public IEnumerable&lt;SyntaxAnnotation&gt; GetAnnotations(string annotationKind)" />
          <member def="public IEnumerable&lt;SyntaxAnnotation&gt; GetAnnotations(IEnumerable&lt;string&gt; annotationKinds)" />
          <member def="public IEnumerable&lt;Diagnostic&gt; GetDiagnostics()" />
          <member def="public SyntaxToken GetFirstToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false)" />
          <member def="public SyntaxToken GetLastToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false)" />
          <member def="public SyntaxTriviaList GetLeadingTrivia()" />
          <member def="public Location GetLocation()" />
          <member def="protected T GetRed&lt;T&gt;(ref T field, int slot) where T : SyntaxNode" />
          <member def="protected T GetRedAtZero&lt;T&gt;(ref T field) where T : SyntaxNode" />
          <member def="public SyntaxReference GetReference()" />
          <member def="public SourceText GetText(Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1)" />
          <member def="public SyntaxTriviaList GetTrailingTrivia()" />
          <member def="public bool HasAnnotation(SyntaxAnnotation annotation)" />
          <member def="public bool HasAnnotations(string annotationKind)" />
          <member def="public bool HasAnnotations(IEnumerable&lt;string&gt; annotationKinds)" />
          <member def="protected internal abstract SyntaxNode InsertNodesInListCore(SyntaxNode nodeInList, IEnumerable&lt;SyntaxNode&gt; nodesToInsert, bool insertBefore)" />
          <member def="protected internal abstract SyntaxNode InsertTokensInListCore(SyntaxToken originalToken, IEnumerable&lt;SyntaxToken&gt; newTokens, bool insertBefore)" />
          <member def="protected internal abstract SyntaxNode InsertTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable&lt;SyntaxTrivia&gt; newTrivia, bool insertBefore)" />
          <member def="public bool IsEquivalentTo(SyntaxNode other)" />
          <member def="public bool IsEquivalentTo(SyntaxNode node, bool topLevel = false)" />
          <member def="protected abstract bool IsEquivalentToCore(SyntaxNode node, bool topLevel = false)" />
          <member def="public bool IsPartOfStructuredTrivia()" />
          <member def="protected internal abstract SyntaxNode NormalizeWhitespaceCore(string indentation, string eol, bool elasticTrivia)" />
          <member def="protected internal abstract SyntaxNode RemoveNodesCore(IEnumerable&lt;SyntaxNode&gt; nodes, SyntaxRemoveOptions options)" />
          <member def="protected internal abstract SyntaxNode ReplaceCore&lt;TNode&gt;(IEnumerable&lt;TNode&gt; nodes = null, Func&lt;TNode, TNode, SyntaxNode&gt; computeReplacementNode = null, IEnumerable&lt;SyntaxToken&gt; tokens = null, Func&lt;SyntaxToken, SyntaxToken, SyntaxToken&gt; computeReplacementToken = null, IEnumerable&lt;SyntaxTrivia&gt; trivia = null, Func&lt;SyntaxTrivia, SyntaxTrivia, SyntaxTrivia&gt; computeReplacementTrivia = null) where TNode : SyntaxNode" />
          <member def="protected internal abstract SyntaxNode ReplaceNodeInListCore(SyntaxNode originalNode, IEnumerable&lt;SyntaxNode&gt; replacementNodes)" />
          <member def="protected internal abstract SyntaxNode ReplaceTokenInListCore(SyntaxToken originalToken, IEnumerable&lt;SyntaxToken&gt; newTokens)" />
          <member def="protected internal abstract SyntaxNode ReplaceTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable&lt;SyntaxTrivia&gt; newTrivia)" />
          <member def="public virtual void SerializeTo(Stream stream, CancellationToken cancellationToken = default)" />
          <member def="public virtual string ToFullString()" />
          <member def="public override string ToString()" />
          <member def="public virtual void WriteTo(TextWriter writer)" />
        </members>
        <type def="public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode : SyntaxNode, IMessageSerializable">
          <members>
            <member def="public override string Language { get; }" />
            <member def="protected override SyntaxTree SyntaxTreeCore { get; }" />
            <member def="public abstract void Accept(CSharpSyntaxVisitor visitor)" />
            <member def="public abstract TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
            <member def="public static SyntaxNode DeserializeFrom(Stream stream, CancellationToken cancellationToken = default)" />
            <member def="protected override bool EquivalentToCore(SyntaxNode other)" />
            <member def="public SyntaxToken FindToken(int position, bool findInsideTrivia = false)" />
            <member def="public SyntaxTrivia FindTrivia(int position, bool findInsideTrivia = false)" />
            <member def="public SyntaxTrivia FindTrivia(int position, Func&lt;SyntaxTrivia, bool&gt; stepInto)" />
            <member def="public IEnumerable&lt;Diagnostic&gt; GetDiagnostics()" />
            <member def="public DirectiveTriviaSyntax GetFirstDirective(Func&lt;DirectiveTriviaSyntax, bool&gt; predicate = null)" />
            <member def="public SyntaxToken GetFirstToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false)" />
            <member def="public DirectiveTriviaSyntax GetLastDirective(Func&lt;DirectiveTriviaSyntax, bool&gt; predicate = null)" />
            <member def="public SyntaxToken GetLastToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false)" />
            <member def="public SyntaxTriviaList GetLeadingTrivia()" />
            <member def="public Location GetLocation()" />
            <member def="public SyntaxTriviaList GetTrailingTrivia()" />
            <member def="protected internal override SyntaxNode InsertNodesInListCore(SyntaxNode nodeInList, IEnumerable&lt;SyntaxNode&gt; nodesToInsert, bool insertBefore)" />
            <member def="protected internal override SyntaxNode InsertTokensInListCore(SyntaxToken originalToken, IEnumerable&lt;SyntaxToken&gt; newTokens, bool insertBefore)" />
            <member def="protected internal override SyntaxNode InsertTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable&lt;SyntaxTrivia&gt; newTrivia, bool insertBefore)" />
            <member def="protected override bool IsEquivalentToCore(SyntaxNode node, bool topLevel = false)" />
            <member def="public SyntaxKind Kind()" />
            <member def="protected internal override SyntaxNode NormalizeWhitespaceCore(string indentation, string eol, bool elasticTrivia)" />
            <member def="protected internal override SyntaxNode RemoveNodesCore(IEnumerable&lt;SyntaxNode&gt; nodes, SyntaxRemoveOptions options)" />
            <member def="protected internal override SyntaxNode ReplaceCore&lt;TNode&gt;(IEnumerable&lt;TNode&gt; nodes = null, Func&lt;TNode, TNode, SyntaxNode&gt; computeReplacementNode = null, IEnumerable&lt;SyntaxToken&gt; tokens = null, Func&lt;SyntaxToken, SyntaxToken, SyntaxToken&gt; computeReplacementToken = null, IEnumerable&lt;SyntaxTrivia&gt; trivia = null, Func&lt;SyntaxTrivia, SyntaxTrivia, SyntaxTrivia&gt; computeReplacementTrivia = null) where TNode : SyntaxNode" />
            <member def="protected internal override SyntaxNode ReplaceNodeInListCore(SyntaxNode originalNode, IEnumerable&lt;SyntaxNode&gt; replacementNodes)" />
            <member def="protected internal override SyntaxNode ReplaceTokenInListCore(SyntaxToken originalToken, IEnumerable&lt;SyntaxToken&gt; newTokens)" />
            <member def="protected internal override SyntaxNode ReplaceTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable&lt;SyntaxTrivia&gt; newTrivia)" />
          </members>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
              <member def="public BlockSyntax Body { get; }" />
              <member def="public ArrowExpressionClauseSyntax ExpressionBody { get; }" />
              <member def="public SyntaxToken Keyword { get; }" />
              <member def="public SyntaxTokenList Modifiers { get; }" />
              <member def="public SyntaxToken SemicolonToken { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public AccessorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
              <member def="public AccessorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)" />
              <member def="public AccessorDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
              <member def="public AccessorDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken)" />
              <member def="public AccessorDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
              <member def="public AccessorDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
              <member def="public AccessorDeclarationSyntax WithBody(BlockSyntax body)" />
              <member def="public AccessorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)" />
              <member def="public AccessorDeclarationSyntax WithKeyword(SyntaxToken keyword)" />
              <member def="public AccessorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
              <member def="public AccessorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxList&lt;AccessorDeclarationSyntax&gt; Accessors { get; }" />
              <member def="public SyntaxToken CloseBraceToken { get; }" />
              <member def="public SyntaxToken OpenBraceToken { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public AccessorListSyntax AddAccessors(params AccessorDeclarationSyntax[] items)" />
              <member def="public AccessorListSyntax Update(SyntaxToken openBraceToken, SyntaxList&lt;AccessorDeclarationSyntax&gt; accessors, SyntaxToken closeBraceToken)" />
              <member def="public AccessorListSyntax WithAccessors(SyntaxList&lt;AccessorDeclarationSyntax&gt; accessors)" />
              <member def="public AccessorListSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)" />
              <member def="public AccessorListSyntax WithOpenBraceToken(SyntaxToken openBraceToken)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax : CSharpSyntaxNode">
            <members>
              <member def="public ExpressionSyntax Expression { get; }" />
              <member def="public NameEqualsSyntax NameEquals { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public AnonymousObjectMemberDeclaratorSyntax Update(NameEqualsSyntax nameEquals, ExpressionSyntax expression)" />
              <member def="public AnonymousObjectMemberDeclaratorSyntax WithExpression(ExpressionSyntax expression)" />
              <member def="public AnonymousObjectMemberDeclaratorSyntax WithNameEquals(NameEqualsSyntax nameEquals)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax : CSharpSyntaxNode">
            <members>
              <member def="public ExpressionSyntax Expression { get; }" />
              <member def="public NameColonSyntax NameColon { get; }" />
              <member def="public SyntaxToken RefOrOutKeyword { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public ArgumentSyntax Update(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)" />
              <member def="public ArgumentSyntax WithExpression(ExpressionSyntax expression)" />
              <member def="public ArgumentSyntax WithNameColon(NameColonSyntax nameColon)" />
              <member def="public ArgumentSyntax WithRefOrOutKeyword(SyntaxToken refOrOutKeyword)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken CloseBracketToken { get; }" />
              <member def="public SyntaxToken OpenBracketToken { get; }" />
              <member def="public int Rank { get; }" />
              <member def="public SeparatedSyntaxList&lt;ExpressionSyntax&gt; Sizes { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public ArrayRankSpecifierSyntax AddSizes(params ExpressionSyntax[] items)" />
              <member def="public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList&lt;ExpressionSyntax&gt; sizes, SyntaxToken closeBracketToken)" />
              <member def="public ArrayRankSpecifierSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)" />
              <member def="public ArrayRankSpecifierSyntax WithOpenBracketToken(SyntaxToken openBracketToken)" />
              <member def="public ArrayRankSpecifierSyntax WithSizes(SeparatedSyntaxList&lt;ExpressionSyntax&gt; sizes)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken ArrowToken { get; }" />
              <member def="public ExpressionSyntax Expression { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public ArrowExpressionClauseSyntax Update(SyntaxToken arrowToken, ExpressionSyntax expression)" />
              <member def="public ArrowExpressionClauseSyntax WithArrowToken(SyntaxToken arrowToken)" />
              <member def="public ArrowExpressionClauseSyntax WithExpression(ExpressionSyntax expression)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SeparatedSyntaxList&lt;AttributeArgumentSyntax&gt; Arguments { get; }" />
              <member def="public SyntaxToken CloseParenToken { get; }" />
              <member def="public SyntaxToken OpenParenToken { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public AttributeArgumentListSyntax AddArguments(params AttributeArgumentSyntax[] items)" />
              <member def="public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList&lt;AttributeArgumentSyntax&gt; arguments, SyntaxToken closeParenToken)" />
              <member def="public AttributeArgumentListSyntax WithArguments(SeparatedSyntaxList&lt;AttributeArgumentSyntax&gt; arguments)" />
              <member def="public AttributeArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
              <member def="public AttributeArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax : CSharpSyntaxNode">
            <members>
              <member def="public ExpressionSyntax Expression { get; }" />
              <member def="public NameColonSyntax NameColon { get; }" />
              <member def="public NameEqualsSyntax NameEquals { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public AttributeArgumentSyntax Update(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)" />
              <member def="public AttributeArgumentSyntax WithExpression(ExpressionSyntax expression)" />
              <member def="public AttributeArgumentSyntax WithNameColon(NameColonSyntax nameColon)" />
              <member def="public AttributeArgumentSyntax WithNameEquals(NameEqualsSyntax nameEquals)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SeparatedSyntaxList&lt;AttributeSyntax&gt; Attributes { get; }" />
              <member def="public SyntaxToken CloseBracketToken { get; }" />
              <member def="public SyntaxToken OpenBracketToken { get; }" />
              <member def="public AttributeTargetSpecifierSyntax Target { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public AttributeListSyntax AddAttributes(params AttributeSyntax[] items)" />
              <member def="public AttributeListSyntax Update(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList&lt;AttributeSyntax&gt; attributes, SyntaxToken closeBracketToken)" />
              <member def="public AttributeListSyntax WithAttributes(SeparatedSyntaxList&lt;AttributeSyntax&gt; attributes)" />
              <member def="public AttributeListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)" />
              <member def="public AttributeListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)" />
              <member def="public AttributeListSyntax WithTarget(AttributeTargetSpecifierSyntax target)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax : CSharpSyntaxNode">
            <members>
              <member def="public AttributeArgumentListSyntax ArgumentList { get; }" />
              <member def="public NameSyntax Name { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public AttributeSyntax AddArgumentListArguments(params AttributeArgumentSyntax[] items)" />
              <member def="public AttributeSyntax Update(NameSyntax name, AttributeArgumentListSyntax argumentList)" />
              <member def="public AttributeSyntax WithArgumentList(AttributeArgumentListSyntax argumentList)" />
              <member def="public AttributeSyntax WithName(NameSyntax name)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken ColonToken { get; }" />
              <member def="public SyntaxToken Identifier { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public AttributeTargetSpecifierSyntax Update(SyntaxToken identifier, SyntaxToken colonToken)" />
              <member def="public AttributeTargetSpecifierSyntax WithColonToken(SyntaxToken colonToken)" />
              <member def="public AttributeTargetSpecifierSyntax WithIdentifier(SyntaxToken identifier)" />
            </members>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax : CSharpSyntaxNode">
            <members>
              <member def="public abstract SeparatedSyntaxList&lt;ArgumentSyntax&gt; Arguments { get; }" />
            </members>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax : BaseArgumentListSyntax">
              <members>
                <member def="public override SeparatedSyntaxList&lt;ArgumentSyntax&gt; Arguments { get; }" />
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ArgumentListSyntax AddArguments(params ArgumentSyntax[] items)" />
                <member def="public ArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList&lt;ArgumentSyntax&gt; arguments, SyntaxToken closeParenToken)" />
                <member def="public ArgumentListSyntax WithArguments(SeparatedSyntaxList&lt;ArgumentSyntax&gt; arguments)" />
                <member def="public ArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public ArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax : BaseArgumentListSyntax">
              <members>
                <member def="public override SeparatedSyntaxList&lt;ArgumentSyntax&gt; Arguments { get; }" />
                <member def="public SyntaxToken CloseBracketToken { get; }" />
                <member def="public SyntaxToken OpenBracketToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public BracketedArgumentListSyntax AddArguments(params ArgumentSyntax[] items)" />
                <member def="public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList&lt;ArgumentSyntax&gt; arguments, SyntaxToken closeBracketToken)" />
                <member def="public BracketedArgumentListSyntax WithArguments(SeparatedSyntaxList&lt;ArgumentSyntax&gt; arguments)" />
                <member def="public BracketedArgumentListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)" />
                <member def="public BracketedArgumentListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)" />
              </members>
            </type>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax : CSharpSyntaxNode">
            <members>
              <member def="public abstract SeparatedSyntaxList&lt;CrefParameterSyntax&gt; Parameters { get; }" />
            </members>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax">
              <members>
                <member def="public SyntaxToken CloseBracketToken { get; }" />
                <member def="public SyntaxToken OpenBracketToken { get; }" />
                <member def="public override SeparatedSyntaxList&lt;CrefParameterSyntax&gt; Parameters { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public CrefBracketedParameterListSyntax AddParameters(params CrefParameterSyntax[] items)" />
                <member def="public CrefBracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList&lt;CrefParameterSyntax&gt; parameters, SyntaxToken closeBracketToken)" />
                <member def="public CrefBracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)" />
                <member def="public CrefBracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)" />
                <member def="public CrefBracketedParameterListSyntax WithParameters(SeparatedSyntaxList&lt;CrefParameterSyntax&gt; parameters)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax : BaseCrefParameterListSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public override SeparatedSyntaxList&lt;CrefParameterSyntax&gt; Parameters { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public CrefParameterListSyntax AddParameters(params CrefParameterSyntax[] items)" />
                <member def="public CrefParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList&lt;CrefParameterSyntax&gt; parameters, SyntaxToken closeParenToken)" />
                <member def="public CrefParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public CrefParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public CrefParameterListSyntax WithParameters(SeparatedSyntaxList&lt;CrefParameterSyntax&gt; parameters)" />
              </members>
            </type>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken ColonToken { get; }" />
              <member def="public SeparatedSyntaxList&lt;BaseTypeSyntax&gt; Types { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public BaseListSyntax AddTypes(params BaseTypeSyntax[] items)" />
              <member def="public BaseListSyntax Update(SyntaxToken colonToken, SeparatedSyntaxList&lt;BaseTypeSyntax&gt; types)" />
              <member def="public BaseListSyntax WithColonToken(SyntaxToken colonToken)" />
              <member def="public BaseListSyntax WithTypes(SeparatedSyntaxList&lt;BaseTypeSyntax&gt; types)" />
            </members>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax : CSharpSyntaxNode">
            <members>
              <member def="public abstract SeparatedSyntaxList&lt;ParameterSyntax&gt; Parameters { get; }" />
            </members>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax : BaseParameterListSyntax">
              <members>
                <member def="public SyntaxToken CloseBracketToken { get; }" />
                <member def="public SyntaxToken OpenBracketToken { get; }" />
                <member def="public override SeparatedSyntaxList&lt;ParameterSyntax&gt; Parameters { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public BracketedParameterListSyntax AddParameters(params ParameterSyntax[] items)" />
                <member def="public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList&lt;ParameterSyntax&gt; parameters, SyntaxToken closeBracketToken)" />
                <member def="public BracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)" />
                <member def="public BracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)" />
                <member def="public BracketedParameterListSyntax WithParameters(SeparatedSyntaxList&lt;ParameterSyntax&gt; parameters)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax : BaseParameterListSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public override SeparatedSyntaxList&lt;ParameterSyntax&gt; Parameters { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ParameterListSyntax AddParameters(params ParameterSyntax[] items)" />
                <member def="public ParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList&lt;ParameterSyntax&gt; parameters, SyntaxToken closeParenToken)" />
                <member def="public ParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public ParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public ParameterListSyntax WithParameters(SeparatedSyntaxList&lt;ParameterSyntax&gt; parameters)" />
              </members>
            </type>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax : CSharpSyntaxNode">
            <members>
              <member def="public abstract TypeSyntax Type { get; }" />
            </members>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax : BaseTypeSyntax">
              <members>
                <member def="public override TypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public SimpleBaseTypeSyntax Update(TypeSyntax type)" />
                <member def="public SimpleBaseTypeSyntax WithType(TypeSyntax type)" />
              </members>
            </type>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax : CSharpSyntaxNode">
            <members>
              <member def="public BlockSyntax Block { get; }" />
              <member def="public SyntaxToken CatchKeyword { get; }" />
              <member def="public CatchDeclarationSyntax Declaration { get; }" />
              <member def="public CatchFilterClauseSyntax Filter { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public CatchClauseSyntax AddBlockStatements(params StatementSyntax[] items)" />
              <member def="public CatchClauseSyntax Update(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)" />
              <member def="public CatchClauseSyntax WithBlock(BlockSyntax block)" />
              <member def="public CatchClauseSyntax WithCatchKeyword(SyntaxToken catchKeyword)" />
              <member def="public CatchClauseSyntax WithDeclaration(CatchDeclarationSyntax declaration)" />
              <member def="public CatchClauseSyntax WithFilter(CatchFilterClauseSyntax filter)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken CloseParenToken { get; }" />
              <member def="public SyntaxToken Identifier { get; }" />
              <member def="public SyntaxToken OpenParenToken { get; }" />
              <member def="public TypeSyntax Type { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public CatchDeclarationSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)" />
              <member def="public CatchDeclarationSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
              <member def="public CatchDeclarationSyntax WithIdentifier(SyntaxToken identifier)" />
              <member def="public CatchDeclarationSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
              <member def="public CatchDeclarationSyntax WithType(TypeSyntax type)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken CloseParenToken { get; }" />
              <member def="public ExpressionSyntax FilterExpression { get; }" />
              <member def="public SyntaxToken OpenParenToken { get; }" />
              <member def="public SyntaxToken WhenKeyword { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public CatchFilterClauseSyntax Update(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)" />
              <member def="public CatchFilterClauseSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
              <member def="public CatchFilterClauseSyntax WithFilterExpression(ExpressionSyntax filterExpression)" />
              <member def="public CatchFilterClauseSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
              <member def="public CatchFilterClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax : CSharpSyntaxNode, ICompilationUnitSyntax">
            <members>
              <member def="public SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
              <member def="public SyntaxToken EndOfFileToken { get; }" />
              <member def="public SyntaxList&lt;ExternAliasDirectiveSyntax&gt; Externs { get; }" />
              <member def="public SyntaxList&lt;MemberDeclarationSyntax&gt; Members { get; }" />
              <member def="public SyntaxList&lt;UsingDirectiveSyntax&gt; Usings { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public CompilationUnitSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
              <member def="public CompilationUnitSyntax AddExterns(params ExternAliasDirectiveSyntax[] items)" />
              <member def="public CompilationUnitSyntax AddMembers(params MemberDeclarationSyntax[] items)" />
              <member def="public CompilationUnitSyntax AddUsings(params UsingDirectiveSyntax[] items)" />
              <member def="public IList&lt;LoadDirectiveTriviaSyntax&gt; GetLoadDirectives()" />
              <member def="public IList&lt;ReferenceDirectiveTriviaSyntax&gt; GetReferenceDirectives()" />
              <member def="public CompilationUnitSyntax Update(SyntaxList&lt;ExternAliasDirectiveSyntax&gt; externs, SyntaxList&lt;UsingDirectiveSyntax&gt; usings, SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxList&lt;MemberDeclarationSyntax&gt; members, SyntaxToken endOfFileToken)" />
              <member def="public CompilationUnitSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
              <member def="public CompilationUnitSyntax WithEndOfFileToken(SyntaxToken endOfFileToken)" />
              <member def="public CompilationUnitSyntax WithExterns(SyntaxList&lt;ExternAliasDirectiveSyntax&gt; externs)" />
              <member def="public CompilationUnitSyntax WithMembers(SyntaxList&lt;MemberDeclarationSyntax&gt; members)" />
              <member def="public CompilationUnitSyntax WithUsings(SyntaxList&lt;UsingDirectiveSyntax&gt; usings)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax : CSharpSyntaxNode">
            <members>
              <member def="public ArgumentListSyntax ArgumentList { get; }" />
              <member def="public SyntaxToken ColonToken { get; }" />
              <member def="public SyntaxToken ThisOrBaseKeyword { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public ConstructorInitializerSyntax AddArgumentListArguments(params ArgumentSyntax[] items)" />
              <member def="public ConstructorInitializerSyntax Update(SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)" />
              <member def="public ConstructorInitializerSyntax WithArgumentList(ArgumentListSyntax argumentList)" />
              <member def="public ConstructorInitializerSyntax WithColonToken(SyntaxToken colonToken)" />
              <member def="public ConstructorInitializerSyntax WithThisOrBaseKeyword(SyntaxToken thisOrBaseKeyword)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken RefOrOutKeyword { get; }" />
              <member def="public TypeSyntax Type { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public CrefParameterSyntax Update(SyntaxToken refOrOutKeyword, TypeSyntax type)" />
              <member def="public CrefParameterSyntax WithRefOrOutKeyword(SyntaxToken refOrOutKeyword)" />
              <member def="public CrefParameterSyntax WithType(TypeSyntax type)" />
            </members>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax : CSharpSyntaxNode">
            <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax : CrefSyntax">
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax : MemberCrefSyntax">
                <members>
                  <member def="public SyntaxToken ImplicitOrExplicitKeyword { get; }" />
                  <member def="public SyntaxToken OperatorKeyword { get; }" />
                  <member def="public CrefParameterListSyntax Parameters { get; }" />
                  <member def="public TypeSyntax Type { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public ConversionOperatorMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)" />
                  <member def="public ConversionOperatorMemberCrefSyntax Update(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)" />
                  <member def="public ConversionOperatorMemberCrefSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword)" />
                  <member def="public ConversionOperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)" />
                  <member def="public ConversionOperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters)" />
                  <member def="public ConversionOperatorMemberCrefSyntax WithType(TypeSyntax type)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax : MemberCrefSyntax">
                <members>
                  <member def="public CrefBracketedParameterListSyntax Parameters { get; }" />
                  <member def="public SyntaxToken ThisKeyword { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public IndexerMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)" />
                  <member def="public IndexerMemberCrefSyntax Update(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)" />
                  <member def="public IndexerMemberCrefSyntax WithParameters(CrefBracketedParameterListSyntax parameters)" />
                  <member def="public IndexerMemberCrefSyntax WithThisKeyword(SyntaxToken thisKeyword)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax : MemberCrefSyntax">
                <members>
                  <member def="public TypeSyntax Name { get; }" />
                  <member def="public CrefParameterListSyntax Parameters { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public NameMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)" />
                  <member def="public NameMemberCrefSyntax Update(TypeSyntax name, CrefParameterListSyntax parameters)" />
                  <member def="public NameMemberCrefSyntax WithName(TypeSyntax name)" />
                  <member def="public NameMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax : MemberCrefSyntax">
                <members>
                  <member def="public SyntaxToken OperatorKeyword { get; }" />
                  <member def="public SyntaxToken OperatorToken { get; }" />
                  <member def="public CrefParameterListSyntax Parameters { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public OperatorMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)" />
                  <member def="public OperatorMemberCrefSyntax Update(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)" />
                  <member def="public OperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)" />
                  <member def="public OperatorMemberCrefSyntax WithOperatorToken(SyntaxToken operatorToken)" />
                  <member def="public OperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters)" />
                </members>
              </type>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax : CrefSyntax">
              <members>
                <member def="public TypeSyntax Container { get; }" />
                <member def="public SyntaxToken DotToken { get; }" />
                <member def="public MemberCrefSyntax Member { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public QualifiedCrefSyntax Update(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)" />
                <member def="public QualifiedCrefSyntax WithContainer(TypeSyntax container)" />
                <member def="public QualifiedCrefSyntax WithDotToken(SyntaxToken dotToken)" />
                <member def="public QualifiedCrefSyntax WithMember(MemberCrefSyntax member)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax : CrefSyntax">
              <members>
                <member def="public TypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public TypeCrefSyntax Update(TypeSyntax type)" />
                <member def="public TypeCrefSyntax WithType(TypeSyntax type)" />
              </members>
            </type>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken ElseKeyword { get; }" />
              <member def="public StatementSyntax Statement { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementSyntax statement)" />
              <member def="public ElseClauseSyntax WithElseKeyword(SyntaxToken elseKeyword)" />
              <member def="public ElseClauseSyntax WithStatement(StatementSyntax statement)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken EqualsToken { get; }" />
              <member def="public ExpressionSyntax Value { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, ExpressionSyntax value)" />
              <member def="public EqualsValueClauseSyntax WithEqualsToken(SyntaxToken equalsToken)" />
              <member def="public EqualsValueClauseSyntax WithValue(ExpressionSyntax value)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken DotToken { get; }" />
              <member def="public NameSyntax Name { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public ExplicitInterfaceSpecifierSyntax Update(NameSyntax name, SyntaxToken dotToken)" />
              <member def="public ExplicitInterfaceSpecifierSyntax WithDotToken(SyntaxToken dotToken)" />
              <member def="public ExplicitInterfaceSpecifierSyntax WithName(NameSyntax name)" />
            </members>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax : CSharpSyntaxNode">
            <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public abstract SyntaxToken AsyncKeyword { get; }" />
                <member def="public abstract CSharpSyntaxNode Body { get; }" />
              </members>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax : AnonymousFunctionExpressionSyntax">
                <members>
                  <member def="public override SyntaxToken AsyncKeyword { get; }" />
                  <member def="public BlockSyntax Block { get; }" />
                  <member def="public override CSharpSyntaxNode Body { get; }" />
                  <member def="public SyntaxToken DelegateKeyword { get; }" />
                  <member def="public ParameterListSyntax ParameterList { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public AnonymousMethodExpressionSyntax AddBlockStatements(params StatementSyntax[] items)" />
                  <member def="public AnonymousMethodExpressionSyntax AddParameterListParameters(params ParameterSyntax[] items)" />
                  <member def="public AnonymousMethodExpressionSyntax Update(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)" />
                  <member def="public AnonymousMethodExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword)" />
                  <member def="public AnonymousMethodExpressionSyntax WithBlock(BlockSyntax block)" />
                  <member def="public AnonymousMethodExpressionSyntax WithBody(CSharpSyntaxNode body)" />
                  <member def="public AnonymousMethodExpressionSyntax WithDelegateKeyword(SyntaxToken delegateKeyword)" />
                  <member def="public AnonymousMethodExpressionSyntax WithParameterList(ParameterListSyntax parameterList)" />
                </members>
              </type>
              <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax : AnonymousFunctionExpressionSyntax">
                <members>
                  <member def="public abstract SyntaxToken ArrowToken { get; }" />
                </members>
                <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax : LambdaExpressionSyntax">
                  <members>
                    <member def="public override SyntaxToken ArrowToken { get; }" />
                    <member def="public override SyntaxToken AsyncKeyword { get; }" />
                    <member def="public override CSharpSyntaxNode Body { get; }" />
                    <member def="public ParameterListSyntax ParameterList { get; }" />
                    <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                    <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                    <member def="public ParenthesizedLambdaExpressionSyntax AddParameterListParameters(params ParameterSyntax[] items)" />
                    <member def="public ParenthesizedLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body)" />
                    <member def="public ParenthesizedLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken)" />
                    <member def="public ParenthesizedLambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword)" />
                    <member def="public ParenthesizedLambdaExpressionSyntax WithBody(CSharpSyntaxNode body)" />
                    <member def="public ParenthesizedLambdaExpressionSyntax WithParameterList(ParameterListSyntax parameterList)" />
                  </members>
                </type>
                <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax : LambdaExpressionSyntax">
                  <members>
                    <member def="public override SyntaxToken ArrowToken { get; }" />
                    <member def="public override SyntaxToken AsyncKeyword { get; }" />
                    <member def="public override CSharpSyntaxNode Body { get; }" />
                    <member def="public ParameterSyntax Parameter { get; }" />
                    <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                    <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                    <member def="public SimpleLambdaExpressionSyntax AddParameterAttributeLists(params AttributeListSyntax[] items)" />
                    <member def="public SimpleLambdaExpressionSyntax AddParameterModifiers(params SyntaxToken[] items)" />
                    <member def="public SimpleLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body)" />
                    <member def="public SimpleLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken)" />
                    <member def="public SimpleLambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword)" />
                    <member def="public SimpleLambdaExpressionSyntax WithBody(CSharpSyntaxNode body)" />
                    <member def="public SimpleLambdaExpressionSyntax WithParameter(ParameterSyntax parameter)" />
                  </members>
                </type>
              </type>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken CloseBraceToken { get; }" />
                <member def="public SeparatedSyntaxList&lt;AnonymousObjectMemberDeclaratorSyntax&gt; Initializers { get; }" />
                <member def="public SyntaxToken NewKeyword { get; }" />
                <member def="public SyntaxToken OpenBraceToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public AnonymousObjectCreationExpressionSyntax AddInitializers(params AnonymousObjectMemberDeclaratorSyntax[] items)" />
                <member def="public AnonymousObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList&lt;AnonymousObjectMemberDeclaratorSyntax&gt; initializers, SyntaxToken closeBraceToken)" />
                <member def="public AnonymousObjectCreationExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)" />
                <member def="public AnonymousObjectCreationExpressionSyntax WithInitializers(SeparatedSyntaxList&lt;AnonymousObjectMemberDeclaratorSyntax&gt; initializers)" />
                <member def="public AnonymousObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)" />
                <member def="public AnonymousObjectCreationExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public InitializerExpressionSyntax Initializer { get; }" />
                <member def="public SyntaxToken NewKeyword { get; }" />
                <member def="public ArrayTypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ArrayCreationExpressionSyntax AddTypeRankSpecifiers(params ArrayRankSpecifierSyntax[] items)" />
                <member def="public ArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)" />
                <member def="public ArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)" />
                <member def="public ArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)" />
                <member def="public ArrayCreationExpressionSyntax WithType(ArrayTypeSyntax type)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public ExpressionSyntax Left { get; }" />
                <member def="public SyntaxToken OperatorToken { get; }" />
                <member def="public ExpressionSyntax Right { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public AssignmentExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
                <member def="public AssignmentExpressionSyntax WithLeft(ExpressionSyntax left)" />
                <member def="public AssignmentExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)" />
                <member def="public AssignmentExpressionSyntax WithRight(ExpressionSyntax right)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken AwaitKeyword { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public AwaitExpressionSyntax Update(SyntaxToken awaitKeyword, ExpressionSyntax expression)" />
                <member def="public AwaitExpressionSyntax WithAwaitKeyword(SyntaxToken awaitKeyword)" />
                <member def="public AwaitExpressionSyntax WithExpression(ExpressionSyntax expression)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public ExpressionSyntax Left { get; }" />
                <member def="public SyntaxToken OperatorToken { get; }" />
                <member def="public ExpressionSyntax Right { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
                <member def="public BinaryExpressionSyntax WithLeft(ExpressionSyntax left)" />
                <member def="public BinaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)" />
                <member def="public BinaryExpressionSyntax WithRight(ExpressionSyntax right)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public TypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public CastExpressionSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)" />
                <member def="public CastExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public CastExpressionSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public CastExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public CastExpressionSyntax WithType(TypeSyntax type)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken Keyword { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public CheckedExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)" />
                <member def="public CheckedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public CheckedExpressionSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public CheckedExpressionSyntax WithKeyword(SyntaxToken keyword)" />
                <member def="public CheckedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken OperatorToken { get; }" />
                <member def="public ExpressionSyntax WhenNotNull { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ConditionalAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)" />
                <member def="public ConditionalAccessExpressionSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public ConditionalAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)" />
                <member def="public ConditionalAccessExpressionSyntax WithWhenNotNull(ExpressionSyntax whenNotNull)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken ColonToken { get; }" />
                <member def="public ExpressionSyntax Condition { get; }" />
                <member def="public SyntaxToken QuestionToken { get; }" />
                <member def="public ExpressionSyntax WhenFalse { get; }" />
                <member def="public ExpressionSyntax WhenTrue { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ConditionalExpressionSyntax Update(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)" />
                <member def="public ConditionalExpressionSyntax WithColonToken(SyntaxToken colonToken)" />
                <member def="public ConditionalExpressionSyntax WithCondition(ExpressionSyntax condition)" />
                <member def="public ConditionalExpressionSyntax WithQuestionToken(SyntaxToken questionToken)" />
                <member def="public ConditionalExpressionSyntax WithWhenFalse(ExpressionSyntax whenFalse)" />
                <member def="public ConditionalExpressionSyntax WithWhenTrue(ExpressionSyntax whenTrue)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public VariableDesignationSyntax Designation { get; }" />
                <member def="public TypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public DeclarationExpressionSyntax Update(TypeSyntax type, VariableDesignationSyntax designation)" />
                <member def="public DeclarationExpressionSyntax WithDesignation(VariableDesignationSyntax designation)" />
                <member def="public DeclarationExpressionSyntax WithType(TypeSyntax type)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public SyntaxToken Keyword { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public TypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public DefaultExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)" />
                <member def="public DefaultExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public DefaultExpressionSyntax WithKeyword(SyntaxToken keyword)" />
                <member def="public DefaultExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public DefaultExpressionSyntax WithType(TypeSyntax type)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public BracketedArgumentListSyntax ArgumentList { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ElementAccessExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)" />
                <member def="public ElementAccessExpressionSyntax Update(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)" />
                <member def="public ElementAccessExpressionSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)" />
                <member def="public ElementAccessExpressionSyntax WithExpression(ExpressionSyntax expression)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public BracketedArgumentListSyntax ArgumentList { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ElementBindingExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)" />
                <member def="public ElementBindingExpressionSyntax Update(BracketedArgumentListSyntax argumentList)" />
                <member def="public ElementBindingExpressionSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken CloseBracketToken { get; }" />
                <member def="public SyntaxTokenList Commas { get; }" />
                <member def="public InitializerExpressionSyntax Initializer { get; }" />
                <member def="public SyntaxToken NewKeyword { get; }" />
                <member def="public SyntaxToken OpenBracketToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ImplicitArrayCreationExpressionSyntax AddCommas(params SyntaxToken[] items)" />
                <member def="public ImplicitArrayCreationExpressionSyntax AddInitializerExpressions(params ExpressionSyntax[] items)" />
                <member def="public ImplicitArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)" />
                <member def="public ImplicitArrayCreationExpressionSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)" />
                <member def="public ImplicitArrayCreationExpressionSyntax WithCommas(SyntaxTokenList commas)" />
                <member def="public ImplicitArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)" />
                <member def="public ImplicitArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)" />
                <member def="public ImplicitArrayCreationExpressionSyntax WithOpenBracketToken(SyntaxToken openBracketToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax : ExpressionSyntax">
              <members>
                <member def="public BracketedArgumentListSyntax ArgumentList { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ImplicitElementAccessSyntax AddArgumentListArguments(params ArgumentSyntax[] items)" />
                <member def="public ImplicitElementAccessSyntax Update(BracketedArgumentListSyntax argumentList)" />
                <member def="public ImplicitElementAccessSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken CloseBraceToken { get; }" />
                <member def="public SeparatedSyntaxList&lt;ExpressionSyntax&gt; Expressions { get; }" />
                <member def="public SyntaxToken OpenBraceToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public InitializerExpressionSyntax AddExpressions(params ExpressionSyntax[] items)" />
                <member def="public InitializerExpressionSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions, SyntaxToken closeBraceToken)" />
                <member def="public InitializerExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)" />
                <member def="public InitializerExpressionSyntax WithExpressions(SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions)" />
                <member def="public InitializerExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken)" />
              </members>
            </type>
            <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InstanceExpressionSyntax : ExpressionSyntax">
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax : InstanceExpressionSyntax">
                <members>
                  <member def="public SyntaxToken Token { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public BaseExpressionSyntax Update(SyntaxToken token)" />
                  <member def="public BaseExpressionSyntax WithToken(SyntaxToken token)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax : InstanceExpressionSyntax">
                <members>
                  <member def="public SyntaxToken Token { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public ThisExpressionSyntax Update(SyntaxToken token)" />
                  <member def="public ThisExpressionSyntax WithToken(SyntaxToken token)" />
                </members>
              </type>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxList&lt;InterpolatedStringContentSyntax&gt; Contents { get; }" />
                <member def="public SyntaxToken StringEndToken { get; }" />
                <member def="public SyntaxToken StringStartToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public InterpolatedStringExpressionSyntax AddContents(params InterpolatedStringContentSyntax[] items)" />
                <member def="public InterpolatedStringExpressionSyntax Update(SyntaxToken stringStartToken, SyntaxList&lt;InterpolatedStringContentSyntax&gt; contents, SyntaxToken stringEndToken)" />
                <member def="public InterpolatedStringExpressionSyntax WithContents(SyntaxList&lt;InterpolatedStringContentSyntax&gt; contents)" />
                <member def="public InterpolatedStringExpressionSyntax WithStringEndToken(SyntaxToken stringEndToken)" />
                <member def="public InterpolatedStringExpressionSyntax WithStringStartToken(SyntaxToken stringStartToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public ArgumentListSyntax ArgumentList { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public InvocationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)" />
                <member def="public InvocationExpressionSyntax Update(ExpressionSyntax expression, ArgumentListSyntax argumentList)" />
                <member def="public InvocationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList)" />
                <member def="public InvocationExpressionSyntax WithExpression(ExpressionSyntax expression)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken IsKeyword { get; }" />
                <member def="public PatternSyntax Pattern { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public IsPatternExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)" />
                <member def="public IsPatternExpressionSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public IsPatternExpressionSyntax WithIsKeyword(SyntaxToken isKeyword)" />
                <member def="public IsPatternExpressionSyntax WithPattern(PatternSyntax pattern)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken Token { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public LiteralExpressionSyntax Update(SyntaxToken token)" />
                <member def="public LiteralExpressionSyntax WithToken(SyntaxToken token)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken Keyword { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public MakeRefExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)" />
                <member def="public MakeRefExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public MakeRefExpressionSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public MakeRefExpressionSyntax WithKeyword(SyntaxToken keyword)" />
                <member def="public MakeRefExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SimpleNameSyntax Name { get; }" />
                <member def="public SyntaxToken OperatorToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public MemberAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)" />
                <member def="public MemberAccessExpressionSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public MemberAccessExpressionSyntax WithName(SimpleNameSyntax name)" />
                <member def="public MemberAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SimpleNameSyntax Name { get; }" />
                <member def="public SyntaxToken OperatorToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public MemberBindingExpressionSyntax Update(SyntaxToken operatorToken, SimpleNameSyntax name)" />
                <member def="public MemberBindingExpressionSyntax WithName(SimpleNameSyntax name)" />
                <member def="public MemberBindingExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public ArgumentListSyntax ArgumentList { get; }" />
                <member def="public InitializerExpressionSyntax Initializer { get; }" />
                <member def="public SyntaxToken NewKeyword { get; }" />
                <member def="public TypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ObjectCreationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)" />
                <member def="public ObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)" />
                <member def="public ObjectCreationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList)" />
                <member def="public ObjectCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)" />
                <member def="public ObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)" />
                <member def="public ObjectCreationExpressionSyntax WithType(TypeSyntax type)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken OmittedArraySizeExpressionToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public OmittedArraySizeExpressionSyntax Update(SyntaxToken omittedArraySizeExpressionToken)" />
                <member def="public OmittedArraySizeExpressionSyntax WithOmittedArraySizeExpressionToken(SyntaxToken omittedArraySizeExpressionToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)" />
                <member def="public ParenthesizedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public ParenthesizedExpressionSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public ParenthesizedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public ExpressionSyntax Operand { get; }" />
                <member def="public SyntaxToken OperatorToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public PostfixUnaryExpressionSyntax Update(ExpressionSyntax operand, SyntaxToken operatorToken)" />
                <member def="public PostfixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand)" />
                <member def="public PostfixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public ExpressionSyntax Operand { get; }" />
                <member def="public SyntaxToken OperatorToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public PrefixUnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand)" />
                <member def="public PrefixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand)" />
                <member def="public PrefixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public QueryBodySyntax Body { get; }" />
                <member def="public FromClauseSyntax FromClause { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public QueryExpressionSyntax AddBodyClauses(params QueryClauseSyntax[] items)" />
                <member def="public QueryExpressionSyntax Update(FromClauseSyntax fromClause, QueryBodySyntax body)" />
                <member def="public QueryExpressionSyntax WithBody(QueryBodySyntax body)" />
                <member def="public QueryExpressionSyntax WithFromClause(FromClauseSyntax fromClause)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken RefKeyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public RefExpressionSyntax Update(SyntaxToken refKeyword, ExpressionSyntax expression)" />
                <member def="public RefExpressionSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public RefExpressionSyntax WithRefKeyword(SyntaxToken refKeyword)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken Keyword { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public RefTypeExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)" />
                <member def="public RefTypeExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public RefTypeExpressionSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public RefTypeExpressionSyntax WithKeyword(SyntaxToken keyword)" />
                <member def="public RefTypeExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public SyntaxToken Comma { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken Keyword { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public TypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public RefValueExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)" />
                <member def="public RefValueExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public RefValueExpressionSyntax WithComma(SyntaxToken comma)" />
                <member def="public RefValueExpressionSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public RefValueExpressionSyntax WithKeyword(SyntaxToken keyword)" />
                <member def="public RefValueExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public RefValueExpressionSyntax WithType(TypeSyntax type)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public SyntaxToken Keyword { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public TypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public SizeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)" />
                <member def="public SizeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public SizeOfExpressionSyntax WithKeyword(SyntaxToken keyword)" />
                <member def="public SizeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public SizeOfExpressionSyntax WithType(TypeSyntax type)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken StackAllocKeyword { get; }" />
                <member def="public TypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public StackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, TypeSyntax type)" />
                <member def="public StackAllocArrayCreationExpressionSyntax WithStackAllocKeyword(SyntaxToken stackAllocKeyword)" />
                <member def="public StackAllocArrayCreationExpressionSyntax WithType(TypeSyntax type)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken ThrowKeyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ThrowExpressionSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression)" />
                <member def="public ThrowExpressionSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public ThrowExpressionSyntax WithThrowKeyword(SyntaxToken throwKeyword)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SeparatedSyntaxList&lt;ArgumentSyntax&gt; Arguments { get; }" />
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public TupleExpressionSyntax AddArguments(params ArgumentSyntax[] items)" />
                <member def="public TupleExpressionSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList&lt;ArgumentSyntax&gt; arguments, SyntaxToken closeParenToken)" />
                <member def="public TupleExpressionSyntax WithArguments(SeparatedSyntaxList&lt;ArgumentSyntax&gt; arguments)" />
                <member def="public TupleExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public TupleExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax : ExpressionSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public SyntaxToken Keyword { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public TypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public TypeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)" />
                <member def="public TypeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public TypeOfExpressionSyntax WithKeyword(SyntaxToken keyword)" />
                <member def="public TypeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public TypeOfExpressionSyntax WithType(TypeSyntax type)" />
              </members>
            </type>
            <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax : ExpressionSyntax">
              <members>
                <member def="public bool IsVar { get; }" />
              </members>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax : TypeSyntax">
                <members>
                  <member def="public TypeSyntax ElementType { get; }" />
                  <member def="public SyntaxList&lt;ArrayRankSpecifierSyntax&gt; RankSpecifiers { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public ArrayTypeSyntax AddRankSpecifiers(params ArrayRankSpecifierSyntax[] items)" />
                  <member def="public ArrayTypeSyntax Update(TypeSyntax elementType, SyntaxList&lt;ArrayRankSpecifierSyntax&gt; rankSpecifiers)" />
                  <member def="public ArrayTypeSyntax WithElementType(TypeSyntax elementType)" />
                  <member def="public ArrayTypeSyntax WithRankSpecifiers(SyntaxList&lt;ArrayRankSpecifierSyntax&gt; rankSpecifiers)" />
                </members>
              </type>
              <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax : TypeSyntax">
                <members>
                  <member def="public int Arity { get; }" />
                </members>
                <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax : NameSyntax">
                  <members>
                    <member def="public IdentifierNameSyntax Alias { get; }" />
                    <member def="public SyntaxToken ColonColonToken { get; }" />
                    <member def="public SimpleNameSyntax Name { get; }" />
                    <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                    <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                    <member def="public AliasQualifiedNameSyntax Update(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)" />
                    <member def="public AliasQualifiedNameSyntax WithAlias(IdentifierNameSyntax alias)" />
                    <member def="public AliasQualifiedNameSyntax WithColonColonToken(SyntaxToken colonColonToken)" />
                    <member def="public AliasQualifiedNameSyntax WithName(SimpleNameSyntax name)" />
                  </members>
                </type>
                <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax : NameSyntax">
                  <members>
                    <member def="public SyntaxToken DotToken { get; }" />
                    <member def="public NameSyntax Left { get; }" />
                    <member def="public SimpleNameSyntax Right { get; }" />
                    <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                    <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                    <member def="public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)" />
                    <member def="public QualifiedNameSyntax WithDotToken(SyntaxToken dotToken)" />
                    <member def="public QualifiedNameSyntax WithLeft(NameSyntax left)" />
                    <member def="public QualifiedNameSyntax WithRight(SimpleNameSyntax right)" />
                  </members>
                </type>
                <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax : NameSyntax">
                  <members>
                    <member def="public abstract SyntaxToken Identifier { get; }" />
                  </members>
                  <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax : SimpleNameSyntax">
                    <members>
                      <member def="public override SyntaxToken Identifier { get; }" />
                      <member def="public bool IsUnboundGenericName { get; }" />
                      <member def="public TypeArgumentListSyntax TypeArgumentList { get; }" />
                      <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                      <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                      <member def="public GenericNameSyntax AddTypeArgumentListArguments(params TypeSyntax[] items)" />
                      <member def="public GenericNameSyntax Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)" />
                      <member def="public GenericNameSyntax WithIdentifier(SyntaxToken identifier)" />
                      <member def="public GenericNameSyntax WithTypeArgumentList(TypeArgumentListSyntax typeArgumentList)" />
                    </members>
                  </type>
                  <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax : SimpleNameSyntax">
                    <members>
                      <member def="public override SyntaxToken Identifier { get; }" />
                      <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                      <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                      <member def="public IdentifierNameSyntax Update(SyntaxToken identifier)" />
                      <member def="public IdentifierNameSyntax WithIdentifier(SyntaxToken identifier)" />
                    </members>
                  </type>
                </type>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax : TypeSyntax">
                <members>
                  <member def="public TypeSyntax ElementType { get; }" />
                  <member def="public SyntaxToken QuestionToken { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public NullableTypeSyntax Update(TypeSyntax elementType, SyntaxToken questionToken)" />
                  <member def="public NullableTypeSyntax WithElementType(TypeSyntax elementType)" />
                  <member def="public NullableTypeSyntax WithQuestionToken(SyntaxToken questionToken)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax : TypeSyntax">
                <members>
                  <member def="public SyntaxToken OmittedTypeArgumentToken { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public OmittedTypeArgumentSyntax Update(SyntaxToken omittedTypeArgumentToken)" />
                  <member def="public OmittedTypeArgumentSyntax WithOmittedTypeArgumentToken(SyntaxToken omittedTypeArgumentToken)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax : TypeSyntax">
                <members>
                  <member def="public SyntaxToken AsteriskToken { get; }" />
                  <member def="public TypeSyntax ElementType { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public PointerTypeSyntax Update(TypeSyntax elementType, SyntaxToken asteriskToken)" />
                  <member def="public PointerTypeSyntax WithAsteriskToken(SyntaxToken asteriskToken)" />
                  <member def="public PointerTypeSyntax WithElementType(TypeSyntax elementType)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax : TypeSyntax">
                <members>
                  <member def="public SyntaxToken Keyword { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public PredefinedTypeSyntax Update(SyntaxToken keyword)" />
                  <member def="public PredefinedTypeSyntax WithKeyword(SyntaxToken keyword)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax : TypeSyntax">
                <members>
                  <member def="public SyntaxToken RefKeyword { get; }" />
                  <member def="public TypeSyntax Type { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public RefTypeSyntax Update(SyntaxToken refKeyword, TypeSyntax type)" />
                  <member def="public RefTypeSyntax WithRefKeyword(SyntaxToken refKeyword)" />
                  <member def="public RefTypeSyntax WithType(TypeSyntax type)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax : TypeSyntax">
                <members>
                  <member def="public SyntaxToken CloseParenToken { get; }" />
                  <member def="public SeparatedSyntaxList&lt;TupleElementSyntax&gt; Elements { get; }" />
                  <member def="public SyntaxToken OpenParenToken { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public TupleTypeSyntax AddElements(params TupleElementSyntax[] items)" />
                  <member def="public TupleTypeSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList&lt;TupleElementSyntax&gt; elements, SyntaxToken closeParenToken)" />
                  <member def="public TupleTypeSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                  <member def="public TupleTypeSyntax WithElements(SeparatedSyntaxList&lt;TupleElementSyntax&gt; elements)" />
                  <member def="public TupleTypeSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                </members>
              </type>
            </type>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken AliasKeyword { get; }" />
              <member def="public SyntaxToken ExternKeyword { get; }" />
              <member def="public SyntaxToken Identifier { get; }" />
              <member def="public SyntaxToken SemicolonToken { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public ExternAliasDirectiveSyntax Update(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)" />
              <member def="public ExternAliasDirectiveSyntax WithAliasKeyword(SyntaxToken aliasKeyword)" />
              <member def="public ExternAliasDirectiveSyntax WithExternKeyword(SyntaxToken externKeyword)" />
              <member def="public ExternAliasDirectiveSyntax WithIdentifier(SyntaxToken identifier)" />
              <member def="public ExternAliasDirectiveSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax : CSharpSyntaxNode">
            <members>
              <member def="public BlockSyntax Block { get; }" />
              <member def="public SyntaxToken FinallyKeyword { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public FinallyClauseSyntax AddBlockStatements(params StatementSyntax[] items)" />
              <member def="public FinallyClauseSyntax Update(SyntaxToken finallyKeyword, BlockSyntax block)" />
              <member def="public FinallyClauseSyntax WithBlock(BlockSyntax block)" />
              <member def="public FinallyClauseSyntax WithFinallyKeyword(SyntaxToken finallyKeyword)" />
            </members>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax : CSharpSyntaxNode">
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax : InterpolatedStringContentSyntax">
              <members>
                <member def="public SyntaxToken TextToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public InterpolatedStringTextSyntax Update(SyntaxToken textToken)" />
                <member def="public InterpolatedStringTextSyntax WithTextToken(SyntaxToken textToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax : InterpolatedStringContentSyntax">
              <members>
                <member def="public InterpolationAlignmentClauseSyntax AlignmentClause { get; }" />
                <member def="public SyntaxToken CloseBraceToken { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public InterpolationFormatClauseSyntax FormatClause { get; }" />
                <member def="public SyntaxToken OpenBraceToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public InterpolationSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)" />
                <member def="public InterpolationSyntax WithAlignmentClause(InterpolationAlignmentClauseSyntax alignmentClause)" />
                <member def="public InterpolationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)" />
                <member def="public InterpolationSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public InterpolationSyntax WithFormatClause(InterpolationFormatClauseSyntax formatClause)" />
                <member def="public InterpolationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)" />
              </members>
            </type>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken CommaToken { get; }" />
              <member def="public ExpressionSyntax Value { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public InterpolationAlignmentClauseSyntax Update(SyntaxToken commaToken, ExpressionSyntax value)" />
              <member def="public InterpolationAlignmentClauseSyntax WithCommaToken(SyntaxToken commaToken)" />
              <member def="public InterpolationAlignmentClauseSyntax WithValue(ExpressionSyntax value)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken ColonToken { get; }" />
              <member def="public SyntaxToken FormatStringToken { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public InterpolationFormatClauseSyntax Update(SyntaxToken colonToken, SyntaxToken formatStringToken)" />
              <member def="public InterpolationFormatClauseSyntax WithColonToken(SyntaxToken colonToken)" />
              <member def="public InterpolationFormatClauseSyntax WithFormatStringToken(SyntaxToken formatStringToken)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken Identifier { get; }" />
              <member def="public SyntaxToken IntoKeyword { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public JoinIntoClauseSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier)" />
              <member def="public JoinIntoClauseSyntax WithIdentifier(SyntaxToken identifier)" />
              <member def="public JoinIntoClauseSyntax WithIntoKeyword(SyntaxToken intoKeyword)" />
            </members>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax : CSharpSyntaxNode">
            <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax : MemberDeclarationSyntax">
              <members>
                <member def="public abstract SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                <member def="public abstract VariableDeclarationSyntax Declaration { get; }" />
                <member def="public abstract SyntaxTokenList Modifiers { get; }" />
                <member def="public abstract SyntaxToken SemicolonToken { get; }" />
              </members>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax">
                <members>
                  <member def="public override SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                  <member def="public override VariableDeclarationSyntax Declaration { get; }" />
                  <member def="public SyntaxToken EventKeyword { get; }" />
                  <member def="public override SyntaxTokenList Modifiers { get; }" />
                  <member def="public override SyntaxToken SemicolonToken { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public EventFieldDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                  <member def="public EventFieldDeclarationSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)" />
                  <member def="public EventFieldDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
                  <member def="public EventFieldDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)" />
                  <member def="public EventFieldDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                  <member def="public EventFieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration)" />
                  <member def="public EventFieldDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword)" />
                  <member def="public EventFieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
                  <member def="public EventFieldDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax : BaseFieldDeclarationSyntax">
                <members>
                  <member def="public override SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                  <member def="public override VariableDeclarationSyntax Declaration { get; }" />
                  <member def="public override SyntaxTokenList Modifiers { get; }" />
                  <member def="public override SyntaxToken SemicolonToken { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public FieldDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                  <member def="public FieldDeclarationSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)" />
                  <member def="public FieldDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
                  <member def="public FieldDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)" />
                  <member def="public FieldDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                  <member def="public FieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration)" />
                  <member def="public FieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
                  <member def="public FieldDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                </members>
              </type>
            </type>
            <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax : MemberDeclarationSyntax">
              <members>
                <member def="public abstract SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                <member def="public abstract BlockSyntax Body { get; }" />
                <member def="public abstract ArrowExpressionClauseSyntax ExpressionBody { get; }" />
                <member def="public abstract SyntaxTokenList Modifiers { get; }" />
                <member def="public abstract ParameterListSyntax ParameterList { get; }" />
                <member def="public abstract SyntaxToken SemicolonToken { get; }" />
              </members>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax">
                <members>
                  <member def="public override SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                  <member def="public override BlockSyntax Body { get; }" />
                  <member def="public override ArrowExpressionClauseSyntax ExpressionBody { get; }" />
                  <member def="public SyntaxToken Identifier { get; }" />
                  <member def="public ConstructorInitializerSyntax Initializer { get; }" />
                  <member def="public override SyntaxTokenList Modifiers { get; }" />
                  <member def="public override ParameterListSyntax ParameterList { get; }" />
                  <member def="public override SyntaxToken SemicolonToken { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public ConstructorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                  <member def="public ConstructorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)" />
                  <member def="public ConstructorDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
                  <member def="public ConstructorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)" />
                  <member def="public ConstructorDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken)" />
                  <member def="public ConstructorDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
                  <member def="public ConstructorDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                  <member def="public ConstructorDeclarationSyntax WithBody(BlockSyntax body)" />
                  <member def="public ConstructorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)" />
                  <member def="public ConstructorDeclarationSyntax WithIdentifier(SyntaxToken identifier)" />
                  <member def="public ConstructorDeclarationSyntax WithInitializer(ConstructorInitializerSyntax initializer)" />
                  <member def="public ConstructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
                  <member def="public ConstructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)" />
                  <member def="public ConstructorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax">
                <members>
                  <member def="public override SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                  <member def="public override BlockSyntax Body { get; }" />
                  <member def="public override ArrowExpressionClauseSyntax ExpressionBody { get; }" />
                  <member def="public SyntaxToken ImplicitOrExplicitKeyword { get; }" />
                  <member def="public override SyntaxTokenList Modifiers { get; }" />
                  <member def="public SyntaxToken OperatorKeyword { get; }" />
                  <member def="public override ParameterListSyntax ParameterList { get; }" />
                  <member def="public override SyntaxToken SemicolonToken { get; }" />
                  <member def="public TypeSyntax Type { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public ConversionOperatorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                  <member def="public ConversionOperatorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)" />
                  <member def="public ConversionOperatorDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
                  <member def="public ConversionOperatorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)" />
                  <member def="public ConversionOperatorDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
                  <member def="public ConversionOperatorDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                  <member def="public ConversionOperatorDeclarationSyntax WithBody(BlockSyntax body)" />
                  <member def="public ConversionOperatorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)" />
                  <member def="public ConversionOperatorDeclarationSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword)" />
                  <member def="public ConversionOperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
                  <member def="public ConversionOperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)" />
                  <member def="public ConversionOperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)" />
                  <member def="public ConversionOperatorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                  <member def="public ConversionOperatorDeclarationSyntax WithType(TypeSyntax type)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax : BaseMethodDeclarationSyntax">
                <members>
                  <member def="public override SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                  <member def="public override BlockSyntax Body { get; }" />
                  <member def="public override ArrowExpressionClauseSyntax ExpressionBody { get; }" />
                  <member def="public SyntaxToken Identifier { get; }" />
                  <member def="public override SyntaxTokenList Modifiers { get; }" />
                  <member def="public override ParameterListSyntax ParameterList { get; }" />
                  <member def="public override SyntaxToken SemicolonToken { get; }" />
                  <member def="public SyntaxToken TildeToken { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public DestructorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                  <member def="public DestructorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)" />
                  <member def="public DestructorDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
                  <member def="public DestructorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)" />
                  <member def="public DestructorDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)" />
                  <member def="public DestructorDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
                  <member def="public DestructorDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                  <member def="public DestructorDeclarationSyntax WithBody(BlockSyntax body)" />
                  <member def="public DestructorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)" />
                  <member def="public DestructorDeclarationSyntax WithIdentifier(SyntaxToken identifier)" />
                  <member def="public DestructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
                  <member def="public DestructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)" />
                  <member def="public DestructorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                  <member def="public DestructorDeclarationSyntax WithTildeToken(SyntaxToken tildeToken)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax : BaseMethodDeclarationSyntax">
                <members>
                  <member def="public int Arity { get; }" />
                  <member def="public override SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                  <member def="public override BlockSyntax Body { get; }" />
                  <member def="public SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; ConstraintClauses { get; }" />
                  <member def="public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }" />
                  <member def="public override ArrowExpressionClauseSyntax ExpressionBody { get; }" />
                  <member def="public SyntaxToken Identifier { get; }" />
                  <member def="public override SyntaxTokenList Modifiers { get; }" />
                  <member def="public override ParameterListSyntax ParameterList { get; }" />
                  <member def="public TypeSyntax ReturnType { get; }" />
                  <member def="public override SyntaxToken SemicolonToken { get; }" />
                  <member def="public TypeParameterListSyntax TypeParameterList { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public MethodDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                  <member def="public MethodDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)" />
                  <member def="public MethodDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)" />
                  <member def="public MethodDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
                  <member def="public MethodDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)" />
                  <member def="public MethodDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)" />
                  <member def="public MethodDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
                  <member def="public MethodDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                  <member def="public MethodDeclarationSyntax WithBody(BlockSyntax body)" />
                  <member def="public MethodDeclarationSyntax WithConstraintClauses(SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses)" />
                  <member def="public MethodDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)" />
                  <member def="public MethodDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)" />
                  <member def="public MethodDeclarationSyntax WithIdentifier(SyntaxToken identifier)" />
                  <member def="public MethodDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
                  <member def="public MethodDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)" />
                  <member def="public MethodDeclarationSyntax WithReturnType(TypeSyntax returnType)" />
                  <member def="public MethodDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                  <member def="public MethodDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax : BaseMethodDeclarationSyntax">
                <members>
                  <member def="public override SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                  <member def="public override BlockSyntax Body { get; }" />
                  <member def="public override ArrowExpressionClauseSyntax ExpressionBody { get; }" />
                  <member def="public override SyntaxTokenList Modifiers { get; }" />
                  <member def="public SyntaxToken OperatorKeyword { get; }" />
                  <member def="public SyntaxToken OperatorToken { get; }" />
                  <member def="public override ParameterListSyntax ParameterList { get; }" />
                  <member def="public TypeSyntax ReturnType { get; }" />
                  <member def="public override SyntaxToken SemicolonToken { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public OperatorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                  <member def="public OperatorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)" />
                  <member def="public OperatorDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
                  <member def="public OperatorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)" />
                  <member def="public OperatorDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
                  <member def="public OperatorDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                  <member def="public OperatorDeclarationSyntax WithBody(BlockSyntax body)" />
                  <member def="public OperatorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)" />
                  <member def="public OperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
                  <member def="public OperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)" />
                  <member def="public OperatorDeclarationSyntax WithOperatorToken(SyntaxToken operatorToken)" />
                  <member def="public OperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)" />
                  <member def="public OperatorDeclarationSyntax WithReturnType(TypeSyntax returnType)" />
                  <member def="public OperatorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                </members>
              </type>
            </type>
            <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax : MemberDeclarationSyntax">
              <members>
                <member def="public abstract AccessorListSyntax AccessorList { get; }" />
                <member def="public abstract SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                <member def="public abstract ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }" />
                <member def="public abstract SyntaxTokenList Modifiers { get; }" />
                <member def="public abstract TypeSyntax Type { get; }" />
              </members>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax : BasePropertyDeclarationSyntax">
                <members>
                  <member def="public override AccessorListSyntax AccessorList { get; }" />
                  <member def="public override SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                  <member def="public SyntaxToken EventKeyword { get; }" />
                  <member def="public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }" />
                  <member def="public SyntaxToken Identifier { get; }" />
                  <member def="public override SyntaxTokenList Modifiers { get; }" />
                  <member def="public override TypeSyntax Type { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public EventDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items)" />
                  <member def="public EventDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                  <member def="public EventDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
                  <member def="public EventDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)" />
                  <member def="public EventDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList)" />
                  <member def="public EventDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                  <member def="public EventDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword)" />
                  <member def="public EventDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)" />
                  <member def="public EventDeclarationSyntax WithIdentifier(SyntaxToken identifier)" />
                  <member def="public EventDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
                  <member def="public EventDeclarationSyntax WithType(TypeSyntax type)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax : BasePropertyDeclarationSyntax">
                <members>
                  <member def="public override AccessorListSyntax AccessorList { get; }" />
                  <member def="public override SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                  <member def="public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }" />
                  <member def="public ArrowExpressionClauseSyntax ExpressionBody { get; }" />
                  <member def="public override SyntaxTokenList Modifiers { get; }" />
                  <member def="public BracketedParameterListSyntax ParameterList { get; }" />
                  <member def="public SyntaxToken Semicolon { get; }" />
                  <member def="public SyntaxToken SemicolonToken { get; }" />
                  <member def="public SyntaxToken ThisKeyword { get; }" />
                  <member def="public override TypeSyntax Type { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public IndexerDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items)" />
                  <member def="public IndexerDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                  <member def="public IndexerDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
                  <member def="public IndexerDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)" />
                  <member def="public IndexerDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
                  <member def="public IndexerDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList)" />
                  <member def="public IndexerDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                  <member def="public IndexerDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)" />
                  <member def="public IndexerDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)" />
                  <member def="public IndexerDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
                  <member def="public IndexerDeclarationSyntax WithParameterList(BracketedParameterListSyntax parameterList)" />
                  <member def="public IndexerDeclarationSyntax WithSemicolon(SyntaxToken semicolon)" />
                  <member def="public IndexerDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                  <member def="public IndexerDeclarationSyntax WithThisKeyword(SyntaxToken thisKeyword)" />
                  <member def="public IndexerDeclarationSyntax WithType(TypeSyntax type)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax : BasePropertyDeclarationSyntax">
                <members>
                  <member def="public override AccessorListSyntax AccessorList { get; }" />
                  <member def="public override SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                  <member def="public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }" />
                  <member def="public ArrowExpressionClauseSyntax ExpressionBody { get; }" />
                  <member def="public SyntaxToken Identifier { get; }" />
                  <member def="public EqualsValueClauseSyntax Initializer { get; }" />
                  <member def="public override SyntaxTokenList Modifiers { get; }" />
                  <member def="public SyntaxToken Semicolon { get; }" />
                  <member def="public SyntaxToken SemicolonToken { get; }" />
                  <member def="public override TypeSyntax Type { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public PropertyDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items)" />
                  <member def="public PropertyDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                  <member def="public PropertyDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
                  <member def="public PropertyDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)" />
                  <member def="public PropertyDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList)" />
                  <member def="public PropertyDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                  <member def="public PropertyDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)" />
                  <member def="public PropertyDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)" />
                  <member def="public PropertyDeclarationSyntax WithIdentifier(SyntaxToken identifier)" />
                  <member def="public PropertyDeclarationSyntax WithInitializer(EqualsValueClauseSyntax initializer)" />
                  <member def="public PropertyDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
                  <member def="public PropertyDeclarationSyntax WithSemicolon(SyntaxToken semicolon)" />
                  <member def="public PropertyDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                  <member def="public PropertyDeclarationSyntax WithType(TypeSyntax type)" />
                </members>
              </type>
            </type>
            <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax : MemberDeclarationSyntax">
              <members>
                <member def="public abstract SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                <member def="public abstract BaseListSyntax BaseList { get; }" />
                <member def="public abstract SyntaxToken CloseBraceToken { get; }" />
                <member def="public abstract SyntaxToken Identifier { get; }" />
                <member def="public abstract SyntaxTokenList Modifiers { get; }" />
                <member def="public abstract SyntaxToken OpenBraceToken { get; }" />
                <member def="public abstract SyntaxToken SemicolonToken { get; }" />
              </members>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax : BaseTypeDeclarationSyntax">
                <members>
                  <member def="public override SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                  <member def="public override BaseListSyntax BaseList { get; }" />
                  <member def="public override SyntaxToken CloseBraceToken { get; }" />
                  <member def="public SyntaxToken EnumKeyword { get; }" />
                  <member def="public override SyntaxToken Identifier { get; }" />
                  <member def="public SeparatedSyntaxList&lt;EnumMemberDeclarationSyntax&gt; Members { get; }" />
                  <member def="public override SyntaxTokenList Modifiers { get; }" />
                  <member def="public override SyntaxToken OpenBraceToken { get; }" />
                  <member def="public override SyntaxToken SemicolonToken { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public EnumDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                  <member def="public EnumDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items)" />
                  <member def="public EnumDeclarationSyntax AddMembers(params EnumMemberDeclarationSyntax[] items)" />
                  <member def="public EnumDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
                  <member def="public EnumDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList&lt;EnumMemberDeclarationSyntax&gt; members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)" />
                  <member def="public EnumDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                  <member def="public EnumDeclarationSyntax WithBaseList(BaseListSyntax baseList)" />
                  <member def="public EnumDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)" />
                  <member def="public EnumDeclarationSyntax WithEnumKeyword(SyntaxToken enumKeyword)" />
                  <member def="public EnumDeclarationSyntax WithIdentifier(SyntaxToken identifier)" />
                  <member def="public EnumDeclarationSyntax WithMembers(SeparatedSyntaxList&lt;EnumMemberDeclarationSyntax&gt; members)" />
                  <member def="public EnumDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
                  <member def="public EnumDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)" />
                  <member def="public EnumDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                </members>
              </type>
              <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax : BaseTypeDeclarationSyntax">
                <members>
                  <member def="public int Arity { get; }" />
                  <member def="public abstract SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; ConstraintClauses { get; }" />
                  <member def="public abstract SyntaxToken Keyword { get; }" />
                  <member def="public abstract SyntaxList&lt;MemberDeclarationSyntax&gt; Members { get; }" />
                  <member def="public abstract TypeParameterListSyntax TypeParameterList { get; }" />
                </members>
                <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax : TypeDeclarationSyntax">
                  <members>
                    <member def="public override SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                    <member def="public override BaseListSyntax BaseList { get; }" />
                    <member def="public override SyntaxToken CloseBraceToken { get; }" />
                    <member def="public override SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; ConstraintClauses { get; }" />
                    <member def="public override SyntaxToken Identifier { get; }" />
                    <member def="public override SyntaxToken Keyword { get; }" />
                    <member def="public override SyntaxList&lt;MemberDeclarationSyntax&gt; Members { get; }" />
                    <member def="public override SyntaxTokenList Modifiers { get; }" />
                    <member def="public override SyntaxToken OpenBraceToken { get; }" />
                    <member def="public override SyntaxToken SemicolonToken { get; }" />
                    <member def="public override TypeParameterListSyntax TypeParameterList { get; }" />
                    <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                    <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                    <member def="public ClassDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                    <member def="public ClassDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items)" />
                    <member def="public ClassDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)" />
                    <member def="public ClassDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)" />
                    <member def="public ClassDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
                    <member def="public ClassDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)" />
                    <member def="public ClassDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, SyntaxToken openBraceToken, SyntaxList&lt;MemberDeclarationSyntax&gt; members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)" />
                    <member def="public ClassDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                    <member def="public ClassDeclarationSyntax WithBaseList(BaseListSyntax baseList)" />
                    <member def="public ClassDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)" />
                    <member def="public ClassDeclarationSyntax WithConstraintClauses(SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses)" />
                    <member def="public ClassDeclarationSyntax WithIdentifier(SyntaxToken identifier)" />
                    <member def="public ClassDeclarationSyntax WithKeyword(SyntaxToken keyword)" />
                    <member def="public ClassDeclarationSyntax WithMembers(SyntaxList&lt;MemberDeclarationSyntax&gt; members)" />
                    <member def="public ClassDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
                    <member def="public ClassDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)" />
                    <member def="public ClassDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                    <member def="public ClassDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)" />
                  </members>
                </type>
                <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax : TypeDeclarationSyntax">
                  <members>
                    <member def="public override SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                    <member def="public override BaseListSyntax BaseList { get; }" />
                    <member def="public override SyntaxToken CloseBraceToken { get; }" />
                    <member def="public override SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; ConstraintClauses { get; }" />
                    <member def="public override SyntaxToken Identifier { get; }" />
                    <member def="public override SyntaxToken Keyword { get; }" />
                    <member def="public override SyntaxList&lt;MemberDeclarationSyntax&gt; Members { get; }" />
                    <member def="public override SyntaxTokenList Modifiers { get; }" />
                    <member def="public override SyntaxToken OpenBraceToken { get; }" />
                    <member def="public override SyntaxToken SemicolonToken { get; }" />
                    <member def="public override TypeParameterListSyntax TypeParameterList { get; }" />
                    <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                    <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                    <member def="public InterfaceDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                    <member def="public InterfaceDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items)" />
                    <member def="public InterfaceDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)" />
                    <member def="public InterfaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)" />
                    <member def="public InterfaceDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
                    <member def="public InterfaceDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)" />
                    <member def="public InterfaceDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, SyntaxToken openBraceToken, SyntaxList&lt;MemberDeclarationSyntax&gt; members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)" />
                    <member def="public InterfaceDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                    <member def="public InterfaceDeclarationSyntax WithBaseList(BaseListSyntax baseList)" />
                    <member def="public InterfaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)" />
                    <member def="public InterfaceDeclarationSyntax WithConstraintClauses(SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses)" />
                    <member def="public InterfaceDeclarationSyntax WithIdentifier(SyntaxToken identifier)" />
                    <member def="public InterfaceDeclarationSyntax WithKeyword(SyntaxToken keyword)" />
                    <member def="public InterfaceDeclarationSyntax WithMembers(SyntaxList&lt;MemberDeclarationSyntax&gt; members)" />
                    <member def="public InterfaceDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
                    <member def="public InterfaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)" />
                    <member def="public InterfaceDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                    <member def="public InterfaceDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)" />
                  </members>
                </type>
                <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax : TypeDeclarationSyntax">
                  <members>
                    <member def="public override SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                    <member def="public override BaseListSyntax BaseList { get; }" />
                    <member def="public override SyntaxToken CloseBraceToken { get; }" />
                    <member def="public override SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; ConstraintClauses { get; }" />
                    <member def="public override SyntaxToken Identifier { get; }" />
                    <member def="public override SyntaxToken Keyword { get; }" />
                    <member def="public override SyntaxList&lt;MemberDeclarationSyntax&gt; Members { get; }" />
                    <member def="public override SyntaxTokenList Modifiers { get; }" />
                    <member def="public override SyntaxToken OpenBraceToken { get; }" />
                    <member def="public override SyntaxToken SemicolonToken { get; }" />
                    <member def="public override TypeParameterListSyntax TypeParameterList { get; }" />
                    <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                    <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                    <member def="public StructDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                    <member def="public StructDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items)" />
                    <member def="public StructDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)" />
                    <member def="public StructDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)" />
                    <member def="public StructDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
                    <member def="public StructDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)" />
                    <member def="public StructDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, SyntaxToken openBraceToken, SyntaxList&lt;MemberDeclarationSyntax&gt; members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)" />
                    <member def="public StructDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                    <member def="public StructDeclarationSyntax WithBaseList(BaseListSyntax baseList)" />
                    <member def="public StructDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)" />
                    <member def="public StructDeclarationSyntax WithConstraintClauses(SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses)" />
                    <member def="public StructDeclarationSyntax WithIdentifier(SyntaxToken identifier)" />
                    <member def="public StructDeclarationSyntax WithKeyword(SyntaxToken keyword)" />
                    <member def="public StructDeclarationSyntax WithMembers(SyntaxList&lt;MemberDeclarationSyntax&gt; members)" />
                    <member def="public StructDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
                    <member def="public StructDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)" />
                    <member def="public StructDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                    <member def="public StructDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)" />
                  </members>
                </type>
              </type>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax : MemberDeclarationSyntax">
              <members>
                <member def="public int Arity { get; }" />
                <member def="public SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                <member def="public SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; ConstraintClauses { get; }" />
                <member def="public SyntaxToken DelegateKeyword { get; }" />
                <member def="public SyntaxToken Identifier { get; }" />
                <member def="public SyntaxTokenList Modifiers { get; }" />
                <member def="public ParameterListSyntax ParameterList { get; }" />
                <member def="public TypeSyntax ReturnType { get; }" />
                <member def="public SyntaxToken SemicolonToken { get; }" />
                <member def="public TypeParameterListSyntax TypeParameterList { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public DelegateDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                <member def="public DelegateDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)" />
                <member def="public DelegateDeclarationSyntax AddModifiers(params SyntaxToken[] items)" />
                <member def="public DelegateDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)" />
                <member def="public DelegateDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)" />
                <member def="public DelegateDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, SyntaxToken semicolonToken)" />
                <member def="public DelegateDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                <member def="public DelegateDeclarationSyntax WithConstraintClauses(SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses)" />
                <member def="public DelegateDeclarationSyntax WithDelegateKeyword(SyntaxToken delegateKeyword)" />
                <member def="public DelegateDeclarationSyntax WithIdentifier(SyntaxToken identifier)" />
                <member def="public DelegateDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)" />
                <member def="public DelegateDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)" />
                <member def="public DelegateDeclarationSyntax WithReturnType(TypeSyntax returnType)" />
                <member def="public DelegateDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                <member def="public DelegateDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax : MemberDeclarationSyntax">
              <members>
                <member def="public SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                <member def="public EqualsValueClauseSyntax EqualsValue { get; }" />
                <member def="public SyntaxToken Identifier { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public EnumMemberDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                <member def="public EnumMemberDeclarationSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)" />
                <member def="public EnumMemberDeclarationSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                <member def="public EnumMemberDeclarationSyntax WithEqualsValue(EqualsValueClauseSyntax equalsValue)" />
                <member def="public EnumMemberDeclarationSyntax WithIdentifier(SyntaxToken identifier)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax : MemberDeclarationSyntax">
              <members>
                <member def="public StatementSyntax Statement { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public GlobalStatementSyntax Update(StatementSyntax statement)" />
                <member def="public GlobalStatementSyntax WithStatement(StatementSyntax statement)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax : MemberDeclarationSyntax">
              <members>
                <member def="public SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
                <member def="public SyntaxTokenList Modifiers { get; }" />
                <member def="public TypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public IncompleteMemberSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
                <member def="public IncompleteMemberSyntax AddModifiers(params SyntaxToken[] items)" />
                <member def="public IncompleteMemberSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax type)" />
                <member def="public IncompleteMemberSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
                <member def="public IncompleteMemberSyntax WithModifiers(SyntaxTokenList modifiers)" />
                <member def="public IncompleteMemberSyntax WithType(TypeSyntax type)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax : MemberDeclarationSyntax">
              <members>
                <member def="public SyntaxToken CloseBraceToken { get; }" />
                <member def="public SyntaxList&lt;ExternAliasDirectiveSyntax&gt; Externs { get; }" />
                <member def="public SyntaxList&lt;MemberDeclarationSyntax&gt; Members { get; }" />
                <member def="public NameSyntax Name { get; }" />
                <member def="public SyntaxToken NamespaceKeyword { get; }" />
                <member def="public SyntaxToken OpenBraceToken { get; }" />
                <member def="public SyntaxToken SemicolonToken { get; }" />
                <member def="public SyntaxList&lt;UsingDirectiveSyntax&gt; Usings { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public NamespaceDeclarationSyntax AddExterns(params ExternAliasDirectiveSyntax[] items)" />
                <member def="public NamespaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)" />
                <member def="public NamespaceDeclarationSyntax AddUsings(params UsingDirectiveSyntax[] items)" />
                <member def="public NamespaceDeclarationSyntax Update(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList&lt;ExternAliasDirectiveSyntax&gt; externs, SyntaxList&lt;UsingDirectiveSyntax&gt; usings, SyntaxList&lt;MemberDeclarationSyntax&gt; members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)" />
                <member def="public NamespaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)" />
                <member def="public NamespaceDeclarationSyntax WithExterns(SyntaxList&lt;ExternAliasDirectiveSyntax&gt; externs)" />
                <member def="public NamespaceDeclarationSyntax WithMembers(SyntaxList&lt;MemberDeclarationSyntax&gt; members)" />
                <member def="public NamespaceDeclarationSyntax WithName(NameSyntax name)" />
                <member def="public NamespaceDeclarationSyntax WithNamespaceKeyword(SyntaxToken namespaceKeyword)" />
                <member def="public NamespaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)" />
                <member def="public NamespaceDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                <member def="public NamespaceDeclarationSyntax WithUsings(SyntaxList&lt;UsingDirectiveSyntax&gt; usings)" />
              </members>
            </type>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken ColonToken { get; }" />
              <member def="public IdentifierNameSyntax Name { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public NameColonSyntax Update(IdentifierNameSyntax name, SyntaxToken colonToken)" />
              <member def="public NameColonSyntax WithColonToken(SyntaxToken colonToken)" />
              <member def="public NameColonSyntax WithName(IdentifierNameSyntax name)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken EqualsToken { get; }" />
              <member def="public IdentifierNameSyntax Name { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public NameEqualsSyntax Update(IdentifierNameSyntax name, SyntaxToken equalsToken)" />
              <member def="public NameEqualsSyntax WithEqualsToken(SyntaxToken equalsToken)" />
              <member def="public NameEqualsSyntax WithName(IdentifierNameSyntax name)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken AscendingOrDescendingKeyword { get; }" />
              <member def="public ExpressionSyntax Expression { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public OrderingSyntax Update(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)" />
              <member def="public OrderingSyntax WithAscendingOrDescendingKeyword(SyntaxToken ascendingOrDescendingKeyword)" />
              <member def="public OrderingSyntax WithExpression(ExpressionSyntax expression)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
              <member def="public EqualsValueClauseSyntax Default { get; }" />
              <member def="public SyntaxToken Identifier { get; }" />
              <member def="public SyntaxTokenList Modifiers { get; }" />
              <member def="public TypeSyntax Type { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public ParameterSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
              <member def="public ParameterSyntax AddModifiers(params SyntaxToken[] items)" />
              <member def="public ParameterSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)" />
              <member def="public ParameterSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
              <member def="public ParameterSyntax WithDefault(EqualsValueClauseSyntax @default)" />
              <member def="public ParameterSyntax WithIdentifier(SyntaxToken identifier)" />
              <member def="public ParameterSyntax WithModifiers(SyntaxTokenList modifiers)" />
              <member def="public ParameterSyntax WithType(TypeSyntax type)" />
            </members>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax : CSharpSyntaxNode">
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax : PatternSyntax">
              <members>
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ConstantPatternSyntax Update(ExpressionSyntax expression)" />
                <member def="public ConstantPatternSyntax WithExpression(ExpressionSyntax expression)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax : PatternSyntax">
              <members>
                <member def="public VariableDesignationSyntax Designation { get; }" />
                <member def="public TypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public DeclarationPatternSyntax Update(TypeSyntax type, VariableDesignationSyntax designation)" />
                <member def="public DeclarationPatternSyntax WithDesignation(VariableDesignationSyntax designation)" />
                <member def="public DeclarationPatternSyntax WithType(TypeSyntax type)" />
              </members>
            </type>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxList&lt;QueryClauseSyntax&gt; Clauses { get; }" />
              <member def="public QueryContinuationSyntax Continuation { get; }" />
              <member def="public SelectOrGroupClauseSyntax SelectOrGroup { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public QueryBodySyntax AddClauses(params QueryClauseSyntax[] items)" />
              <member def="public QueryBodySyntax Update(SyntaxList&lt;QueryClauseSyntax&gt; clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)" />
              <member def="public QueryBodySyntax WithClauses(SyntaxList&lt;QueryClauseSyntax&gt; clauses)" />
              <member def="public QueryBodySyntax WithContinuation(QueryContinuationSyntax continuation)" />
              <member def="public QueryBodySyntax WithSelectOrGroup(SelectOrGroupClauseSyntax selectOrGroup)" />
            </members>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax : CSharpSyntaxNode">
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax : QueryClauseSyntax">
              <members>
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken FromKeyword { get; }" />
                <member def="public SyntaxToken Identifier { get; }" />
                <member def="public SyntaxToken InKeyword { get; }" />
                <member def="public TypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public FromClauseSyntax Update(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)" />
                <member def="public FromClauseSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public FromClauseSyntax WithFromKeyword(SyntaxToken fromKeyword)" />
                <member def="public FromClauseSyntax WithIdentifier(SyntaxToken identifier)" />
                <member def="public FromClauseSyntax WithInKeyword(SyntaxToken inKeyword)" />
                <member def="public FromClauseSyntax WithType(TypeSyntax type)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax : QueryClauseSyntax">
              <members>
                <member def="public SyntaxToken EqualsKeyword { get; }" />
                <member def="public SyntaxToken Identifier { get; }" />
                <member def="public ExpressionSyntax InExpression { get; }" />
                <member def="public SyntaxToken InKeyword { get; }" />
                <member def="public JoinIntoClauseSyntax Into { get; }" />
                <member def="public SyntaxToken JoinKeyword { get; }" />
                <member def="public ExpressionSyntax LeftExpression { get; }" />
                <member def="public SyntaxToken OnKeyword { get; }" />
                <member def="public ExpressionSyntax RightExpression { get; }" />
                <member def="public TypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public JoinClauseSyntax Update(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)" />
                <member def="public JoinClauseSyntax WithEqualsKeyword(SyntaxToken equalsKeyword)" />
                <member def="public JoinClauseSyntax WithIdentifier(SyntaxToken identifier)" />
                <member def="public JoinClauseSyntax WithInExpression(ExpressionSyntax inExpression)" />
                <member def="public JoinClauseSyntax WithInKeyword(SyntaxToken inKeyword)" />
                <member def="public JoinClauseSyntax WithInto(JoinIntoClauseSyntax into)" />
                <member def="public JoinClauseSyntax WithJoinKeyword(SyntaxToken joinKeyword)" />
                <member def="public JoinClauseSyntax WithLeftExpression(ExpressionSyntax leftExpression)" />
                <member def="public JoinClauseSyntax WithOnKeyword(SyntaxToken onKeyword)" />
                <member def="public JoinClauseSyntax WithRightExpression(ExpressionSyntax rightExpression)" />
                <member def="public JoinClauseSyntax WithType(TypeSyntax type)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax : QueryClauseSyntax">
              <members>
                <member def="public SyntaxToken EqualsToken { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken Identifier { get; }" />
                <member def="public SyntaxToken LetKeyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public LetClauseSyntax Update(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)" />
                <member def="public LetClauseSyntax WithEqualsToken(SyntaxToken equalsToken)" />
                <member def="public LetClauseSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public LetClauseSyntax WithIdentifier(SyntaxToken identifier)" />
                <member def="public LetClauseSyntax WithLetKeyword(SyntaxToken letKeyword)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax : QueryClauseSyntax">
              <members>
                <member def="public SyntaxToken OrderByKeyword { get; }" />
                <member def="public SeparatedSyntaxList&lt;OrderingSyntax&gt; Orderings { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public OrderByClauseSyntax AddOrderings(params OrderingSyntax[] items)" />
                <member def="public OrderByClauseSyntax Update(SyntaxToken orderByKeyword, SeparatedSyntaxList&lt;OrderingSyntax&gt; orderings)" />
                <member def="public OrderByClauseSyntax WithOrderByKeyword(SyntaxToken orderByKeyword)" />
                <member def="public OrderByClauseSyntax WithOrderings(SeparatedSyntaxList&lt;OrderingSyntax&gt; orderings)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax : QueryClauseSyntax">
              <members>
                <member def="public ExpressionSyntax Condition { get; }" />
                <member def="public SyntaxToken WhereKeyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public WhereClauseSyntax Update(SyntaxToken whereKeyword, ExpressionSyntax condition)" />
                <member def="public WhereClauseSyntax WithCondition(ExpressionSyntax condition)" />
                <member def="public WhereClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword)" />
              </members>
            </type>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax : CSharpSyntaxNode">
            <members>
              <member def="public QueryBodySyntax Body { get; }" />
              <member def="public SyntaxToken Identifier { get; }" />
              <member def="public SyntaxToken IntoKeyword { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public QueryContinuationSyntax AddBodyClauses(params QueryClauseSyntax[] items)" />
              <member def="public QueryContinuationSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)" />
              <member def="public QueryContinuationSyntax WithBody(QueryBodySyntax body)" />
              <member def="public QueryContinuationSyntax WithIdentifier(SyntaxToken identifier)" />
              <member def="public QueryContinuationSyntax WithIntoKeyword(SyntaxToken intoKeyword)" />
            </members>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax : CSharpSyntaxNode">
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax : SelectOrGroupClauseSyntax">
              <members>
                <member def="public ExpressionSyntax ByExpression { get; }" />
                <member def="public SyntaxToken ByKeyword { get; }" />
                <member def="public ExpressionSyntax GroupExpression { get; }" />
                <member def="public SyntaxToken GroupKeyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public GroupClauseSyntax Update(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)" />
                <member def="public GroupClauseSyntax WithByExpression(ExpressionSyntax byExpression)" />
                <member def="public GroupClauseSyntax WithByKeyword(SyntaxToken byKeyword)" />
                <member def="public GroupClauseSyntax WithGroupExpression(ExpressionSyntax groupExpression)" />
                <member def="public GroupClauseSyntax WithGroupKeyword(SyntaxToken groupKeyword)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax : SelectOrGroupClauseSyntax">
              <members>
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken SelectKeyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public SelectClauseSyntax Update(SyntaxToken selectKeyword, ExpressionSyntax expression)" />
                <member def="public SelectClauseSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public SelectClauseSyntax WithSelectKeyword(SyntaxToken selectKeyword)" />
              </members>
            </type>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax : CSharpSyntaxNode">
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax : StatementSyntax">
              <members>
                <member def="public SyntaxToken CloseBraceToken { get; }" />
                <member def="public SyntaxToken OpenBraceToken { get; }" />
                <member def="public SyntaxList&lt;StatementSyntax&gt; Statements { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public BlockSyntax AddStatements(params StatementSyntax[] items)" />
                <member def="public BlockSyntax Update(SyntaxToken openBraceToken, SyntaxList&lt;StatementSyntax&gt; statements, SyntaxToken closeBraceToken)" />
                <member def="public BlockSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)" />
                <member def="public BlockSyntax WithOpenBraceToken(SyntaxToken openBraceToken)" />
                <member def="public BlockSyntax WithStatements(SyntaxList&lt;StatementSyntax&gt; statements)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax : StatementSyntax">
              <members>
                <member def="public SyntaxToken BreakKeyword { get; }" />
                <member def="public SyntaxToken SemicolonToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public BreakStatementSyntax Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken)" />
                <member def="public BreakStatementSyntax WithBreakKeyword(SyntaxToken breakKeyword)" />
                <member def="public BreakStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax : StatementSyntax">
              <members>
                <member def="public BlockSyntax Block { get; }" />
                <member def="public SyntaxToken Keyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public CheckedStatementSyntax AddBlockStatements(params StatementSyntax[] items)" />
                <member def="public CheckedStatementSyntax Update(SyntaxToken keyword, BlockSyntax block)" />
                <member def="public CheckedStatementSyntax WithBlock(BlockSyntax block)" />
                <member def="public CheckedStatementSyntax WithKeyword(SyntaxToken keyword)" />
              </members>
            </type>
            <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax : StatementSyntax">
              <members>
                <member def="public abstract SyntaxToken CloseParenToken { get; }" />
                <member def="public abstract ExpressionSyntax Expression { get; }" />
                <member def="public abstract SyntaxToken ForEachKeyword { get; }" />
                <member def="public abstract SyntaxToken InKeyword { get; }" />
                <member def="public abstract SyntaxToken OpenParenToken { get; }" />
                <member def="public abstract StatementSyntax Statement { get; }" />
              </members>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax : CommonForEachStatementSyntax">
                <members>
                  <member def="public override SyntaxToken CloseParenToken { get; }" />
                  <member def="public override ExpressionSyntax Expression { get; }" />
                  <member def="public override SyntaxToken ForEachKeyword { get; }" />
                  <member def="public SyntaxToken Identifier { get; }" />
                  <member def="public override SyntaxToken InKeyword { get; }" />
                  <member def="public override SyntaxToken OpenParenToken { get; }" />
                  <member def="public override StatementSyntax Statement { get; }" />
                  <member def="public TypeSyntax Type { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public ForEachStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)" />
                  <member def="public ForEachStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                  <member def="public ForEachStatementSyntax WithExpression(ExpressionSyntax expression)" />
                  <member def="public ForEachStatementSyntax WithForEachKeyword(SyntaxToken forEachKeyword)" />
                  <member def="public ForEachStatementSyntax WithIdentifier(SyntaxToken identifier)" />
                  <member def="public ForEachStatementSyntax WithInKeyword(SyntaxToken inKeyword)" />
                  <member def="public ForEachStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                  <member def="public ForEachStatementSyntax WithStatement(StatementSyntax statement)" />
                  <member def="public ForEachStatementSyntax WithType(TypeSyntax type)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax : CommonForEachStatementSyntax">
                <members>
                  <member def="public override SyntaxToken CloseParenToken { get; }" />
                  <member def="public override ExpressionSyntax Expression { get; }" />
                  <member def="public override SyntaxToken ForEachKeyword { get; }" />
                  <member def="public override SyntaxToken InKeyword { get; }" />
                  <member def="public override SyntaxToken OpenParenToken { get; }" />
                  <member def="public override StatementSyntax Statement { get; }" />
                  <member def="public ExpressionSyntax Variable { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public ForEachVariableStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)" />
                  <member def="public ForEachVariableStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                  <member def="public ForEachVariableStatementSyntax WithExpression(ExpressionSyntax expression)" />
                  <member def="public ForEachVariableStatementSyntax WithForEachKeyword(SyntaxToken forEachKeyword)" />
                  <member def="public ForEachVariableStatementSyntax WithInKeyword(SyntaxToken inKeyword)" />
                  <member def="public ForEachVariableStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                  <member def="public ForEachVariableStatementSyntax WithStatement(StatementSyntax statement)" />
                  <member def="public ForEachVariableStatementSyntax WithVariable(ExpressionSyntax variable)" />
                </members>
              </type>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax : StatementSyntax">
              <members>
                <member def="public SyntaxToken ContinueKeyword { get; }" />
                <member def="public SyntaxToken SemicolonToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ContinueStatementSyntax Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken)" />
                <member def="public ContinueStatementSyntax WithContinueKeyword(SyntaxToken continueKeyword)" />
                <member def="public ContinueStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax : StatementSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public ExpressionSyntax Condition { get; }" />
                <member def="public SyntaxToken DoKeyword { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public SyntaxToken SemicolonToken { get; }" />
                <member def="public StatementSyntax Statement { get; }" />
                <member def="public SyntaxToken WhileKeyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public DoStatementSyntax Update(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)" />
                <member def="public DoStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public DoStatementSyntax WithCondition(ExpressionSyntax condition)" />
                <member def="public DoStatementSyntax WithDoKeyword(SyntaxToken doKeyword)" />
                <member def="public DoStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public DoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                <member def="public DoStatementSyntax WithStatement(StatementSyntax statement)" />
                <member def="public DoStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax : StatementSyntax">
              <members>
                <member def="public SyntaxToken SemicolonToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public EmptyStatementSyntax Update(SyntaxToken semicolonToken)" />
                <member def="public EmptyStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax : StatementSyntax">
              <members>
                <member def="public bool AllowsAnyExpression { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken SemicolonToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ExpressionStatementSyntax Update(ExpressionSyntax expression, SyntaxToken semicolonToken)" />
                <member def="public ExpressionStatementSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public ExpressionStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax : StatementSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public VariableDeclarationSyntax Declaration { get; }" />
                <member def="public SyntaxToken FixedKeyword { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public StatementSyntax Statement { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public FixedStatementSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)" />
                <member def="public FixedStatementSyntax Update(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)" />
                <member def="public FixedStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public FixedStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)" />
                <member def="public FixedStatementSyntax WithFixedKeyword(SyntaxToken fixedKeyword)" />
                <member def="public FixedStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public FixedStatementSyntax WithStatement(StatementSyntax statement)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax : StatementSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public ExpressionSyntax Condition { get; }" />
                <member def="public VariableDeclarationSyntax Declaration { get; }" />
                <member def="public SyntaxToken FirstSemicolonToken { get; }" />
                <member def="public SyntaxToken ForKeyword { get; }" />
                <member def="public SeparatedSyntaxList&lt;ExpressionSyntax&gt; Incrementors { get; }" />
                <member def="public SeparatedSyntaxList&lt;ExpressionSyntax&gt; Initializers { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public SyntaxToken SecondSemicolonToken { get; }" />
                <member def="public StatementSyntax Statement { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ForStatementSyntax AddIncrementors(params ExpressionSyntax[] items)" />
                <member def="public ForStatementSyntax AddInitializers(params ExpressionSyntax[] items)" />
                <member def="public ForStatementSyntax Update(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList&lt;ExpressionSyntax&gt; initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList&lt;ExpressionSyntax&gt; incrementors, SyntaxToken closeParenToken, StatementSyntax statement)" />
                <member def="public ForStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public ForStatementSyntax WithCondition(ExpressionSyntax condition)" />
                <member def="public ForStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)" />
                <member def="public ForStatementSyntax WithFirstSemicolonToken(SyntaxToken firstSemicolonToken)" />
                <member def="public ForStatementSyntax WithForKeyword(SyntaxToken forKeyword)" />
                <member def="public ForStatementSyntax WithIncrementors(SeparatedSyntaxList&lt;ExpressionSyntax&gt; incrementors)" />
                <member def="public ForStatementSyntax WithInitializers(SeparatedSyntaxList&lt;ExpressionSyntax&gt; initializers)" />
                <member def="public ForStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public ForStatementSyntax WithSecondSemicolonToken(SyntaxToken secondSemicolonToken)" />
                <member def="public ForStatementSyntax WithStatement(StatementSyntax statement)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax : StatementSyntax">
              <members>
                <member def="public SyntaxToken CaseOrDefaultKeyword { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken GotoKeyword { get; }" />
                <member def="public SyntaxToken SemicolonToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public GotoStatementSyntax Update(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)" />
                <member def="public GotoStatementSyntax WithCaseOrDefaultKeyword(SyntaxToken caseOrDefaultKeyword)" />
                <member def="public GotoStatementSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public GotoStatementSyntax WithGotoKeyword(SyntaxToken gotoKeyword)" />
                <member def="public GotoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax : StatementSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public ExpressionSyntax Condition { get; }" />
                <member def="public ElseClauseSyntax Else { get; }" />
                <member def="public SyntaxToken IfKeyword { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public StatementSyntax Statement { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public IfStatementSyntax Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)" />
                <member def="public IfStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public IfStatementSyntax WithCondition(ExpressionSyntax condition)" />
                <member def="public IfStatementSyntax WithElse(ElseClauseSyntax @else)" />
                <member def="public IfStatementSyntax WithIfKeyword(SyntaxToken ifKeyword)" />
                <member def="public IfStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public IfStatementSyntax WithStatement(StatementSyntax statement)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax : StatementSyntax">
              <members>
                <member def="public SyntaxToken ColonToken { get; }" />
                <member def="public SyntaxToken Identifier { get; }" />
                <member def="public StatementSyntax Statement { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public LabeledStatementSyntax Update(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)" />
                <member def="public LabeledStatementSyntax WithColonToken(SyntaxToken colonToken)" />
                <member def="public LabeledStatementSyntax WithIdentifier(SyntaxToken identifier)" />
                <member def="public LabeledStatementSyntax WithStatement(StatementSyntax statement)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax : StatementSyntax">
              <members>
                <member def="public VariableDeclarationSyntax Declaration { get; }" />
                <member def="public bool IsConst { get; }" />
                <member def="public SyntaxTokenList Modifiers { get; }" />
                <member def="public SyntaxToken SemicolonToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public LocalDeclarationStatementSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)" />
                <member def="public LocalDeclarationStatementSyntax AddModifiers(params SyntaxToken[] items)" />
                <member def="public LocalDeclarationStatementSyntax Update(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)" />
                <member def="public LocalDeclarationStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)" />
                <member def="public LocalDeclarationStatementSyntax WithModifiers(SyntaxTokenList modifiers)" />
                <member def="public LocalDeclarationStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax : StatementSyntax">
              <members>
                <member def="public BlockSyntax Body { get; }" />
                <member def="public SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; ConstraintClauses { get; }" />
                <member def="public ArrowExpressionClauseSyntax ExpressionBody { get; }" />
                <member def="public SyntaxToken Identifier { get; }" />
                <member def="public SyntaxTokenList Modifiers { get; }" />
                <member def="public ParameterListSyntax ParameterList { get; }" />
                <member def="public TypeSyntax ReturnType { get; }" />
                <member def="public SyntaxToken SemicolonToken { get; }" />
                <member def="public TypeParameterListSyntax TypeParameterList { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public LocalFunctionStatementSyntax AddBodyStatements(params StatementSyntax[] items)" />
                <member def="public LocalFunctionStatementSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)" />
                <member def="public LocalFunctionStatementSyntax AddModifiers(params SyntaxToken[] items)" />
                <member def="public LocalFunctionStatementSyntax AddParameterListParameters(params ParameterSyntax[] items)" />
                <member def="public LocalFunctionStatementSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)" />
                <member def="public LocalFunctionStatementSyntax Update(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
                <member def="public LocalFunctionStatementSyntax WithBody(BlockSyntax body)" />
                <member def="public LocalFunctionStatementSyntax WithConstraintClauses(SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses)" />
                <member def="public LocalFunctionStatementSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)" />
                <member def="public LocalFunctionStatementSyntax WithIdentifier(SyntaxToken identifier)" />
                <member def="public LocalFunctionStatementSyntax WithModifiers(SyntaxTokenList modifiers)" />
                <member def="public LocalFunctionStatementSyntax WithParameterList(ParameterListSyntax parameterList)" />
                <member def="public LocalFunctionStatementSyntax WithReturnType(TypeSyntax returnType)" />
                <member def="public LocalFunctionStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                <member def="public LocalFunctionStatementSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax : StatementSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken LockKeyword { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public StatementSyntax Statement { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public LockStatementSyntax Update(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)" />
                <member def="public LockStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public LockStatementSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public LockStatementSyntax WithLockKeyword(SyntaxToken lockKeyword)" />
                <member def="public LockStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public LockStatementSyntax WithStatement(StatementSyntax statement)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax : StatementSyntax">
              <members>
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken ReturnKeyword { get; }" />
                <member def="public SyntaxToken SemicolonToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ReturnStatementSyntax Update(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)" />
                <member def="public ReturnStatementSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public ReturnStatementSyntax WithReturnKeyword(SyntaxToken returnKeyword)" />
                <member def="public ReturnStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax : StatementSyntax">
              <members>
                <member def="public SyntaxToken CloseBraceToken { get; }" />
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken OpenBraceToken { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public SyntaxList&lt;SwitchSectionSyntax&gt; Sections { get; }" />
                <member def="public SyntaxToken SwitchKeyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public SwitchStatementSyntax AddSections(params SwitchSectionSyntax[] items)" />
                <member def="public SwitchStatementSyntax Update(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList&lt;SwitchSectionSyntax&gt; sections, SyntaxToken closeBraceToken)" />
                <member def="public SwitchStatementSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)" />
                <member def="public SwitchStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public SwitchStatementSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public SwitchStatementSyntax WithOpenBraceToken(SyntaxToken openBraceToken)" />
                <member def="public SwitchStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public SwitchStatementSyntax WithSections(SyntaxList&lt;SwitchSectionSyntax&gt; sections)" />
                <member def="public SwitchStatementSyntax WithSwitchKeyword(SyntaxToken switchKeyword)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax : StatementSyntax">
              <members>
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken SemicolonToken { get; }" />
                <member def="public SyntaxToken ThrowKeyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ThrowStatementSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)" />
                <member def="public ThrowStatementSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public ThrowStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                <member def="public ThrowStatementSyntax WithThrowKeyword(SyntaxToken throwKeyword)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax : StatementSyntax">
              <members>
                <member def="public BlockSyntax Block { get; }" />
                <member def="public SyntaxList&lt;CatchClauseSyntax&gt; Catches { get; }" />
                <member def="public FinallyClauseSyntax Finally { get; }" />
                <member def="public SyntaxToken TryKeyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public TryStatementSyntax AddBlockStatements(params StatementSyntax[] items)" />
                <member def="public TryStatementSyntax AddCatches(params CatchClauseSyntax[] items)" />
                <member def="public TryStatementSyntax Update(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList&lt;CatchClauseSyntax&gt; catches, FinallyClauseSyntax @finally)" />
                <member def="public TryStatementSyntax WithBlock(BlockSyntax block)" />
                <member def="public TryStatementSyntax WithCatches(SyntaxList&lt;CatchClauseSyntax&gt; catches)" />
                <member def="public TryStatementSyntax WithFinally(FinallyClauseSyntax @finally)" />
                <member def="public TryStatementSyntax WithTryKeyword(SyntaxToken tryKeyword)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax : StatementSyntax">
              <members>
                <member def="public BlockSyntax Block { get; }" />
                <member def="public SyntaxToken UnsafeKeyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public UnsafeStatementSyntax AddBlockStatements(params StatementSyntax[] items)" />
                <member def="public UnsafeStatementSyntax Update(SyntaxToken unsafeKeyword, BlockSyntax block)" />
                <member def="public UnsafeStatementSyntax WithBlock(BlockSyntax block)" />
                <member def="public UnsafeStatementSyntax WithUnsafeKeyword(SyntaxToken unsafeKeyword)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax : StatementSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public VariableDeclarationSyntax Declaration { get; }" />
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public StatementSyntax Statement { get; }" />
                <member def="public SyntaxToken UsingKeyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public UsingStatementSyntax Update(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)" />
                <member def="public UsingStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public UsingStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)" />
                <member def="public UsingStatementSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public UsingStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public UsingStatementSyntax WithStatement(StatementSyntax statement)" />
                <member def="public UsingStatementSyntax WithUsingKeyword(SyntaxToken usingKeyword)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax : StatementSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public ExpressionSyntax Condition { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public StatementSyntax Statement { get; }" />
                <member def="public SyntaxToken WhileKeyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public WhileStatementSyntax Update(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)" />
                <member def="public WhileStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public WhileStatementSyntax WithCondition(ExpressionSyntax condition)" />
                <member def="public WhileStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public WhileStatementSyntax WithStatement(StatementSyntax statement)" />
                <member def="public WhileStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax : StatementSyntax">
              <members>
                <member def="public ExpressionSyntax Expression { get; }" />
                <member def="public SyntaxToken ReturnOrBreakKeyword { get; }" />
                <member def="public SyntaxToken SemicolonToken { get; }" />
                <member def="public SyntaxToken YieldKeyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public YieldStatementSyntax Update(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)" />
                <member def="public YieldStatementSyntax WithExpression(ExpressionSyntax expression)" />
                <member def="public YieldStatementSyntax WithReturnOrBreakKeyword(SyntaxToken returnOrBreakKeyword)" />
                <member def="public YieldStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
                <member def="public YieldStatementSyntax WithYieldKeyword(SyntaxToken yieldKeyword)" />
              </members>
            </type>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax : CSharpSyntaxNode, IStructuredTriviaSyntax">
            <members>
              <member def="public override SyntaxTrivia ParentTrivia { get; }" />
            </members>
            <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax : StructuredTriviaSyntax">
              <members>
                <member def="public SyntaxToken DirectiveNameToken { get; }" />
                <member def="public abstract SyntaxToken EndOfDirectiveToken { get; }" />
                <member def="public abstract SyntaxToken HashToken { get; }" />
                <member def="public abstract bool IsActive { get; }" />
                <member def="public DirectiveTriviaSyntax GetNextDirective(Func&lt;DirectiveTriviaSyntax, bool&gt; predicate = null)" />
                <member def="public DirectiveTriviaSyntax GetPreviousDirective(Func&lt;DirectiveTriviaSyntax, bool&gt; predicate = null)" />
                <member def="public List&lt;DirectiveTriviaSyntax&gt; GetRelatedDirectives()" />
              </members>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax : DirectiveTriviaSyntax">
                <members>
                  <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                  <member def="public override SyntaxToken HashToken { get; }" />
                  <member def="public SyntaxToken Identifier { get; }" />
                  <member def="public override bool IsActive { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public BadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)" />
                  <member def="public BadDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                  <member def="public BadDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                  <member def="public BadDirectiveTriviaSyntax WithIdentifier(SyntaxToken identifier)" />
                  <member def="public BadDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                </members>
              </type>
              <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BranchingDirectiveTriviaSyntax : DirectiveTriviaSyntax">
                <members>
                  <member def="public abstract bool BranchTaken { get; }" />
                </members>
                <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax">
                  <members>
                    <member def="public abstract ExpressionSyntax Condition { get; }" />
                    <member def="public abstract bool ConditionValue { get; }" />
                  </members>
                  <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax">
                    <members>
                      <member def="public override bool BranchTaken { get; }" />
                      <member def="public override ExpressionSyntax Condition { get; }" />
                      <member def="public override bool ConditionValue { get; }" />
                      <member def="public SyntaxToken ElifKeyword { get; }" />
                      <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                      <member def="public override SyntaxToken HashToken { get; }" />
                      <member def="public override bool IsActive { get; }" />
                      <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                      <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                      <member def="public ElifDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)" />
                      <member def="public ElifDirectiveTriviaSyntax WithBranchTaken(bool branchTaken)" />
                      <member def="public ElifDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition)" />
                      <member def="public ElifDirectiveTriviaSyntax WithConditionValue(bool conditionValue)" />
                      <member def="public ElifDirectiveTriviaSyntax WithElifKeyword(SyntaxToken elifKeyword)" />
                      <member def="public ElifDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                      <member def="public ElifDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                      <member def="public ElifDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                    </members>
                  </type>
                  <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax">
                    <members>
                      <member def="public override bool BranchTaken { get; }" />
                      <member def="public override ExpressionSyntax Condition { get; }" />
                      <member def="public override bool ConditionValue { get; }" />
                      <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                      <member def="public override SyntaxToken HashToken { get; }" />
                      <member def="public SyntaxToken IfKeyword { get; }" />
                      <member def="public override bool IsActive { get; }" />
                      <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                      <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                      <member def="public IfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)" />
                      <member def="public IfDirectiveTriviaSyntax WithBranchTaken(bool branchTaken)" />
                      <member def="public IfDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition)" />
                      <member def="public IfDirectiveTriviaSyntax WithConditionValue(bool conditionValue)" />
                      <member def="public IfDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                      <member def="public IfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                      <member def="public IfDirectiveTriviaSyntax WithIfKeyword(SyntaxToken ifKeyword)" />
                      <member def="public IfDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                    </members>
                  </type>
                </type>
                <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax">
                  <members>
                    <member def="public override bool BranchTaken { get; }" />
                    <member def="public SyntaxToken ElseKeyword { get; }" />
                    <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                    <member def="public override SyntaxToken HashToken { get; }" />
                    <member def="public override bool IsActive { get; }" />
                    <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                    <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                    <member def="public ElseDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)" />
                    <member def="public ElseDirectiveTriviaSyntax WithBranchTaken(bool branchTaken)" />
                    <member def="public ElseDirectiveTriviaSyntax WithElseKeyword(SyntaxToken elseKeyword)" />
                    <member def="public ElseDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                    <member def="public ElseDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                    <member def="public ElseDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                  </members>
                </type>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax : DirectiveTriviaSyntax">
                <members>
                  <member def="public SyntaxToken DefineKeyword { get; }" />
                  <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                  <member def="public override SyntaxToken HashToken { get; }" />
                  <member def="public override bool IsActive { get; }" />
                  <member def="public SyntaxToken Name { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public DefineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)" />
                  <member def="public DefineDirectiveTriviaSyntax WithDefineKeyword(SyntaxToken defineKeyword)" />
                  <member def="public DefineDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                  <member def="public DefineDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                  <member def="public DefineDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                  <member def="public DefineDirectiveTriviaSyntax WithName(SyntaxToken name)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax">
                <members>
                  <member def="public SyntaxToken EndIfKeyword { get; }" />
                  <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                  <member def="public override SyntaxToken HashToken { get; }" />
                  <member def="public override bool IsActive { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public EndIfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)" />
                  <member def="public EndIfDirectiveTriviaSyntax WithEndIfKeyword(SyntaxToken endIfKeyword)" />
                  <member def="public EndIfDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                  <member def="public EndIfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                  <member def="public EndIfDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax">
                <members>
                  <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                  <member def="public SyntaxToken EndRegionKeyword { get; }" />
                  <member def="public override SyntaxToken HashToken { get; }" />
                  <member def="public override bool IsActive { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public EndRegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)" />
                  <member def="public EndRegionDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                  <member def="public EndRegionDirectiveTriviaSyntax WithEndRegionKeyword(SyntaxToken endRegionKeyword)" />
                  <member def="public EndRegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                  <member def="public EndRegionDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax : DirectiveTriviaSyntax">
                <members>
                  <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                  <member def="public SyntaxToken ErrorKeyword { get; }" />
                  <member def="public override SyntaxToken HashToken { get; }" />
                  <member def="public override bool IsActive { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public ErrorDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)" />
                  <member def="public ErrorDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                  <member def="public ErrorDirectiveTriviaSyntax WithErrorKeyword(SyntaxToken errorKeyword)" />
                  <member def="public ErrorDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                  <member def="public ErrorDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax : DirectiveTriviaSyntax">
                <members>
                  <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                  <member def="public SyntaxToken File { get; }" />
                  <member def="public override SyntaxToken HashToken { get; }" />
                  <member def="public override bool IsActive { get; }" />
                  <member def="public SyntaxToken Line { get; }" />
                  <member def="public SyntaxToken LineKeyword { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public LineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)" />
                  <member def="public LineDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                  <member def="public LineDirectiveTriviaSyntax WithFile(SyntaxToken file)" />
                  <member def="public LineDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                  <member def="public LineDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                  <member def="public LineDirectiveTriviaSyntax WithLine(SyntaxToken line)" />
                  <member def="public LineDirectiveTriviaSyntax WithLineKeyword(SyntaxToken lineKeyword)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax : DirectiveTriviaSyntax">
                <members>
                  <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                  <member def="public SyntaxToken File { get; }" />
                  <member def="public override SyntaxToken HashToken { get; }" />
                  <member def="public override bool IsActive { get; }" />
                  <member def="public SyntaxToken LoadKeyword { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public LoadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)" />
                  <member def="public LoadDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                  <member def="public LoadDirectiveTriviaSyntax WithFile(SyntaxToken file)" />
                  <member def="public LoadDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                  <member def="public LoadDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                  <member def="public LoadDirectiveTriviaSyntax WithLoadKeyword(SyntaxToken loadKeyword)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax">
                <members>
                  <member def="public SyntaxToken Bytes { get; }" />
                  <member def="public SyntaxToken ChecksumKeyword { get; }" />
                  <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                  <member def="public SyntaxToken File { get; }" />
                  <member def="public SyntaxToken Guid { get; }" />
                  <member def="public override SyntaxToken HashToken { get; }" />
                  <member def="public override bool IsActive { get; }" />
                  <member def="public SyntaxToken PragmaKeyword { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public PragmaChecksumDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)" />
                  <member def="public PragmaChecksumDirectiveTriviaSyntax WithBytes(SyntaxToken bytes)" />
                  <member def="public PragmaChecksumDirectiveTriviaSyntax WithChecksumKeyword(SyntaxToken checksumKeyword)" />
                  <member def="public PragmaChecksumDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                  <member def="public PragmaChecksumDirectiveTriviaSyntax WithFile(SyntaxToken file)" />
                  <member def="public PragmaChecksumDirectiveTriviaSyntax WithGuid(SyntaxToken guid)" />
                  <member def="public PragmaChecksumDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                  <member def="public PragmaChecksumDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                  <member def="public PragmaChecksumDirectiveTriviaSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax">
                <members>
                  <member def="public SyntaxToken DisableOrRestoreKeyword { get; }" />
                  <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                  <member def="public SeparatedSyntaxList&lt;ExpressionSyntax&gt; ErrorCodes { get; }" />
                  <member def="public override SyntaxToken HashToken { get; }" />
                  <member def="public override bool IsActive { get; }" />
                  <member def="public SyntaxToken PragmaKeyword { get; }" />
                  <member def="public SyntaxToken WarningKeyword { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public PragmaWarningDirectiveTriviaSyntax AddErrorCodes(params ExpressionSyntax[] items)" />
                  <member def="public PragmaWarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList&lt;ExpressionSyntax&gt; errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)" />
                  <member def="public PragmaWarningDirectiveTriviaSyntax WithDisableOrRestoreKeyword(SyntaxToken disableOrRestoreKeyword)" />
                  <member def="public PragmaWarningDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                  <member def="public PragmaWarningDirectiveTriviaSyntax WithErrorCodes(SeparatedSyntaxList&lt;ExpressionSyntax&gt; errorCodes)" />
                  <member def="public PragmaWarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                  <member def="public PragmaWarningDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                  <member def="public PragmaWarningDirectiveTriviaSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword)" />
                  <member def="public PragmaWarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax">
                <members>
                  <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                  <member def="public SyntaxToken File { get; }" />
                  <member def="public override SyntaxToken HashToken { get; }" />
                  <member def="public override bool IsActive { get; }" />
                  <member def="public SyntaxToken ReferenceKeyword { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public ReferenceDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)" />
                  <member def="public ReferenceDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                  <member def="public ReferenceDirectiveTriviaSyntax WithFile(SyntaxToken file)" />
                  <member def="public ReferenceDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                  <member def="public ReferenceDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                  <member def="public ReferenceDirectiveTriviaSyntax WithReferenceKeyword(SyntaxToken referenceKeyword)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax">
                <members>
                  <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                  <member def="public override SyntaxToken HashToken { get; }" />
                  <member def="public override bool IsActive { get; }" />
                  <member def="public SyntaxToken RegionKeyword { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public RegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)" />
                  <member def="public RegionDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                  <member def="public RegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                  <member def="public RegionDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                  <member def="public RegionDirectiveTriviaSyntax WithRegionKeyword(SyntaxToken regionKeyword)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax : DirectiveTriviaSyntax">
                <members>
                  <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                  <member def="public SyntaxToken ExclamationToken { get; }" />
                  <member def="public override SyntaxToken HashToken { get; }" />
                  <member def="public override bool IsActive { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public ShebangDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)" />
                  <member def="public ShebangDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                  <member def="public ShebangDirectiveTriviaSyntax WithExclamationToken(SyntaxToken exclamationToken)" />
                  <member def="public ShebangDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                  <member def="public ShebangDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax : DirectiveTriviaSyntax">
                <members>
                  <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                  <member def="public override SyntaxToken HashToken { get; }" />
                  <member def="public override bool IsActive { get; }" />
                  <member def="public SyntaxToken Name { get; }" />
                  <member def="public SyntaxToken UndefKeyword { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public UndefDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)" />
                  <member def="public UndefDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                  <member def="public UndefDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                  <member def="public UndefDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                  <member def="public UndefDirectiveTriviaSyntax WithName(SyntaxToken name)" />
                  <member def="public UndefDirectiveTriviaSyntax WithUndefKeyword(SyntaxToken undefKeyword)" />
                </members>
              </type>
              <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax : DirectiveTriviaSyntax">
                <members>
                  <member def="public override SyntaxToken EndOfDirectiveToken { get; }" />
                  <member def="public override SyntaxToken HashToken { get; }" />
                  <member def="public override bool IsActive { get; }" />
                  <member def="public SyntaxToken WarningKeyword { get; }" />
                  <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                  <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                  <member def="public WarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)" />
                  <member def="public WarningDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)" />
                  <member def="public WarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)" />
                  <member def="public WarningDirectiveTriviaSyntax WithIsActive(bool isActive)" />
                  <member def="public WarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword)" />
                </members>
              </type>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax : StructuredTriviaSyntax">
              <members>
                <member def="public SyntaxList&lt;XmlNodeSyntax&gt; Content { get; }" />
                <member def="public SyntaxToken EndOfComment { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public DocumentationCommentTriviaSyntax AddContent(params XmlNodeSyntax[] items)" />
                <member def="public DocumentationCommentTriviaSyntax Update(SyntaxList&lt;XmlNodeSyntax&gt; content, SyntaxToken endOfComment)" />
                <member def="public DocumentationCommentTriviaSyntax WithContent(SyntaxList&lt;XmlNodeSyntax&gt; content)" />
                <member def="public DocumentationCommentTriviaSyntax WithEndOfComment(SyntaxToken endOfComment)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax : StructuredTriviaSyntax, ISkippedTokensTriviaSyntax">
              <members>
                <member def="public SyntaxTokenList Tokens { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public SkippedTokensTriviaSyntax AddTokens(params SyntaxToken[] items)" />
                <member def="public SkippedTokensTriviaSyntax Update(SyntaxTokenList tokens)" />
                <member def="public SkippedTokensTriviaSyntax WithTokens(SyntaxTokenList tokens)" />
              </members>
            </type>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax : CSharpSyntaxNode">
            <members>
              <member def="public abstract SyntaxToken ColonToken { get; }" />
              <member def="public abstract SyntaxToken Keyword { get; }" />
            </members>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax : SwitchLabelSyntax">
              <members>
                <member def="public override SyntaxToken ColonToken { get; }" />
                <member def="public override SyntaxToken Keyword { get; }" />
                <member def="public PatternSyntax Pattern { get; }" />
                <member def="public WhenClauseSyntax WhenClause { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public CasePatternSwitchLabelSyntax Update(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)" />
                <member def="public CasePatternSwitchLabelSyntax WithColonToken(SyntaxToken colonToken)" />
                <member def="public CasePatternSwitchLabelSyntax WithKeyword(SyntaxToken keyword)" />
                <member def="public CasePatternSwitchLabelSyntax WithPattern(PatternSyntax pattern)" />
                <member def="public CasePatternSwitchLabelSyntax WithWhenClause(WhenClauseSyntax whenClause)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax : SwitchLabelSyntax">
              <members>
                <member def="public override SyntaxToken ColonToken { get; }" />
                <member def="public override SyntaxToken Keyword { get; }" />
                <member def="public ExpressionSyntax Value { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public CaseSwitchLabelSyntax Update(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)" />
                <member def="public CaseSwitchLabelSyntax WithColonToken(SyntaxToken colonToken)" />
                <member def="public CaseSwitchLabelSyntax WithKeyword(SyntaxToken keyword)" />
                <member def="public CaseSwitchLabelSyntax WithValue(ExpressionSyntax value)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax : SwitchLabelSyntax">
              <members>
                <member def="public override SyntaxToken ColonToken { get; }" />
                <member def="public override SyntaxToken Keyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public DefaultSwitchLabelSyntax Update(SyntaxToken keyword, SyntaxToken colonToken)" />
                <member def="public DefaultSwitchLabelSyntax WithColonToken(SyntaxToken colonToken)" />
                <member def="public DefaultSwitchLabelSyntax WithKeyword(SyntaxToken keyword)" />
              </members>
            </type>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxList&lt;SwitchLabelSyntax&gt; Labels { get; }" />
              <member def="public SyntaxList&lt;StatementSyntax&gt; Statements { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public SwitchSectionSyntax AddLabels(params SwitchLabelSyntax[] items)" />
              <member def="public SwitchSectionSyntax AddStatements(params StatementSyntax[] items)" />
              <member def="public SwitchSectionSyntax Update(SyntaxList&lt;SwitchLabelSyntax&gt; labels, SyntaxList&lt;StatementSyntax&gt; statements)" />
              <member def="public SwitchSectionSyntax WithLabels(SyntaxList&lt;SwitchLabelSyntax&gt; labels)" />
              <member def="public SwitchSectionSyntax WithStatements(SyntaxList&lt;StatementSyntax&gt; statements)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken Identifier { get; }" />
              <member def="public TypeSyntax Type { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public TupleElementSyntax Update(TypeSyntax type, SyntaxToken identifier)" />
              <member def="public TupleElementSyntax WithIdentifier(SyntaxToken identifier)" />
              <member def="public TupleElementSyntax WithType(TypeSyntax type)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SeparatedSyntaxList&lt;TypeSyntax&gt; Arguments { get; }" />
              <member def="public SyntaxToken GreaterThanToken { get; }" />
              <member def="public SyntaxToken LessThanToken { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public TypeArgumentListSyntax AddArguments(params TypeSyntax[] items)" />
              <member def="public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList&lt;TypeSyntax&gt; arguments, SyntaxToken greaterThanToken)" />
              <member def="public TypeArgumentListSyntax WithArguments(SeparatedSyntaxList&lt;TypeSyntax&gt; arguments)" />
              <member def="public TypeArgumentListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)" />
              <member def="public TypeArgumentListSyntax WithLessThanToken(SyntaxToken lessThanToken)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken ColonToken { get; }" />
              <member def="public SeparatedSyntaxList&lt;TypeParameterConstraintSyntax&gt; Constraints { get; }" />
              <member def="public IdentifierNameSyntax Name { get; }" />
              <member def="public SyntaxToken WhereKeyword { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public TypeParameterConstraintClauseSyntax AddConstraints(params TypeParameterConstraintSyntax[] items)" />
              <member def="public TypeParameterConstraintClauseSyntax Update(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList&lt;TypeParameterConstraintSyntax&gt; constraints)" />
              <member def="public TypeParameterConstraintClauseSyntax WithColonToken(SyntaxToken colonToken)" />
              <member def="public TypeParameterConstraintClauseSyntax WithConstraints(SeparatedSyntaxList&lt;TypeParameterConstraintSyntax&gt; constraints)" />
              <member def="public TypeParameterConstraintClauseSyntax WithName(IdentifierNameSyntax name)" />
              <member def="public TypeParameterConstraintClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword)" />
            </members>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax : CSharpSyntaxNode">
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax">
              <members>
                <member def="public SyntaxToken ClassOrStructKeyword { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ClassOrStructConstraintSyntax Update(SyntaxToken classOrStructKeyword)" />
                <member def="public ClassOrStructConstraintSyntax WithClassOrStructKeyword(SyntaxToken classOrStructKeyword)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax : TypeParameterConstraintSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public SyntaxToken NewKeyword { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ConstructorConstraintSyntax Update(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)" />
                <member def="public ConstructorConstraintSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public ConstructorConstraintSyntax WithNewKeyword(SyntaxToken newKeyword)" />
                <member def="public ConstructorConstraintSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax : TypeParameterConstraintSyntax">
              <members>
                <member def="public TypeSyntax Type { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public TypeConstraintSyntax Update(TypeSyntax type)" />
                <member def="public TypeConstraintSyntax WithType(TypeSyntax type)" />
              </members>
            </type>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken GreaterThanToken { get; }" />
              <member def="public SyntaxToken LessThanToken { get; }" />
              <member def="public SeparatedSyntaxList&lt;TypeParameterSyntax&gt; Parameters { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public TypeParameterListSyntax AddParameters(params TypeParameterSyntax[] items)" />
              <member def="public TypeParameterListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList&lt;TypeParameterSyntax&gt; parameters, SyntaxToken greaterThanToken)" />
              <member def="public TypeParameterListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)" />
              <member def="public TypeParameterListSyntax WithLessThanToken(SyntaxToken lessThanToken)" />
              <member def="public TypeParameterListSyntax WithParameters(SeparatedSyntaxList&lt;TypeParameterSyntax&gt; parameters)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxList&lt;AttributeListSyntax&gt; AttributeLists { get; }" />
              <member def="public SyntaxToken Identifier { get; }" />
              <member def="public SyntaxToken VarianceKeyword { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public TypeParameterSyntax AddAttributeLists(params AttributeListSyntax[] items)" />
              <member def="public TypeParameterSyntax Update(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)" />
              <member def="public TypeParameterSyntax WithAttributeLists(SyntaxList&lt;AttributeListSyntax&gt; attributeLists)" />
              <member def="public TypeParameterSyntax WithIdentifier(SyntaxToken identifier)" />
              <member def="public TypeParameterSyntax WithVarianceKeyword(SyntaxToken varianceKeyword)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax : CSharpSyntaxNode">
            <members>
              <member def="public NameEqualsSyntax Alias { get; }" />
              <member def="public NameSyntax Name { get; }" />
              <member def="public SyntaxToken SemicolonToken { get; }" />
              <member def="public SyntaxToken StaticKeyword { get; }" />
              <member def="public SyntaxToken UsingKeyword { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public UsingDirectiveSyntax Update(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)" />
              <member def="public UsingDirectiveSyntax WithAlias(NameEqualsSyntax alias)" />
              <member def="public UsingDirectiveSyntax WithName(NameSyntax name)" />
              <member def="public UsingDirectiveSyntax WithSemicolonToken(SyntaxToken semicolonToken)" />
              <member def="public UsingDirectiveSyntax WithStaticKeyword(SyntaxToken staticKeyword)" />
              <member def="public UsingDirectiveSyntax WithUsingKeyword(SyntaxToken usingKeyword)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax : CSharpSyntaxNode">
            <members>
              <member def="public TypeSyntax Type { get; }" />
              <member def="public SeparatedSyntaxList&lt;VariableDeclaratorSyntax&gt; Variables { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public VariableDeclarationSyntax AddVariables(params VariableDeclaratorSyntax[] items)" />
              <member def="public VariableDeclarationSyntax Update(TypeSyntax type, SeparatedSyntaxList&lt;VariableDeclaratorSyntax&gt; variables)" />
              <member def="public VariableDeclarationSyntax WithType(TypeSyntax type)" />
              <member def="public VariableDeclarationSyntax WithVariables(SeparatedSyntaxList&lt;VariableDeclaratorSyntax&gt; variables)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax : CSharpSyntaxNode">
            <members>
              <member def="public BracketedArgumentListSyntax ArgumentList { get; }" />
              <member def="public SyntaxToken Identifier { get; }" />
              <member def="public EqualsValueClauseSyntax Initializer { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public VariableDeclaratorSyntax AddArgumentListArguments(params ArgumentSyntax[] items)" />
              <member def="public VariableDeclaratorSyntax Update(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)" />
              <member def="public VariableDeclaratorSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)" />
              <member def="public VariableDeclaratorSyntax WithIdentifier(SyntaxToken identifier)" />
              <member def="public VariableDeclaratorSyntax WithInitializer(EqualsValueClauseSyntax initializer)" />
            </members>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax : CSharpSyntaxNode">
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax : VariableDesignationSyntax">
              <members>
                <member def="public SyntaxToken UnderscoreToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public DiscardDesignationSyntax Update(SyntaxToken underscoreToken)" />
                <member def="public DiscardDesignationSyntax WithUnderscoreToken(SyntaxToken underscoreToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax : VariableDesignationSyntax">
              <members>
                <member def="public SyntaxToken CloseParenToken { get; }" />
                <member def="public SyntaxToken OpenParenToken { get; }" />
                <member def="public SeparatedSyntaxList&lt;VariableDesignationSyntax&gt; Variables { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public ParenthesizedVariableDesignationSyntax AddVariables(params VariableDesignationSyntax[] items)" />
                <member def="public ParenthesizedVariableDesignationSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList&lt;VariableDesignationSyntax&gt; variables, SyntaxToken closeParenToken)" />
                <member def="public ParenthesizedVariableDesignationSyntax WithCloseParenToken(SyntaxToken closeParenToken)" />
                <member def="public ParenthesizedVariableDesignationSyntax WithOpenParenToken(SyntaxToken openParenToken)" />
                <member def="public ParenthesizedVariableDesignationSyntax WithVariables(SeparatedSyntaxList&lt;VariableDesignationSyntax&gt; variables)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax : VariableDesignationSyntax">
              <members>
                <member def="public SyntaxToken Identifier { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public SingleVariableDesignationSyntax Update(SyntaxToken identifier)" />
                <member def="public SingleVariableDesignationSyntax WithIdentifier(SyntaxToken identifier)" />
              </members>
            </type>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax : CSharpSyntaxNode">
            <members>
              <member def="public ExpressionSyntax Condition { get; }" />
              <member def="public SyntaxToken WhenKeyword { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public WhenClauseSyntax Update(SyntaxToken whenKeyword, ExpressionSyntax condition)" />
              <member def="public WhenClauseSyntax WithCondition(ExpressionSyntax condition)" />
              <member def="public WhenClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword)" />
            </members>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax : CSharpSyntaxNode">
            <members>
              <member def="public abstract SyntaxToken EndQuoteToken { get; }" />
              <member def="public abstract SyntaxToken EqualsToken { get; }" />
              <member def="public abstract XmlNameSyntax Name { get; }" />
              <member def="public abstract SyntaxToken StartQuoteToken { get; }" />
            </members>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax : XmlAttributeSyntax">
              <members>
                <member def="public CrefSyntax Cref { get; }" />
                <member def="public override SyntaxToken EndQuoteToken { get; }" />
                <member def="public override SyntaxToken EqualsToken { get; }" />
                <member def="public override XmlNameSyntax Name { get; }" />
                <member def="public override SyntaxToken StartQuoteToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public XmlCrefAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)" />
                <member def="public XmlCrefAttributeSyntax WithCref(CrefSyntax cref)" />
                <member def="public XmlCrefAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken)" />
                <member def="public XmlCrefAttributeSyntax WithEqualsToken(SyntaxToken equalsToken)" />
                <member def="public XmlCrefAttributeSyntax WithName(XmlNameSyntax name)" />
                <member def="public XmlCrefAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax : XmlAttributeSyntax">
              <members>
                <member def="public override SyntaxToken EndQuoteToken { get; }" />
                <member def="public override SyntaxToken EqualsToken { get; }" />
                <member def="public IdentifierNameSyntax Identifier { get; }" />
                <member def="public override XmlNameSyntax Name { get; }" />
                <member def="public override SyntaxToken StartQuoteToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)" />
                <member def="public XmlNameAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken)" />
                <member def="public XmlNameAttributeSyntax WithEqualsToken(SyntaxToken equalsToken)" />
                <member def="public XmlNameAttributeSyntax WithIdentifier(IdentifierNameSyntax identifier)" />
                <member def="public XmlNameAttributeSyntax WithName(XmlNameSyntax name)" />
                <member def="public XmlNameAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax : XmlAttributeSyntax">
              <members>
                <member def="public override SyntaxToken EndQuoteToken { get; }" />
                <member def="public override SyntaxToken EqualsToken { get; }" />
                <member def="public override XmlNameSyntax Name { get; }" />
                <member def="public override SyntaxToken StartQuoteToken { get; }" />
                <member def="public SyntaxTokenList TextTokens { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public XmlTextAttributeSyntax AddTextTokens(params SyntaxToken[] items)" />
                <member def="public XmlTextAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)" />
                <member def="public XmlTextAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken)" />
                <member def="public XmlTextAttributeSyntax WithEqualsToken(SyntaxToken equalsToken)" />
                <member def="public XmlTextAttributeSyntax WithName(XmlNameSyntax name)" />
                <member def="public XmlTextAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken)" />
                <member def="public XmlTextAttributeSyntax WithTextTokens(SyntaxTokenList textTokens)" />
              </members>
            </type>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken GreaterThanToken { get; }" />
              <member def="public SyntaxToken LessThanSlashToken { get; }" />
              <member def="public XmlNameSyntax Name { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)" />
              <member def="public XmlElementEndTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)" />
              <member def="public XmlElementEndTagSyntax WithLessThanSlashToken(SyntaxToken lessThanSlashToken)" />
              <member def="public XmlElementEndTagSyntax WithName(XmlNameSyntax name)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxList&lt;XmlAttributeSyntax&gt; Attributes { get; }" />
              <member def="public SyntaxToken GreaterThanToken { get; }" />
              <member def="public SyntaxToken LessThanToken { get; }" />
              <member def="public XmlNameSyntax Name { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public XmlElementStartTagSyntax AddAttributes(params XmlAttributeSyntax[] items)" />
              <member def="public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList&lt;XmlAttributeSyntax&gt; attributes, SyntaxToken greaterThanToken)" />
              <member def="public XmlElementStartTagSyntax WithAttributes(SyntaxList&lt;XmlAttributeSyntax&gt; attributes)" />
              <member def="public XmlElementStartTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)" />
              <member def="public XmlElementStartTagSyntax WithLessThanToken(SyntaxToken lessThanToken)" />
              <member def="public XmlElementStartTagSyntax WithName(XmlNameSyntax name)" />
            </members>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken LocalName { get; }" />
              <member def="public XmlPrefixSyntax Prefix { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName)" />
              <member def="public XmlNameSyntax WithLocalName(SyntaxToken localName)" />
              <member def="public XmlNameSyntax WithPrefix(XmlPrefixSyntax prefix)" />
            </members>
          </type>
          <type def="public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax : CSharpSyntaxNode">
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax : XmlNodeSyntax">
              <members>
                <member def="public SyntaxToken EndCDataToken { get; }" />
                <member def="public SyntaxToken StartCDataToken { get; }" />
                <member def="public SyntaxTokenList TextTokens { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public XmlCDataSectionSyntax AddTextTokens(params SyntaxToken[] items)" />
                <member def="public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken)" />
                <member def="public XmlCDataSectionSyntax WithEndCDataToken(SyntaxToken endCDataToken)" />
                <member def="public XmlCDataSectionSyntax WithStartCDataToken(SyntaxToken startCDataToken)" />
                <member def="public XmlCDataSectionSyntax WithTextTokens(SyntaxTokenList textTokens)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax : XmlNodeSyntax">
              <members>
                <member def="public SyntaxToken LessThanExclamationMinusMinusToken { get; }" />
                <member def="public SyntaxToken MinusMinusGreaterThanToken { get; }" />
                <member def="public SyntaxTokenList TextTokens { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public XmlCommentSyntax AddTextTokens(params SyntaxToken[] items)" />
                <member def="public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken)" />
                <member def="public XmlCommentSyntax WithLessThanExclamationMinusMinusToken(SyntaxToken lessThanExclamationMinusMinusToken)" />
                <member def="public XmlCommentSyntax WithMinusMinusGreaterThanToken(SyntaxToken minusMinusGreaterThanToken)" />
                <member def="public XmlCommentSyntax WithTextTokens(SyntaxTokenList textTokens)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax : XmlNodeSyntax">
              <members>
                <member def="public SyntaxList&lt;XmlNodeSyntax&gt; Content { get; }" />
                <member def="public XmlElementEndTagSyntax EndTag { get; }" />
                <member def="public XmlElementStartTagSyntax StartTag { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public XmlElementSyntax AddContent(params XmlNodeSyntax[] items)" />
                <member def="public XmlElementSyntax AddStartTagAttributes(params XmlAttributeSyntax[] items)" />
                <member def="public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, SyntaxList&lt;XmlNodeSyntax&gt; content, XmlElementEndTagSyntax endTag)" />
                <member def="public XmlElementSyntax WithContent(SyntaxList&lt;XmlNodeSyntax&gt; content)" />
                <member def="public XmlElementSyntax WithEndTag(XmlElementEndTagSyntax endTag)" />
                <member def="public XmlElementSyntax WithStartTag(XmlElementStartTagSyntax startTag)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax : XmlNodeSyntax">
              <members>
                <member def="public SyntaxList&lt;XmlAttributeSyntax&gt; Attributes { get; }" />
                <member def="public SyntaxToken LessThanToken { get; }" />
                <member def="public XmlNameSyntax Name { get; }" />
                <member def="public SyntaxToken SlashGreaterThanToken { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public XmlEmptyElementSyntax AddAttributes(params XmlAttributeSyntax[] items)" />
                <member def="public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList&lt;XmlAttributeSyntax&gt; attributes, SyntaxToken slashGreaterThanToken)" />
                <member def="public XmlEmptyElementSyntax WithAttributes(SyntaxList&lt;XmlAttributeSyntax&gt; attributes)" />
                <member def="public XmlEmptyElementSyntax WithLessThanToken(SyntaxToken lessThanToken)" />
                <member def="public XmlEmptyElementSyntax WithName(XmlNameSyntax name)" />
                <member def="public XmlEmptyElementSyntax WithSlashGreaterThanToken(SyntaxToken slashGreaterThanToken)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax : XmlNodeSyntax">
              <members>
                <member def="public SyntaxToken EndProcessingInstructionToken { get; }" />
                <member def="public XmlNameSyntax Name { get; }" />
                <member def="public SyntaxToken StartProcessingInstructionToken { get; }" />
                <member def="public SyntaxTokenList TextTokens { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public XmlProcessingInstructionSyntax AddTextTokens(params SyntaxToken[] items)" />
                <member def="public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken)" />
                <member def="public XmlProcessingInstructionSyntax WithEndProcessingInstructionToken(SyntaxToken endProcessingInstructionToken)" />
                <member def="public XmlProcessingInstructionSyntax WithName(XmlNameSyntax name)" />
                <member def="public XmlProcessingInstructionSyntax WithStartProcessingInstructionToken(SyntaxToken startProcessingInstructionToken)" />
                <member def="public XmlProcessingInstructionSyntax WithTextTokens(SyntaxTokenList textTokens)" />
              </members>
            </type>
            <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax : XmlNodeSyntax">
              <members>
                <member def="public SyntaxTokenList TextTokens { get; }" />
                <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
                <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
                <member def="public XmlTextSyntax AddTextTokens(params SyntaxToken[] items)" />
                <member def="public XmlTextSyntax Update(SyntaxTokenList textTokens)" />
                <member def="public XmlTextSyntax WithTextTokens(SyntaxTokenList textTokens)" />
              </members>
            </type>
          </type>
          <type def="public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax : CSharpSyntaxNode">
            <members>
              <member def="public SyntaxToken ColonToken { get; }" />
              <member def="public SyntaxToken Prefix { get; }" />
              <member def="public override void Accept(CSharpSyntaxVisitor visitor)" />
              <member def="public override TResult Accept&lt;TResult&gt;(CSharpSyntaxVisitor&lt;TResult&gt; visitor)" />
              <member def="public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken)" />
              <member def="public XmlPrefixSyntax WithColonToken(SyntaxToken colonToken)" />
              <member def="public XmlPrefixSyntax WithPrefix(SyntaxToken prefix)" />
            </members>
          </type>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.SyntaxReference">
        <members>
          <member def="protected SyntaxReference()" />
          <member def="public abstract TextSpan Span { get; }" />
          <member def="public abstract SyntaxTree SyntaxTree { get; }" />
          <member def="public abstract SyntaxNode GetSyntax(CancellationToken cancellationToken = default)" />
          <member def="public virtual Task&lt;SyntaxNode&gt; GetSyntaxAsync(CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.SyntaxTree">
        <members>
          <member def="protected SyntaxTree()" />
          <member def="public abstract Encoding Encoding { get; }" />
          <member def="public abstract string FilePath { get; }" />
          <member def="public abstract bool HasCompilationUnitRoot { get; }" />
          <member def="public abstract int Length { get; }" />
          <member def="public ParseOptions Options { get; }" />
          <member def="protected abstract ParseOptions OptionsCore { get; }" />
          <member def="public abstract IList&lt;TextSpan&gt; GetChangedSpans(SyntaxTree syntaxTree)" />
          <member def="public abstract IList&lt;TextChange&gt; GetChanges(SyntaxTree oldTree)" />
          <member def="public abstract IEnumerable&lt;Diagnostic&gt; GetDiagnostics(CancellationToken cancellationToken = default)" />
          <member def="public abstract IEnumerable&lt;Diagnostic&gt; GetDiagnostics(SyntaxNode node)" />
          <member def="public abstract IEnumerable&lt;Diagnostic&gt; GetDiagnostics(SyntaxNodeOrToken nodeOrToken)" />
          <member def="public abstract IEnumerable&lt;Diagnostic&gt; GetDiagnostics(SyntaxToken token)" />
          <member def="public abstract IEnumerable&lt;Diagnostic&gt; GetDiagnostics(SyntaxTrivia trivia)" />
          <member def="public abstract FileLinePositionSpan GetLineSpan(TextSpan span, CancellationToken cancellationToken = default)" />
          <member def="public virtual LineVisibility GetLineVisibility(int position, CancellationToken cancellationToken = default)" />
          <member def="public abstract Location GetLocation(TextSpan span)" />
          <member def="public abstract FileLinePositionSpan GetMappedLineSpan(TextSpan span, CancellationToken cancellationToken = default)" />
          <member def="public abstract SyntaxReference GetReference(SyntaxNode node)" />
          <member def="public SyntaxNode GetRoot(CancellationToken cancellationToken = default)" />
          <member def="public Task&lt;SyntaxNode&gt; GetRootAsync(CancellationToken cancellationToken = default)" />
          <member def="protected abstract Task&lt;SyntaxNode&gt; GetRootAsyncCore(CancellationToken cancellationToken)" />
          <member def="protected abstract SyntaxNode GetRootCore(CancellationToken cancellationToken)" />
          <member def="public abstract SourceText GetText(CancellationToken cancellationToken = default)" />
          <member def="public virtual Task&lt;SourceText&gt; GetTextAsync(CancellationToken cancellationToken = default)" />
          <member def="public abstract bool HasHiddenRegions()" />
          <member def="public abstract bool IsEquivalentTo(SyntaxTree tree, bool topLevel = false)" />
          <member def="public override string ToString()" />
          <member def="public bool TryGetRoot(out SyntaxNode root)" />
          <member def="protected abstract bool TryGetRootCore(out SyntaxNode root)" />
          <member def="public abstract bool TryGetText(out SourceText text)" />
          <member def="public abstract SyntaxTree WithChangedText(SourceText newText)" />
          <member def="public abstract SyntaxTree WithFilePath(string path)" />
          <member def="public abstract SyntaxTree WithRootAndOptions(SyntaxNode root, ParseOptions options)" />
        </members>
        <type def="public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree : SyntaxTree">
          <members>
            <member def="protected CSharpSyntaxTree()" />
            <member def="public abstract CSharpParseOptions Options { get; }" />
            <member def="protected override ParseOptions OptionsCore { get; }" />
            <member def="protected T CloneNodeAsRoot&lt;T&gt;(T node) where T : CSharpSyntaxNode" />
            <member def="public static SyntaxTree Create(CSharpSyntaxNode root, CSharpParseOptions options = null, string path = &quot;&quot;, Encoding encoding = null)" />
            <member def="public override IList&lt;TextSpan&gt; GetChangedSpans(SyntaxTree oldTree)" />
            <member def="public override IList&lt;TextChange&gt; GetChanges(SyntaxTree oldTree)" />
            <member def="public CompilationUnitSyntax GetCompilationUnitRoot(CancellationToken cancellationToken = default)" />
            <member def="public override IEnumerable&lt;Diagnostic&gt; GetDiagnostics(CancellationToken cancellationToken = default)" />
            <member def="public override IEnumerable&lt;Diagnostic&gt; GetDiagnostics(SyntaxNode node)" />
            <member def="public override IEnumerable&lt;Diagnostic&gt; GetDiagnostics(SyntaxNodeOrToken nodeOrToken)" />
            <member def="public override IEnumerable&lt;Diagnostic&gt; GetDiagnostics(SyntaxToken token)" />
            <member def="public override IEnumerable&lt;Diagnostic&gt; GetDiagnostics(SyntaxTrivia trivia)" />
            <member def="public override FileLinePositionSpan GetLineSpan(TextSpan span, CancellationToken cancellationToken = default)" />
            <member def="public override LineVisibility GetLineVisibility(int position, CancellationToken cancellationToken = default)" />
            <member def="public override Location GetLocation(TextSpan span)" />
            <member def="public override FileLinePositionSpan GetMappedLineSpan(TextSpan span, CancellationToken cancellationToken = default)" />
            <member def="public abstract CSharpSyntaxNode GetRoot(CancellationToken cancellationToken = default)" />
            <member def="public virtual Task&lt;CSharpSyntaxNode&gt; GetRootAsync(CancellationToken cancellationToken = default)" />
            <member def="protected override Task&lt;SyntaxNode&gt; GetRootAsyncCore(CancellationToken cancellationToken)" />
            <member def="protected override SyntaxNode GetRootCore(CancellationToken cancellationToken)" />
            <member def="public override bool HasHiddenRegions()" />
            <member def="public override bool IsEquivalentTo(SyntaxTree tree, bool topLevel = false)" />
            <member def="public static SyntaxTree ParseText(SourceText text, CSharpParseOptions options = null, string path = &quot;&quot;, CancellationToken cancellationToken = default)" />
            <member def="public static SyntaxTree ParseText(string text, CSharpParseOptions options = null, string path = &quot;&quot;, Encoding encoding = null, CancellationToken cancellationToken = default)" />
            <member def="public abstract bool TryGetRoot(out CSharpSyntaxNode root)" />
            <member def="protected override bool TryGetRootCore(out SyntaxNode root)" />
            <member def="public override SyntaxTree WithChangedText(SourceText newText)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.SyntaxWalker">
        <members>
          <member def="protected SyntaxWalker(SyntaxWalkerDepth depth = Node)" />
          <member def="protected SyntaxWalkerDepth Depth { get; }" />
          <member def="public virtual void Visit(SyntaxNode node)" />
          <member def="protected virtual void VisitToken(SyntaxToken token)" />
          <member def="protected virtual void VisitTrivia(SyntaxTrivia trivia)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.TextAndVersion">
        <members>
          <member def="public string FilePath { get; }" />
          <member def="public SourceText Text { get; }" />
          <member def="public VersionStamp Version { get; }" />
          <member def="public static TextAndVersion Create(SourceText text, VersionStamp version, string filePath = null)" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.TextDocument">
        <members>
          <member def="protected TextDocument()" />
          <member def="public string FilePath { get; }" />
          <member def="public IReadOnlyList&lt;string&gt; Folders { get; }" />
          <member def="public DocumentId Id { get; }" />
          <member def="public string Name { get; }" />
          <member def="public Project Project { get; protected set; }" />
          <member def="public Task&lt;SourceText&gt; GetTextAsync(CancellationToken cancellationToken = default)" />
          <member def="public Task&lt;VersionStamp&gt; GetTextVersionAsync(CancellationToken cancellationToken = default)" />
          <member def="public bool TryGetText(out SourceText text)" />
          <member def="public bool TryGetTextVersion(out VersionStamp version)" />
        </members>
        <type def="public class Microsoft.CodeAnalysis.Document : TextDocument">
          <members>
            <member def="public SourceCodeKind SourceCodeKind { get; }" />
            <member def="public bool SupportsSemanticModel { get; }" />
            <member def="public bool SupportsSyntaxTree { get; }" />
            <member def="public ImmutableArray&lt;DocumentId&gt; GetLinkedDocumentIds()" />
            <member def="public Task&lt;DocumentOptionSet&gt; GetOptionsAsync(CancellationToken cancellationToken = default)" />
            <member def="public Task&lt;SemanticModel&gt; GetSemanticModelAsync(CancellationToken cancellationToken = default)" />
            <member def="public Task&lt;SyntaxNode&gt; GetSyntaxRootAsync(CancellationToken cancellationToken = default)" />
            <member def="public Task&lt;SyntaxTree&gt; GetSyntaxTreeAsync(CancellationToken cancellationToken = default)" />
            <member def="public Task&lt;VersionStamp&gt; GetSyntaxVersionAsync(CancellationToken cancellationToken = default)" />
            <member def="public Task&lt;IEnumerable&lt;TextChange&gt;&gt; GetTextChangesAsync(Document oldDocument, CancellationToken cancellationToken = default)" />
            <member def="public bool TryGetSemanticModel(out SemanticModel semanticModel)" />
            <member def="public bool TryGetSyntaxRoot(out SyntaxNode root)" />
            <member def="public bool TryGetSyntaxTree(out SyntaxTree syntaxTree)" />
            <member def="public bool TryGetSyntaxVersion(out VersionStamp version)" />
            <member def="public Document WithFilePath(string filePath)" />
            <member def="public Document WithFolders(IEnumerable&lt;string&gt; folders)" />
            <member def="public Document WithName(string name)" />
            <member def="public Document WithSourceCodeKind(SourceCodeKind kind)" />
            <member def="public Document WithSyntaxRoot(SyntaxNode root)" />
            <member def="public Document WithText(SourceText text)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.TextLoader">
        <members>
          <member def="protected TextLoader()" />
          <member def="public static TextLoader From(TextAndVersion textAndVersion)" />
          <member def="public static TextLoader From(SourceTextContainer container, VersionStamp version, string filePath = null)" />
          <member def="public abstract Task&lt;TextAndVersion&gt; LoadTextAndVersionAsync(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Workspace : IDisposable">
        <members>
          <member def="protected Workspace(HostServices host, string workspaceKind)" />
          <member def="public event EventHandler&lt;DocumentActiveContextChangedEventArgs&gt; DocumentActiveContextChanged" />
          <member def="public event EventHandler&lt;DocumentEventArgs&gt; DocumentClosed" />
          <member def="public event EventHandler&lt;DocumentEventArgs&gt; DocumentOpened" />
          <member def="public event EventHandler&lt;WorkspaceChangeEventArgs&gt; WorkspaceChanged" />
          <member def="public event EventHandler&lt;WorkspaceDiagnosticEventArgs&gt; WorkspaceFailed" />
          <member def="public virtual bool CanOpenDocuments { get; }" />
          <member def="public Solution CurrentSolution { get; }" />
          <member def="public string Kind { get; }" />
          <member def="public OptionSet Options { get; set; }" />
          <member def="protected internal virtual bool PartialSemanticsEnabled { get; }" />
          <member def="public HostWorkspaceServices Services { get; }" />
          <member def="protected virtual Project AdjustReloadedProject(Project oldProject, Project reloadedProject)" />
          <member def="protected virtual Solution AdjustReloadedSolution(Solution oldSolution, Solution reloadedSolution)" />
          <member def="protected virtual void ApplyAdditionalDocumentAdded(DocumentInfo info, SourceText text)" />
          <member def="protected virtual void ApplyAdditionalDocumentRemoved(DocumentId documentId)" />
          <member def="protected virtual void ApplyAdditionalDocumentTextChanged(DocumentId id, SourceText text)" />
          <member def="protected virtual void ApplyAnalyzerReferenceAdded(ProjectId projectId, AnalyzerReference analyzerReference)" />
          <member def="protected virtual void ApplyAnalyzerReferenceRemoved(ProjectId projectId, AnalyzerReference analyzerReference)" />
          <member def="protected virtual void ApplyCompilationOptionsChanged(ProjectId projectId, CompilationOptions options)" />
          <member def="protected virtual void ApplyDocumentAdded(DocumentInfo info, SourceText text)" />
          <member def="protected virtual void ApplyDocumentInfoChanged(DocumentId id, DocumentInfo info)" />
          <member def="protected virtual void ApplyDocumentRemoved(DocumentId documentId)" />
          <member def="protected virtual void ApplyDocumentTextChanged(DocumentId id, SourceText text)" />
          <member def="protected virtual void ApplyMetadataReferenceAdded(ProjectId projectId, MetadataReference metadataReference)" />
          <member def="protected virtual void ApplyMetadataReferenceRemoved(ProjectId projectId, MetadataReference metadataReference)" />
          <member def="protected virtual void ApplyParseOptionsChanged(ProjectId projectId, ParseOptions options)" />
          <member def="protected virtual void ApplyProjectAdded(ProjectInfo project)" />
          <member def="protected virtual void ApplyProjectChanges(ProjectChanges projectChanges)" />
          <member def="protected virtual void ApplyProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference)" />
          <member def="protected virtual void ApplyProjectReferenceRemoved(ProjectId projectId, ProjectReference projectReference)" />
          <member def="protected virtual void ApplyProjectRemoved(ProjectId projectId)" />
          <member def="public virtual bool CanApplyChange(ApplyChangesKind feature)" />
          <member def="protected virtual bool CanApplyParseOptionChange(ParseOptions oldOptions, ParseOptions newOptions, Project project)" />
          <member def="protected void CheckAdditionalDocumentIsInCurrentSolution(DocumentId documentId)" />
          <member def="protected void CheckAdditionalDocumentIsNotInCurrentSolution(DocumentId documentId)" />
          <member def="protected void CheckCanOpenDocuments()" />
          <member def="protected virtual void CheckDocumentCanBeRemoved(DocumentId documentId)" />
          <member def="protected void CheckDocumentIsClosed(DocumentId documentId)" />
          <member def="protected void CheckDocumentIsInCurrentSolution(DocumentId documentId)" />
          <member def="protected void CheckDocumentIsNotInCurrentSolution(DocumentId documentId)" />
          <member def="protected void CheckDocumentIsOpen(DocumentId documentId)" />
          <member def="protected virtual void CheckProjectCanBeRemoved(ProjectId projectId)" />
          <member def="protected void CheckProjectDoesNotContainOpenDocuments(ProjectId projectId)" />
          <member def="protected void CheckProjectDoesNotHaveAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference)" />
          <member def="protected void CheckProjectDoesNotHaveMetadataReference(ProjectId projectId, MetadataReference metadataReference)" />
          <member def="protected void CheckProjectDoesNotHaveProjectReference(ProjectId fromProjectId, ProjectReference projectReference)" />
          <member def="protected void CheckProjectDoesNotHaveTransitiveProjectReference(ProjectId fromProjectId, ProjectId toProjectId)" />
          <member def="protected void CheckProjectHasAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference)" />
          <member def="protected void CheckProjectHasMetadataReference(ProjectId projectId, MetadataReference metadataReference)" />
          <member def="protected void CheckProjectHasProjectReference(ProjectId fromProjectId, ProjectReference projectReference)" />
          <member def="protected void CheckProjectIsInCurrentSolution(ProjectId projectId)" />
          <member def="protected void CheckProjectIsNotInCurrentSolution(ProjectId projectId)" />
          <member def="protected void CheckSolutionIsEmpty()" />
          <member def="protected virtual void ClearDocumentData(DocumentId documentId)" />
          <member def="protected void ClearOpenDocument(DocumentId documentId, bool isSolutionClosing = false)" />
          <member def="protected virtual void ClearProjectData(ProjectId projectId)" />
          <member def="protected void ClearSolution()" />
          <member def="protected virtual void ClearSolutionData()" />
          <member def="public virtual void CloseAdditionalDocument(DocumentId documentId)" />
          <member def="public virtual void CloseDocument(DocumentId documentId)" />
          <member def="protected internal Solution CreateSolution(SolutionId id)" />
          <member def="protected internal Solution CreateSolution(SolutionInfo solutionInfo)" />
          <member def="public void Dispose()" />
          <member def="protected virtual void Dispose(bool finalize)" />
          <member def="protected virtual string GetAdditionalDocumentName(DocumentId documentId)" />
          <member def="public virtual DocumentId GetDocumentIdInCurrentContext(SourceTextContainer container)" />
          <member def="protected virtual string GetDocumentName(DocumentId documentId)" />
          <member def="public virtual IEnumerable&lt;DocumentId&gt; GetOpenDocumentIds(ProjectId projectId = null)" />
          <member def="protected virtual string GetProjectName(ProjectId projectId)" />
          <member def="public virtual IEnumerable&lt;DocumentId&gt; GetRelatedDocumentIds(SourceTextContainer container)" />
          <member def="public static WorkspaceRegistration GetWorkspaceRegistration(SourceTextContainer textContainer)" />
          <member def="public virtual bool IsDocumentOpen(DocumentId documentId)" />
          <member def="protected internal void OnAdditionalDocumentAdded(DocumentInfo documentInfo)" />
          <member def="protected internal void OnAdditionalDocumentClosed(DocumentId documentId, TextLoader reloader)" />
          <member def="protected internal void OnAdditionalDocumentOpened(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext = true)" />
          <member def="protected internal void OnAdditionalDocumentRemoved(DocumentId documentId)" />
          <member def="protected internal void OnAdditionalDocumentTextChanged(DocumentId documentId, SourceText newText, PreservationMode mode)" />
          <member def="protected internal void OnAdditionalDocumentTextLoaderChanged(DocumentId documentId, TextLoader loader)" />
          <member def="protected internal void OnAnalyzerReferenceAdded(ProjectId projectId, AnalyzerReference analyzerReference)" />
          <member def="protected internal void OnAnalyzerReferenceRemoved(ProjectId projectId, AnalyzerReference analyzerReference)" />
          <member def="protected internal void OnAssemblyNameChanged(ProjectId projectId, string assemblyName)" />
          <member def="protected internal void OnCompilationOptionsChanged(ProjectId projectId, CompilationOptions options)" />
          <member def="protected internal void OnDocumentAdded(DocumentInfo documentInfo)" />
          <member def="protected internal void OnDocumentClosed(DocumentId documentId, TextLoader reloader, bool updateActiveContext = false)" />
          <member def="protected virtual void OnDocumentClosing(DocumentId documentId)" />
          <member def="protected void OnDocumentContextUpdated(DocumentId documentId)" />
          <member def="protected internal void OnDocumentInfoChanged(DocumentId documentId, DocumentInfo newInfo)" />
          <member def="protected internal void OnDocumentOpened(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext = true)" />
          <member def="protected internal void OnDocumentReloaded(DocumentInfo newDocumentInfo)" />
          <member def="protected internal void OnDocumentRemoved(DocumentId documentId)" />
          <member def="protected internal void OnDocumentSourceCodeKindChanged(DocumentId documentId, SourceCodeKind sourceCodeKind)" />
          <member def="protected virtual void OnDocumentTextChanged(Document document)" />
          <member def="protected internal void OnDocumentTextChanged(DocumentId documentId, SourceText newText, PreservationMode mode)" />
          <member def="protected internal void OnDocumentTextLoaderChanged(DocumentId documentId, TextLoader loader)" />
          <member def="protected internal void OnMetadataReferenceAdded(ProjectId projectId, MetadataReference metadataReference)" />
          <member def="protected internal void OnMetadataReferenceRemoved(ProjectId projectId, MetadataReference metadataReference)" />
          <member def="protected internal void OnOutputFilePathChanged(ProjectId projectId, string outputFilePath)" />
          <member def="protected internal void OnParseOptionsChanged(ProjectId projectId, ParseOptions options)" />
          <member def="protected internal void OnProjectAdded(ProjectInfo projectInfo)" />
          <member def="protected internal void OnProjectNameChanged(ProjectId projectId, string name, string filePath)" />
          <member def="protected internal void OnProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference)" />
          <member def="protected internal void OnProjectReferenceRemoved(ProjectId projectId, ProjectReference projectReference)" />
          <member def="protected internal virtual void OnProjectReloaded(ProjectInfo reloadedProjectInfo)" />
          <member def="protected internal virtual void OnProjectRemoved(ProjectId projectId)" />
          <member def="protected internal void OnSolutionAdded(SolutionInfo solutionInfo)" />
          <member def="protected internal void OnSolutionReloaded(SolutionInfo reloadedSolutionInfo)" />
          <member def="protected internal void OnSolutionRemoved()" />
          <member def="protected internal virtual void OnWorkspaceFailed(WorkspaceDiagnostic diagnostic)" />
          <member def="public virtual void OpenAdditionalDocument(DocumentId documentId, bool activate = true)" />
          <member def="public virtual void OpenDocument(DocumentId documentId, bool activate = true)" />
          <member def="protected Task RaiseDocumentActiveContextChangedEventAsync(Document document)" />
          <member def="protected Task RaiseDocumentActiveContextChangedEventAsync(SourceTextContainer sourceTextContainer, DocumentId oldActiveContextDocumentId, DocumentId newActiveContextDocumentId)" />
          <member def="protected Task RaiseDocumentClosedEventAsync(Document document)" />
          <member def="protected Task RaiseDocumentOpenedEventAsync(Document document)" />
          <member def="protected Task RaiseWorkspaceChangedEventAsync(WorkspaceChangeKind kind, Solution oldSolution, Solution newSolution, ProjectId projectId = null, DocumentId documentId = null)" />
          <member def="protected void RegisterText(SourceTextContainer textContainer)" />
          <member def="protected internal Task ScheduleTask(Action action, string taskName = &quot;Workspace.Task&quot;)" />
          <member def="protected internal Task&lt;T&gt; ScheduleTask&lt;T&gt;(Func&lt;T&gt; func, string taskName = &quot;Workspace.Task&quot;)" />
          <member def="protected Solution SetCurrentSolution(Solution solution)" />
          <member def="public virtual bool TryApplyChanges(Solution newSolution)" />
          <member def="public static bool TryGetWorkspace(SourceTextContainer textContainer, out Workspace workspace)" />
          <member def="protected void UnregisterText(SourceTextContainer textContainer)" />
          <member def="protected void UpdateReferencesAfterAdd()" />
        </members>
        <type def="public sealed class Microsoft.CodeAnalysis.AdhocWorkspace : Workspace">
          <members>
            <member def="public AdhocWorkspace()" />
            <member def="public AdhocWorkspace(HostServices host, string workspaceKind = &quot;Custom&quot;)" />
            <member def="public override bool CanOpenDocuments { get; }" />
            <member def="public Document AddDocument(DocumentInfo documentInfo)" />
            <member def="public Document AddDocument(ProjectId projectId, string name, SourceText text)" />
            <member def="public Project AddProject(ProjectInfo projectInfo)" />
            <member def="public Project AddProject(string name, string language)" />
            <member def="public void AddProjects(IEnumerable&lt;ProjectInfo&gt; projectInfos)" />
            <member def="public Solution AddSolution(SolutionInfo solutionInfo)" />
            <member def="public override bool CanApplyChange(ApplyChangesKind feature)" />
            <member def="public void ClearSolution()" />
            <member def="public override void CloseAdditionalDocument(DocumentId documentId)" />
            <member def="public override void CloseDocument(DocumentId documentId)" />
            <member def="public override void OpenAdditionalDocument(DocumentId documentId, bool activate = true)" />
            <member def="public override void OpenDocument(DocumentId documentId, bool activate = true)" />
          </members>
        </type>
      </type>
      <type def="public class Microsoft.CodeAnalysis.WorkspaceDiagnostic">
        <members>
          <member def="public WorkspaceDiagnostic(WorkspaceDiagnosticKind kind, string message)" />
          <member def="public WorkspaceDiagnosticKind Kind { get; }" />
          <member def="public string Message { get; }" />
          <member def="public override string ToString()" />
        </members>
        <type def="public class Microsoft.CodeAnalysis.DocumentDiagnostic : WorkspaceDiagnostic">
          <members>
            <member def="public DocumentDiagnostic(WorkspaceDiagnosticKind kind, string message, DocumentId documentId)" />
            <member def="public DocumentId DocumentId { get; }" />
          </members>
        </type>
        <type def="public class Microsoft.CodeAnalysis.ProjectDiagnostic : WorkspaceDiagnostic">
          <members>
            <member def="public ProjectDiagnostic(WorkspaceDiagnosticKind kind, string message, ProjectId projectId)" />
            <member def="public ProjectId ProjectId { get; }" />
          </members>
        </type>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.WorkspaceRegistration">
        <members>
          <member def="public event EventHandler WorkspaceChanged" />
          <member def="public Workspace Workspace { get; }" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.XmlReferenceResolver">
        <members>
          <member def="protected XmlReferenceResolver()" />
          <member def="public override abstract bool Equals(object other)" />
          <member def="public override abstract int GetHashCode()" />
          <member def="public abstract Stream OpenRead(string resolvedPath)" />
          <member def="public abstract string ResolveReference(string path, string baseFilePath)" />
        </members>
        <type def="public class Microsoft.CodeAnalysis.XmlFileResolver : XmlReferenceResolver">
          <members>
            <member def="public XmlFileResolver(string baseDirectory)" />
            <member def="public string BaseDirectory { get; }" />
            <member def="public static XmlFileResolver Default { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="protected virtual bool FileExists(string resolvedPath)" />
            <member def="public override int GetHashCode()" />
            <member def="public override Stream OpenRead(string resolvedPath)" />
            <member def="public override string ResolveReference(string path, string baseFilePath)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor">
        <members>
          <member def="protected CSharpSyntaxVisitor()" />
          <member def="public virtual void DefaultVisit(SyntaxNode node)" />
          <member def="public virtual void Visit(SyntaxNode node)" />
          <member def="public virtual void VisitAccessorDeclaration(AccessorDeclarationSyntax node)" />
          <member def="public virtual void VisitAccessorList(AccessorListSyntax node)" />
          <member def="public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node)" />
          <member def="public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)" />
          <member def="public virtual void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)" />
          <member def="public virtual void VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)" />
          <member def="public virtual void VisitArgument(ArgumentSyntax node)" />
          <member def="public virtual void VisitArgumentList(ArgumentListSyntax node)" />
          <member def="public virtual void VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)" />
          <member def="public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)" />
          <member def="public virtual void VisitArrayType(ArrayTypeSyntax node)" />
          <member def="public virtual void VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)" />
          <member def="public virtual void VisitAssignmentExpression(AssignmentExpressionSyntax node)" />
          <member def="public virtual void VisitAttribute(AttributeSyntax node)" />
          <member def="public virtual void VisitAttributeArgument(AttributeArgumentSyntax node)" />
          <member def="public virtual void VisitAttributeArgumentList(AttributeArgumentListSyntax node)" />
          <member def="public virtual void VisitAttributeList(AttributeListSyntax node)" />
          <member def="public virtual void VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)" />
          <member def="public virtual void VisitAwaitExpression(AwaitExpressionSyntax node)" />
          <member def="public virtual void VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitBaseExpression(BaseExpressionSyntax node)" />
          <member def="public virtual void VisitBaseList(BaseListSyntax node)" />
          <member def="public virtual void VisitBinaryExpression(BinaryExpressionSyntax node)" />
          <member def="public virtual void VisitBlock(BlockSyntax node)" />
          <member def="public virtual void VisitBracketedArgumentList(BracketedArgumentListSyntax node)" />
          <member def="public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node)" />
          <member def="public virtual void VisitBreakStatement(BreakStatementSyntax node)" />
          <member def="public virtual void VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)" />
          <member def="public virtual void VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)" />
          <member def="public virtual void VisitCastExpression(CastExpressionSyntax node)" />
          <member def="public virtual void VisitCatchClause(CatchClauseSyntax node)" />
          <member def="public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node)" />
          <member def="public virtual void VisitCatchFilterClause(CatchFilterClauseSyntax node)" />
          <member def="public virtual void VisitCheckedExpression(CheckedExpressionSyntax node)" />
          <member def="public virtual void VisitCheckedStatement(CheckedStatementSyntax node)" />
          <member def="public virtual void VisitClassDeclaration(ClassDeclarationSyntax node)" />
          <member def="public virtual void VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)" />
          <member def="public virtual void VisitCompilationUnit(CompilationUnitSyntax node)" />
          <member def="public virtual void VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)" />
          <member def="public virtual void VisitConditionalExpression(ConditionalExpressionSyntax node)" />
          <member def="public virtual void VisitConstantPattern(ConstantPatternSyntax node)" />
          <member def="public virtual void VisitConstructorConstraint(ConstructorConstraintSyntax node)" />
          <member def="public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node)" />
          <member def="public virtual void VisitConstructorInitializer(ConstructorInitializerSyntax node)" />
          <member def="public virtual void VisitContinueStatement(ContinueStatementSyntax node)" />
          <member def="public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)" />
          <member def="public virtual void VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)" />
          <member def="public virtual void VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)" />
          <member def="public virtual void VisitCrefParameter(CrefParameterSyntax node)" />
          <member def="public virtual void VisitCrefParameterList(CrefParameterListSyntax node)" />
          <member def="public virtual void VisitDeclarationExpression(DeclarationExpressionSyntax node)" />
          <member def="public virtual void VisitDeclarationPattern(DeclarationPatternSyntax node)" />
          <member def="public virtual void VisitDefaultExpression(DefaultExpressionSyntax node)" />
          <member def="public virtual void VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)" />
          <member def="public virtual void VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node)" />
          <member def="public virtual void VisitDestructorDeclaration(DestructorDeclarationSyntax node)" />
          <member def="public virtual void VisitDiscardDesignation(DiscardDesignationSyntax node)" />
          <member def="public virtual void VisitDoStatement(DoStatementSyntax node)" />
          <member def="public virtual void VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)" />
          <member def="public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node)" />
          <member def="public virtual void VisitElementBindingExpression(ElementBindingExpressionSyntax node)" />
          <member def="public virtual void VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitElseClause(ElseClauseSyntax node)" />
          <member def="public virtual void VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitEmptyStatement(EmptyStatementSyntax node)" />
          <member def="public virtual void VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node)" />
          <member def="public virtual void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)" />
          <member def="public virtual void VisitEqualsValueClause(EqualsValueClauseSyntax node)" />
          <member def="public virtual void VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitEventDeclaration(EventDeclarationSyntax node)" />
          <member def="public virtual void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)" />
          <member def="public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)" />
          <member def="public virtual void VisitExpressionStatement(ExpressionStatementSyntax node)" />
          <member def="public virtual void VisitExternAliasDirective(ExternAliasDirectiveSyntax node)" />
          <member def="public virtual void VisitFieldDeclaration(FieldDeclarationSyntax node)" />
          <member def="public virtual void VisitFinallyClause(FinallyClauseSyntax node)" />
          <member def="public virtual void VisitFixedStatement(FixedStatementSyntax node)" />
          <member def="public virtual void VisitForEachStatement(ForEachStatementSyntax node)" />
          <member def="public virtual void VisitForEachVariableStatement(ForEachVariableStatementSyntax node)" />
          <member def="public virtual void VisitForStatement(ForStatementSyntax node)" />
          <member def="public virtual void VisitFromClause(FromClauseSyntax node)" />
          <member def="public virtual void VisitGenericName(GenericNameSyntax node)" />
          <member def="public virtual void VisitGlobalStatement(GlobalStatementSyntax node)" />
          <member def="public virtual void VisitGotoStatement(GotoStatementSyntax node)" />
          <member def="public virtual void VisitGroupClause(GroupClauseSyntax node)" />
          <member def="public virtual void VisitIdentifierName(IdentifierNameSyntax node)" />
          <member def="public virtual void VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitIfStatement(IfStatementSyntax node)" />
          <member def="public virtual void VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)" />
          <member def="public virtual void VisitImplicitElementAccess(ImplicitElementAccessSyntax node)" />
          <member def="public virtual void VisitIncompleteMember(IncompleteMemberSyntax node)" />
          <member def="public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node)" />
          <member def="public virtual void VisitIndexerMemberCref(IndexerMemberCrefSyntax node)" />
          <member def="public virtual void VisitInitializerExpression(InitializerExpressionSyntax node)" />
          <member def="public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)" />
          <member def="public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)" />
          <member def="public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node)" />
          <member def="public virtual void VisitInterpolation(InterpolationSyntax node)" />
          <member def="public virtual void VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)" />
          <member def="public virtual void VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)" />
          <member def="public virtual void VisitInvocationExpression(InvocationExpressionSyntax node)" />
          <member def="public virtual void VisitIsPatternExpression(IsPatternExpressionSyntax node)" />
          <member def="public virtual void VisitJoinClause(JoinClauseSyntax node)" />
          <member def="public virtual void VisitJoinIntoClause(JoinIntoClauseSyntax node)" />
          <member def="public virtual void VisitLabeledStatement(LabeledStatementSyntax node)" />
          <member def="public virtual void VisitLetClause(LetClauseSyntax node)" />
          <member def="public virtual void VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitLiteralExpression(LiteralExpressionSyntax node)" />
          <member def="public virtual void VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)" />
          <member def="public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)" />
          <member def="public virtual void VisitLockStatement(LockStatementSyntax node)" />
          <member def="public virtual void VisitMakeRefExpression(MakeRefExpressionSyntax node)" />
          <member def="public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node)" />
          <member def="public virtual void VisitMemberBindingExpression(MemberBindingExpressionSyntax node)" />
          <member def="public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node)" />
          <member def="public virtual void VisitNameColon(NameColonSyntax node)" />
          <member def="public virtual void VisitNameEquals(NameEqualsSyntax node)" />
          <member def="public virtual void VisitNameMemberCref(NameMemberCrefSyntax node)" />
          <member def="public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)" />
          <member def="public virtual void VisitNullableType(NullableTypeSyntax node)" />
          <member def="public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)" />
          <member def="public virtual void VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)" />
          <member def="public virtual void VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)" />
          <member def="public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node)" />
          <member def="public virtual void VisitOperatorMemberCref(OperatorMemberCrefSyntax node)" />
          <member def="public virtual void VisitOrderByClause(OrderByClauseSyntax node)" />
          <member def="public virtual void VisitOrdering(OrderingSyntax node)" />
          <member def="public virtual void VisitParameter(ParameterSyntax node)" />
          <member def="public virtual void VisitParameterList(ParameterListSyntax node)" />
          <member def="public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)" />
          <member def="public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)" />
          <member def="public virtual void VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)" />
          <member def="public virtual void VisitPointerType(PointerTypeSyntax node)" />
          <member def="public virtual void VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)" />
          <member def="public virtual void VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitPredefinedType(PredefinedTypeSyntax node)" />
          <member def="public virtual void VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)" />
          <member def="public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node)" />
          <member def="public virtual void VisitQualifiedCref(QualifiedCrefSyntax node)" />
          <member def="public virtual void VisitQualifiedName(QualifiedNameSyntax node)" />
          <member def="public virtual void VisitQueryBody(QueryBodySyntax node)" />
          <member def="public virtual void VisitQueryContinuation(QueryContinuationSyntax node)" />
          <member def="public virtual void VisitQueryExpression(QueryExpressionSyntax node)" />
          <member def="public virtual void VisitRefExpression(RefExpressionSyntax node)" />
          <member def="public virtual void VisitRefType(RefTypeSyntax node)" />
          <member def="public virtual void VisitRefTypeExpression(RefTypeExpressionSyntax node)" />
          <member def="public virtual void VisitRefValueExpression(RefValueExpressionSyntax node)" />
          <member def="public virtual void VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitReturnStatement(ReturnStatementSyntax node)" />
          <member def="public virtual void VisitSelectClause(SelectClauseSyntax node)" />
          <member def="public virtual void VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitSimpleBaseType(SimpleBaseTypeSyntax node)" />
          <member def="public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)" />
          <member def="public virtual void VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)" />
          <member def="public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node)" />
          <member def="public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)" />
          <member def="public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)" />
          <member def="public virtual void VisitStructDeclaration(StructDeclarationSyntax node)" />
          <member def="public virtual void VisitSwitchSection(SwitchSectionSyntax node)" />
          <member def="public virtual void VisitSwitchStatement(SwitchStatementSyntax node)" />
          <member def="public virtual void VisitThisExpression(ThisExpressionSyntax node)" />
          <member def="public virtual void VisitThrowExpression(ThrowExpressionSyntax node)" />
          <member def="public virtual void VisitThrowStatement(ThrowStatementSyntax node)" />
          <member def="public virtual void VisitTryStatement(TryStatementSyntax node)" />
          <member def="public virtual void VisitTupleElement(TupleElementSyntax node)" />
          <member def="public virtual void VisitTupleExpression(TupleExpressionSyntax node)" />
          <member def="public virtual void VisitTupleType(TupleTypeSyntax node)" />
          <member def="public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node)" />
          <member def="public virtual void VisitTypeConstraint(TypeConstraintSyntax node)" />
          <member def="public virtual void VisitTypeCref(TypeCrefSyntax node)" />
          <member def="public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node)" />
          <member def="public virtual void VisitTypeParameter(TypeParameterSyntax node)" />
          <member def="public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)" />
          <member def="public virtual void VisitTypeParameterList(TypeParameterListSyntax node)" />
          <member def="public virtual void VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node)" />
          <member def="public virtual void VisitUsingDirective(UsingDirectiveSyntax node)" />
          <member def="public virtual void VisitUsingStatement(UsingStatementSyntax node)" />
          <member def="public virtual void VisitVariableDeclaration(VariableDeclarationSyntax node)" />
          <member def="public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node)" />
          <member def="public virtual void VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)" />
          <member def="public virtual void VisitWhenClause(WhenClauseSyntax node)" />
          <member def="public virtual void VisitWhereClause(WhereClauseSyntax node)" />
          <member def="public virtual void VisitWhileStatement(WhileStatementSyntax node)" />
          <member def="public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node)" />
          <member def="public virtual void VisitXmlComment(XmlCommentSyntax node)" />
          <member def="public virtual void VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)" />
          <member def="public virtual void VisitXmlElement(XmlElementSyntax node)" />
          <member def="public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node)" />
          <member def="public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node)" />
          <member def="public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node)" />
          <member def="public virtual void VisitXmlName(XmlNameSyntax node)" />
          <member def="public virtual void VisitXmlNameAttribute(XmlNameAttributeSyntax node)" />
          <member def="public virtual void VisitXmlPrefix(XmlPrefixSyntax node)" />
          <member def="public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)" />
          <member def="public virtual void VisitXmlText(XmlTextSyntax node)" />
          <member def="public virtual void VisitXmlTextAttribute(XmlTextAttributeSyntax node)" />
          <member def="public virtual void VisitYieldStatement(YieldStatementSyntax node)" />
        </members>
        <type def="public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker : CSharpSyntaxVisitor">
          <members>
            <member def="protected CSharpSyntaxWalker(SyntaxWalkerDepth depth = Node)" />
            <member def="protected SyntaxWalkerDepth Depth { get; }" />
            <member def="public override void DefaultVisit(SyntaxNode node)" />
            <member def="public override void Visit(SyntaxNode node)" />
            <member def="public virtual void VisitLeadingTrivia(SyntaxToken token)" />
            <member def="public virtual void VisitToken(SyntaxToken token)" />
            <member def="public virtual void VisitTrailingTrivia(SyntaxToken token)" />
            <member def="public virtual void VisitTrivia(SyntaxTrivia trivia)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&lt;TResult&gt;">
        <members>
          <member def="protected CSharpSyntaxVisitor()" />
          <member def="public virtual TResult DefaultVisit(SyntaxNode node)" />
          <member def="public virtual TResult Visit(SyntaxNode node)" />
          <member def="public virtual TResult VisitAccessorDeclaration(AccessorDeclarationSyntax node)" />
          <member def="public virtual TResult VisitAccessorList(AccessorListSyntax node)" />
          <member def="public virtual TResult VisitAliasQualifiedName(AliasQualifiedNameSyntax node)" />
          <member def="public virtual TResult VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)" />
          <member def="public virtual TResult VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)" />
          <member def="public virtual TResult VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)" />
          <member def="public virtual TResult VisitArgument(ArgumentSyntax node)" />
          <member def="public virtual TResult VisitArgumentList(ArgumentListSyntax node)" />
          <member def="public virtual TResult VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)" />
          <member def="public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)" />
          <member def="public virtual TResult VisitArrayType(ArrayTypeSyntax node)" />
          <member def="public virtual TResult VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)" />
          <member def="public virtual TResult VisitAssignmentExpression(AssignmentExpressionSyntax node)" />
          <member def="public virtual TResult VisitAttribute(AttributeSyntax node)" />
          <member def="public virtual TResult VisitAttributeArgument(AttributeArgumentSyntax node)" />
          <member def="public virtual TResult VisitAttributeArgumentList(AttributeArgumentListSyntax node)" />
          <member def="public virtual TResult VisitAttributeList(AttributeListSyntax node)" />
          <member def="public virtual TResult VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)" />
          <member def="public virtual TResult VisitAwaitExpression(AwaitExpressionSyntax node)" />
          <member def="public virtual TResult VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitBaseExpression(BaseExpressionSyntax node)" />
          <member def="public virtual TResult VisitBaseList(BaseListSyntax node)" />
          <member def="public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node)" />
          <member def="public virtual TResult VisitBlock(BlockSyntax node)" />
          <member def="public virtual TResult VisitBracketedArgumentList(BracketedArgumentListSyntax node)" />
          <member def="public virtual TResult VisitBracketedParameterList(BracketedParameterListSyntax node)" />
          <member def="public virtual TResult VisitBreakStatement(BreakStatementSyntax node)" />
          <member def="public virtual TResult VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)" />
          <member def="public virtual TResult VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)" />
          <member def="public virtual TResult VisitCastExpression(CastExpressionSyntax node)" />
          <member def="public virtual TResult VisitCatchClause(CatchClauseSyntax node)" />
          <member def="public virtual TResult VisitCatchDeclaration(CatchDeclarationSyntax node)" />
          <member def="public virtual TResult VisitCatchFilterClause(CatchFilterClauseSyntax node)" />
          <member def="public virtual TResult VisitCheckedExpression(CheckedExpressionSyntax node)" />
          <member def="public virtual TResult VisitCheckedStatement(CheckedStatementSyntax node)" />
          <member def="public virtual TResult VisitClassDeclaration(ClassDeclarationSyntax node)" />
          <member def="public virtual TResult VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)" />
          <member def="public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node)" />
          <member def="public virtual TResult VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)" />
          <member def="public virtual TResult VisitConditionalExpression(ConditionalExpressionSyntax node)" />
          <member def="public virtual TResult VisitConstantPattern(ConstantPatternSyntax node)" />
          <member def="public virtual TResult VisitConstructorConstraint(ConstructorConstraintSyntax node)" />
          <member def="public virtual TResult VisitConstructorDeclaration(ConstructorDeclarationSyntax node)" />
          <member def="public virtual TResult VisitConstructorInitializer(ConstructorInitializerSyntax node)" />
          <member def="public virtual TResult VisitContinueStatement(ContinueStatementSyntax node)" />
          <member def="public virtual TResult VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)" />
          <member def="public virtual TResult VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)" />
          <member def="public virtual TResult VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)" />
          <member def="public virtual TResult VisitCrefParameter(CrefParameterSyntax node)" />
          <member def="public virtual TResult VisitCrefParameterList(CrefParameterListSyntax node)" />
          <member def="public virtual TResult VisitDeclarationExpression(DeclarationExpressionSyntax node)" />
          <member def="public virtual TResult VisitDeclarationPattern(DeclarationPatternSyntax node)" />
          <member def="public virtual TResult VisitDefaultExpression(DefaultExpressionSyntax node)" />
          <member def="public virtual TResult VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)" />
          <member def="public virtual TResult VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitDelegateDeclaration(DelegateDeclarationSyntax node)" />
          <member def="public virtual TResult VisitDestructorDeclaration(DestructorDeclarationSyntax node)" />
          <member def="public virtual TResult VisitDiscardDesignation(DiscardDesignationSyntax node)" />
          <member def="public virtual TResult VisitDoStatement(DoStatementSyntax node)" />
          <member def="public virtual TResult VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)" />
          <member def="public virtual TResult VisitElementAccessExpression(ElementAccessExpressionSyntax node)" />
          <member def="public virtual TResult VisitElementBindingExpression(ElementBindingExpressionSyntax node)" />
          <member def="public virtual TResult VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitElseClause(ElseClauseSyntax node)" />
          <member def="public virtual TResult VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node)" />
          <member def="public virtual TResult VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitEnumDeclaration(EnumDeclarationSyntax node)" />
          <member def="public virtual TResult VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)" />
          <member def="public virtual TResult VisitEqualsValueClause(EqualsValueClauseSyntax node)" />
          <member def="public virtual TResult VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitEventDeclaration(EventDeclarationSyntax node)" />
          <member def="public virtual TResult VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)" />
          <member def="public virtual TResult VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)" />
          <member def="public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node)" />
          <member def="public virtual TResult VisitExternAliasDirective(ExternAliasDirectiveSyntax node)" />
          <member def="public virtual TResult VisitFieldDeclaration(FieldDeclarationSyntax node)" />
          <member def="public virtual TResult VisitFinallyClause(FinallyClauseSyntax node)" />
          <member def="public virtual TResult VisitFixedStatement(FixedStatementSyntax node)" />
          <member def="public virtual TResult VisitForEachStatement(ForEachStatementSyntax node)" />
          <member def="public virtual TResult VisitForEachVariableStatement(ForEachVariableStatementSyntax node)" />
          <member def="public virtual TResult VisitForStatement(ForStatementSyntax node)" />
          <member def="public virtual TResult VisitFromClause(FromClauseSyntax node)" />
          <member def="public virtual TResult VisitGenericName(GenericNameSyntax node)" />
          <member def="public virtual TResult VisitGlobalStatement(GlobalStatementSyntax node)" />
          <member def="public virtual TResult VisitGotoStatement(GotoStatementSyntax node)" />
          <member def="public virtual TResult VisitGroupClause(GroupClauseSyntax node)" />
          <member def="public virtual TResult VisitIdentifierName(IdentifierNameSyntax node)" />
          <member def="public virtual TResult VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitIfStatement(IfStatementSyntax node)" />
          <member def="public virtual TResult VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)" />
          <member def="public virtual TResult VisitImplicitElementAccess(ImplicitElementAccessSyntax node)" />
          <member def="public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node)" />
          <member def="public virtual TResult VisitIndexerDeclaration(IndexerDeclarationSyntax node)" />
          <member def="public virtual TResult VisitIndexerMemberCref(IndexerMemberCrefSyntax node)" />
          <member def="public virtual TResult VisitInitializerExpression(InitializerExpressionSyntax node)" />
          <member def="public virtual TResult VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)" />
          <member def="public virtual TResult VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)" />
          <member def="public virtual TResult VisitInterpolatedStringText(InterpolatedStringTextSyntax node)" />
          <member def="public virtual TResult VisitInterpolation(InterpolationSyntax node)" />
          <member def="public virtual TResult VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)" />
          <member def="public virtual TResult VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)" />
          <member def="public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node)" />
          <member def="public virtual TResult VisitIsPatternExpression(IsPatternExpressionSyntax node)" />
          <member def="public virtual TResult VisitJoinClause(JoinClauseSyntax node)" />
          <member def="public virtual TResult VisitJoinIntoClause(JoinIntoClauseSyntax node)" />
          <member def="public virtual TResult VisitLabeledStatement(LabeledStatementSyntax node)" />
          <member def="public virtual TResult VisitLetClause(LetClauseSyntax node)" />
          <member def="public virtual TResult VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node)" />
          <member def="public virtual TResult VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)" />
          <member def="public virtual TResult VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)" />
          <member def="public virtual TResult VisitLockStatement(LockStatementSyntax node)" />
          <member def="public virtual TResult VisitMakeRefExpression(MakeRefExpressionSyntax node)" />
          <member def="public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node)" />
          <member def="public virtual TResult VisitMemberBindingExpression(MemberBindingExpressionSyntax node)" />
          <member def="public virtual TResult VisitMethodDeclaration(MethodDeclarationSyntax node)" />
          <member def="public virtual TResult VisitNameColon(NameColonSyntax node)" />
          <member def="public virtual TResult VisitNameEquals(NameEqualsSyntax node)" />
          <member def="public virtual TResult VisitNameMemberCref(NameMemberCrefSyntax node)" />
          <member def="public virtual TResult VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)" />
          <member def="public virtual TResult VisitNullableType(NullableTypeSyntax node)" />
          <member def="public virtual TResult VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)" />
          <member def="public virtual TResult VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)" />
          <member def="public virtual TResult VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)" />
          <member def="public virtual TResult VisitOperatorDeclaration(OperatorDeclarationSyntax node)" />
          <member def="public virtual TResult VisitOperatorMemberCref(OperatorMemberCrefSyntax node)" />
          <member def="public virtual TResult VisitOrderByClause(OrderByClauseSyntax node)" />
          <member def="public virtual TResult VisitOrdering(OrderingSyntax node)" />
          <member def="public virtual TResult VisitParameter(ParameterSyntax node)" />
          <member def="public virtual TResult VisitParameterList(ParameterListSyntax node)" />
          <member def="public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)" />
          <member def="public virtual TResult VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)" />
          <member def="public virtual TResult VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)" />
          <member def="public virtual TResult VisitPointerType(PointerTypeSyntax node)" />
          <member def="public virtual TResult VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)" />
          <member def="public virtual TResult VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitPredefinedType(PredefinedTypeSyntax node)" />
          <member def="public virtual TResult VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)" />
          <member def="public virtual TResult VisitPropertyDeclaration(PropertyDeclarationSyntax node)" />
          <member def="public virtual TResult VisitQualifiedCref(QualifiedCrefSyntax node)" />
          <member def="public virtual TResult VisitQualifiedName(QualifiedNameSyntax node)" />
          <member def="public virtual TResult VisitQueryBody(QueryBodySyntax node)" />
          <member def="public virtual TResult VisitQueryContinuation(QueryContinuationSyntax node)" />
          <member def="public virtual TResult VisitQueryExpression(QueryExpressionSyntax node)" />
          <member def="public virtual TResult VisitRefExpression(RefExpressionSyntax node)" />
          <member def="public virtual TResult VisitRefType(RefTypeSyntax node)" />
          <member def="public virtual TResult VisitRefTypeExpression(RefTypeExpressionSyntax node)" />
          <member def="public virtual TResult VisitRefValueExpression(RefValueExpressionSyntax node)" />
          <member def="public virtual TResult VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitReturnStatement(ReturnStatementSyntax node)" />
          <member def="public virtual TResult VisitSelectClause(SelectClauseSyntax node)" />
          <member def="public virtual TResult VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitSimpleBaseType(SimpleBaseTypeSyntax node)" />
          <member def="public virtual TResult VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)" />
          <member def="public virtual TResult VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)" />
          <member def="public virtual TResult VisitSizeOfExpression(SizeOfExpressionSyntax node)" />
          <member def="public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)" />
          <member def="public virtual TResult VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)" />
          <member def="public virtual TResult VisitStructDeclaration(StructDeclarationSyntax node)" />
          <member def="public virtual TResult VisitSwitchSection(SwitchSectionSyntax node)" />
          <member def="public virtual TResult VisitSwitchStatement(SwitchStatementSyntax node)" />
          <member def="public virtual TResult VisitThisExpression(ThisExpressionSyntax node)" />
          <member def="public virtual TResult VisitThrowExpression(ThrowExpressionSyntax node)" />
          <member def="public virtual TResult VisitThrowStatement(ThrowStatementSyntax node)" />
          <member def="public virtual TResult VisitTryStatement(TryStatementSyntax node)" />
          <member def="public virtual TResult VisitTupleElement(TupleElementSyntax node)" />
          <member def="public virtual TResult VisitTupleExpression(TupleExpressionSyntax node)" />
          <member def="public virtual TResult VisitTupleType(TupleTypeSyntax node)" />
          <member def="public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node)" />
          <member def="public virtual TResult VisitTypeConstraint(TypeConstraintSyntax node)" />
          <member def="public virtual TResult VisitTypeCref(TypeCrefSyntax node)" />
          <member def="public virtual TResult VisitTypeOfExpression(TypeOfExpressionSyntax node)" />
          <member def="public virtual TResult VisitTypeParameter(TypeParameterSyntax node)" />
          <member def="public virtual TResult VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)" />
          <member def="public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node)" />
          <member def="public virtual TResult VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitUnsafeStatement(UnsafeStatementSyntax node)" />
          <member def="public virtual TResult VisitUsingDirective(UsingDirectiveSyntax node)" />
          <member def="public virtual TResult VisitUsingStatement(UsingStatementSyntax node)" />
          <member def="public virtual TResult VisitVariableDeclaration(VariableDeclarationSyntax node)" />
          <member def="public virtual TResult VisitVariableDeclarator(VariableDeclaratorSyntax node)" />
          <member def="public virtual TResult VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)" />
          <member def="public virtual TResult VisitWhenClause(WhenClauseSyntax node)" />
          <member def="public virtual TResult VisitWhereClause(WhereClauseSyntax node)" />
          <member def="public virtual TResult VisitWhileStatement(WhileStatementSyntax node)" />
          <member def="public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node)" />
          <member def="public virtual TResult VisitXmlComment(XmlCommentSyntax node)" />
          <member def="public virtual TResult VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)" />
          <member def="public virtual TResult VisitXmlElement(XmlElementSyntax node)" />
          <member def="public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node)" />
          <member def="public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node)" />
          <member def="public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node)" />
          <member def="public virtual TResult VisitXmlName(XmlNameSyntax node)" />
          <member def="public virtual TResult VisitXmlNameAttribute(XmlNameAttributeSyntax node)" />
          <member def="public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node)" />
          <member def="public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)" />
          <member def="public virtual TResult VisitXmlText(XmlTextSyntax node)" />
          <member def="public virtual TResult VisitXmlTextAttribute(XmlTextAttributeSyntax node)" />
          <member def="public virtual TResult VisitYieldStatement(YieldStatementSyntax node)" />
        </members>
        <type def="public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter : CSharpSyntaxVisitor&lt;SyntaxNode&gt;">
          <members>
            <member def="public CSharpSyntaxRewriter(bool visitIntoStructuredTrivia = false)" />
            <member def="public virtual bool VisitIntoStructuredTrivia { get; }" />
            <member def="public override SyntaxNode Visit(SyntaxNode node)" />
            <member def="public override SyntaxNode VisitAccessorDeclaration(AccessorDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitAccessorList(AccessorListSyntax node)" />
            <member def="public override SyntaxNode VisitAliasQualifiedName(AliasQualifiedNameSyntax node)" />
            <member def="public override SyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)" />
            <member def="public override SyntaxNode VisitArgument(ArgumentSyntax node)" />
            <member def="public override SyntaxNode VisitArgumentList(ArgumentListSyntax node)" />
            <member def="public override SyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)" />
            <member def="public override SyntaxNode VisitArrayType(ArrayTypeSyntax node)" />
            <member def="public override SyntaxNode VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)" />
            <member def="public override SyntaxNode VisitAssignmentExpression(AssignmentExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitAttribute(AttributeSyntax node)" />
            <member def="public override SyntaxNode VisitAttributeArgument(AttributeArgumentSyntax node)" />
            <member def="public override SyntaxNode VisitAttributeArgumentList(AttributeArgumentListSyntax node)" />
            <member def="public override SyntaxNode VisitAttributeList(AttributeListSyntax node)" />
            <member def="public override SyntaxNode VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)" />
            <member def="public override SyntaxNode VisitAwaitExpression(AwaitExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitBaseExpression(BaseExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitBaseList(BaseListSyntax node)" />
            <member def="public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitBlock(BlockSyntax node)" />
            <member def="public override SyntaxNode VisitBracketedArgumentList(BracketedArgumentListSyntax node)" />
            <member def="public override SyntaxNode VisitBracketedParameterList(BracketedParameterListSyntax node)" />
            <member def="public override SyntaxNode VisitBreakStatement(BreakStatementSyntax node)" />
            <member def="public override SyntaxNode VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)" />
            <member def="public override SyntaxNode VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)" />
            <member def="public override SyntaxNode VisitCastExpression(CastExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitCatchClause(CatchClauseSyntax node)" />
            <member def="public override SyntaxNode VisitCatchDeclaration(CatchDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node)" />
            <member def="public override SyntaxNode VisitCheckedExpression(CheckedExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitCheckedStatement(CheckedStatementSyntax node)" />
            <member def="public override SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)" />
            <member def="public override SyntaxNode VisitCompilationUnit(CompilationUnitSyntax node)" />
            <member def="public override SyntaxNode VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitConstantPattern(ConstantPatternSyntax node)" />
            <member def="public override SyntaxNode VisitConstructorConstraint(ConstructorConstraintSyntax node)" />
            <member def="public override SyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitConstructorInitializer(ConstructorInitializerSyntax node)" />
            <member def="public override SyntaxNode VisitContinueStatement(ContinueStatementSyntax node)" />
            <member def="public override SyntaxNode VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)" />
            <member def="public override SyntaxNode VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)" />
            <member def="public override SyntaxNode VisitCrefParameter(CrefParameterSyntax node)" />
            <member def="public override SyntaxNode VisitCrefParameterList(CrefParameterListSyntax node)" />
            <member def="public override SyntaxNode VisitDeclarationExpression(DeclarationExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitDeclarationPattern(DeclarationPatternSyntax node)" />
            <member def="public override SyntaxNode VisitDefaultExpression(DefaultExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)" />
            <member def="public override SyntaxNode VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitDelegateDeclaration(DelegateDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitDestructorDeclaration(DestructorDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitDiscardDesignation(DiscardDesignationSyntax node)" />
            <member def="public override SyntaxNode VisitDoStatement(DoStatementSyntax node)" />
            <member def="public override SyntaxNode VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitElementBindingExpression(ElementBindingExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitElseClause(ElseClauseSyntax node)" />
            <member def="public override SyntaxNode VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitEmptyStatement(EmptyStatementSyntax node)" />
            <member def="public override SyntaxNode VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitEqualsValueClause(EqualsValueClauseSyntax node)" />
            <member def="public override SyntaxNode VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitEventDeclaration(EventDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)" />
            <member def="public override SyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node)" />
            <member def="public override SyntaxNode VisitExternAliasDirective(ExternAliasDirectiveSyntax node)" />
            <member def="public override SyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitFinallyClause(FinallyClauseSyntax node)" />
            <member def="public override SyntaxNode VisitFixedStatement(FixedStatementSyntax node)" />
            <member def="public override SyntaxNode VisitForEachStatement(ForEachStatementSyntax node)" />
            <member def="public override SyntaxNode VisitForEachVariableStatement(ForEachVariableStatementSyntax node)" />
            <member def="public override SyntaxNode VisitForStatement(ForStatementSyntax node)" />
            <member def="public override SyntaxNode VisitFromClause(FromClauseSyntax node)" />
            <member def="public override SyntaxNode VisitGenericName(GenericNameSyntax node)" />
            <member def="public override SyntaxNode VisitGlobalStatement(GlobalStatementSyntax node)" />
            <member def="public override SyntaxNode VisitGotoStatement(GotoStatementSyntax node)" />
            <member def="public override SyntaxNode VisitGroupClause(GroupClauseSyntax node)" />
            <member def="public override SyntaxNode VisitIdentifierName(IdentifierNameSyntax node)" />
            <member def="public override SyntaxNode VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitIfStatement(IfStatementSyntax node)" />
            <member def="public override SyntaxNode VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitImplicitElementAccess(ImplicitElementAccessSyntax node)" />
            <member def="public override SyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node)" />
            <member def="public override SyntaxNode VisitIndexerDeclaration(IndexerDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitIndexerMemberCref(IndexerMemberCrefSyntax node)" />
            <member def="public override SyntaxNode VisitInitializerExpression(InitializerExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node)" />
            <member def="public override SyntaxNode VisitInterpolation(InterpolationSyntax node)" />
            <member def="public override SyntaxNode VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)" />
            <member def="public override SyntaxNode VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)" />
            <member def="public override SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitIsPatternExpression(IsPatternExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitJoinClause(JoinClauseSyntax node)" />
            <member def="public override SyntaxNode VisitJoinIntoClause(JoinIntoClauseSyntax node)" />
            <member def="public override SyntaxNode VisitLabeledStatement(LabeledStatementSyntax node)" />
            <member def="public override SyntaxNode VisitLetClause(LetClauseSyntax node)" />
            <member def="public override SyntaxNode VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)" />
            <member def="public virtual SyntaxTokenList VisitList(SyntaxTokenList list)" />
            <member def="public virtual SyntaxTriviaList VisitList(SyntaxTriviaList list)" />
            <member def="public virtual SyntaxList&lt;TNode&gt; VisitList&lt;TNode&gt;(SyntaxList&lt;TNode&gt; list) where TNode : SyntaxNode" />
            <member def="public virtual SeparatedSyntaxList&lt;TNode&gt; VisitList&lt;TNode&gt;(SeparatedSyntaxList&lt;TNode&gt; list) where TNode : SyntaxNode" />
            <member def="public virtual SyntaxTrivia VisitListElement(SyntaxTrivia element)" />
            <member def="public virtual TNode VisitListElement&lt;TNode&gt;(TNode node) where TNode : SyntaxNode" />
            <member def="public virtual SyntaxToken VisitListSeparator(SyntaxToken separator)" />
            <member def="public override SyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)" />
            <member def="public override SyntaxNode VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)" />
            <member def="public override SyntaxNode VisitLockStatement(LockStatementSyntax node)" />
            <member def="public override SyntaxNode VisitMakeRefExpression(MakeRefExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitMemberBindingExpression(MemberBindingExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitNameColon(NameColonSyntax node)" />
            <member def="public override SyntaxNode VisitNameEquals(NameEqualsSyntax node)" />
            <member def="public override SyntaxNode VisitNameMemberCref(NameMemberCrefSyntax node)" />
            <member def="public override SyntaxNode VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitNullableType(NullableTypeSyntax node)" />
            <member def="public override SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)" />
            <member def="public override SyntaxNode VisitOperatorDeclaration(OperatorDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitOperatorMemberCref(OperatorMemberCrefSyntax node)" />
            <member def="public override SyntaxNode VisitOrderByClause(OrderByClauseSyntax node)" />
            <member def="public override SyntaxNode VisitOrdering(OrderingSyntax node)" />
            <member def="public override SyntaxNode VisitParameter(ParameterSyntax node)" />
            <member def="public override SyntaxNode VisitParameterList(ParameterListSyntax node)" />
            <member def="public override SyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)" />
            <member def="public override SyntaxNode VisitPointerType(PointerTypeSyntax node)" />
            <member def="public override SyntaxNode VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitPredefinedType(PredefinedTypeSyntax node)" />
            <member def="public override SyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitQualifiedCref(QualifiedCrefSyntax node)" />
            <member def="public override SyntaxNode VisitQualifiedName(QualifiedNameSyntax node)" />
            <member def="public override SyntaxNode VisitQueryBody(QueryBodySyntax node)" />
            <member def="public override SyntaxNode VisitQueryContinuation(QueryContinuationSyntax node)" />
            <member def="public override SyntaxNode VisitQueryExpression(QueryExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitRefExpression(RefExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitRefType(RefTypeSyntax node)" />
            <member def="public override SyntaxNode VisitRefTypeExpression(RefTypeExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitRefValueExpression(RefValueExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitReturnStatement(ReturnStatementSyntax node)" />
            <member def="public override SyntaxNode VisitSelectClause(SelectClauseSyntax node)" />
            <member def="public override SyntaxNode VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitSimpleBaseType(SimpleBaseTypeSyntax node)" />
            <member def="public override SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)" />
            <member def="public override SyntaxNode VisitSizeOfExpression(SizeOfExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitStructDeclaration(StructDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitSwitchSection(SwitchSectionSyntax node)" />
            <member def="public override SyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)" />
            <member def="public override SyntaxNode VisitThisExpression(ThisExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitThrowExpression(ThrowExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitThrowStatement(ThrowStatementSyntax node)" />
            <member def="public virtual SyntaxToken VisitToken(SyntaxToken token)" />
            <member def="public virtual SyntaxTrivia VisitTrivia(SyntaxTrivia trivia)" />
            <member def="public override SyntaxNode VisitTryStatement(TryStatementSyntax node)" />
            <member def="public override SyntaxNode VisitTupleElement(TupleElementSyntax node)" />
            <member def="public override SyntaxNode VisitTupleExpression(TupleExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitTupleType(TupleTypeSyntax node)" />
            <member def="public override SyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node)" />
            <member def="public override SyntaxNode VisitTypeConstraint(TypeConstraintSyntax node)" />
            <member def="public override SyntaxNode VisitTypeCref(TypeCrefSyntax node)" />
            <member def="public override SyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node)" />
            <member def="public override SyntaxNode VisitTypeParameter(TypeParameterSyntax node)" />
            <member def="public override SyntaxNode VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)" />
            <member def="public override SyntaxNode VisitTypeParameterList(TypeParameterListSyntax node)" />
            <member def="public override SyntaxNode VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitUnsafeStatement(UnsafeStatementSyntax node)" />
            <member def="public override SyntaxNode VisitUsingDirective(UsingDirectiveSyntax node)" />
            <member def="public override SyntaxNode VisitUsingStatement(UsingStatementSyntax node)" />
            <member def="public override SyntaxNode VisitVariableDeclaration(VariableDeclarationSyntax node)" />
            <member def="public override SyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node)" />
            <member def="public override SyntaxNode VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)" />
            <member def="public override SyntaxNode VisitWhenClause(WhenClauseSyntax node)" />
            <member def="public override SyntaxNode VisitWhereClause(WhereClauseSyntax node)" />
            <member def="public override SyntaxNode VisitWhileStatement(WhileStatementSyntax node)" />
            <member def="public override SyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node)" />
            <member def="public override SyntaxNode VisitXmlComment(XmlCommentSyntax node)" />
            <member def="public override SyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)" />
            <member def="public override SyntaxNode VisitXmlElement(XmlElementSyntax node)" />
            <member def="public override SyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node)" />
            <member def="public override SyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node)" />
            <member def="public override SyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node)" />
            <member def="public override SyntaxNode VisitXmlName(XmlNameSyntax node)" />
            <member def="public override SyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node)" />
            <member def="public override SyntaxNode VisitXmlPrefix(XmlPrefixSyntax node)" />
            <member def="public override SyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)" />
            <member def="public override SyntaxNode VisitXmlText(XmlTextSyntax node)" />
            <member def="public override SyntaxNode VisitXmlTextAttribute(XmlTextAttributeSyntax node)" />
            <member def="public override SyntaxNode VisitYieldStatement(YieldStatementSyntax node)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.CodeActions.CodeAction">
        <members>
          <member def="protected CodeAction()" />
          <member def="public virtual string EquivalenceKey { get; }" />
          <member def="public virtual ImmutableArray&lt;string&gt; Tags { get; }" />
          <member def="public abstract string Title { get; }" />
          <member def="protected virtual Task&lt;IEnumerable&lt;CodeActionOperation&gt;&gt; ComputeOperationsAsync(CancellationToken cancellationToken)" />
          <member def="protected virtual Task&lt;IEnumerable&lt;CodeActionOperation&gt;&gt; ComputePreviewOperationsAsync(CancellationToken cancellationToken)" />
          <member def="public static CodeAction Create(string title, Func&lt;CancellationToken, Task&lt;Document&gt;&gt; createChangedDocument, string equivalenceKey = null)" />
          <member def="public static CodeAction Create(string title, Func&lt;CancellationToken, Task&lt;Solution&gt;&gt; createChangedSolution, string equivalenceKey = null)" />
          <member def="protected virtual Task&lt;Document&gt; GetChangedDocumentAsync(CancellationToken cancellationToken)" />
          <member def="protected virtual Task&lt;Solution&gt; GetChangedSolutionAsync(CancellationToken cancellationToken)" />
          <member def="public Task&lt;ImmutableArray&lt;CodeActionOperation&gt;&gt; GetOperationsAsync(CancellationToken cancellationToken)" />
          <member def="public Task&lt;ImmutableArray&lt;CodeActionOperation&gt;&gt; GetPreviewOperationsAsync(CancellationToken cancellationToken)" />
          <member def="protected Task&lt;ImmutableArray&lt;CodeActionOperation&gt;&gt; PostProcessAsync(IEnumerable&lt;CodeActionOperation&gt; operations, CancellationToken cancellationToken)" />
          <member def="protected Task&lt;Solution&gt; PostProcessChangesAsync(Solution changedSolution, CancellationToken cancellationToken)" />
          <member def="protected virtual Task&lt;Document&gt; PostProcessChangesAsync(Document document, CancellationToken cancellationToken)" />
        </members>
        <type def="public abstract class Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions : CodeAction">
          <members>
            <member def="protected CodeActionWithOptions()" />
            <member def="protected override Task&lt;IEnumerable&lt;CodeActionOperation&gt;&gt; ComputeOperationsAsync(CancellationToken cancellationToken)" />
            <member def="protected abstract Task&lt;IEnumerable&lt;CodeActionOperation&gt;&gt; ComputeOperationsAsync(object options, CancellationToken cancellationToken)" />
            <member def="public Task&lt;IEnumerable&lt;CodeActionOperation&gt;&gt; GetOperationsAsync(object options, CancellationToken cancellationToken)" />
            <member def="public abstract object GetOptions(CancellationToken cancellationToken)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.CodeActions.CodeActionOperation">
        <members>
          <member def="protected CodeActionOperation()" />
          <member def="public virtual string Title { get; }" />
          <member def="public virtual void Apply(Workspace workspace, CancellationToken cancellationToken)" />
        </members>
        <type def="public sealed class Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation : CodeActionOperation">
          <members>
            <member def="public ApplyChangesOperation(Solution changedSolution)" />
            <member def="public Solution ChangedSolution { get; }" />
            <member def="public override void Apply(Workspace workspace, CancellationToken cancellationToken)" />
          </members>
        </type>
        <type def="public sealed class Microsoft.CodeAnalysis.CodeActions.OpenDocumentOperation : CodeActionOperation">
          <members>
            <member def="public OpenDocumentOperation(DocumentId documentId, bool activateIfAlreadyOpen = false)" />
            <member def="public DocumentId DocumentId { get; }" />
            <member def="public override void Apply(Workspace workspace, CancellationToken cancellationToken)" />
          </members>
        </type>
        <type def="public abstract class Microsoft.CodeAnalysis.CodeActions.PreviewOperation : CodeActionOperation">
          <members>
            <member def="protected PreviewOperation()" />
            <member def="public abstract Task&lt;object&gt; GetPreviewAsync(CancellationToken cancellationToken)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider">
        <members>
          <member def="protected CodeFixProvider()" />
          <member def="public abstract ImmutableArray&lt;string&gt; FixableDiagnosticIds { get; }" />
          <member def="public virtual FixAllProvider GetFixAllProvider()" />
          <member def="public abstract Task RegisterCodeFixesAsync(CodeFixContext context)" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.CodeFixes.FixAllContext">
        <members>
          <member def="public FixAllContext(Document document, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable&lt;string&gt; diagnosticIds, FixAllContext.DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken)" />
          <member def="public FixAllContext(Project project, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable&lt;string&gt; diagnosticIds, FixAllContext.DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken)" />
          <member def="public CancellationToken CancellationToken { get; }" />
          <member def="public string CodeActionEquivalenceKey { get; }" />
          <member def="public CodeFixProvider CodeFixProvider { get; }" />
          <member def="public ImmutableHashSet&lt;string&gt; DiagnosticIds { get; }" />
          <member def="public Document Document { get; }" />
          <member def="public Project Project { get; }" />
          <member def="public FixAllScope Scope { get; }" />
          <member def="public Solution Solution { get; }" />
          <member def="public Task&lt;ImmutableArray&lt;Diagnostic&gt;&gt; GetAllDiagnosticsAsync(Project project)" />
          <member def="public Task&lt;ImmutableArray&lt;Diagnostic&gt;&gt; GetDocumentDiagnosticsAsync(Document document)" />
          <member def="public Task&lt;ImmutableArray&lt;Diagnostic&gt;&gt; GetProjectDiagnosticsAsync(Project project)" />
          <member def="public FixAllContext WithCancellationToken(CancellationToken cancellationToken)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider">
        <members>
          <member def="protected DiagnosticProvider()" />
          <member def="public abstract Task&lt;IEnumerable&lt;Diagnostic&gt;&gt; GetAllDiagnosticsAsync(Project project, CancellationToken cancellationToken)" />
          <member def="public abstract Task&lt;IEnumerable&lt;Diagnostic&gt;&gt; GetDocumentDiagnosticsAsync(Document document, CancellationToken cancellationToken)" />
          <member def="public abstract Task&lt;IEnumerable&lt;Diagnostic&gt;&gt; GetProjectDiagnosticsAsync(Project project, CancellationToken cancellationToken)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.CodeFixes.FixAllProvider">
        <members>
          <member def="protected FixAllProvider()" />
          <member def="public abstract Task&lt;CodeAction&gt; GetFixAsync(FixAllContext fixAllContext)" />
          <member def="public virtual IEnumerable&lt;string&gt; GetSupportedFixAllDiagnosticIds(CodeFixProvider originalCodeFixProvider)" />
          <member def="public virtual IEnumerable&lt;FixAllScope&gt; GetSupportedFixAllScopes()" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider">
        <members>
          <member def="protected CodeRefactoringProvider()" />
          <member def="public abstract Task ComputeRefactoringsAsync(CodeRefactoringContext context)" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption&lt;T&gt; : IEquatable&lt;CodeStyleOption&lt;T&gt;&gt;, ICodeStyleOption">
        <members>
          <member def="public CodeStyleOption(T value, NotificationOption notification)" />
          <member def="public static CodeStyleOption&lt;T&gt; Default { get; }" />
          <member def="public NotificationOption Notification { get; set; }" />
          <member def="public T Value { get; set; }" />
          <member def="public override bool Equals(object obj)" />
          <member def="public bool Equals(CodeStyleOption&lt;T&gt; other)" />
          <member def="public static CodeStyleOption&lt;T&gt; FromXElement(XElement element)" />
          <member def="public override int GetHashCode()" />
          <member def="public XElement ToXElement()" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions">
        <members>
          <member def="public static readonly PerLanguageOption&lt;CodeStyleOption&lt;bool&gt;&gt; PreferIntrinsicPredefinedTypeKeywordInDeclaration" />
          <member def="public static readonly PerLanguageOption&lt;CodeStyleOption&lt;bool&gt;&gt; PreferIntrinsicPredefinedTypeKeywordInMemberAccess" />
          <member def="public static readonly PerLanguageOption&lt;CodeStyleOption&lt;bool&gt;&gt; QualifyEventAccess" />
          <member def="public static readonly PerLanguageOption&lt;CodeStyleOption&lt;bool&gt;&gt; QualifyFieldAccess" />
          <member def="public static readonly PerLanguageOption&lt;CodeStyleOption&lt;bool&gt;&gt; QualifyMethodAccess" />
          <member def="public static readonly PerLanguageOption&lt;CodeStyleOption&lt;bool&gt;&gt; QualifyPropertyAccess" />
          <member def="public CodeStyleOptions()" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.CodeStyle.NotificationOption">
        <members>
          <member def="public static readonly NotificationOption Error" />
          <member def="public static readonly NotificationOption None" />
          <member def="public static readonly NotificationOption Suggestion" />
          <member def="public static readonly NotificationOption Warning" />
          <member def="public string Name { get; set; }" />
          <member def="public DiagnosticSeverity Value { get; set; }" />
          <member def="public override string ToString()" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Diagnostics.AnalysisContext">
        <members>
          <member def="protected AnalysisContext()" />
          <member def="public virtual void ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags analysisMode)" />
          <member def="public virtual void EnableConcurrentExecution()" />
          <member def="public abstract void RegisterCodeBlockAction(Action&lt;CodeBlockAnalysisContext&gt; action)" />
          <member def="public abstract void RegisterCodeBlockStartAction&lt;TLanguageKindEnum&gt;(Action&lt;CodeBlockStartAnalysisContext&lt;TLanguageKindEnum&gt;&gt; action) where TLanguageKindEnum : struct" />
          <member def="public abstract void RegisterCompilationAction(Action&lt;CompilationAnalysisContext&gt; action)" />
          <member def="public abstract void RegisterCompilationStartAction(Action&lt;CompilationStartAnalysisContext&gt; action)" />
          <member def="public void RegisterOperationAction(Action&lt;OperationAnalysisContext&gt; action, params OperationKind[] operationKinds)" />
          <member def="public virtual void RegisterOperationAction(Action&lt;OperationAnalysisContext&gt; action, ImmutableArray&lt;OperationKind&gt; operationKinds)" />
          <member def="public virtual void RegisterOperationBlockAction(Action&lt;OperationBlockAnalysisContext&gt; action)" />
          <member def="public virtual void RegisterOperationBlockStartAction(Action&lt;OperationBlockStartAnalysisContext&gt; action)" />
          <member def="public abstract void RegisterSemanticModelAction(Action&lt;SemanticModelAnalysisContext&gt; action)" />
          <member def="public void RegisterSymbolAction(Action&lt;SymbolAnalysisContext&gt; action, params SymbolKind[] symbolKinds)" />
          <member def="public abstract void RegisterSymbolAction(Action&lt;SymbolAnalysisContext&gt; action, ImmutableArray&lt;SymbolKind&gt; symbolKinds)" />
          <member def="public void RegisterSyntaxNodeAction&lt;TLanguageKindEnum&gt;(Action&lt;SyntaxNodeAnalysisContext&gt; action, params TLanguageKindEnum[] syntaxKinds) where TLanguageKindEnum : struct" />
          <member def="public abstract void RegisterSyntaxNodeAction&lt;TLanguageKindEnum&gt;(Action&lt;SyntaxNodeAnalysisContext&gt; action, ImmutableArray&lt;TLanguageKindEnum&gt; syntaxKinds) where TLanguageKindEnum : struct" />
          <member def="public abstract void RegisterSyntaxTreeAction(Action&lt;SyntaxTreeAnalysisContext&gt; action)" />
          <member def="public bool TryGetValue&lt;TValue&gt;(SourceText text, SourceTextValueProvider&lt;TValue&gt; valueProvider, out TValue value)" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.Diagnostics.AnalysisResult">
        <members>
          <member def="public ImmutableDictionary&lt;DiagnosticAnalyzer, AnalyzerTelemetryInfo&gt; AnalyzerTelemetryInfo { get; }" />
          <member def="public ImmutableArray&lt;DiagnosticAnalyzer&gt; Analyzers { get; }" />
          <member def="public ImmutableDictionary&lt;DiagnosticAnalyzer, ImmutableArray&lt;Diagnostic&gt;&gt; CompilationDiagnostics { get; }" />
          <member def="public ImmutableDictionary&lt;SyntaxTree, ImmutableDictionary&lt;DiagnosticAnalyzer, ImmutableArray&lt;Diagnostic&gt;&gt;&gt; SemanticDiagnostics { get; }" />
          <member def="public ImmutableDictionary&lt;SyntaxTree, ImmutableDictionary&lt;DiagnosticAnalyzer, ImmutableArray&lt;Diagnostic&gt;&gt;&gt; SyntaxDiagnostics { get; }" />
          <member def="public ImmutableArray&lt;Diagnostic&gt; GetAllDiagnostics()" />
          <member def="public ImmutableArray&lt;Diagnostic&gt; GetAllDiagnostics(DiagnosticAnalyzer analyzer)" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions">
        <members>
          <member def="public AnalyzerOptions(ImmutableArray&lt;AdditionalText&gt; additionalFiles)" />
          <member def="public ImmutableArray&lt;AdditionalText&gt; AdditionalFiles { get; }" />
          <member def="public override bool Equals(object obj)" />
          <member def="public override int GetHashCode()" />
          <member def="public AnalyzerOptions WithAdditionalFiles(ImmutableArray&lt;AdditionalText&gt; additionalFiles)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference">
        <members>
          <member def="protected AnalyzerReference()" />
          <member def="public virtual string Display { get; }" />
          <member def="public abstract string FullPath { get; }" />
          <member def="public abstract object Id { get; }" />
          <member def="public abstract ImmutableArray&lt;DiagnosticAnalyzer&gt; GetAnalyzers(string language)" />
          <member def="public abstract ImmutableArray&lt;DiagnosticAnalyzer&gt; GetAnalyzersForAllLanguages()" />
        </members>
        <type def="public sealed class Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference : AnalyzerReference, IEquatable&lt;AnalyzerReference&gt;">
          <members>
            <member def="public AnalyzerFileReference(string fullPath, IAnalyzerAssemblyLoader assemblyLoader)" />
            <member def="public event EventHandler&lt;AnalyzerLoadFailureEventArgs&gt; AnalyzerLoadFailed" />
            <member def="public override string Display { get; }" />
            <member def="public override string FullPath { get; }" />
            <member def="public override object Id { get; }" />
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(AnalyzerReference other)" />
            <member def="public override ImmutableArray&lt;DiagnosticAnalyzer&gt; GetAnalyzers(string language)" />
            <member def="public override ImmutableArray&lt;DiagnosticAnalyzer&gt; GetAnalyzersForAllLanguages()" />
            <member def="public Assembly GetAssembly()" />
            <member def="public override int GetHashCode()" />
          </members>
        </type>
        <type def="public sealed class Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference : AnalyzerReference">
          <members>
            <member def="public AnalyzerImageReference(ImmutableArray&lt;DiagnosticAnalyzer&gt; analyzers, string fullPath = null, string display = null)" />
            <member def="public override string Display { get; }" />
            <member def="public override string FullPath { get; }" />
            <member def="public override object Id { get; }" />
            <member def="public override ImmutableArray&lt;DiagnosticAnalyzer&gt; GetAnalyzers(string language)" />
            <member def="public override ImmutableArray&lt;DiagnosticAnalyzer&gt; GetAnalyzersForAllLanguages()" />
          </members>
        </type>
        <type def="public sealed class Microsoft.CodeAnalysis.Diagnostics.UnresolvedAnalyzerReference : AnalyzerReference">
          <members>
            <member def="public UnresolvedAnalyzerReference(string unresolvedPath)" />
            <member def="public override string Display { get; }" />
            <member def="public override string FullPath { get; }" />
            <member def="public override object Id { get; }" />
            <member def="public override ImmutableArray&lt;DiagnosticAnalyzer&gt; GetAnalyzers(string language)" />
            <member def="public override ImmutableArray&lt;DiagnosticAnalyzer&gt; GetAnalyzersForAllLanguages()" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext&lt;TLanguageKindEnum&gt; where TLanguageKindEnum : struct">
        <members>
          <member def="protected CodeBlockStartAnalysisContext(SyntaxNode codeBlock, ISymbol owningSymbol, SemanticModel semanticModel, AnalyzerOptions options, CancellationToken cancellationToken)" />
          <member def="public CancellationToken CancellationToken { get; }" />
          <member def="public SyntaxNode CodeBlock { get; }" />
          <member def="public AnalyzerOptions Options { get; }" />
          <member def="public ISymbol OwningSymbol { get; }" />
          <member def="public SemanticModel SemanticModel { get; }" />
          <member def="public abstract void RegisterCodeBlockEndAction(Action&lt;CodeBlockAnalysisContext&gt; action)" />
          <member def="public void RegisterSyntaxNodeAction(Action&lt;SyntaxNodeAnalysisContext&gt; action, params TLanguageKindEnum[] syntaxKinds)" />
          <member def="public abstract void RegisterSyntaxNodeAction(Action&lt;SyntaxNodeAnalysisContext&gt; action, ImmutableArray&lt;TLanguageKindEnum&gt; syntaxKinds)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext">
        <members>
          <member def="protected CompilationStartAnalysisContext(Compilation compilation, AnalyzerOptions options, CancellationToken cancellationToken)" />
          <member def="public CancellationToken CancellationToken { get; }" />
          <member def="public Compilation Compilation { get; }" />
          <member def="public AnalyzerOptions Options { get; }" />
          <member def="public abstract void RegisterCodeBlockAction(Action&lt;CodeBlockAnalysisContext&gt; action)" />
          <member def="public abstract void RegisterCodeBlockStartAction&lt;TLanguageKindEnum&gt;(Action&lt;CodeBlockStartAnalysisContext&lt;TLanguageKindEnum&gt;&gt; action) where TLanguageKindEnum : struct" />
          <member def="public abstract void RegisterCompilationEndAction(Action&lt;CompilationAnalysisContext&gt; action)" />
          <member def="public void RegisterOperationAction(Action&lt;OperationAnalysisContext&gt; action, params OperationKind[] operationKinds)" />
          <member def="public virtual void RegisterOperationAction(Action&lt;OperationAnalysisContext&gt; action, ImmutableArray&lt;OperationKind&gt; operationKinds)" />
          <member def="public virtual void RegisterOperationBlockAction(Action&lt;OperationBlockAnalysisContext&gt; action)" />
          <member def="public virtual void RegisterOperationBlockStartAction(Action&lt;OperationBlockStartAnalysisContext&gt; action)" />
          <member def="public abstract void RegisterSemanticModelAction(Action&lt;SemanticModelAnalysisContext&gt; action)" />
          <member def="public void RegisterSymbolAction(Action&lt;SymbolAnalysisContext&gt; action, params SymbolKind[] symbolKinds)" />
          <member def="public abstract void RegisterSymbolAction(Action&lt;SymbolAnalysisContext&gt; action, ImmutableArray&lt;SymbolKind&gt; symbolKinds)" />
          <member def="public void RegisterSyntaxNodeAction&lt;TLanguageKindEnum&gt;(Action&lt;SyntaxNodeAnalysisContext&gt; action, params TLanguageKindEnum[] syntaxKinds) where TLanguageKindEnum : struct" />
          <member def="public abstract void RegisterSyntaxNodeAction&lt;TLanguageKindEnum&gt;(Action&lt;SyntaxNodeAnalysisContext&gt; action, ImmutableArray&lt;TLanguageKindEnum&gt; syntaxKinds) where TLanguageKindEnum : struct" />
          <member def="public abstract void RegisterSyntaxTreeAction(Action&lt;SyntaxTreeAnalysisContext&gt; action)" />
          <member def="public bool TryGetValue&lt;TValue&gt;(SourceText text, SourceTextValueProvider&lt;TValue&gt; valueProvider, out TValue value)" />
          <member def="public bool TryGetValue&lt;TValue&gt;(SyntaxTree tree, SyntaxTreeValueProvider&lt;TValue&gt; valueProvider, out TValue value)" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers">
        <members>
          <member def="public CompilationWithAnalyzers(Compilation compilation, ImmutableArray&lt;DiagnosticAnalyzer&gt; analyzers, CompilationWithAnalyzersOptions analysisOptions)" />
          <member def="public CompilationWithAnalyzers(Compilation compilation, ImmutableArray&lt;DiagnosticAnalyzer&gt; analyzers, AnalyzerOptions options, CancellationToken cancellationToken)" />
          <member def="public CompilationWithAnalyzersOptions AnalysisOptions { get; }" />
          <member def="public ImmutableArray&lt;DiagnosticAnalyzer&gt; Analyzers { get; }" />
          <member def="public CancellationToken CancellationToken { get; }" />
          <member def="public Compilation Compilation { get; }" />
          <member def="public static void ClearAnalyzerState(ImmutableArray&lt;DiagnosticAnalyzer&gt; analyzers)" />
          <member def="public Task&lt;ImmutableArray&lt;Diagnostic&gt;&gt; GetAllDiagnosticsAsync()" />
          <member def="public Task&lt;ImmutableArray&lt;Diagnostic&gt;&gt; GetAllDiagnosticsAsync(CancellationToken cancellationToken)" />
          <member def="public Task&lt;AnalysisResult&gt; GetAnalysisResultAsync(CancellationToken cancellationToken)" />
          <member def="public Task&lt;AnalysisResult&gt; GetAnalysisResultAsync(ImmutableArray&lt;DiagnosticAnalyzer&gt; analyzers, CancellationToken cancellationToken)" />
          <member def="public Task&lt;ImmutableArray&lt;Diagnostic&gt;&gt; GetAnalyzerCompilationDiagnosticsAsync(CancellationToken cancellationToken)" />
          <member def="public Task&lt;ImmutableArray&lt;Diagnostic&gt;&gt; GetAnalyzerCompilationDiagnosticsAsync(ImmutableArray&lt;DiagnosticAnalyzer&gt; analyzers, CancellationToken cancellationToken)" />
          <member def="public Task&lt;ImmutableArray&lt;Diagnostic&gt;&gt; GetAnalyzerDiagnosticsAsync()" />
          <member def="public Task&lt;ImmutableArray&lt;Diagnostic&gt;&gt; GetAnalyzerDiagnosticsAsync(CancellationToken cancellationToken)" />
          <member def="public Task&lt;ImmutableArray&lt;Diagnostic&gt;&gt; GetAnalyzerDiagnosticsAsync(ImmutableArray&lt;DiagnosticAnalyzer&gt; analyzers, CancellationToken cancellationToken)" />
          <member def="public Task&lt;ImmutableArray&lt;Diagnostic&gt;&gt; GetAnalyzerSemanticDiagnosticsAsync(SemanticModel model, TextSpan? filterSpan, CancellationToken cancellationToken)" />
          <member def="public Task&lt;ImmutableArray&lt;Diagnostic&gt;&gt; GetAnalyzerSemanticDiagnosticsAsync(SemanticModel model, TextSpan? filterSpan, ImmutableArray&lt;DiagnosticAnalyzer&gt; analyzers, CancellationToken cancellationToken)" />
          <member def="public Task&lt;ImmutableArray&lt;Diagnostic&gt;&gt; GetAnalyzerSyntaxDiagnosticsAsync(SyntaxTree tree, CancellationToken cancellationToken)" />
          <member def="public Task&lt;ImmutableArray&lt;Diagnostic&gt;&gt; GetAnalyzerSyntaxDiagnosticsAsync(SyntaxTree tree, ImmutableArray&lt;DiagnosticAnalyzer&gt; analyzers, CancellationToken cancellationToken)" />
          <member def="public Task&lt;AnalyzerTelemetryInfo&gt; GetAnalyzerTelemetryInfoAsync(DiagnosticAnalyzer analyzer, CancellationToken cancellationToken)" />
          <member def="public static IEnumerable&lt;Diagnostic&gt; GetEffectiveDiagnostics(IEnumerable&lt;Diagnostic&gt; diagnostics, Compilation compilation)" />
          <member def="public static IEnumerable&lt;Diagnostic&gt; GetEffectiveDiagnostics(ImmutableArray&lt;Diagnostic&gt; diagnostics, Compilation compilation)" />
          <member def="public static bool IsDiagnosticAnalyzerSuppressed(DiagnosticAnalyzer analyzer, CompilationOptions options, Action&lt;Exception, DiagnosticAnalyzer, Diagnostic&gt; onAnalyzerException = null)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions">
        <members>
          <member def="public CompilationWithAnalyzersOptions(AnalyzerOptions options, Action&lt;Exception, DiagnosticAnalyzer, Diagnostic&gt; onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime)" />
          <member def="public CompilationWithAnalyzersOptions(AnalyzerOptions options, Action&lt;Exception, DiagnosticAnalyzer, Diagnostic&gt; onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime, bool reportSuppressedDiagnostics)" />
          <member def="public CompilationWithAnalyzersOptions(AnalyzerOptions options, Action&lt;Exception, DiagnosticAnalyzer, Diagnostic&gt; onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime, bool reportSuppressedDiagnostics, Func&lt;Exception, bool&gt; analyzerExceptionFilter)" />
          <member def="public Func&lt;Exception, bool&gt; AnalyzerExceptionFilter { get; }" />
          <member def="public bool ConcurrentAnalysis { get; }" />
          <member def="public bool LogAnalyzerExecutionTime { get; }" />
          <member def="public Action&lt;Exception, DiagnosticAnalyzer, Diagnostic&gt; OnAnalyzerException { get; }" />
          <member def="public AnalyzerOptions Options { get; }" />
          <member def="public bool ReportSuppressedDiagnostics { get; }" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer">
        <members>
          <member def="protected DiagnosticAnalyzer()" />
          <member def="public abstract ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics { get; }" />
          <member def="public override sealed bool Equals(object obj)" />
          <member def="public override sealed int GetHashCode()" />
          <member def="public abstract void Initialize(AnalysisContext context)" />
          <member def="public override sealed string ToString()" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext">
        <members>
          <member def="protected OperationBlockStartAnalysisContext(ImmutableArray&lt;IOperation&gt; operationBlocks, ISymbol owningSymbol, Compilation compilation, AnalyzerOptions options, CancellationToken cancellationToken)" />
          <member def="public CancellationToken CancellationToken { get; }" />
          <member def="public Compilation Compilation { get; }" />
          <member def="public ImmutableArray&lt;IOperation&gt; OperationBlocks { get; }" />
          <member def="public AnalyzerOptions Options { get; }" />
          <member def="public ISymbol OwningSymbol { get; }" />
          <member def="public void RegisterOperationAction(Action&lt;OperationAnalysisContext&gt; action, params OperationKind[] operationKinds)" />
          <member def="public abstract void RegisterOperationAction(Action&lt;OperationAnalysisContext&gt; action, ImmutableArray&lt;OperationKind&gt; operationKinds)" />
          <member def="public abstract void RegisterOperationBlockEndAction(Action&lt;OperationBlockAnalysisContext&gt; action)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.Diagnostics.SourceTextValueProvider&lt;TValue&gt;">
        <members>
          <member def="public SourceTextValueProvider(Func&lt;SourceText, TValue&gt; computeValue, IEqualityComparer&lt;SourceText&gt; sourceTextComparer = null)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.Diagnostics.SuppressionInfo">
        <members>
          <member def="public AttributeData Attribute { get; }" />
          <member def="public string Id { get; }" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeValueProvider&lt;TValue&gt;">
        <members>
          <member def="public SyntaxTreeValueProvider(Func&lt;SyntaxTree, TValue&gt; computeValue, IEqualityComparer&lt;SyntaxTree&gt; syntaxTreeComparer = null)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo">
        <members>
          <member def="public AnalyzerTelemetryInfo()" />
          <member def="public int CodeBlockActionsCount { get; set; }" />
          <member def="public int CodeBlockEndActionsCount { get; set; }" />
          <member def="public int CodeBlockStartActionsCount { get; set; }" />
          <member def="public int CompilationActionsCount { get; set; }" />
          <member def="public int CompilationEndActionsCount { get; set; }" />
          <member def="public int CompilationStartActionsCount { get; set; }" />
          <member def="public TimeSpan ExecutionTime { get; set; }" />
          <member def="public int OperationActionsCount { get; set; }" />
          <member def="public int OperationBlockActionsCount { get; set; }" />
          <member def="public int OperationBlockEndActionsCount { get; set; }" />
          <member def="public int OperationBlockStartActionsCount { get; set; }" />
          <member def="public int SemanticModelActionsCount { get; set; }" />
          <member def="public int SymbolActionsCount { get; set; }" />
          <member def="public int SyntaxNodeActionsCount { get; set; }" />
          <member def="public int SyntaxTreeActionsCount { get; set; }" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.Differencing.EditScript&lt;TNode&gt;">
        <members>
          <member def="public ImmutableArray&lt;Edit&lt;TNode&gt;&gt; Edits { get; }" />
          <member def="public Match&lt;TNode&gt; Match { get; }" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.Differencing.Match&lt;TNode&gt;">
        <members>
          <member def="public TreeComparer&lt;TNode&gt; Comparer { get; }" />
          <member def="public IReadOnlyDictionary&lt;TNode, TNode&gt; Matches { get; }" />
          <member def="public TNode NewRoot { get; }" />
          <member def="public TNode OldRoot { get; }" />
          <member def="public IReadOnlyDictionary&lt;TNode, TNode&gt; ReverseMatches { get; }" />
          <member def="public IEnumerable&lt;Edit&lt;TNode&gt;&gt; GetSequenceEdits(IEnumerable&lt;TNode&gt; oldNodes, IEnumerable&lt;TNode&gt; newNodes)" />
          <member def="public EditScript&lt;TNode&gt; GetTreeEdits()" />
          <member def="public bool TryGetNewNode(TNode oldNode, out TNode newNode)" />
          <member def="public bool TryGetOldNode(TNode newNode, out TNode oldNode)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Differencing.TreeComparer&lt;TNode&gt;">
        <members>
          <member def="protected TreeComparer()" />
          <member def="protected internal abstract int LabelCount { get; }" />
          <member def="public EditScript&lt;TNode&gt; ComputeEditScript(TNode oldRoot, TNode newRoot)" />
          <member def="public Match&lt;TNode&gt; ComputeMatch(TNode oldRoot, TNode newRoot, IEnumerable&lt;KeyValuePair&lt;TNode, TNode&gt;&gt; knownMatches = null)" />
          <member def="protected internal abstract IEnumerable&lt;TNode&gt; GetChildren(TNode node)" />
          <member def="protected internal abstract IEnumerable&lt;TNode&gt; GetDescendants(TNode node)" />
          <member def="public abstract double GetDistance(TNode oldNode, TNode newNode)" />
          <member def="protected internal abstract int GetLabel(TNode node)" />
          <member def="protected internal abstract TextSpan GetSpan(TNode node)" />
          <member def="protected internal abstract int TiedToAncestor(int label)" />
          <member def="protected internal abstract bool TreesEqual(TNode oldNode, TNode newNode)" />
          <member def="protected internal abstract bool TryGetParent(TNode node, out TNode parent)" />
          <member def="public abstract bool ValuesEqual(TNode oldNode, TNode newNode)" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.Editing.SolutionEditor">
        <members>
          <member def="public SolutionEditor(Solution solution)" />
          <member def="public Solution OriginalSolution { get; }" />
          <member def="public Solution GetChangedSolution()" />
          <member def="public Task&lt;DocumentEditor&gt; GetDocumentEditorAsync(DocumentId id, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.Editing.SymbolEditor">
        <members>
          <member def="public Solution ChangedSolution { get; }" />
          <member def="public Solution OriginalSolution { get; }" />
          <member def="public static SymbolEditor Create(Document document)" />
          <member def="public static SymbolEditor Create(Solution solution)" />
          <member def="public Task&lt;ISymbol&gt; EditAllDeclarationsAsync(ISymbol symbol, SymbolEditor.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default)" />
          <member def="public Task&lt;ISymbol&gt; EditAllDeclarationsAsync(ISymbol symbol, SymbolEditor.DeclarationEditAction editAction, CancellationToken cancellationToken = default)" />
          <member def="public Task&lt;ISymbol&gt; EditOneDeclarationAsync(ISymbol symbol, SymbolEditor.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default)" />
          <member def="public Task&lt;ISymbol&gt; EditOneDeclarationAsync(ISymbol symbol, SymbolEditor.DeclarationEditAction editAction, CancellationToken cancellationToken = default)" />
          <member def="public Task&lt;ISymbol&gt; EditOneDeclarationAsync(ISymbol symbol, Location location, SymbolEditor.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default)" />
          <member def="public Task&lt;ISymbol&gt; EditOneDeclarationAsync(ISymbol symbol, Location location, SymbolEditor.DeclarationEditAction editAction, CancellationToken cancellationToken = default)" />
          <member def="public Task&lt;ISymbol&gt; EditOneDeclarationAsync(ISymbol symbol, ISymbol member, SymbolEditor.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default)" />
          <member def="public Task&lt;ISymbol&gt; EditOneDeclarationAsync(ISymbol symbol, ISymbol member, SymbolEditor.DeclarationEditAction editAction, CancellationToken cancellationToken = default)" />
          <member def="public IEnumerable&lt;Document&gt; GetChangedDocuments()" />
          <member def="public Task&lt;IReadOnlyList&lt;SyntaxNode&gt;&gt; GetCurrentDeclarationsAsync(ISymbol symbol, CancellationToken cancellationToken = default)" />
          <member def="public Task&lt;ISymbol&gt; GetCurrentSymbolAsync(ISymbol symbol, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.Editing.SyntaxEditor">
        <members>
          <member def="public SyntaxEditor(SyntaxNode root, Workspace workspace)" />
          <member def="public SyntaxGenerator Generator { get; }" />
          <member def="public SyntaxNode OriginalRoot { get; }" />
          <member def="public SyntaxNode GetChangedRoot()" />
          <member def="public void InsertAfter(SyntaxNode node, SyntaxNode newNode)" />
          <member def="public void InsertAfter(SyntaxNode node, IEnumerable&lt;SyntaxNode&gt; newNodes)" />
          <member def="public void InsertBefore(SyntaxNode node, SyntaxNode newNode)" />
          <member def="public void InsertBefore(SyntaxNode node, IEnumerable&lt;SyntaxNode&gt; newNodes)" />
          <member def="public void RemoveNode(SyntaxNode node)" />
          <member def="public void RemoveNode(SyntaxNode node, SyntaxRemoveOptions options)" />
          <member def="public void ReplaceNode(SyntaxNode node, Func&lt;SyntaxNode, SyntaxGenerator, SyntaxNode&gt; computeReplacement)" />
          <member def="public void ReplaceNode(SyntaxNode node, SyntaxNode newNode)" />
          <member def="public void TrackNode(SyntaxNode node)" />
        </members>
        <type def="public class Microsoft.CodeAnalysis.Editing.DocumentEditor : SyntaxEditor">
          <members>
            <member def="public Document OriginalDocument { get; }" />
            <member def="public SemanticModel SemanticModel { get; }" />
            <member def="public static Task&lt;DocumentEditor&gt; CreateAsync(Document document, CancellationToken cancellationToken = default)" />
            <member def="public Document GetChangedDocument()" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Editing.SyntaxGenerator : ILanguageService">
        <members>
          <member def="public static SyntaxRemoveOptions DefaultRemoveOptions" />
          <member def="protected SyntaxGenerator()" />
          <member def="public SyntaxNode AddAccessors(SyntaxNode declaration, IEnumerable&lt;SyntaxNode&gt; accessors)" />
          <member def="public SyntaxNode AddAttributeArguments(SyntaxNode attributeDeclaration, IEnumerable&lt;SyntaxNode&gt; attributeArguments)" />
          <member def="public SyntaxNode AddAttributes(SyntaxNode declaration, IEnumerable&lt;SyntaxNode&gt; attributes)" />
          <member def="public SyntaxNode AddAttributes(SyntaxNode declaration, params SyntaxNode[] attributes)" />
          <member def="public abstract SyntaxNode AddBaseType(SyntaxNode declaration, SyntaxNode baseType)" />
          <member def="public abstract SyntaxNode AddEventHandler(SyntaxNode @event, SyntaxNode handler)" />
          <member def="public abstract SyntaxNode AddExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public abstract SyntaxNode AddInterfaceType(SyntaxNode declaration, SyntaxNode interfaceType)" />
          <member def="public SyntaxNode AddMembers(SyntaxNode declaration, IEnumerable&lt;SyntaxNode&gt; members)" />
          <member def="public SyntaxNode AddMembers(SyntaxNode declaration, params SyntaxNode[] members)" />
          <member def="public SyntaxNode AddNamespaceImports(SyntaxNode declaration, IEnumerable&lt;SyntaxNode&gt; imports)" />
          <member def="public SyntaxNode AddNamespaceImports(SyntaxNode declaration, params SyntaxNode[] imports)" />
          <member def="public SyntaxNode AddParameters(SyntaxNode declaration, IEnumerable&lt;SyntaxNode&gt; parameters)" />
          <member def="public SyntaxNode AddReturnAttributes(SyntaxNode declaration, IEnumerable&lt;SyntaxNode&gt; attributes)" />
          <member def="public SyntaxNode AddReturnAttributes(SyntaxNode declaration, params SyntaxNode[] attributes)" />
          <member def="public SyntaxNode AddSwitchSections(SyntaxNode switchStatement, IEnumerable&lt;SyntaxNode&gt; switchSections)" />
          <member def="public SyntaxNode Argument(SyntaxNode expression)" />
          <member def="public SyntaxNode Argument(RefKind refKind, SyntaxNode expression)" />
          <member def="public abstract SyntaxNode Argument(string name, RefKind refKind, SyntaxNode expression)" />
          <member def="public abstract SyntaxNode ArrayCreationExpression(SyntaxNode elementType, IEnumerable&lt;SyntaxNode&gt; elements)" />
          <member def="public abstract SyntaxNode ArrayCreationExpression(SyntaxNode elementType, SyntaxNode size)" />
          <member def="public abstract SyntaxNode ArrayTypeExpression(SyntaxNode type)" />
          <member def="public SyntaxNode AsPrivateInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType)" />
          <member def="public abstract SyntaxNode AsPrivateInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType, string interfaceMemberName)" />
          <member def="public SyntaxNode AsPublicInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType)" />
          <member def="public abstract SyntaxNode AsPublicInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType, string interfaceMemberName)" />
          <member def="public abstract SyntaxNode AssignmentStatement(SyntaxNode left, SyntaxNode right)" />
          <member def="public SyntaxNode Attribute(AttributeData attribute)" />
          <member def="public abstract SyntaxNode Attribute(SyntaxNode name, IEnumerable&lt;SyntaxNode&gt; attributeArguments = null)" />
          <member def="public SyntaxNode Attribute(string name, IEnumerable&lt;SyntaxNode&gt; attributeArguments = null)" />
          <member def="public SyntaxNode Attribute(string name, params SyntaxNode[] attributeArguments)" />
          <member def="public SyntaxNode AttributeArgument(SyntaxNode expression)" />
          <member def="public abstract SyntaxNode AttributeArgument(string name, SyntaxNode expression)" />
          <member def="public abstract SyntaxNode AwaitExpression(SyntaxNode expression)" />
          <member def="public abstract SyntaxNode BaseExpression()" />
          <member def="public abstract SyntaxNode BitwiseAndExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public abstract SyntaxNode BitwiseNotExpression(SyntaxNode operand)" />
          <member def="public abstract SyntaxNode BitwiseOrExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public abstract SyntaxNode CastExpression(SyntaxNode type, SyntaxNode expression)" />
          <member def="public SyntaxNode CastExpression(ITypeSymbol type, SyntaxNode expression)" />
          <member def="public abstract SyntaxNode CatchClause(SyntaxNode type, string identifier, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public SyntaxNode CatchClause(ITypeSymbol type, string identifier, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public abstract SyntaxNode ClassDeclaration(string name, IEnumerable&lt;string&gt; typeParameters = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, SyntaxNode baseType = null, IEnumerable&lt;SyntaxNode&gt; interfaceTypes = null, IEnumerable&lt;SyntaxNode&gt; members = null)" />
          <member def="public abstract TNode ClearTrivia&lt;TNode&gt;(TNode node) where TNode : SyntaxNode" />
          <member def="public abstract SyntaxNode CoalesceExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public abstract SyntaxNode CompilationUnit(IEnumerable&lt;SyntaxNode&gt; declarations)" />
          <member def="public SyntaxNode CompilationUnit(params SyntaxNode[] declarations)" />
          <member def="public abstract SyntaxNode ConditionalExpression(SyntaxNode condition, SyntaxNode whenTrue, SyntaxNode whenFalse)" />
          <member def="public SyntaxNode ConstructorDeclaration(IMethodSymbol constructorMethod, IEnumerable&lt;SyntaxNode&gt; baseConstructorArguments = null, IEnumerable&lt;SyntaxNode&gt; statements = null)" />
          <member def="public abstract SyntaxNode ConstructorDeclaration(string containingTypeName = null, IEnumerable&lt;SyntaxNode&gt; parameters = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable&lt;SyntaxNode&gt; baseConstructorArguments = null, IEnumerable&lt;SyntaxNode&gt; statements = null)" />
          <member def="public abstract SyntaxNode ConvertExpression(SyntaxNode type, SyntaxNode expression)" />
          <member def="public SyntaxNode ConvertExpression(ITypeSymbol type, SyntaxNode expression)" />
          <member def="public SyntaxNode CustomEventDeclaration(IEventSymbol symbol, IEnumerable&lt;SyntaxNode&gt; addAccessorStatements = null, IEnumerable&lt;SyntaxNode&gt; removeAccessorStatements = null)" />
          <member def="public abstract SyntaxNode CustomEventDeclaration(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable&lt;SyntaxNode&gt; parameters = null, IEnumerable&lt;SyntaxNode&gt; addAccessorStatements = null, IEnumerable&lt;SyntaxNode&gt; removeAccessorStatements = null)" />
          <member def="public SyntaxNode Declaration(ISymbol symbol)" />
          <member def="public abstract SyntaxNode DefaultExpression(SyntaxNode type)" />
          <member def="public abstract SyntaxNode DefaultExpression(ITypeSymbol type)" />
          <member def="public abstract SyntaxNode DefaultSwitchSection(IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public abstract SyntaxNode DelegateDeclaration(string name, IEnumerable&lt;SyntaxNode&gt; parameters = null, IEnumerable&lt;string&gt; typeParameters = null, SyntaxNode returnType = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default)" />
          <member def="public abstract SyntaxNode DivideExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public SyntaxNode DottedName(string dottedName)" />
          <member def="public abstract SyntaxNode ElementAccessExpression(SyntaxNode expression, IEnumerable&lt;SyntaxNode&gt; arguments)" />
          <member def="public SyntaxNode ElementAccessExpression(SyntaxNode expression, params SyntaxNode[] arguments)" />
          <member def="public abstract SyntaxNode EnumDeclaration(string name, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable&lt;SyntaxNode&gt; members = null)" />
          <member def="public abstract SyntaxNode EnumMember(string name, SyntaxNode expression = null)" />
          <member def="public SyntaxNode EventDeclaration(IEventSymbol symbol)" />
          <member def="public abstract SyntaxNode EventDeclaration(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default)" />
          <member def="public abstract SyntaxNode ExitSwitchStatement()" />
          <member def="public abstract SyntaxNode ExpressionStatement(SyntaxNode expression)" />
          <member def="public SyntaxNode FalseLiteralExpression()" />
          <member def="public SyntaxNode FieldDeclaration(IFieldSymbol field)" />
          <member def="public SyntaxNode FieldDeclaration(IFieldSymbol field, SyntaxNode initializer)" />
          <member def="public abstract SyntaxNode FieldDeclaration(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, SyntaxNode initializer = null)" />
          <member def="public abstract SyntaxNode GenericName(string identifier, IEnumerable&lt;SyntaxNode&gt; typeArguments)" />
          <member def="public SyntaxNode GenericName(string identifier, IEnumerable&lt;ITypeSymbol&gt; typeArguments)" />
          <member def="public SyntaxNode GenericName(string identifier, params SyntaxNode[] typeArguments)" />
          <member def="public SyntaxNode GenericName(string identifier, params ITypeSymbol[] typeArguments)" />
          <member def="public abstract Accessibility GetAccessibility(SyntaxNode declaration)" />
          <member def="public SyntaxNode GetAccessor(SyntaxNode declaration, DeclarationKind kind)" />
          <member def="public abstract IReadOnlyList&lt;SyntaxNode&gt; GetAccessors(SyntaxNode declaration)" />
          <member def="public abstract IReadOnlyList&lt;SyntaxNode&gt; GetAttributeArguments(SyntaxNode attributeDeclaration)" />
          <member def="public abstract IReadOnlyList&lt;SyntaxNode&gt; GetAttributes(SyntaxNode declaration)" />
          <member def="public abstract IReadOnlyList&lt;SyntaxNode&gt; GetBaseAndInterfaceTypes(SyntaxNode declaration)" />
          <member def="public SyntaxNode GetDeclaration(SyntaxNode node)" />
          <member def="public SyntaxNode GetDeclaration(SyntaxNode node, DeclarationKind kind)" />
          <member def="public abstract DeclarationKind GetDeclarationKind(SyntaxNode declaration)" />
          <member def="public abstract SyntaxNode GetExpression(SyntaxNode declaration)" />
          <member def="public static SyntaxGenerator GetGenerator(Document document)" />
          <member def="public static SyntaxGenerator GetGenerator(Project project)" />
          <member def="public static SyntaxGenerator GetGenerator(Workspace workspace, string language)" />
          <member def="public abstract IReadOnlyList&lt;SyntaxNode&gt; GetGetAccessorStatements(SyntaxNode declaration)" />
          <member def="public abstract IReadOnlyList&lt;SyntaxNode&gt; GetMembers(SyntaxNode declaration)" />
          <member def="public abstract DeclarationModifiers GetModifiers(SyntaxNode declaration)" />
          <member def="public abstract string GetName(SyntaxNode declaration)" />
          <member def="public abstract IReadOnlyList&lt;SyntaxNode&gt; GetNamespaceImports(SyntaxNode declaration)" />
          <member def="public abstract IReadOnlyList&lt;SyntaxNode&gt; GetParameters(SyntaxNode declaration)" />
          <member def="public abstract IReadOnlyList&lt;SyntaxNode&gt; GetReturnAttributes(SyntaxNode declaration)" />
          <member def="public abstract IReadOnlyList&lt;SyntaxNode&gt; GetSetAccessorStatements(SyntaxNode declaration)" />
          <member def="public abstract IReadOnlyList&lt;SyntaxNode&gt; GetStatements(SyntaxNode declaration)" />
          <member def="public abstract IReadOnlyList&lt;SyntaxNode&gt; GetSwitchSections(SyntaxNode switchStatement)" />
          <member def="public abstract SyntaxNode GetType(SyntaxNode declaration)" />
          <member def="public abstract SyntaxNode GreaterThanExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public abstract SyntaxNode GreaterThanOrEqualExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public abstract SyntaxNode IdentifierName(string identifier)" />
          <member def="public SyntaxNode IfStatement(SyntaxNode condition, IEnumerable&lt;SyntaxNode&gt; trueStatements, SyntaxNode falseStatement)" />
          <member def="public abstract SyntaxNode IfStatement(SyntaxNode condition, IEnumerable&lt;SyntaxNode&gt; trueStatements, IEnumerable&lt;SyntaxNode&gt; falseStatements = null)" />
          <member def="protected int IndexOf&lt;T&gt;(IReadOnlyList&lt;T&gt; list, T element)" />
          <member def="public SyntaxNode IndexerDeclaration(IPropertySymbol indexer, IEnumerable&lt;SyntaxNode&gt; getAccessorStatements = null, IEnumerable&lt;SyntaxNode&gt; setAccessorStatements = null)" />
          <member def="public abstract SyntaxNode IndexerDeclaration(IEnumerable&lt;SyntaxNode&gt; parameters, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable&lt;SyntaxNode&gt; getAccessorStatements = null, IEnumerable&lt;SyntaxNode&gt; setAccessorStatements = null)" />
          <member def="public abstract SyntaxNode InsertAccessors(SyntaxNode declaration, int index, IEnumerable&lt;SyntaxNode&gt; accessors)" />
          <member def="public abstract SyntaxNode InsertAttributeArguments(SyntaxNode attributeDeclaration, int index, IEnumerable&lt;SyntaxNode&gt; attributeArguments)" />
          <member def="public abstract SyntaxNode InsertAttributes(SyntaxNode declaration, int index, IEnumerable&lt;SyntaxNode&gt; attributes)" />
          <member def="public SyntaxNode InsertAttributes(SyntaxNode declaration, int index, params SyntaxNode[] attributes)" />
          <member def="public abstract SyntaxNode InsertMembers(SyntaxNode declaration, int index, IEnumerable&lt;SyntaxNode&gt; members)" />
          <member def="public SyntaxNode InsertMembers(SyntaxNode declaration, int index, params SyntaxNode[] members)" />
          <member def="public abstract SyntaxNode InsertNamespaceImports(SyntaxNode declaration, int index, IEnumerable&lt;SyntaxNode&gt; imports)" />
          <member def="public SyntaxNode InsertNamespaceImports(SyntaxNode declaration, int index, params SyntaxNode[] imports)" />
          <member def="public virtual SyntaxNode InsertNodesAfter(SyntaxNode root, SyntaxNode node, IEnumerable&lt;SyntaxNode&gt; newDeclarations)" />
          <member def="public virtual SyntaxNode InsertNodesBefore(SyntaxNode root, SyntaxNode node, IEnumerable&lt;SyntaxNode&gt; newDeclarations)" />
          <member def="public abstract SyntaxNode InsertParameters(SyntaxNode declaration, int index, IEnumerable&lt;SyntaxNode&gt; parameters)" />
          <member def="public abstract SyntaxNode InsertReturnAttributes(SyntaxNode declaration, int index, IEnumerable&lt;SyntaxNode&gt; attributes)" />
          <member def="public SyntaxNode InsertReturnAttributes(SyntaxNode declaration, int index, params SyntaxNode[] attributes)" />
          <member def="public abstract SyntaxNode InsertSwitchSections(SyntaxNode switchStatement, int index, IEnumerable&lt;SyntaxNode&gt; switchSections)" />
          <member def="public abstract SyntaxNode InterfaceDeclaration(string name, IEnumerable&lt;string&gt; typeParameters = null, Accessibility accessibility = NotApplicable, IEnumerable&lt;SyntaxNode&gt; interfaceTypes = null, IEnumerable&lt;SyntaxNode&gt; members = null)" />
          <member def="public abstract SyntaxNode InvocationExpression(SyntaxNode expression, IEnumerable&lt;SyntaxNode&gt; arguments)" />
          <member def="public SyntaxNode InvocationExpression(SyntaxNode expression, params SyntaxNode[] arguments)" />
          <member def="public abstract SyntaxNode IsTypeExpression(SyntaxNode expression, SyntaxNode type)" />
          <member def="public SyntaxNode IsTypeExpression(SyntaxNode expression, ITypeSymbol type)" />
          <member def="public abstract SyntaxNode LambdaParameter(string identifier, SyntaxNode type = null)" />
          <member def="public SyntaxNode LambdaParameter(string identifier, ITypeSymbol type)" />
          <member def="public abstract SyntaxNode LessThanExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public abstract SyntaxNode LessThanOrEqualExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public abstract SyntaxNode LiteralExpression(object value)" />
          <member def="public SyntaxNode LocalDeclarationStatement(string name, SyntaxNode initializer)" />
          <member def="public abstract SyntaxNode LocalDeclarationStatement(SyntaxNode type, string identifier, SyntaxNode initializer = null, bool isConst = false)" />
          <member def="public SyntaxNode LocalDeclarationStatement(ITypeSymbol type, string name, SyntaxNode initializer = null, bool isConst = false)" />
          <member def="public abstract SyntaxNode LockStatement(SyntaxNode expression, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public abstract SyntaxNode LogicalAndExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public abstract SyntaxNode LogicalNotExpression(SyntaxNode expression)" />
          <member def="public abstract SyntaxNode LogicalOrExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public virtual SyntaxNode MemberAccessExpression(SyntaxNode expression, SyntaxNode memberName)" />
          <member def="public SyntaxNode MemberAccessExpression(SyntaxNode expression, string memberName)" />
          <member def="public SyntaxNode MethodDeclaration(IMethodSymbol method, IEnumerable&lt;SyntaxNode&gt; statements = null)" />
          <member def="public abstract SyntaxNode MethodDeclaration(string name, IEnumerable&lt;SyntaxNode&gt; parameters = null, IEnumerable&lt;string&gt; typeParameters = null, SyntaxNode returnType = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable&lt;SyntaxNode&gt; statements = null)" />
          <member def="public abstract SyntaxNode ModuloExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public abstract SyntaxNode MultiplyExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public abstract SyntaxNode NameOfExpression(SyntaxNode expression)" />
          <member def="public abstract SyntaxNode NamespaceDeclaration(SyntaxNode name, IEnumerable&lt;SyntaxNode&gt; declarations)" />
          <member def="public SyntaxNode NamespaceDeclaration(SyntaxNode name, params SyntaxNode[] declarations)" />
          <member def="public SyntaxNode NamespaceDeclaration(string name, IEnumerable&lt;SyntaxNode&gt; declarations)" />
          <member def="public SyntaxNode NamespaceDeclaration(string name, params SyntaxNode[] declarations)" />
          <member def="public abstract SyntaxNode NamespaceImportDeclaration(SyntaxNode name)" />
          <member def="public SyntaxNode NamespaceImportDeclaration(string name)" />
          <member def="public abstract SyntaxNode NegateExpression(SyntaxNode expression)" />
          <member def="public SyntaxNode NullLiteralExpression()" />
          <member def="public abstract SyntaxNode NullableTypeExpression(SyntaxNode type)" />
          <member def="public abstract SyntaxNode ObjectCreationExpression(SyntaxNode namedType, IEnumerable&lt;SyntaxNode&gt; arguments)" />
          <member def="public SyntaxNode ObjectCreationExpression(ITypeSymbol type, IEnumerable&lt;SyntaxNode&gt; arguments)" />
          <member def="public SyntaxNode ObjectCreationExpression(SyntaxNode type, params SyntaxNode[] arguments)" />
          <member def="public SyntaxNode ObjectCreationExpression(ITypeSymbol type, params SyntaxNode[] arguments)" />
          <member def="public SyntaxNode OperatorDeclaration(IMethodSymbol method, IEnumerable&lt;SyntaxNode&gt; statements = null)" />
          <member def="public virtual SyntaxNode OperatorDeclaration(OperatorKind kind, IEnumerable&lt;SyntaxNode&gt; parameters = null, SyntaxNode returnType = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable&lt;SyntaxNode&gt; statements = null)" />
          <member def="public SyntaxNode ParameterDeclaration(IParameterSymbol symbol, SyntaxNode initializer = null)" />
          <member def="public abstract SyntaxNode ParameterDeclaration(string name, SyntaxNode type = null, SyntaxNode initializer = null, RefKind refKind = None)" />
          <member def="protected static SyntaxNode PreserveTrivia&lt;TNode&gt;(TNode node, Func&lt;TNode, SyntaxNode&gt; nodeChanger) where TNode : SyntaxNode" />
          <member def="public SyntaxNode PropertyDeclaration(IPropertySymbol property, IEnumerable&lt;SyntaxNode&gt; getAccessorStatements = null, IEnumerable&lt;SyntaxNode&gt; setAccessorStatements = null)" />
          <member def="public abstract SyntaxNode PropertyDeclaration(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable&lt;SyntaxNode&gt; getAccessorStatements = null, IEnumerable&lt;SyntaxNode&gt; setAccessorStatements = null)" />
          <member def="public abstract SyntaxNode QualifiedName(SyntaxNode left, SyntaxNode right)" />
          <member def="public abstract SyntaxNode ReferenceEqualsExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public abstract SyntaxNode ReferenceNotEqualsExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public SyntaxNode RemoveAllAttributes(SyntaxNode declaration)" />
          <member def="public abstract SyntaxNode RemoveEventHandler(SyntaxNode @event, SyntaxNode handler)" />
          <member def="public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode node)" />
          <member def="public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode node, SyntaxRemoveOptions options)" />
          <member def="public SyntaxNode RemoveNodes(SyntaxNode root, IEnumerable&lt;SyntaxNode&gt; declarations)" />
          <member def="protected static SeparatedSyntaxList&lt;TNode&gt; RemoveRange&lt;TNode&gt;(SeparatedSyntaxList&lt;TNode&gt; list, int offset, int count) where TNode : SyntaxNode" />
          <member def="protected static SyntaxList&lt;TNode&gt; RemoveRange&lt;TNode&gt;(SyntaxList&lt;TNode&gt; list, int offset, int count) where TNode : SyntaxNode" />
          <member def="public virtual SyntaxNode ReplaceNode(SyntaxNode root, SyntaxNode node, SyntaxNode newDeclaration)" />
          <member def="protected static SyntaxNode ReplaceRange(SyntaxNode root, SyntaxNode node, IEnumerable&lt;SyntaxNode&gt; replacements)" />
          <member def="protected static SyntaxNode ReplaceWithTrivia(SyntaxNode root, SyntaxNode original, SyntaxNode replacement)" />
          <member def="protected static SyntaxNode ReplaceWithTrivia(SyntaxNode root, SyntaxToken original, SyntaxToken replacement)" />
          <member def="protected static SyntaxNode ReplaceWithTrivia&lt;TNode&gt;(SyntaxNode root, TNode original, Func&lt;TNode, SyntaxNode&gt; replacer) where TNode : SyntaxNode" />
          <member def="public abstract SyntaxNode ReturnStatement(SyntaxNode expression = null)" />
          <member def="public abstract SyntaxNode StructDeclaration(string name, IEnumerable&lt;string&gt; typeParameters = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable&lt;SyntaxNode&gt; interfaceTypes = null, IEnumerable&lt;SyntaxNode&gt; members = null)" />
          <member def="public abstract SyntaxNode SubtractExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public SyntaxNode SwitchSection(SyntaxNode caseExpression, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public abstract SyntaxNode SwitchSection(IEnumerable&lt;SyntaxNode&gt; caseExpressions, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public abstract SyntaxNode SwitchStatement(SyntaxNode expression, IEnumerable&lt;SyntaxNode&gt; sections)" />
          <member def="public SyntaxNode SwitchStatement(SyntaxNode expression, params SyntaxNode[] sections)" />
          <member def="public abstract SyntaxNode ThisExpression()" />
          <member def="public abstract SyntaxNode ThrowExpression(SyntaxNode expression)" />
          <member def="public abstract SyntaxNode ThrowStatement(SyntaxNode expression = null)" />
          <member def="public SyntaxNode TrueLiteralExpression()" />
          <member def="public abstract SyntaxNode TryCastExpression(SyntaxNode expression, SyntaxNode type)" />
          <member def="public SyntaxNode TryCastExpression(SyntaxNode expression, ITypeSymbol type)" />
          <member def="public SyntaxNode TryCatchStatement(IEnumerable&lt;SyntaxNode&gt; tryStatements, params SyntaxNode[] catchClauses)" />
          <member def="public abstract SyntaxNode TryCatchStatement(IEnumerable&lt;SyntaxNode&gt; tryStatements, IEnumerable&lt;SyntaxNode&gt; catchClauses, IEnumerable&lt;SyntaxNode&gt; finallyStatements = null)" />
          <member def="public SyntaxNode TryFinallyStatement(IEnumerable&lt;SyntaxNode&gt; tryStatements, IEnumerable&lt;SyntaxNode&gt; finallyStatements)" />
          <member def="public abstract SyntaxNode TypeExpression(SpecialType specialType)" />
          <member def="public abstract SyntaxNode TypeExpression(ITypeSymbol typeSymbol)" />
          <member def="public SyntaxNode TypeExpression(ITypeSymbol typeSymbol, bool addImport)" />
          <member def="public abstract SyntaxNode TypeOfExpression(SyntaxNode type)" />
          <member def="public abstract SyntaxNode TypedConstantExpression(TypedConstant value)" />
          <member def="public abstract SyntaxNode UsingStatement(SyntaxNode expression, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public SyntaxNode UsingStatement(string name, SyntaxNode expression, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public abstract SyntaxNode UsingStatement(SyntaxNode type, string name, SyntaxNode expression, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public abstract SyntaxNode ValueEqualsExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public abstract SyntaxNode ValueNotEqualsExpression(SyntaxNode left, SyntaxNode right)" />
          <member def="public SyntaxNode ValueReturningLambdaExpression(SyntaxNode expression)" />
          <member def="public SyntaxNode ValueReturningLambdaExpression(IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public abstract SyntaxNode ValueReturningLambdaExpression(IEnumerable&lt;SyntaxNode&gt; lambdaParameters, SyntaxNode expression)" />
          <member def="public abstract SyntaxNode ValueReturningLambdaExpression(IEnumerable&lt;SyntaxNode&gt; lambdaParameters, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public SyntaxNode ValueReturningLambdaExpression(string parameterName, SyntaxNode expression)" />
          <member def="public SyntaxNode ValueReturningLambdaExpression(string parameterName, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public SyntaxNode VoidReturningLambdaExpression(SyntaxNode expression)" />
          <member def="public SyntaxNode VoidReturningLambdaExpression(IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public abstract SyntaxNode VoidReturningLambdaExpression(IEnumerable&lt;SyntaxNode&gt; lambdaParameters, SyntaxNode expression)" />
          <member def="public abstract SyntaxNode VoidReturningLambdaExpression(IEnumerable&lt;SyntaxNode&gt; lambdaParameters, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public SyntaxNode VoidReturningLambdaExpression(string parameterName, SyntaxNode expression)" />
          <member def="public SyntaxNode VoidReturningLambdaExpression(string parameterName, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public abstract SyntaxNode WhileStatement(SyntaxNode condition, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public abstract SyntaxNode WithAccessibility(SyntaxNode declaration, Accessibility accessibility)" />
          <member def="public abstract SyntaxNode WithExpression(SyntaxNode declaration, SyntaxNode expression)" />
          <member def="public abstract SyntaxNode WithGetAccessorStatements(SyntaxNode declaration, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public abstract SyntaxNode WithModifiers(SyntaxNode declaration, DeclarationModifiers modifiers)" />
          <member def="public abstract SyntaxNode WithName(SyntaxNode declaration, string name)" />
          <member def="public abstract SyntaxNode WithSetAccessorStatements(SyntaxNode declaration, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public abstract SyntaxNode WithStatements(SyntaxNode declaration, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public abstract SyntaxNode WithType(SyntaxNode declaration, SyntaxNode type)" />
          <member def="public abstract SyntaxNode WithTypeArguments(SyntaxNode expression, IEnumerable&lt;SyntaxNode&gt; typeArguments)" />
          <member def="public SyntaxNode WithTypeArguments(SyntaxNode expression, params SyntaxNode[] typeArguments)" />
          <member def="public SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, params SyntaxNode[] types)" />
          <member def="public abstract SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, IEnumerable&lt;SyntaxNode&gt; types = null)" />
          <member def="public SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, params SyntaxNode[] types)" />
          <member def="public abstract SyntaxNode WithTypeParameters(SyntaxNode declaration, IEnumerable&lt;string&gt; typeParameters)" />
          <member def="public SyntaxNode WithTypeParameters(SyntaxNode declaration, params string[] typeParameters)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.Emit.EmitBaseline">
        <members>
          <member def="public ModuleMetadata OriginalMetadata { get; }" />
          <member def="public static EmitBaseline CreateInitialBaseline(ModuleMetadata module, Func&lt;MethodDefinitionHandle, EditAndContinueMethodDebugInformation&gt; debugInformationProvider)" />
        </members>
      </type>
      <type def="public sealed class Microsoft.CodeAnalysis.Emit.EmitOptions : IEquatable&lt;EmitOptions&gt;">
        <members>
          <member def="public EmitOptions(bool metadataOnly, DebugInformationFormat debugInformationFormat, string pdbFilePath, string outputNameOverride, int fileAlignment, ulong baseAddress, bool highEntropyVirtualAddressSpace, SubsystemVersion subsystemVersion, string runtimeMetadataVersion, bool tolerateErrors, bool includePrivateMembers)" />
          <member def="public EmitOptions(bool metadataOnly = false, DebugInformationFormat debugInformationFormat = (DebugInformationFormat)0, string pdbFilePath = null, string outputNameOverride = null, int fileAlignment = 0, ulong baseAddress = 0, bool highEntropyVirtualAddressSpace = false, SubsystemVersion subsystemVersion = default, string runtimeMetadataVersion = null, bool tolerateErrors = false, bool includePrivateMembers = true, ImmutableArray&lt;InstrumentationKind&gt; instrumentationKinds = default)" />
          <member def="public ulong BaseAddress { get; }" />
          <member def="public DebugInformationFormat DebugInformationFormat { get; }" />
          <member def="public bool EmitMetadataOnly { get; }" />
          <member def="public int FileAlignment { get; }" />
          <member def="public bool HighEntropyVirtualAddressSpace { get; }" />
          <member def="public bool IncludePrivateMembers { get; }" />
          <member def="public ImmutableArray&lt;InstrumentationKind&gt; InstrumentationKinds { get; }" />
          <member def="public string OutputNameOverride { get; }" />
          <member def="public string PdbFilePath { get; }" />
          <member def="public string RuntimeMetadataVersion { get; }" />
          <member def="public SubsystemVersion SubsystemVersion { get; }" />
          <member def="public bool TolerateErrors { get; }" />
          <member def="public override bool Equals(object obj)" />
          <member def="public bool Equals(EmitOptions other)" />
          <member def="public override int GetHashCode()" />
          <member def="public EmitOptions WithBaseAddress(ulong value)" />
          <member def="public EmitOptions WithDebugInformationFormat(DebugInformationFormat format)" />
          <member def="public EmitOptions WithEmitMetadataOnly(bool value)" />
          <member def="public EmitOptions WithFileAlignment(int value)" />
          <member def="public EmitOptions WithHighEntropyVirtualAddressSpace(bool value)" />
          <member def="public EmitOptions WithIncludePrivateMembers(bool value)" />
          <member def="public EmitOptions WithInstrumentationKinds(ImmutableArray&lt;InstrumentationKind&gt; instrumentationKinds)" />
          <member def="public EmitOptions WithOutputNameOverride(string outputName)" />
          <member def="public EmitOptions WithPdbFilePath(string path)" />
          <member def="public EmitOptions WithRuntimeMetadataVersion(string version)" />
          <member def="public EmitOptions WithSubsystemVersion(SubsystemVersion subsystemVersion)" />
          <member def="public EmitOptions WithTolerateErrors(bool value)" />
          <member def="public static bool operator ==(EmitOptions left, EmitOptions right)" />
          <member def="public static bool operator !=(EmitOptions left, EmitOptions right)" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.Emit.EmitResult">
        <members>
          <member def="public ImmutableArray&lt;Diagnostic&gt; Diagnostics { get; }" />
          <member def="public bool Success { get; }" />
          <member def="protected virtual string GetDebuggerDisplay()" />
        </members>
        <type def="public sealed class Microsoft.CodeAnalysis.Emit.EmitDifferenceResult : EmitResult">
          <members>
            <member def="public EmitBaseline Baseline { get; }" />
          </members>
        </type>
      </type>
      <type def="public class Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol">
        <members>
          <member def="public ISymbol Definition { get; }" />
          <member def="public IEnumerable&lt;ReferenceLocation&gt; Locations { get; }" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Host.HostLanguageServices">
        <members>
          <member def="protected HostLanguageServices()" />
          <member def="public abstract string Language { get; }" />
          <member def="public abstract HostWorkspaceServices WorkspaceServices { get; }" />
          <member def="public TLanguageService GetRequiredService&lt;TLanguageService&gt;() where TLanguageService : ILanguageService" />
          <member def="public abstract TLanguageService GetService&lt;TLanguageService&gt;() where TLanguageService : ILanguageService" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Host.HostServices">
        <members>
          <member def="protected HostServices()" />
          <member def="protected internal abstract HostWorkspaceServices CreateWorkspaceServices(Workspace workspace)" />
        </members>
        <type def="public class Microsoft.CodeAnalysis.Host.Mef.MefHostServices : HostServices, IMefHostExportProvider">
          <members>
            <member def="public MefHostServices(CompositionContext compositionContext)" />
            <member def="public static ImmutableArray&lt;Assembly&gt; DefaultAssemblies { get; }" />
            <member def="public static MefHostServices DefaultHost { get; }" />
            <member def="public static MefHostServices Create(IEnumerable&lt;Assembly&gt; assemblies)" />
            <member def="public static MefHostServices Create(CompositionContext compositionContext)" />
            <member def="protected internal override HostWorkspaceServices CreateWorkspaceServices(Workspace workspace)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Host.HostWorkspaceServices">
        <members>
          <member def="protected HostWorkspaceServices()" />
          <member def="public abstract HostServices HostServices { get; }" />
          <member def="public virtual IPersistentStorageService PersistentStorage { get; }" />
          <member def="public virtual IEnumerable&lt;string&gt; SupportedLanguages { get; }" />
          <member def="public virtual ITemporaryStorageService TemporaryStorage { get; }" />
          <member def="public abstract Workspace Workspace { get; }" />
          <member def="public abstract IEnumerable&lt;TLanguageService&gt; FindLanguageServices&lt;TLanguageService&gt;(HostWorkspaceServices.MetadataFilter filter)" />
          <member def="public virtual HostLanguageServices GetLanguageServices(string languageName)" />
          <member def="public TWorkspaceService GetRequiredService&lt;TWorkspaceService&gt;() where TWorkspaceService : IWorkspaceService" />
          <member def="public abstract TWorkspaceService GetService&lt;TWorkspaceService&gt;() where TWorkspaceService : IWorkspaceService" />
          <member def="public virtual bool IsSupported(string languageName)" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.Options.Option&lt;T&gt; : IOption">
        <members>
          <member def="public Option(string feature, string name)" />
          <member def="public Option(string feature, string name, T defaultValue)" />
          <member def="public Option(string feature, string name, T defaultValue, params OptionStorageLocation[] storageLocations)" />
          <member def="public T DefaultValue { get; }" />
          <member def="public string Feature { get; }" />
          <member def="public string Name { get; }" />
          <member def="public ImmutableArray&lt;OptionStorageLocation&gt; StorageLocations { get; }" />
          <member def="public Type Type { get; }" />
          <member def="public override string ToString()" />
          <member def="public static implicit operator OptionKey(Option&lt;T&gt; option)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Options.OptionSet">
        <members>
          <member def="protected OptionSet()" />
          <member def="public abstract object GetOption(OptionKey optionKey)" />
          <member def="public T GetOption&lt;T&gt;(Option&lt;T&gt; option)" />
          <member def="public T GetOption&lt;T&gt;(PerLanguageOption&lt;T&gt; option, string language)" />
          <member def="public abstract OptionSet WithChangedOption(OptionKey optionAndLanguage, object value)" />
          <member def="public OptionSet WithChangedOption&lt;T&gt;(Option&lt;T&gt; option, T value)" />
          <member def="public OptionSet WithChangedOption&lt;T&gt;(PerLanguageOption&lt;T&gt; option, string language, T value)" />
        </members>
        <type def="public sealed class Microsoft.CodeAnalysis.Options.DocumentOptionSet : OptionSet">
          <members>
            <member def="public override object GetOption(OptionKey optionKey)" />
            <member def="public T GetOption&lt;T&gt;(PerLanguageOption&lt;T&gt; option)" />
            <member def="public override OptionSet WithChangedOption(OptionKey optionAndLanguage, object value)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Options.OptionStorageLocation">
        <members>
          <member def="protected OptionStorageLocation()" />
        </members>
      </type>
      <type def="public class Microsoft.CodeAnalysis.Options.PerLanguageOption&lt;T&gt; : IOption">
        <members>
          <member def="public PerLanguageOption(string feature, string name, T defaultValue)" />
          <member def="public PerLanguageOption(string feature, string name, T defaultValue, params OptionStorageLocation[] storageLocations)" />
          <member def="public T DefaultValue { get; }" />
          <member def="public string Feature { get; }" />
          <member def="public string Name { get; }" />
          <member def="public ImmutableArray&lt;OptionStorageLocation&gt; StorageLocations { get; }" />
          <member def="public Type Type { get; }" />
          <member def="public override string ToString()" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Semantics.OperationVisitor">
        <members>
          <member def="protected OperationVisitor()" />
          <member def="public virtual void DefaultVisit(IOperation operation)" />
          <member def="public virtual void Visit(IOperation operation)" />
          <member def="public virtual void VisitAddressOfExpression(IAddressOfExpression operation)" />
          <member def="public virtual void VisitArgument(IArgument operation)" />
          <member def="public virtual void VisitArrayCreationExpression(IArrayCreationExpression operation)" />
          <member def="public virtual void VisitArrayElementReferenceExpression(IArrayElementReferenceExpression operation)" />
          <member def="public virtual void VisitArrayInitializer(IArrayInitializer operation)" />
          <member def="public virtual void VisitAssignmentExpression(IAssignmentExpression operation)" />
          <member def="public virtual void VisitAwaitExpression(IAwaitExpression operation)" />
          <member def="public virtual void VisitBinaryOperatorExpression(IBinaryOperatorExpression operation)" />
          <member def="public virtual void VisitBlockStatement(IBlockStatement operation)" />
          <member def="public virtual void VisitBranchStatement(IBranchStatement operation)" />
          <member def="public virtual void VisitCatchClause(ICatchClause operation)" />
          <member def="public virtual void VisitCompoundAssignmentExpression(ICompoundAssignmentExpression operation)" />
          <member def="public virtual void VisitConditionalAccessExpression(IConditionalAccessExpression operation)" />
          <member def="public virtual void VisitConditionalAccessInstanceExpression(IConditionalAccessInstanceExpression operation)" />
          <member def="public virtual void VisitConditionalChoiceExpression(IConditionalChoiceExpression operation)" />
          <member def="public virtual void VisitConversionExpression(IConversionExpression operation)" />
          <member def="public virtual void VisitDefaultValueExpression(IDefaultValueExpression operation)" />
          <member def="public virtual void VisitEmptyStatement(IEmptyStatement operation)" />
          <member def="public virtual void VisitEndStatement(IEndStatement operation)" />
          <member def="public virtual void VisitEventAssignmentExpression(IEventAssignmentExpression operation)" />
          <member def="public virtual void VisitEventReferenceExpression(IEventReferenceExpression operation)" />
          <member def="public virtual void VisitExpressionStatement(IExpressionStatement operation)" />
          <member def="public virtual void VisitFieldInitializer(IFieldInitializer operation)" />
          <member def="public virtual void VisitFieldReferenceExpression(IFieldReferenceExpression operation)" />
          <member def="public virtual void VisitFixedStatement(IFixedStatement operation)" />
          <member def="public virtual void VisitForEachLoopStatement(IForEachLoopStatement operation)" />
          <member def="public virtual void VisitForLoopStatement(IForLoopStatement operation)" />
          <member def="public virtual void VisitIfStatement(IIfStatement operation)" />
          <member def="public virtual void VisitIncrementExpression(IIncrementExpression operation)" />
          <member def="public virtual void VisitIndexedPropertyReferenceExpression(IIndexedPropertyReferenceExpression operation)" />
          <member def="public virtual void VisitInstanceReferenceExpression(IInstanceReferenceExpression operation)" />
          <member def="public virtual void VisitInvalidExpression(IInvalidExpression operation)" />
          <member def="public virtual void VisitInvalidStatement(IInvalidStatement operation)" />
          <member def="public virtual void VisitInvocationExpression(IInvocationExpression operation)" />
          <member def="public virtual void VisitIsTypeExpression(IIsTypeExpression operation)" />
          <member def="public virtual void VisitLabelStatement(ILabelStatement operation)" />
          <member def="public virtual void VisitLambdaExpression(ILambdaExpression operation)" />
          <member def="public virtual void VisitLateBoundMemberReferenceExpression(ILateBoundMemberReferenceExpression operation)" />
          <member def="public virtual void VisitLiteralExpression(ILiteralExpression operation)" />
          <member def="public virtual void VisitLocalReferenceExpression(ILocalReferenceExpression operation)" />
          <member def="public virtual void VisitLockStatement(ILockStatement operation)" />
          <member def="public virtual void VisitMethodBindingExpression(IMethodBindingExpression operation)" />
          <member def="public virtual void VisitNullCoalescingExpression(INullCoalescingExpression operation)" />
          <member def="public virtual void VisitObjectCreationExpression(IObjectCreationExpression operation)" />
          <member def="public virtual void VisitOmittedArgumentExpression(IOmittedArgumentExpression operation)" />
          <member def="public virtual void VisitParameterInitializer(IParameterInitializer operation)" />
          <member def="public virtual void VisitParameterReferenceExpression(IParameterReferenceExpression operation)" />
          <member def="public virtual void VisitParenthesizedExpression(IParenthesizedExpression operation)" />
          <member def="public virtual void VisitPlaceholderExpression(IPlaceholderExpression operation)" />
          <member def="public virtual void VisitPointerIndirectionReferenceExpression(IPointerIndirectionReferenceExpression operation)" />
          <member def="public virtual void VisitPropertyInitializer(IPropertyInitializer operation)" />
          <member def="public virtual void VisitPropertyReferenceExpression(IPropertyReferenceExpression operation)" />
          <member def="public virtual void VisitRangeCaseClause(IRangeCaseClause operation)" />
          <member def="public virtual void VisitRelationalCaseClause(IRelationalCaseClause operation)" />
          <member def="public virtual void VisitReturnStatement(IReturnStatement operation)" />
          <member def="public virtual void VisitSingleValueCaseClause(ISingleValueCaseClause operation)" />
          <member def="public virtual void VisitSizeOfExpression(ISizeOfExpression operation)" />
          <member def="public virtual void VisitStopStatement(IStopStatement operation)" />
          <member def="public virtual void VisitSwitchCase(ISwitchCase operation)" />
          <member def="public virtual void VisitSwitchStatement(ISwitchStatement operation)" />
          <member def="public virtual void VisitSyntheticLocalReferenceExpression(ISyntheticLocalReferenceExpression operation)" />
          <member def="public virtual void VisitThrowStatement(IThrowStatement operation)" />
          <member def="public virtual void VisitTryStatement(ITryStatement operation)" />
          <member def="public virtual void VisitTypeOfExpression(ITypeOfExpression operation)" />
          <member def="public virtual void VisitTypeParameterObjectCreationExpression(ITypeParameterObjectCreationExpression operation)" />
          <member def="public virtual void VisitUnaryOperatorExpression(IUnaryOperatorExpression operation)" />
          <member def="public virtual void VisitUnboundLambdaExpression(IUnboundLambdaExpression operation)" />
          <member def="public virtual void VisitUsingStatement(IUsingStatement operation)" />
          <member def="public virtual void VisitVariableDeclaration(IVariableDeclaration operation)" />
          <member def="public virtual void VisitVariableDeclarationStatement(IVariableDeclarationStatement operation)" />
          <member def="public virtual void VisitWhileUntilLoopStatement(IWhileUntilLoopStatement operation)" />
          <member def="public virtual void VisitWithStatement(IWithStatement operation)" />
          <member def="public virtual void VisitYieldBreakStatement(IReturnStatement operation)" />
        </members>
        <type def="public abstract class Microsoft.CodeAnalysis.Semantics.OperationWalker : OperationVisitor">
          <members>
            <member def="protected OperationWalker()" />
            <member def="public override void Visit(IOperation operation)" />
            <member def="public override void VisitAddressOfExpression(IAddressOfExpression operation)" />
            <member def="public override void VisitArgument(IArgument operation)" />
            <member def="public override void VisitArrayCreationExpression(IArrayCreationExpression operation)" />
            <member def="public override void VisitArrayElementReferenceExpression(IArrayElementReferenceExpression operation)" />
            <member def="public override void VisitArrayInitializer(IArrayInitializer operation)" />
            <member def="public override void VisitAssignmentExpression(IAssignmentExpression operation)" />
            <member def="public override void VisitAwaitExpression(IAwaitExpression operation)" />
            <member def="public override void VisitBinaryOperatorExpression(IBinaryOperatorExpression operation)" />
            <member def="public override void VisitBlockStatement(IBlockStatement operation)" />
            <member def="public override void VisitBranchStatement(IBranchStatement operation)" />
            <member def="public override void VisitCatchClause(ICatchClause operation)" />
            <member def="public override void VisitCompoundAssignmentExpression(ICompoundAssignmentExpression operation)" />
            <member def="public override void VisitConditionalAccessExpression(IConditionalAccessExpression operation)" />
            <member def="public override void VisitConditionalAccessInstanceExpression(IConditionalAccessInstanceExpression operation)" />
            <member def="public override void VisitConditionalChoiceExpression(IConditionalChoiceExpression operation)" />
            <member def="public override void VisitConversionExpression(IConversionExpression operation)" />
            <member def="public override void VisitDefaultValueExpression(IDefaultValueExpression operation)" />
            <member def="public override void VisitEmptyStatement(IEmptyStatement operation)" />
            <member def="public override void VisitEndStatement(IEndStatement operation)" />
            <member def="public override void VisitEventAssignmentExpression(IEventAssignmentExpression operation)" />
            <member def="public override void VisitEventReferenceExpression(IEventReferenceExpression operation)" />
            <member def="public override void VisitExpressionStatement(IExpressionStatement operation)" />
            <member def="public override void VisitFieldInitializer(IFieldInitializer operation)" />
            <member def="public override void VisitFieldReferenceExpression(IFieldReferenceExpression operation)" />
            <member def="public override void VisitFixedStatement(IFixedStatement operation)" />
            <member def="public override void VisitForEachLoopStatement(IForEachLoopStatement operation)" />
            <member def="public override void VisitForLoopStatement(IForLoopStatement operation)" />
            <member def="public override void VisitIfStatement(IIfStatement operation)" />
            <member def="public override void VisitIncrementExpression(IIncrementExpression operation)" />
            <member def="public override void VisitIndexedPropertyReferenceExpression(IIndexedPropertyReferenceExpression operation)" />
            <member def="public override void VisitInstanceReferenceExpression(IInstanceReferenceExpression operation)" />
            <member def="public override void VisitInvalidExpression(IInvalidExpression operation)" />
            <member def="public override void VisitInvalidStatement(IInvalidStatement operation)" />
            <member def="public override void VisitInvocationExpression(IInvocationExpression operation)" />
            <member def="public override void VisitIsTypeExpression(IIsTypeExpression operation)" />
            <member def="public override void VisitLabelStatement(ILabelStatement operation)" />
            <member def="public override void VisitLambdaExpression(ILambdaExpression operation)" />
            <member def="public override void VisitLateBoundMemberReferenceExpression(ILateBoundMemberReferenceExpression operation)" />
            <member def="public override void VisitLiteralExpression(ILiteralExpression operation)" />
            <member def="public override void VisitLocalReferenceExpression(ILocalReferenceExpression operation)" />
            <member def="public override void VisitLockStatement(ILockStatement operation)" />
            <member def="public override void VisitMethodBindingExpression(IMethodBindingExpression operation)" />
            <member def="public override void VisitNullCoalescingExpression(INullCoalescingExpression operation)" />
            <member def="public override void VisitObjectCreationExpression(IObjectCreationExpression operation)" />
            <member def="public override void VisitOmittedArgumentExpression(IOmittedArgumentExpression operation)" />
            <member def="public override void VisitParameterInitializer(IParameterInitializer operation)" />
            <member def="public override void VisitParameterReferenceExpression(IParameterReferenceExpression operation)" />
            <member def="public override void VisitParenthesizedExpression(IParenthesizedExpression operation)" />
            <member def="public override void VisitPlaceholderExpression(IPlaceholderExpression operation)" />
            <member def="public override void VisitPointerIndirectionReferenceExpression(IPointerIndirectionReferenceExpression operation)" />
            <member def="public override void VisitPropertyInitializer(IPropertyInitializer operation)" />
            <member def="public override void VisitPropertyReferenceExpression(IPropertyReferenceExpression operation)" />
            <member def="public override void VisitRangeCaseClause(IRangeCaseClause operation)" />
            <member def="public override void VisitRelationalCaseClause(IRelationalCaseClause operation)" />
            <member def="public override void VisitReturnStatement(IReturnStatement operation)" />
            <member def="public override void VisitSingleValueCaseClause(ISingleValueCaseClause operation)" />
            <member def="public override void VisitSizeOfExpression(ISizeOfExpression operation)" />
            <member def="public override void VisitStopStatement(IStopStatement operation)" />
            <member def="public override void VisitSwitchCase(ISwitchCase operation)" />
            <member def="public override void VisitSwitchStatement(ISwitchStatement operation)" />
            <member def="public override void VisitSyntheticLocalReferenceExpression(ISyntheticLocalReferenceExpression operation)" />
            <member def="public override void VisitThrowStatement(IThrowStatement operation)" />
            <member def="public override void VisitTryStatement(ITryStatement operation)" />
            <member def="public override void VisitTypeOfExpression(ITypeOfExpression operation)" />
            <member def="public override void VisitTypeParameterObjectCreationExpression(ITypeParameterObjectCreationExpression operation)" />
            <member def="public override void VisitUnaryOperatorExpression(IUnaryOperatorExpression operation)" />
            <member def="public override void VisitUnboundLambdaExpression(IUnboundLambdaExpression operation)" />
            <member def="public override void VisitUsingStatement(IUsingStatement operation)" />
            <member def="public override void VisitVariableDeclaration(IVariableDeclaration operation)" />
            <member def="public override void VisitVariableDeclarationStatement(IVariableDeclarationStatement operation)" />
            <member def="public override void VisitWhileUntilLoopStatement(IWhileUntilLoopStatement operation)" />
            <member def="public override void VisitWithStatement(IWithStatement operation)" />
            <member def="public override void VisitYieldBreakStatement(IReturnStatement operation)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Semantics.OperationVisitor&lt;TArgument, TResult&gt;">
        <members>
          <member def="protected OperationVisitor()" />
          <member def="public virtual TResult DefaultVisit(IOperation operation, TArgument argument)" />
          <member def="public virtual TResult Visit(IOperation operation, TArgument argument)" />
          <member def="public virtual TResult VisitAddressOfExpression(IAddressOfExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitArgument(IArgument operation, TArgument argument)" />
          <member def="public virtual TResult VisitArrayCreationExpression(IArrayCreationExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitArrayElementReferenceExpression(IArrayElementReferenceExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitArrayInitializer(IArrayInitializer operation, TArgument argument)" />
          <member def="public virtual TResult VisitAssignmentExpression(IAssignmentExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitAwaitExpression(IAwaitExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitBinaryOperatorExpression(IBinaryOperatorExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitBlockStatement(IBlockStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitBranchStatement(IBranchStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitCatchClause(ICatchClause operation, TArgument argument)" />
          <member def="public virtual TResult VisitCompoundAssignmentExpression(ICompoundAssignmentExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitConditionalAccessExpression(IConditionalAccessExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitConditionalAccessInstanceExpression(IConditionalAccessInstanceExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitConditionalChoiceExpression(IConditionalChoiceExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitConversionExpression(IConversionExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitDefaultValueExpression(IDefaultValueExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitEmptyStatement(IEmptyStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitEndStatement(IEndStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitEventAssignmentExpression(IEventAssignmentExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitEventReferenceExpression(IEventReferenceExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitExpressionStatement(IExpressionStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitFieldInitializer(IFieldInitializer operation, TArgument argument)" />
          <member def="public virtual TResult VisitFieldReferenceExpression(IFieldReferenceExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitFixedStatement(IFixedStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitForEachLoopStatement(IForEachLoopStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitForLoopStatement(IForLoopStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitIfStatement(IIfStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitIncrementExpression(IIncrementExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitIndexedPropertyReferenceExpression(IIndexedPropertyReferenceExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitInstanceReferenceExpression(IInstanceReferenceExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitInvalidExpression(IInvalidExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitInvalidStatement(IInvalidStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitInvocationExpression(IInvocationExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitIsTypeExpression(IIsTypeExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitLabelStatement(ILabelStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitLambdaExpression(ILambdaExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitLateBoundMemberReferenceExpression(ILateBoundMemberReferenceExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitLiteralExpression(ILiteralExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitLocalReferenceExpression(ILocalReferenceExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitLockStatement(ILockStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitMethodBindingExpression(IMethodBindingExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitNullCoalescingExpression(INullCoalescingExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitObjectCreationExpression(IObjectCreationExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitOmittedArgumentExpression(IOmittedArgumentExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitParameterInitializer(IParameterInitializer operation, TArgument argument)" />
          <member def="public virtual TResult VisitParameterReferenceExpression(IParameterReferenceExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitParenthesizedExpression(IParenthesizedExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitPlaceholderExpression(IPlaceholderExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitPointerIndirectionReferenceExpression(IPointerIndirectionReferenceExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitPropertyInitializer(IPropertyInitializer operation, TArgument argument)" />
          <member def="public virtual TResult VisitPropertyReferenceExpression(IPropertyReferenceExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitRangeCaseClause(IRangeCaseClause operation, TArgument argument)" />
          <member def="public virtual TResult VisitRelationalCaseClause(IRelationalCaseClause operation, TArgument argument)" />
          <member def="public virtual TResult VisitReturnStatement(IReturnStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitSingleValueCaseClause(ISingleValueCaseClause operation, TArgument argument)" />
          <member def="public virtual TResult VisitSizeOfExpression(ISizeOfExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitStopStatement(IStopStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitSwitchCase(ISwitchCase operation, TArgument argument)" />
          <member def="public virtual TResult VisitSwitchStatement(ISwitchStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitSyntheticLocalReferenceExpression(ISyntheticLocalReferenceExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitThrowStatement(IThrowStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitTryStatement(ITryStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitTypeOfExpression(ITypeOfExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitTypeParameterObjectCreationExpression(ITypeParameterObjectCreationExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitUnaryOperatorExpression(IUnaryOperatorExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitUnboundLambdaExpression(IUnboundLambdaExpression operation, TArgument argument)" />
          <member def="public virtual TResult VisitUsingStatement(IUsingStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitVariableDeclaration(IVariableDeclaration operation, TArgument argument)" />
          <member def="public virtual TResult VisitVariableDeclarationStatement(IVariableDeclarationStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitWhileUntilLoopStatement(IWhileUntilLoopStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitWithStatement(IWithStatement operation, TArgument argument)" />
          <member def="public virtual TResult VisitYieldBreakStatement(IReturnStatement operation, TArgument argument)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Text.SourceText">
        <members>
          <member def="protected SourceText(ImmutableArray&lt;byte&gt; checksum = default, SourceHashAlgorithm checksumAlgorithm = Sha1, SourceTextContainer container = null)" />
          <member def="public bool CanBeEmbedded { get; }" />
          <member def="public SourceHashAlgorithm ChecksumAlgorithm { get; }" />
          <member def="public virtual SourceTextContainer Container { get; }" />
          <member def="public abstract Encoding Encoding { get; }" />
          <member def="public abstract int Length { get; }" />
          <member def="public TextLineCollection Lines { get; }" />
          <member def="public abstract char this[int position] { get; }" />
          <member def="public bool ContentEquals(SourceText other)" />
          <member def="protected virtual bool ContentEqualsImpl(SourceText other)" />
          <member def="public abstract void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count)" />
          <member def="public static SourceText From(string text, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1)" />
          <member def="public static SourceText From(TextReader reader, int length, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1)" />
          <member def="public static SourceText From(Stream stream, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected)" />
          <member def="public static SourceText From(byte[] buffer, int length, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected)" />
          <member def="public static SourceText From(Stream stream, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1, bool throwIfBinaryDetected = false, bool canBeEmbedded = false)" />
          <member def="public static SourceText From(byte[] buffer, int length, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1, bool throwIfBinaryDetected = false, bool canBeEmbedded = false)" />
          <member def="public virtual IReadOnlyList&lt;TextChangeRange&gt; GetChangeRanges(SourceText oldText)" />
          <member def="public ImmutableArray&lt;byte&gt; GetChecksum()" />
          <member def="protected virtual TextLineCollection GetLinesCore()" />
          <member def="public virtual SourceText GetSubText(TextSpan span)" />
          <member def="public SourceText GetSubText(int start)" />
          <member def="public virtual IReadOnlyList&lt;TextChange&gt; GetTextChanges(SourceText oldText)" />
          <member def="public SourceText Replace(TextSpan span, string newText)" />
          <member def="public SourceText Replace(int start, int length, string newText)" />
          <member def="public override string ToString()" />
          <member def="public virtual string ToString(TextSpan span)" />
          <member def="public virtual SourceText WithChanges(IEnumerable&lt;TextChange&gt; changes)" />
          <member def="public SourceText WithChanges(params TextChange[] changes)" />
          <member def="public void Write(TextWriter textWriter, CancellationToken cancellationToken = default)" />
          <member def="public virtual void Write(TextWriter writer, TextSpan span, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Text.SourceTextContainer">
        <members>
          <member def="protected SourceTextContainer()" />
          <member def="public abstract event EventHandler&lt;TextChangeEventArgs&gt; TextChanged" />
          <member def="public abstract SourceText CurrentText { get; }" />
        </members>
      </type>
      <type def="public abstract class Microsoft.CodeAnalysis.Text.TextLineCollection : IEnumerable&lt;TextLine&gt;, IReadOnlyCollection&lt;TextLine&gt;, IReadOnlyList&lt;TextLine&gt;">
        <members>
          <member def="protected TextLineCollection()" />
          <member def="public abstract int Count { get; }" />
          <member def="public abstract TextLine this[int index] { get; }" />
          <member def="public TextLineCollection.Enumerator GetEnumerator()" />
          <member def="public virtual TextLine GetLineFromPosition(int position)" />
          <member def="public virtual LinePosition GetLinePosition(int position)" />
          <member def="public LinePositionSpan GetLinePositionSpan(TextSpan span)" />
          <member def="public int GetPosition(LinePosition position)" />
          <member def="public TextSpan GetTextSpan(LinePositionSpan span)" />
          <member def="public abstract int IndexOf(int position)" />
        </members>
      </type>
      <type def="public abstract class Roslynator.NameGenerator">
        <members>
          <member def="protected NameGenerator()" />
          <member def="public static NameGenerator Default { get; }" />
          <member def="public static string CreateName(ITypeSymbol typeSymbol, bool firstCharToLower = false)" />
          <member def="public string EnsureUniqueEnumMemberName(string baseName, INamedTypeSymbol enumType, bool isCaseSensitive = true)" />
          <member def="public string EnsureUniqueLocalName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true, CancellationToken cancellationToken = default)" />
          <member def="public string EnsureUniqueMemberName(string baseName, INamedTypeSymbol typeSymbol, bool isCaseSensitive = true)" />
          <member def="public string EnsureUniqueMemberName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true, CancellationToken cancellationToken = default)" />
          <member def="public abstract string EnsureUniqueName(string baseName, IEnumerable&lt;string&gt; reservedNames, bool isCaseSensitive = true)" />
          <member def="public abstract string EnsureUniqueName(string baseName, ImmutableArray&lt;ISymbol&gt; symbols, bool isCaseSensitive = true)" />
          <member def="public string EnsureUniqueName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true)" />
          <member def="public static bool IsUniqueName(string name, IEnumerable&lt;string&gt; reservedNames, bool isCaseSensitive = true)" />
          <member def="public static bool IsUniqueName(string name, ImmutableArray&lt;ISymbol&gt; symbols, bool isCaseSensitive = true)" />
        </members>
      </type>
      <type def="public class Roslynator.SeparatedSyntaxListSelection&lt;TNode&gt; : ISelection&lt;TNode&gt; where TNode : SyntaxNode">
        <members>
          <member def="protected SeparatedSyntaxListSelection(SeparatedSyntaxList&lt;TNode&gt; list, TextSpan span, int firstIndex, int lastIndex)" />
          <member def="public int Count { get; }" />
          <member def="public int FirstIndex { get; }" />
          <member def="public int LastIndex { get; }" />
          <member def="public TextSpan OriginalSpan { get; }" />
          <member def="public SeparatedSyntaxList&lt;TNode&gt; UnderlyingList { get; }" />
          <member def="public TNode this[int index] { get; }" />
          <member def="public static SeparatedSyntaxListSelection&lt;TNode&gt; Create(SeparatedSyntaxList&lt;TNode&gt; list, TextSpan span)" />
          <member def="public TNode First()" />
          <member def="public SeparatedSyntaxListSelection&lt;TNode&gt;.Enumerator GetEnumerator()" />
          <member def="public TNode Last()" />
          <member def="public static bool TryCreate(SeparatedSyntaxList&lt;TNode&gt; list, TextSpan span, out SeparatedSyntaxListSelection&lt;TNode&gt; selection)" />
        </members>
      </type>
      <type def="public class Roslynator.SyntaxListSelection&lt;TNode&gt; : ISelection&lt;TNode&gt; where TNode : SyntaxNode">
        <members>
          <member def="protected SyntaxListSelection(SyntaxList&lt;TNode&gt; list, TextSpan span, int firstIndex, int lastIndex)" />
          <member def="public int Count { get; }" />
          <member def="public int FirstIndex { get; }" />
          <member def="public int LastIndex { get; }" />
          <member def="public TextSpan OriginalSpan { get; }" />
          <member def="public SyntaxList&lt;TNode&gt; UnderlyingList { get; }" />
          <member def="public TNode this[int index] { get; }" />
          <member def="public static SyntaxListSelection&lt;TNode&gt; Create(SyntaxList&lt;TNode&gt; list, TextSpan span)" />
          <member def="public TNode First()" />
          <member def="public SyntaxListSelection&lt;TNode&gt;.Enumerator GetEnumerator()" />
          <member def="public TNode Last()" />
          <member def="public static bool TryCreate(SyntaxList&lt;TNode&gt; list, TextSpan span, out SyntaxListSelection&lt;TNode&gt; selection)" />
        </members>
        <type def="public sealed class Roslynator.CSharp.MemberDeclarationListSelection : SyntaxListSelection&lt;MemberDeclarationSyntax&gt;">
          <members>
            <member def="public SyntaxNode Parent { get; }" />
            <member def="public static MemberDeclarationListSelection Create(CompilationUnitSyntax compilationUnit, TextSpan span)" />
            <member def="public static MemberDeclarationListSelection Create(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span)" />
            <member def="public static MemberDeclarationListSelection Create(TypeDeclarationSyntax typeDeclaration, TextSpan span)" />
            <member def="public static bool TryCreate(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span, out MemberDeclarationListSelection selectedMembers)" />
            <member def="public static bool TryCreate(TypeDeclarationSyntax typeDeclaration, TextSpan span, out MemberDeclarationListSelection selectedMembers)" />
          </members>
        </type>
        <type def="public sealed class Roslynator.CSharp.StatementListSelection : SyntaxListSelection&lt;StatementSyntax&gt;">
          <members>
            <member def="public static StatementListSelection Create(BlockSyntax block, TextSpan span)" />
            <member def="public static StatementListSelection Create(SwitchSectionSyntax switchSection, TextSpan span)" />
            <member def="public static StatementListSelection Create(in StatementListInfo statementsInfo, TextSpan span)" />
            <member def="public static bool TryCreate(BlockSyntax block, TextSpan span, out StatementListSelection selectedStatements)" />
            <member def="public static bool TryCreate(SwitchSectionSyntax switchSection, TextSpan span, out StatementListSelection selectedStatements)" />
          </members>
        </type>
      </type>
      <type def="public abstract class Roslynator.CSharp.ModifierList&lt;TNode&gt; where TNode : SyntaxNode">
        <members>
          <member def="public static ModifierList&lt;TNode&gt; Instance { get; }" />
          <member def="public TNode Insert(TNode node, SyntaxKind kind, IComparer&lt;SyntaxKind&gt; comparer = null)" />
          <member def="public TNode Insert(TNode node, SyntaxToken modifier, IComparer&lt;SyntaxToken&gt; comparer = null)" />
          <member def="public TNode Remove(TNode node, SyntaxKind kind)" />
          <member def="public TNode Remove(TNode node, SyntaxToken modifier)" />
          <member def="public TNode RemoveAll(TNode node)" />
          <member def="public TNode RemoveAll(TNode node, Func&lt;SyntaxToken, bool&gt; predicate)" />
          <member def="public TNode RemoveAt(TNode node, int index)" />
        </members>
      </type>
      <type def="public class Roslynator.Text.TextLineCollectionSelection : ISelection&lt;TextLine&gt;">
        <members>
          <member def="protected TextLineCollectionSelection(TextLineCollection lines, TextSpan span, int firstIndex, int lastIndex)" />
          <member def="public int Count { get; }" />
          <member def="public int FirstIndex { get; }" />
          <member def="public int LastIndex { get; }" />
          <member def="public TextSpan OriginalSpan { get; }" />
          <member def="public TextLineCollection UnderlyingLines { get; }" />
          <member def="public TextLine this[int index] { get; }" />
          <member def="public static TextLineCollectionSelection Create(TextLineCollection lines, TextSpan span)" />
          <member def="public TextLine First()" />
          <member def="public TextLineCollectionSelection.Enumerator GetEnumerator()" />
          <member def="public TextLine Last()" />
          <member def="public static bool TryCreate(TextLineCollection lines, TextSpan span, out TextLineCollectionSelection selectedLines)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.AnnotationExtensions">
        <members>
          <member def="public static TNode WithAdditionalAnnotations&lt;TNode&gt;(this TNode node, params SyntaxAnnotation[] annotations) where TNode : SyntaxNode" />
          <member def="public static TNode WithAdditionalAnnotations&lt;TNode&gt;(this TNode node, IEnumerable&lt;SyntaxAnnotation&gt; annotations) where TNode : SyntaxNode" />
          <member def="public static TNode WithoutAnnotations&lt;TNode&gt;(this TNode node, string annotationKind) where TNode : SyntaxNode" />
          <member def="public static TNode WithoutAnnotations&lt;TNode&gt;(this TNode node, params SyntaxAnnotation[] annotations) where TNode : SyntaxNode" />
          <member def="public static TNode WithoutAnnotations&lt;TNode&gt;(this TNode node, IEnumerable&lt;SyntaxAnnotation&gt; annotations) where TNode : SyntaxNode" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.CSharpExtensions">
        <members>
          <member def="public static bool Any(this SyntaxTriviaList list, SyntaxKind kind)" />
          <member def="public static bool Any(this SyntaxTokenList list, SyntaxKind kind)" />
          <member def="public static bool Any&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode" />
          <member def="public static bool Any&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode" />
          <member def="public static int IndexOf(this SyntaxTriviaList list, SyntaxKind kind)" />
          <member def="public static int IndexOf(this SyntaxTokenList list, SyntaxKind kind)" />
          <member def="public static int IndexOf&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode" />
          <member def="public static int IndexOf&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode" />
          <member def="public static bool IsKind(this SyntaxNode node, SyntaxKind kind)" />
          <member def="public static bool IsKind(this SyntaxNodeOrToken nodeOrToken, SyntaxKind kind)" />
          <member def="public static bool IsKind(this SyntaxToken token, SyntaxKind kind)" />
          <member def="public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.CaseInsensitiveComparison">
        <members>
          <member def="public static StringComparer Comparer { get; }" />
          <member def="public static int Compare(string left, string right)" />
          <member def="public static bool EndsWith(string value, string possibleEnd)" />
          <member def="public static bool Equals(string left, string right)" />
          <member def="public static int GetHashCode(string value)" />
          <member def="public static bool StartsWith(string value, string possibleStart)" />
          <member def="public static void ToLower(StringBuilder builder)" />
          <member def="public static char ToLower(char c)" />
          <member def="public static string ToLower(string value)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.DocumentationCommentId">
        <members>
          <member def="public static string CreateDeclarationId(ISymbol symbol)" />
          <member def="public static string CreateReferenceId(ISymbol symbol)" />
          <member def="public static ISymbol GetFirstSymbolForDeclarationId(string id, Compilation compilation)" />
          <member def="public static ISymbol GetFirstSymbolForReferenceId(string id, Compilation compilation)" />
          <member def="public static ImmutableArray&lt;ISymbol&gt; GetSymbolsForDeclarationId(string id, Compilation compilation)" />
          <member def="public static ImmutableArray&lt;ISymbol&gt; GetSymbolsForReferenceId(string id, Compilation compilation)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.FileSystemExtensions">
        <members>
          <member def="public static EmitResult Emit(this Compilation compilation, string outputPath, string pdbPath = null, string xmlDocPath = null, string win32ResourcesPath = null, IEnumerable&lt;ResourceDescription&gt; manifestResources = null, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.ISymbolExtensions">
        <members>
          <member def="public static IMethodSymbol GetConstructedReducedFrom(this IMethodSymbol method)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.LanguageNames">
        <members>
          <member def="public const string CSharp = &quot;C#&quot;" />
          <member def="public const string FSharp = &quot;F#&quot;" />
          <member def="public const string VisualBasic = &quot;Visual Basic&quot;" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.ModelExtensions">
        <members>
          <member def="public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, SyntaxNode statement)" />
          <member def="public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement)" />
          <member def="public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, SyntaxNode statementOrExpression)" />
          <member def="public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement)" />
          <member def="public static IAliasSymbol GetAliasInfo(this SemanticModel semanticModel, SyntaxNode nameSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, SyntaxNode declaration, CancellationToken cancellationToken = default)" />
          <member def="public static ImmutableArray&lt;ISymbol&gt; GetMemberGroup(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default)" />
          <member def="public static IAliasSymbol GetSpeculativeAliasInfo(this SemanticModel semanticModel, int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption)" />
          <member def="public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, SyntaxNode expression, SpeculativeBindingOption bindingOption)" />
          <member def="public static TypeInfo GetSpeculativeTypeInfo(this SemanticModel semanticModel, int position, SyntaxNode expression, SpeculativeBindingOption bindingOption)" />
          <member def="public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default)" />
          <member def="public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.SymbolDisplayExtensions">
        <members>
          <member def="public static string ToDisplayString(this ImmutableArray&lt;SymbolDisplayPart&gt; parts)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.SyntaxNodeExtensions">
        <members>
          <member def="public static TNode GetCurrentNode&lt;TNode&gt;(this SyntaxNode root, TNode node) where TNode : SyntaxNode" />
          <member def="public static IEnumerable&lt;TNode&gt; GetCurrentNodes&lt;TNode&gt;(this SyntaxNode root, TNode node) where TNode : SyntaxNode" />
          <member def="public static IEnumerable&lt;TNode&gt; GetCurrentNodes&lt;TNode&gt;(this SyntaxNode root, IEnumerable&lt;TNode&gt; nodes) where TNode : SyntaxNode" />
          <member def="public static TRoot InsertNodesAfter&lt;TRoot&gt;(this TRoot root, SyntaxNode nodeInList, IEnumerable&lt;SyntaxNode&gt; newNodes) where TRoot : SyntaxNode" />
          <member def="public static TRoot InsertNodesBefore&lt;TRoot&gt;(this TRoot root, SyntaxNode nodeInList, IEnumerable&lt;SyntaxNode&gt; newNodes) where TRoot : SyntaxNode" />
          <member def="public static TRoot InsertTokensAfter&lt;TRoot&gt;(this TRoot root, SyntaxToken tokenInList, IEnumerable&lt;SyntaxToken&gt; newTokens) where TRoot : SyntaxNode" />
          <member def="public static TRoot InsertTokensBefore&lt;TRoot&gt;(this TRoot root, SyntaxToken tokenInList, IEnumerable&lt;SyntaxToken&gt; newTokens) where TRoot : SyntaxNode" />
          <member def="public static TRoot InsertTriviaAfter&lt;TRoot&gt;(this TRoot root, SyntaxTrivia trivia, IEnumerable&lt;SyntaxTrivia&gt; newTrivia) where TRoot : SyntaxNode" />
          <member def="public static TRoot InsertTriviaBefore&lt;TRoot&gt;(this TRoot root, SyntaxTrivia trivia, IEnumerable&lt;SyntaxTrivia&gt; newTrivia) where TRoot : SyntaxNode" />
          <member def="public static TNode NormalizeWhitespace&lt;TNode&gt;(this TNode node, string indentation, bool elasticTrivia) where TNode : SyntaxNode" />
          <member def="public static TNode NormalizeWhitespace&lt;TNode&gt;(this TNode node, string indentation = &quot;    &quot;, string eol = &quot;\r\n&quot;, bool elasticTrivia = false) where TNode : SyntaxNode" />
          <member def="public static TRoot RemoveNode&lt;TRoot&gt;(this TRoot root, SyntaxNode node, SyntaxRemoveOptions options) where TRoot : SyntaxNode" />
          <member def="public static TRoot RemoveNodes&lt;TRoot&gt;(this TRoot root, IEnumerable&lt;SyntaxNode&gt; nodes, SyntaxRemoveOptions options) where TRoot : SyntaxNode" />
          <member def="public static TRoot ReplaceNode&lt;TRoot&gt;(this TRoot root, SyntaxNode oldNode, SyntaxNode newNode) where TRoot : SyntaxNode" />
          <member def="public static TRoot ReplaceNode&lt;TRoot&gt;(this TRoot root, SyntaxNode oldNode, IEnumerable&lt;SyntaxNode&gt; newNodes) where TRoot : SyntaxNode" />
          <member def="public static TRoot ReplaceNodes&lt;TRoot, TNode&gt;(this TRoot root, IEnumerable&lt;TNode&gt; nodes, Func&lt;TNode, TNode, SyntaxNode&gt; computeReplacementNode) where TRoot : SyntaxNode where TNode : SyntaxNode" />
          <member def="public static TRoot ReplaceSyntax&lt;TRoot&gt;(this TRoot root, IEnumerable&lt;SyntaxNode&gt; nodes, Func&lt;SyntaxNode, SyntaxNode, SyntaxNode&gt; computeReplacementNode, IEnumerable&lt;SyntaxToken&gt; tokens, Func&lt;SyntaxToken, SyntaxToken, SyntaxToken&gt; computeReplacementToken, IEnumerable&lt;SyntaxTrivia&gt; trivia, Func&lt;SyntaxTrivia, SyntaxTrivia, SyntaxTrivia&gt; computeReplacementTrivia) where TRoot : SyntaxNode" />
          <member def="public static TRoot ReplaceToken&lt;TRoot&gt;(this TRoot root, SyntaxToken oldToken, SyntaxToken newToken) where TRoot : SyntaxNode" />
          <member def="public static TRoot ReplaceToken&lt;TRoot&gt;(this TRoot root, SyntaxToken tokenInList, IEnumerable&lt;SyntaxToken&gt; newTokens) where TRoot : SyntaxNode" />
          <member def="public static TRoot ReplaceTokens&lt;TRoot&gt;(this TRoot root, IEnumerable&lt;SyntaxToken&gt; tokens, Func&lt;SyntaxToken, SyntaxToken, SyntaxToken&gt; computeReplacementToken) where TRoot : SyntaxNode" />
          <member def="public static TRoot ReplaceTrivia&lt;TRoot&gt;(this TRoot root, SyntaxTrivia oldTrivia, IEnumerable&lt;SyntaxTrivia&gt; newTrivia) where TRoot : SyntaxNode" />
          <member def="public static TRoot ReplaceTrivia&lt;TRoot&gt;(this TRoot root, IEnumerable&lt;SyntaxTrivia&gt; trivia, Func&lt;SyntaxTrivia, SyntaxTrivia, SyntaxTrivia&gt; computeReplacementTrivia) where TRoot : SyntaxNode" />
          <member def="public static TRoot ReplaceTrivia&lt;TRoot&gt;(this TRoot root, SyntaxTrivia trivia, SyntaxTrivia newTrivia) where TRoot : SyntaxNode" />
          <member def="public static TRoot TrackNodes&lt;TRoot&gt;(this TRoot root, IEnumerable&lt;SyntaxNode&gt; nodes) where TRoot : SyntaxNode" />
          <member def="public static TRoot TrackNodes&lt;TRoot&gt;(this TRoot root, params SyntaxNode[] nodes) where TRoot : SyntaxNode" />
          <member def="public static TSyntax WithLeadingTrivia&lt;TSyntax&gt;(this TSyntax node, SyntaxTriviaList trivia) where TSyntax : SyntaxNode" />
          <member def="public static TSyntax WithLeadingTrivia&lt;TSyntax&gt;(this TSyntax node, IEnumerable&lt;SyntaxTrivia&gt; trivia) where TSyntax : SyntaxNode" />
          <member def="public static TSyntax WithLeadingTrivia&lt;TSyntax&gt;(this TSyntax node, params SyntaxTrivia[] trivia) where TSyntax : SyntaxNode" />
          <member def="public static TSyntax WithTrailingTrivia&lt;TSyntax&gt;(this TSyntax node, SyntaxTriviaList trivia) where TSyntax : SyntaxNode" />
          <member def="public static TSyntax WithTrailingTrivia&lt;TSyntax&gt;(this TSyntax node, IEnumerable&lt;SyntaxTrivia&gt; trivia) where TSyntax : SyntaxNode" />
          <member def="public static TSyntax WithTrailingTrivia&lt;TSyntax&gt;(this TSyntax node, params SyntaxTrivia[] trivia) where TSyntax : SyntaxNode" />
          <member def="public static TSyntax WithTriviaFrom&lt;TSyntax&gt;(this TSyntax syntax, SyntaxNode node) where TSyntax : SyntaxNode" />
          <member def="public static TSyntax WithoutLeadingTrivia&lt;TSyntax&gt;(this TSyntax node) where TSyntax : SyntaxNode" />
          <member def="public static TSyntax WithoutTrailingTrivia&lt;TSyntax&gt;(this TSyntax node) where TSyntax : SyntaxNode" />
          <member def="public static SyntaxToken WithoutTrivia(this SyntaxToken token)" />
          <member def="public static TSyntax WithoutTrivia&lt;TSyntax&gt;(this TSyntax syntax) where TSyntax : SyntaxNode" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.WellKnownDiagnosticTags">
        <members>
          <member def="public const string AnalyzerException = &quot;AnalyzerException&quot;" />
          <member def="public const string Build = &quot;Build&quot;" />
          <member def="public const string Compiler = &quot;Compiler&quot;" />
          <member def="public const string EditAndContinue = &quot;EditAndContinue&quot;" />
          <member def="public const string NotConfigurable = &quot;NotConfigurable&quot;" />
          <member def="public const string Telemetry = &quot;Telemetry&quot;" />
          <member def="public const string Unnecessary = &quot;Unnecessary&quot;" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.WellKnownMemberNames">
        <members>
          <member def="public const string AdditionOperatorName = &quot;op_Addition&quot;" />
          <member def="public const string BitwiseAndOperatorName = &quot;op_BitwiseAnd&quot;" />
          <member def="public const string BitwiseOrOperatorName = &quot;op_BitwiseOr&quot;" />
          <member def="public const string CollectionInitializerAddMethodName = &quot;Add&quot;" />
          <member def="public const string ConcatenateOperatorName = &quot;op_Concatenate&quot;" />
          <member def="public const string CurrentPropertyName = &quot;Current&quot;" />
          <member def="public const string DecrementOperatorName = &quot;op_Decrement&quot;" />
          <member def="public const string DefaultScriptClassName = &quot;Script&quot;" />
          <member def="public const string DelegateBeginInvokeName = &quot;BeginInvoke&quot;" />
          <member def="public const string DelegateEndInvokeName = &quot;EndInvoke&quot;" />
          <member def="public const string DelegateInvokeName = &quot;Invoke&quot;" />
          <member def="public const string DestructorName = &quot;Finalize&quot;" />
          <member def="public const string DivisionOperatorName = &quot;op_Division&quot;" />
          <member def="public const string EntryPointMethodName = &quot;Main&quot;" />
          <member def="public const string EnumBackingFieldName = &quot;value__&quot;" />
          <member def="public const string EqualityOperatorName = &quot;op_Equality&quot;" />
          <member def="public const string ExclusiveOrOperatorName = &quot;op_ExclusiveOr&quot;" />
          <member def="public const string ExplicitConversionName = &quot;op_Explicit&quot;" />
          <member def="public const string ExponentOperatorName = &quot;op_Exponent&quot;" />
          <member def="public const string FalseOperatorName = &quot;op_False&quot;" />
          <member def="public const string GetAwaiter = &quot;GetAwaiter&quot;" />
          <member def="public const string GetEnumeratorMethodName = &quot;GetEnumerator&quot;" />
          <member def="public const string GetResult = &quot;GetResult&quot;" />
          <member def="public const string GreaterThanOperatorName = &quot;op_GreaterThan&quot;" />
          <member def="public const string GreaterThanOrEqualOperatorName = &quot;op_GreaterThanOrEqual&quot;" />
          <member def="public const string ImplicitConversionName = &quot;op_Implicit&quot;" />
          <member def="public const string IncrementOperatorName = &quot;op_Increment&quot;" />
          <member def="public const string Indexer = &quot;this[]&quot;" />
          <member def="public const string InequalityOperatorName = &quot;op_Inequality&quot;" />
          <member def="public const string InstanceConstructorName = &quot;.ctor&quot;" />
          <member def="public const string IntegerDivisionOperatorName = &quot;op_IntegerDivision&quot;" />
          <member def="public const string IsCompleted = &quot;IsCompleted&quot;" />
          <member def="public const string LeftShiftOperatorName = &quot;op_LeftShift&quot;" />
          <member def="public const string LessThanOperatorName = &quot;op_LessThan&quot;" />
          <member def="public const string LessThanOrEqualOperatorName = &quot;op_LessThanOrEqual&quot;" />
          <member def="public const string LikeOperatorName = &quot;op_Like&quot;" />
          <member def="public const string LogicalAndOperatorName = &quot;op_LogicalAnd&quot;" />
          <member def="public const string LogicalNotOperatorName = &quot;op_LogicalNot&quot;" />
          <member def="public const string LogicalOrOperatorName = &quot;op_LogicalOr&quot;" />
          <member def="public const string ModulusOperatorName = &quot;op_Modulus&quot;" />
          <member def="public const string MoveNextMethodName = &quot;MoveNext&quot;" />
          <member def="public const string MultiplyOperatorName = &quot;op_Multiply&quot;" />
          <member def="public const string ObjectEquals = &quot;Equals&quot;" />
          <member def="public const string ObjectGetHashCode = &quot;GetHashCode&quot;" />
          <member def="public const string ObjectToString = &quot;ToString&quot;" />
          <member def="public const string OnCompleted = &quot;OnCompleted&quot;" />
          <member def="public const string OnesComplementOperatorName = &quot;op_OnesComplement&quot;" />
          <member def="public const string RightShiftOperatorName = &quot;op_RightShift&quot;" />
          <member def="public const string StaticConstructorName = &quot;.cctor&quot;" />
          <member def="public const string SubtractionOperatorName = &quot;op_Subtraction&quot;" />
          <member def="public const string TrueOperatorName = &quot;op_True&quot;" />
          <member def="public const string UnaryNegationOperatorName = &quot;op_UnaryNegation&quot;" />
          <member def="public const string UnaryPlusOperatorName = &quot;op_UnaryPlus&quot;" />
          <member def="public const string UnsignedLeftShiftOperatorName = &quot;op_UnsignedLeftShift&quot;" />
          <member def="public const string UnsignedRightShiftOperatorName = &quot;op_UnsignedRightShift&quot;" />
          <member def="public const string ValuePropertyName = &quot;Value&quot;" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.WorkspaceKind">
        <members>
          <member def="public const string Debugger = &quot;Debugger&quot;" />
          <member def="public const string Host = &quot;Host&quot;" />
          <member def="public const string Interactive = &quot;Interactive&quot;" />
          <member def="public const string MetadataAsSource = &quot;MetadataAsSource&quot;" />
          <member def="public const string MiscellaneousFiles = &quot;MiscellaneousFiles&quot;" />
          <member def="public const string Preview = &quot;Preview&quot;" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.CSharp.CSharpExtensions">
        <members>
          <member def="public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax statement)" />
          <member def="public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)" />
          <member def="public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, ExpressionSyntax expression)" />
          <member def="public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax statement)" />
          <member def="public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)" />
          <member def="public static Conversion ClassifyConversion(this Compilation compilation, ITypeSymbol source, ITypeSymbol destination)" />
          <member def="public static Conversion ClassifyConversion(this SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)" />
          <member def="public static Conversion ClassifyConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)" />
          <member def="public static IAliasSymbol GetAliasInfo(this SemanticModel semanticModel, IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static AwaitExpressionInfo GetAwaitExpressionInfo(this SemanticModel semanticModel, AwaitExpressionSyntax awaitExpression)" />
          <member def="public static SymbolInfo GetCollectionInitializerSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)" />
          <member def="public static CompilationUnitSyntax GetCompilationUnitRoot(this SyntaxTree tree, CancellationToken cancellationToken = default)" />
          <member def="public static Optional&lt;object&gt; GetConstantValue(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)" />
          <member def="public static Conversion GetConversion(this SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken = default)" />
          <member def="public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, CatchDeclarationSyntax catchDeclaration, CancellationToken cancellationToken = default)" />
          <member def="public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static INamespaceSymbol GetDeclaredSymbol(this SemanticModel semanticModel, NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static IFieldSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static IEventSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, TupleElementSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static IParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ParameterSyntax declarationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, TupleExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, ArgumentSyntax declaratorSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, SingleVariableDesignationSyntax designationSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, CancellationToken cancellationToken = default)" />
          <member def="public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, JoinIntoClauseSyntax node, CancellationToken cancellationToken = default)" />
          <member def="public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryContinuationSyntax node, CancellationToken cancellationToken = default)" />
          <member def="public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryClauseSyntax queryClause, CancellationToken cancellationToken = default)" />
          <member def="public static ITypeParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, TypeParameterSyntax typeParameter, CancellationToken cancellationToken = default)" />
          <member def="public static DirectiveTriviaSyntax GetFirstDirective(this SyntaxNode node, Func&lt;DirectiveTriviaSyntax, bool&gt; predicate = null)" />
          <member def="public static ForEachStatementInfo GetForEachStatementInfo(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement)" />
          <member def="public static ForEachStatementInfo GetForEachStatementInfo(this SemanticModel semanticModel, CommonForEachStatementSyntax forEachStatement)" />
          <member def="public static ImmutableArray&lt;IPropertySymbol&gt; GetIndexerGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)" />
          <member def="public static DirectiveTriviaSyntax GetLastDirective(this SyntaxNode node, Func&lt;DirectiveTriviaSyntax, bool&gt; predicate = null)" />
          <member def="public static ImmutableArray&lt;ISymbol&gt; GetMemberGroup(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default)" />
          <member def="public static ImmutableArray&lt;ISymbol&gt; GetMemberGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)" />
          <member def="public static ImmutableArray&lt;ISymbol&gt; GetMemberGroup(this SemanticModel semanticModel, ConstructorInitializerSyntax initializer, CancellationToken cancellationToken = default)" />
          <member def="public static QueryClauseInfo GetQueryClauseInfo(this SemanticModel semanticModel, QueryClauseSyntax node, CancellationToken cancellationToken = default)" />
          <member def="public static IAliasSymbol GetSpeculativeAliasInfo(this SemanticModel semanticModel, int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption)" />
          <member def="public static Conversion GetSpeculativeConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)" />
          <member def="public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, AttributeSyntax attribute)" />
          <member def="public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer)" />
          <member def="public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)" />
          <member def="public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, CrefSyntax expression, SpeculativeBindingOption bindingOption)" />
          <member def="public static TypeInfo GetSpeculativeTypeInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)" />
          <member def="public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default)" />
          <member def="public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, CrefSyntax crefSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)" />
          <member def="public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, OrderingSyntax node, CancellationToken cancellationToken = default)" />
          <member def="public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default)" />
          <member def="public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default)" />
          <member def="public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default)" />
          <member def="public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)" />
          <member def="public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default)" />
          <member def="public static SyntaxTokenList Insert(this SyntaxTokenList list, int index, params SyntaxToken[] items)" />
          <member def="public static bool IsContextualKeyword(this SyntaxToken token)" />
          <member def="public static bool IsKeyword(this SyntaxToken token)" />
          <member def="public static bool IsReservedKeyword(this SyntaxToken token)" />
          <member def="public static bool IsVerbatimIdentifier(this SyntaxToken token)" />
          <member def="public static bool IsVerbatimStringLiteral(this SyntaxToken token)" />
          <member def="public static SyntaxKind Kind(this SyntaxNode node)" />
          <member def="public static SyntaxKind Kind(this SyntaxNodeOrToken nodeOrToken)" />
          <member def="public static SyntaxKind Kind(this SyntaxToken token)" />
          <member def="public static SyntaxKind Kind(this SyntaxTrivia trivia)" />
          <member def="public static SyntaxToken ReplaceTrivia(this SyntaxToken token, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia)" />
          <member def="public static SyntaxToken ReplaceTrivia(this SyntaxToken token, IEnumerable&lt;SyntaxTrivia&gt; trivia, Func&lt;SyntaxTrivia, SyntaxTrivia, SyntaxTrivia&gt; computeReplacementTrivia)" />
          <member def="public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, AttributeSyntax attribute, out SemanticModel speculativeModel)" />
          <member def="public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer, out SemanticModel speculativeModel)" />
          <member def="public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, CrefSyntax crefSyntax, out SemanticModel speculativeModel)" />
          <member def="public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ArrowExpressionClauseSyntax expressionBody, out SemanticModel speculativeModel)" />
          <member def="public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, EqualsValueClauseSyntax initializer, out SemanticModel speculativeModel)" />
          <member def="public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, StatementSyntax statement, out SemanticModel speculativeModel)" />
          <member def="public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, TypeSyntax type, out SemanticModel speculativeModel, SpeculativeBindingOption bindingOption = BindAsExpression)" />
          <member def="public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, AccessorDeclarationSyntax accessor, out SemanticModel speculativeModel)" />
          <member def="public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, BaseMethodDeclarationSyntax method, out SemanticModel speculativeModel)" />
          <member def="public static VarianceKind VarianceKindFromToken(this SyntaxToken node)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.CSharp.CSharpFileSystemExtensions">
        <members>
          <member def="public static EmitResult Emit(this CSharpCompilation compilation, string outputPath, string pdbPath = null, string xmlDocumentationPath = null, string win32ResourcesPath = null, IEnumerable&lt;ResourceDescription&gt; manifestResources = null, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts">
        <members>
          <member def="public static LanguageVersion MapSpecifiedToEffectiveVersion(this LanguageVersion version)" />
          <member def="public static string ToDisplayString(this LanguageVersion version)" />
          <member def="public static bool TryParse(this string version, out LanguageVersion result)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.CSharp.SymbolDisplay">
        <members>
          <member def="public static string FormatLiteral(char c, bool quote)" />
          <member def="public static string FormatLiteral(string value, bool quote)" />
          <member def="public static string FormatPrimitive(object obj, bool quoteStrings, bool useHexadecimalNumbers)" />
          <member def="public static ImmutableArray&lt;SymbolDisplayPart&gt; ToDisplayParts(ISymbol symbol, SymbolDisplayFormat format = null)" />
          <member def="public static string ToDisplayString(ISymbol symbol, SymbolDisplayFormat format = null)" />
          <member def="public static ImmutableArray&lt;SymbolDisplayPart&gt; ToMinimalDisplayParts(ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)" />
          <member def="public static string ToMinimalDisplayString(ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.CSharp.SyntaxExtensions">
        <members>
          <member def="public static SyntaxTriviaList NormalizeWhitespace(this SyntaxTriviaList list, string indentation, bool elasticTrivia)" />
          <member def="public static SyntaxToken NormalizeWhitespace(this SyntaxToken token, string indentation, bool elasticTrivia)" />
          <member def="public static SyntaxTriviaList NormalizeWhitespace(this SyntaxTriviaList list, string indentation = &quot;    &quot;, string eol = &quot;\r\n&quot;, bool elasticTrivia = false)" />
          <member def="public static SyntaxToken NormalizeWhitespace(this SyntaxToken token, string indentation = &quot;    &quot;, string eol = &quot;\r\n&quot;, bool elasticTrivia = false)" />
          <member def="public static SyntaxTriviaList ToSyntaxTriviaList(this IEnumerable&lt;SyntaxTrivia&gt; sequence)" />
          <member def="public static IndexerDeclarationSyntax Update(this IndexerDeclarationSyntax syntax, SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList)" />
          <member def="public static OperatorDeclarationSyntax Update(this OperatorDeclarationSyntax syntax, SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax block, SyntaxToken semicolonToken)" />
          <member def="public static MethodDeclarationSyntax Update(this MethodDeclarationSyntax syntax, SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, BlockSyntax block, SyntaxToken semicolonToken)" />
          <member def="public static SimpleNameSyntax WithIdentifier(this SimpleNameSyntax simpleName, SyntaxToken identifier)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.CSharp.SyntaxFactory">
        <members>
          <member def="public static SyntaxTrivia CarriageReturn { get; }" />
          <member def="public static SyntaxTrivia CarriageReturnLineFeed { get; }" />
          <member def="public static SyntaxTrivia ElasticCarriageReturn { get; }" />
          <member def="public static SyntaxTrivia ElasticCarriageReturnLineFeed { get; }" />
          <member def="public static SyntaxTrivia ElasticLineFeed { get; }" />
          <member def="public static SyntaxTrivia ElasticMarker { get; }" />
          <member def="public static SyntaxTrivia ElasticSpace { get; }" />
          <member def="public static SyntaxTrivia ElasticTab { get; }" />
          <member def="public static SyntaxTrivia LineFeed { get; }" />
          <member def="public static SyntaxTrivia Space { get; }" />
          <member def="public static SyntaxTrivia Tab { get; }" />
          <member def="public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind)" />
          <member def="public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, BlockSyntax body)" />
          <member def="public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, BlockSyntax body)" />
          <member def="public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken)" />
          <member def="public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
          <member def="public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
          <member def="public static AccessorListSyntax AccessorList(SyntaxList&lt;AccessorDeclarationSyntax&gt; accessors = default)" />
          <member def="public static AccessorListSyntax AccessorList(SyntaxToken openBraceToken, SyntaxList&lt;AccessorDeclarationSyntax&gt; accessors, SyntaxToken closeBraceToken)" />
          <member def="public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SimpleNameSyntax name)" />
          <member def="public static AliasQualifiedNameSyntax AliasQualifiedName(string alias, SimpleNameSyntax name)" />
          <member def="public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)" />
          <member def="public static AnonymousMethodExpressionSyntax AnonymousMethodExpression()" />
          <member def="public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(CSharpSyntaxNode body)" />
          <member def="public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(ParameterListSyntax parameterList, CSharpSyntaxNode body)" />
          <member def="public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)" />
          <member def="public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SeparatedSyntaxList&lt;AnonymousObjectMemberDeclaratorSyntax&gt; initializers = default)" />
          <member def="public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList&lt;AnonymousObjectMemberDeclaratorSyntax&gt; initializers, SyntaxToken closeBraceToken)" />
          <member def="public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(ExpressionSyntax expression)" />
          <member def="public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression)" />
          <member def="public static bool AreEquivalent(SyntaxTokenList oldList, SyntaxTokenList newList)" />
          <member def="public static bool AreEquivalent(SyntaxToken oldToken, SyntaxToken newToken)" />
          <member def="public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, Func&lt;SyntaxKind, bool&gt; ignoreChildNode = null)" />
          <member def="public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, bool topLevel)" />
          <member def="public static bool AreEquivalent(SyntaxTree oldTree, SyntaxTree newTree, bool topLevel)" />
          <member def="public static bool AreEquivalent&lt;TNode&gt;(SyntaxList&lt;TNode&gt; oldList, SyntaxList&lt;TNode&gt; newList, Func&lt;SyntaxKind, bool&gt; ignoreChildNode = null) where TNode : SyntaxNode" />
          <member def="public static bool AreEquivalent&lt;TNode&gt;(SeparatedSyntaxList&lt;TNode&gt; oldList, SeparatedSyntaxList&lt;TNode&gt; newList, Func&lt;SyntaxKind, bool&gt; ignoreChildNode = null) where TNode : SyntaxNode" />
          <member def="public static bool AreEquivalent&lt;TNode&gt;(SyntaxList&lt;TNode&gt; oldList, SyntaxList&lt;TNode&gt; newList, bool topLevel) where TNode : CSharpSyntaxNode" />
          <member def="public static bool AreEquivalent&lt;TNode&gt;(SeparatedSyntaxList&lt;TNode&gt; oldList, SeparatedSyntaxList&lt;TNode&gt; newList, bool topLevel) where TNode : SyntaxNode" />
          <member def="public static ArgumentSyntax Argument(ExpressionSyntax expression)" />
          <member def="public static ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)" />
          <member def="public static ArgumentListSyntax ArgumentList(SeparatedSyntaxList&lt;ArgumentSyntax&gt; arguments = default)" />
          <member def="public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList&lt;ArgumentSyntax&gt; arguments, SyntaxToken closeParenToken)" />
          <member def="public static ArrayCreationExpressionSyntax ArrayCreationExpression(ArrayTypeSyntax type)" />
          <member def="public static ArrayCreationExpressionSyntax ArrayCreationExpression(ArrayTypeSyntax type, InitializerExpressionSyntax initializer)" />
          <member def="public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)" />
          <member def="public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SeparatedSyntaxList&lt;ExpressionSyntax&gt; sizes = default)" />
          <member def="public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, SeparatedSyntaxList&lt;ExpressionSyntax&gt; sizes, SyntaxToken closeBracketToken)" />
          <member def="public static ArrayTypeSyntax ArrayType(TypeSyntax elementType)" />
          <member def="public static ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList&lt;ArrayRankSpecifierSyntax&gt; rankSpecifiers)" />
          <member def="public static ArrowExpressionClauseSyntax ArrowExpressionClause(ExpressionSyntax expression)" />
          <member def="public static ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, ExpressionSyntax expression)" />
          <member def="public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static AttributeSyntax Attribute(NameSyntax name)" />
          <member def="public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList)" />
          <member def="public static AttributeArgumentSyntax AttributeArgument(ExpressionSyntax expression)" />
          <member def="public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)" />
          <member def="public static AttributeArgumentListSyntax AttributeArgumentList(SeparatedSyntaxList&lt;AttributeArgumentSyntax&gt; arguments = default)" />
          <member def="public static AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList&lt;AttributeArgumentSyntax&gt; arguments, SyntaxToken closeParenToken)" />
          <member def="public static AttributeListSyntax AttributeList(SeparatedSyntaxList&lt;AttributeSyntax&gt; attributes = default)" />
          <member def="public static AttributeListSyntax AttributeList(AttributeTargetSpecifierSyntax target, SeparatedSyntaxList&lt;AttributeSyntax&gt; attributes)" />
          <member def="public static AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList&lt;AttributeSyntax&gt; attributes, SyntaxToken closeBracketToken)" />
          <member def="public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier)" />
          <member def="public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)" />
          <member def="public static AwaitExpressionSyntax AwaitExpression(ExpressionSyntax expression)" />
          <member def="public static AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression)" />
          <member def="public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken identifier, bool isActive)" />
          <member def="public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)" />
          <member def="public static SyntaxToken BadToken(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing)" />
          <member def="public static BaseExpressionSyntax BaseExpression()" />
          <member def="public static BaseExpressionSyntax BaseExpression(SyntaxToken token)" />
          <member def="public static BaseListSyntax BaseList(SeparatedSyntaxList&lt;BaseTypeSyntax&gt; types = default)" />
          <member def="public static BaseListSyntax BaseList(SyntaxToken colonToken, SeparatedSyntaxList&lt;BaseTypeSyntax&gt; types)" />
          <member def="public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static BlockSyntax Block(params StatementSyntax[] statements)" />
          <member def="public static BlockSyntax Block(IEnumerable&lt;StatementSyntax&gt; statements)" />
          <member def="public static BlockSyntax Block(SyntaxList&lt;StatementSyntax&gt; statements = default)" />
          <member def="public static BlockSyntax Block(SyntaxToken openBraceToken, SyntaxList&lt;StatementSyntax&gt; statements, SyntaxToken closeBraceToken)" />
          <member def="public static BracketedArgumentListSyntax BracketedArgumentList(SeparatedSyntaxList&lt;ArgumentSyntax&gt; arguments = default)" />
          <member def="public static BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, SeparatedSyntaxList&lt;ArgumentSyntax&gt; arguments, SyntaxToken closeBracketToken)" />
          <member def="public static BracketedParameterListSyntax BracketedParameterList(SeparatedSyntaxList&lt;ParameterSyntax&gt; parameters = default)" />
          <member def="public static BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList&lt;ParameterSyntax&gt; parameters, SyntaxToken closeBracketToken)" />
          <member def="public static BreakStatementSyntax BreakStatement()" />
          <member def="public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken)" />
          <member def="public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(PatternSyntax pattern, SyntaxToken colonToken)" />
          <member def="public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)" />
          <member def="public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)" />
          <member def="public static CaseSwitchLabelSyntax CaseSwitchLabel(ExpressionSyntax value)" />
          <member def="public static CaseSwitchLabelSyntax CaseSwitchLabel(ExpressionSyntax value, SyntaxToken colonToken)" />
          <member def="public static CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)" />
          <member def="public static CastExpressionSyntax CastExpression(TypeSyntax type, ExpressionSyntax expression)" />
          <member def="public static CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)" />
          <member def="public static CatchClauseSyntax CatchClause()" />
          <member def="public static CatchClauseSyntax CatchClause(CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)" />
          <member def="public static CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)" />
          <member def="public static CatchDeclarationSyntax CatchDeclaration(TypeSyntax type)" />
          <member def="public static CatchDeclarationSyntax CatchDeclaration(TypeSyntax type, SyntaxToken identifier)" />
          <member def="public static CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)" />
          <member def="public static CatchFilterClauseSyntax CatchFilterClause(ExpressionSyntax filterExpression)" />
          <member def="public static CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)" />
          <member def="public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, ExpressionSyntax expression)" />
          <member def="public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)" />
          <member def="public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, BlockSyntax block = null)" />
          <member def="public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)" />
          <member def="public static ClassDeclarationSyntax ClassDeclaration(SyntaxToken identifier)" />
          <member def="public static ClassDeclarationSyntax ClassDeclaration(string identifier)" />
          <member def="public static ClassDeclarationSyntax ClassDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, SyntaxList&lt;MemberDeclarationSyntax&gt; members)" />
          <member def="public static ClassDeclarationSyntax ClassDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, SyntaxToken openBraceToken, SyntaxList&lt;MemberDeclarationSyntax&gt; members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)" />
          <member def="public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind)" />
          <member def="public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword)" />
          <member def="public static SyntaxTrivia Comment(string text)" />
          <member def="public static CompilationUnitSyntax CompilationUnit()" />
          <member def="public static CompilationUnitSyntax CompilationUnit(SyntaxList&lt;ExternAliasDirectiveSyntax&gt; externs, SyntaxList&lt;UsingDirectiveSyntax&gt; usings, SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxList&lt;MemberDeclarationSyntax&gt; members)" />
          <member def="public static CompilationUnitSyntax CompilationUnit(SyntaxList&lt;ExternAliasDirectiveSyntax&gt; externs, SyntaxList&lt;UsingDirectiveSyntax&gt; usings, SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxList&lt;MemberDeclarationSyntax&gt; members, SyntaxToken endOfFileToken)" />
          <member def="public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, ExpressionSyntax whenNotNull)" />
          <member def="public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)" />
          <member def="public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse)" />
          <member def="public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)" />
          <member def="public static ConstantPatternSyntax ConstantPattern(ExpressionSyntax expression)" />
          <member def="public static ConstructorConstraintSyntax ConstructorConstraint()" />
          <member def="public static ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)" />
          <member def="public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxToken identifier)" />
          <member def="public static ConstructorDeclarationSyntax ConstructorDeclaration(string identifier)" />
          <member def="public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body)" />
          <member def="public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken)" />
          <member def="public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
          <member def="public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
          <member def="public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, ArgumentListSyntax argumentList = null)" />
          <member def="public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)" />
          <member def="public static ContinueStatementSyntax ContinueStatement()" />
          <member def="public static ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken)" />
          <member def="public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type)" />
          <member def="public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)" />
          <member def="public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
          <member def="public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type)" />
          <member def="public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type, CrefParameterListSyntax parameters)" />
          <member def="public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)" />
          <member def="public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SeparatedSyntaxList&lt;CrefParameterSyntax&gt; parameters = default)" />
          <member def="public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList&lt;CrefParameterSyntax&gt; parameters, SyntaxToken closeBracketToken)" />
          <member def="public static CrefParameterSyntax CrefParameter(TypeSyntax type)" />
          <member def="public static CrefParameterSyntax CrefParameter(SyntaxToken refOrOutKeyword, TypeSyntax type)" />
          <member def="public static CrefParameterListSyntax CrefParameterList(SeparatedSyntaxList&lt;CrefParameterSyntax&gt; parameters = default)" />
          <member def="public static CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, SeparatedSyntaxList&lt;CrefParameterSyntax&gt; parameters, SyntaxToken closeParenToken)" />
          <member def="public static DeclarationExpressionSyntax DeclarationExpression(TypeSyntax type, VariableDesignationSyntax designation)" />
          <member def="public static DeclarationPatternSyntax DeclarationPattern(TypeSyntax type, VariableDesignationSyntax designation)" />
          <member def="public static DefaultExpressionSyntax DefaultExpression(TypeSyntax type)" />
          <member def="public static DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)" />
          <member def="public static DefaultSwitchLabelSyntax DefaultSwitchLabel()" />
          <member def="public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken colonToken)" />
          <member def="public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken)" />
          <member def="public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken name, bool isActive)" />
          <member def="public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(string name, bool isActive)" />
          <member def="public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)" />
          <member def="public static DelegateDeclarationSyntax DelegateDeclaration(TypeSyntax returnType, SyntaxToken identifier)" />
          <member def="public static DelegateDeclarationSyntax DelegateDeclaration(TypeSyntax returnType, string identifier)" />
          <member def="public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses)" />
          <member def="public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, SyntaxToken semicolonToken)" />
          <member def="public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxToken identifier)" />
          <member def="public static DestructorDeclarationSyntax DestructorDeclaration(string identifier)" />
          <member def="public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body)" />
          <member def="public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)" />
          <member def="public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
          <member def="public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
          <member def="public static SyntaxTrivia DisabledText(string text)" />
          <member def="public static DiscardDesignationSyntax DiscardDesignation()" />
          <member def="public static DiscardDesignationSyntax DiscardDesignation(SyntaxToken underscoreToken)" />
          <member def="public static DoStatementSyntax DoStatement(StatementSyntax statement, ExpressionSyntax condition)" />
          <member def="public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)" />
          <member def="public static DocumentationCommentTriviaSyntax DocumentationComment(params XmlNodeSyntax[] content)" />
          <member def="public static SyntaxTrivia DocumentationCommentExterior(string text)" />
          <member def="public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList&lt;XmlNodeSyntax&gt; content = default)" />
          <member def="public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList&lt;XmlNodeSyntax&gt; content, SyntaxToken endOfComment)" />
          <member def="public static SyntaxTrivia ElasticEndOfLine(string text)" />
          <member def="public static SyntaxTrivia ElasticWhitespace(string text)" />
          <member def="public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression)" />
          <member def="public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)" />
          <member def="public static ElementBindingExpressionSyntax ElementBindingExpression()" />
          <member def="public static ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList)" />
          <member def="public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue)" />
          <member def="public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)" />
          <member def="public static ElseClauseSyntax ElseClause(StatementSyntax statement)" />
          <member def="public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)" />
          <member def="public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(bool isActive, bool branchTaken)" />
          <member def="public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)" />
          <member def="public static EmptyStatementSyntax EmptyStatement()" />
          <member def="public static EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)" />
          <member def="public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(bool isActive)" />
          <member def="public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)" />
          <member def="public static SyntaxTrivia EndOfLine(string text)" />
          <member def="public static SyntaxTrivia EndOfLine(string text, bool elastic)" />
          <member def="public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(bool isActive)" />
          <member def="public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)" />
          <member def="public static EnumDeclarationSyntax EnumDeclaration(SyntaxToken identifier)" />
          <member def="public static EnumDeclarationSyntax EnumDeclaration(string identifier)" />
          <member def="public static EnumDeclarationSyntax EnumDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, BaseListSyntax baseList, SeparatedSyntaxList&lt;EnumMemberDeclarationSyntax&gt; members)" />
          <member def="public static EnumDeclarationSyntax EnumDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList&lt;EnumMemberDeclarationSyntax&gt; members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)" />
          <member def="public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier)" />
          <member def="public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string identifier)" />
          <member def="public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)" />
          <member def="public static EqualsValueClauseSyntax EqualsValueClause(ExpressionSyntax value)" />
          <member def="public static EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value)" />
          <member def="public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(bool isActive)" />
          <member def="public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)" />
          <member def="public static EventDeclarationSyntax EventDeclaration(TypeSyntax type, SyntaxToken identifier)" />
          <member def="public static EventDeclarationSyntax EventDeclaration(TypeSyntax type, string identifier)" />
          <member def="public static EventDeclarationSyntax EventDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)" />
          <member def="public static EventDeclarationSyntax EventDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)" />
          <member def="public static EventFieldDeclarationSyntax EventFieldDeclaration(VariableDeclarationSyntax declaration)" />
          <member def="public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration)" />
          <member def="public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)" />
          <member def="public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name)" />
          <member def="public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)" />
          <member def="public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression)" />
          <member def="public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken)" />
          <member def="public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken identifier)" />
          <member def="public static ExternAliasDirectiveSyntax ExternAliasDirective(string identifier)" />
          <member def="public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)" />
          <member def="public static FieldDeclarationSyntax FieldDeclaration(VariableDeclarationSyntax declaration)" />
          <member def="public static FieldDeclarationSyntax FieldDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration)" />
          <member def="public static FieldDeclarationSyntax FieldDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)" />
          <member def="public static FinallyClauseSyntax FinallyClause(BlockSyntax block = null)" />
          <member def="public static FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)" />
          <member def="public static FixedStatementSyntax FixedStatement(VariableDeclarationSyntax declaration, StatementSyntax statement)" />
          <member def="public static FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)" />
          <member def="public static ForEachStatementSyntax ForEachStatement(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax expression, StatementSyntax statement)" />
          <member def="public static ForEachStatementSyntax ForEachStatement(TypeSyntax type, string identifier, ExpressionSyntax expression, StatementSyntax statement)" />
          <member def="public static ForEachStatementSyntax ForEachStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)" />
          <member def="public static ForEachVariableStatementSyntax ForEachVariableStatement(ExpressionSyntax variable, ExpressionSyntax expression, StatementSyntax statement)" />
          <member def="public static ForEachVariableStatementSyntax ForEachVariableStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)" />
          <member def="public static ForStatementSyntax ForStatement(StatementSyntax statement)" />
          <member def="public static ForStatementSyntax ForStatement(VariableDeclarationSyntax declaration, SeparatedSyntaxList&lt;ExpressionSyntax&gt; initializers, ExpressionSyntax condition, SeparatedSyntaxList&lt;ExpressionSyntax&gt; incrementors, StatementSyntax statement)" />
          <member def="public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList&lt;ExpressionSyntax&gt; initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList&lt;ExpressionSyntax&gt; incrementors, SyntaxToken closeParenToken, StatementSyntax statement)" />
          <member def="public static FromClauseSyntax FromClause(SyntaxToken identifier, ExpressionSyntax expression)" />
          <member def="public static FromClauseSyntax FromClause(string identifier, ExpressionSyntax expression)" />
          <member def="public static FromClauseSyntax FromClause(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax expression)" />
          <member def="public static FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)" />
          <member def="public static GenericNameSyntax GenericName(SyntaxToken identifier)" />
          <member def="public static GenericNameSyntax GenericName(string identifier)" />
          <member def="public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)" />
          <member def="public static ExpressionSyntax GetNonGenericExpression(ExpressionSyntax expression)" />
          <member def="public static ExpressionSyntax GetStandaloneExpression(ExpressionSyntax expression)" />
          <member def="public static GlobalStatementSyntax GlobalStatement(StatementSyntax statement)" />
          <member def="public static GotoStatementSyntax GotoStatement(SyntaxKind kind, ExpressionSyntax expression = null)" />
          <member def="public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression)" />
          <member def="public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)" />
          <member def="public static GroupClauseSyntax GroupClause(ExpressionSyntax groupExpression, ExpressionSyntax byExpression)" />
          <member def="public static GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)" />
          <member def="public static SyntaxToken Identifier(string text)" />
          <member def="public static SyntaxToken Identifier(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing)" />
          <member def="public static SyntaxToken Identifier(SyntaxTriviaList leading, SyntaxKind contextualKind, string text, string valueText, SyntaxTriviaList trailing)" />
          <member def="public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)" />
          <member def="public static IdentifierNameSyntax IdentifierName(string name)" />
          <member def="public static IfDirectiveTriviaSyntax IfDirectiveTrivia(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue)" />
          <member def="public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)" />
          <member def="public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementSyntax statement)" />
          <member def="public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementSyntax statement, ElseClauseSyntax @else)" />
          <member def="public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)" />
          <member def="public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(InitializerExpressionSyntax initializer)" />
          <member def="public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxTokenList commas, InitializerExpressionSyntax initializer)" />
          <member def="public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)" />
          <member def="public static ImplicitElementAccessSyntax ImplicitElementAccess()" />
          <member def="public static ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList)" />
          <member def="public static IncompleteMemberSyntax IncompleteMember(TypeSyntax type = null)" />
          <member def="public static IncompleteMemberSyntax IncompleteMember(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax type)" />
          <member def="public static IndexerDeclarationSyntax IndexerDeclaration(TypeSyntax type)" />
          <member def="public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList)" />
          <member def="public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
          <member def="public static IndexerMemberCrefSyntax IndexerMemberCref(CrefBracketedParameterListSyntax parameters = null)" />
          <member def="public static IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)" />
          <member def="public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions = default)" />
          <member def="public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions, SyntaxToken closeBraceToken)" />
          <member def="public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxToken identifier)" />
          <member def="public static InterfaceDeclarationSyntax InterfaceDeclaration(string identifier)" />
          <member def="public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, SyntaxList&lt;MemberDeclarationSyntax&gt; members)" />
          <member def="public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, SyntaxToken openBraceToken, SyntaxList&lt;MemberDeclarationSyntax&gt; members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)" />
          <member def="public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken)" />
          <member def="public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList&lt;InterpolatedStringContentSyntax&gt; contents)" />
          <member def="public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList&lt;InterpolatedStringContentSyntax&gt; contents, SyntaxToken stringEndToken)" />
          <member def="public static InterpolatedStringTextSyntax InterpolatedStringText()" />
          <member def="public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)" />
          <member def="public static InterpolationSyntax Interpolation(ExpressionSyntax expression)" />
          <member def="public static InterpolationSyntax Interpolation(ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause)" />
          <member def="public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)" />
          <member def="public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value)" />
          <member def="public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken)" />
          <member def="public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)" />
          <member def="public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression)" />
          <member def="public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)" />
          <member def="public static bool IsCompleteSubmission(SyntaxTree tree)" />
          <member def="public static IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, PatternSyntax pattern)" />
          <member def="public static IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)" />
          <member def="public static JoinClauseSyntax JoinClause(SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression)" />
          <member def="public static JoinClauseSyntax JoinClause(string identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression)" />
          <member def="public static JoinClauseSyntax JoinClause(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)" />
          <member def="public static JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)" />
          <member def="public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken identifier)" />
          <member def="public static JoinIntoClauseSyntax JoinIntoClause(string identifier)" />
          <member def="public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)" />
          <member def="public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, StatementSyntax statement)" />
          <member def="public static LabeledStatementSyntax LabeledStatement(string identifier, StatementSyntax statement)" />
          <member def="public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)" />
          <member def="public static LetClauseSyntax LetClause(SyntaxToken identifier, ExpressionSyntax expression)" />
          <member def="public static LetClauseSyntax LetClause(string identifier, ExpressionSyntax expression)" />
          <member def="public static LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)" />
          <member def="public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken line, bool isActive)" />
          <member def="public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken line, SyntaxToken file, bool isActive)" />
          <member def="public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)" />
          <member def="public static SyntaxList&lt;TNode&gt; List&lt;TNode&gt;() where TNode : SyntaxNode" />
          <member def="public static SyntaxList&lt;TNode&gt; List&lt;TNode&gt;(IEnumerable&lt;TNode&gt; nodes) where TNode : SyntaxNode" />
          <member def="public static SyntaxToken Literal(int value)" />
          <member def="public static SyntaxToken Literal(uint value)" />
          <member def="public static SyntaxToken Literal(long value)" />
          <member def="public static SyntaxToken Literal(ulong value)" />
          <member def="public static SyntaxToken Literal(float value)" />
          <member def="public static SyntaxToken Literal(double value)" />
          <member def="public static SyntaxToken Literal(decimal value)" />
          <member def="public static SyntaxToken Literal(string value)" />
          <member def="public static SyntaxToken Literal(char value)" />
          <member def="public static SyntaxToken Literal(string text, int value)" />
          <member def="public static SyntaxToken Literal(string text, uint value)" />
          <member def="public static SyntaxToken Literal(string text, long value)" />
          <member def="public static SyntaxToken Literal(string text, ulong value)" />
          <member def="public static SyntaxToken Literal(string text, float value)" />
          <member def="public static SyntaxToken Literal(string text, double value)" />
          <member def="public static SyntaxToken Literal(string text, decimal value)" />
          <member def="public static SyntaxToken Literal(string text, string value)" />
          <member def="public static SyntaxToken Literal(string text, char value)" />
          <member def="public static SyntaxToken Literal(SyntaxTriviaList leading, string text, int value, SyntaxTriviaList trailing)" />
          <member def="public static SyntaxToken Literal(SyntaxTriviaList leading, string text, uint value, SyntaxTriviaList trailing)" />
          <member def="public static SyntaxToken Literal(SyntaxTriviaList leading, string text, long value, SyntaxTriviaList trailing)" />
          <member def="public static SyntaxToken Literal(SyntaxTriviaList leading, string text, ulong value, SyntaxTriviaList trailing)" />
          <member def="public static SyntaxToken Literal(SyntaxTriviaList leading, string text, float value, SyntaxTriviaList trailing)" />
          <member def="public static SyntaxToken Literal(SyntaxTriviaList leading, string text, double value, SyntaxTriviaList trailing)" />
          <member def="public static SyntaxToken Literal(SyntaxTriviaList leading, string text, decimal value, SyntaxTriviaList trailing)" />
          <member def="public static SyntaxToken Literal(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)" />
          <member def="public static SyntaxToken Literal(SyntaxTriviaList leading, string text, char value, SyntaxTriviaList trailing)" />
          <member def="public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind)" />
          <member def="public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)" />
          <member def="public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken file, bool isActive)" />
          <member def="public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)" />
          <member def="public static LocalDeclarationStatementSyntax LocalDeclarationStatement(VariableDeclarationSyntax declaration)" />
          <member def="public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration)" />
          <member def="public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)" />
          <member def="public static LocalFunctionStatementSyntax LocalFunctionStatement(TypeSyntax returnType, SyntaxToken identifier)" />
          <member def="public static LocalFunctionStatementSyntax LocalFunctionStatement(TypeSyntax returnType, string identifier)" />
          <member def="public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
          <member def="public static LockStatementSyntax LockStatement(ExpressionSyntax expression, StatementSyntax statement)" />
          <member def="public static LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)" />
          <member def="public static MakeRefExpressionSyntax MakeRefExpression(ExpressionSyntax expression)" />
          <member def="public static MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)" />
          <member def="public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SimpleNameSyntax name)" />
          <member def="public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)" />
          <member def="public static MemberBindingExpressionSyntax MemberBindingExpression(SimpleNameSyntax name)" />
          <member def="public static MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name)" />
          <member def="public static MethodDeclarationSyntax MethodDeclaration(TypeSyntax returnType, SyntaxToken identifier)" />
          <member def="public static MethodDeclarationSyntax MethodDeclaration(TypeSyntax returnType, string identifier)" />
          <member def="public static MethodDeclarationSyntax MethodDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static MethodDeclarationSyntax MethodDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, BlockSyntax body, SyntaxToken semicolonToken)" />
          <member def="public static MethodDeclarationSyntax MethodDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
          <member def="public static SyntaxToken MissingToken(SyntaxKind kind)" />
          <member def="public static SyntaxToken MissingToken(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing)" />
          <member def="public static NameColonSyntax NameColon(IdentifierNameSyntax name)" />
          <member def="public static NameColonSyntax NameColon(string name)" />
          <member def="public static NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)" />
          <member def="public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name)" />
          <member def="public static NameEqualsSyntax NameEquals(string name)" />
          <member def="public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken)" />
          <member def="public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name)" />
          <member def="public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters)" />
          <member def="public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name)" />
          <member def="public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, SyntaxList&lt;ExternAliasDirectiveSyntax&gt; externs, SyntaxList&lt;UsingDirectiveSyntax&gt; usings, SyntaxList&lt;MemberDeclarationSyntax&gt; members)" />
          <member def="public static NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList&lt;ExternAliasDirectiveSyntax&gt; externs, SyntaxList&lt;UsingDirectiveSyntax&gt; usings, SyntaxList&lt;MemberDeclarationSyntax&gt; members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)" />
          <member def="public static SyntaxNodeOrTokenList NodeOrTokenList()" />
          <member def="public static SyntaxNodeOrTokenList NodeOrTokenList(IEnumerable&lt;SyntaxNodeOrToken&gt; nodesAndTokens)" />
          <member def="public static SyntaxNodeOrTokenList NodeOrTokenList(params SyntaxNodeOrToken[] nodesAndTokens)" />
          <member def="public static NullableTypeSyntax NullableType(TypeSyntax elementType)" />
          <member def="public static NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)" />
          <member def="public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type)" />
          <member def="public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)" />
          <member def="public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)" />
          <member def="public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression()" />
          <member def="public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)" />
          <member def="public static OmittedTypeArgumentSyntax OmittedTypeArgument()" />
          <member def="public static OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)" />
          <member def="public static OperatorDeclarationSyntax OperatorDeclaration(TypeSyntax returnType, SyntaxToken operatorToken)" />
          <member def="public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)" />
          <member def="public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)" />
          <member def="public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorToken)" />
          <member def="public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorToken, CrefParameterListSyntax parameters)" />
          <member def="public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)" />
          <member def="public static OrderByClauseSyntax OrderByClause(SeparatedSyntaxList&lt;OrderingSyntax&gt; orderings = default)" />
          <member def="public static OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, SeparatedSyntaxList&lt;OrderingSyntax&gt; orderings)" />
          <member def="public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression)" />
          <member def="public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)" />
          <member def="public static ParameterSyntax Parameter(SyntaxToken identifier)" />
          <member def="public static ParameterSyntax Parameter(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)" />
          <member def="public static ParameterListSyntax ParameterList(SeparatedSyntaxList&lt;ParameterSyntax&gt; parameters = default)" />
          <member def="public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList&lt;ParameterSyntax&gt; parameters, SyntaxToken closeParenToken)" />
          <member def="public static ParenthesizedExpressionSyntax ParenthesizedExpression(ExpressionSyntax expression)" />
          <member def="public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)" />
          <member def="public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(CSharpSyntaxNode body)" />
          <member def="public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(ParameterListSyntax parameterList, CSharpSyntaxNode body)" />
          <member def="public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body)" />
          <member def="public static ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SeparatedSyntaxList&lt;VariableDesignationSyntax&gt; variables = default)" />
          <member def="public static ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SyntaxToken openParenToken, SeparatedSyntaxList&lt;VariableDesignationSyntax&gt; variables, SyntaxToken closeParenToken)" />
          <member def="public static ArgumentListSyntax ParseArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)" />
          <member def="public static AttributeArgumentListSyntax ParseAttributeArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)" />
          <member def="public static BracketedArgumentListSyntax ParseBracketedArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)" />
          <member def="public static BracketedParameterListSyntax ParseBracketedParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)" />
          <member def="public static CompilationUnitSyntax ParseCompilationUnit(string text, int offset = 0, CSharpParseOptions options = null)" />
          <member def="public static ExpressionSyntax ParseExpression(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)" />
          <member def="public static SyntaxTriviaList ParseLeadingTrivia(string text, int offset = 0)" />
          <member def="public static NameSyntax ParseName(string text, int offset = 0, bool consumeFullText = true)" />
          <member def="public static ParameterListSyntax ParseParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)" />
          <member def="public static StatementSyntax ParseStatement(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)" />
          <member def="public static SyntaxTree ParseSyntaxTree(SourceText text, ParseOptions options = null, string path = &quot;&quot;, CancellationToken cancellationToken = default)" />
          <member def="public static SyntaxTree ParseSyntaxTree(string text, ParseOptions options = null, string path = &quot;&quot;, Encoding encoding = null, CancellationToken cancellationToken = default)" />
          <member def="public static SyntaxToken ParseToken(string text, int offset = 0)" />
          <member def="public static IEnumerable&lt;SyntaxToken&gt; ParseTokens(string text, int offset = 0, int initialTokenPosition = 0, CSharpParseOptions options = null)" />
          <member def="public static SyntaxTriviaList ParseTrailingTrivia(string text, int offset = 0)" />
          <member def="public static TypeSyntax ParseTypeName(string text, int offset = 0, bool consumeFullText = true)" />
          <member def="public static PointerTypeSyntax PointerType(TypeSyntax elementType)" />
          <member def="public static PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)" />
          <member def="public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand)" />
          <member def="public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)" />
          <member def="public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, bool isActive)" />
          <member def="public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)" />
          <member def="public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, bool isActive)" />
          <member def="public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList&lt;ExpressionSyntax&gt; errorCodes, bool isActive)" />
          <member def="public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList&lt;ExpressionSyntax&gt; errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)" />
          <member def="public static PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)" />
          <member def="public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand)" />
          <member def="public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)" />
          <member def="public static SyntaxTrivia PreprocessingMessage(string text)" />
          <member def="public static PropertyDeclarationSyntax PropertyDeclaration(TypeSyntax type, SyntaxToken identifier)" />
          <member def="public static PropertyDeclarationSyntax PropertyDeclaration(TypeSyntax type, string identifier)" />
          <member def="public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)" />
          <member def="public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer)" />
          <member def="public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)" />
          <member def="public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, MemberCrefSyntax member)" />
          <member def="public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)" />
          <member def="public static QualifiedNameSyntax QualifiedName(NameSyntax left, SimpleNameSyntax right)" />
          <member def="public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)" />
          <member def="public static QueryBodySyntax QueryBody(SelectOrGroupClauseSyntax selectOrGroup)" />
          <member def="public static QueryBodySyntax QueryBody(SyntaxList&lt;QueryClauseSyntax&gt; clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)" />
          <member def="public static QueryContinuationSyntax QueryContinuation(SyntaxToken identifier, QueryBodySyntax body)" />
          <member def="public static QueryContinuationSyntax QueryContinuation(string identifier, QueryBodySyntax body)" />
          <member def="public static QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)" />
          <member def="public static QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)" />
          <member def="public static RefExpressionSyntax RefExpression(ExpressionSyntax expression)" />
          <member def="public static RefExpressionSyntax RefExpression(SyntaxToken refKeyword, ExpressionSyntax expression)" />
          <member def="public static RefTypeSyntax RefType(TypeSyntax type)" />
          <member def="public static RefTypeSyntax RefType(SyntaxToken refKeyword, TypeSyntax type)" />
          <member def="public static RefTypeExpressionSyntax RefTypeExpression(ExpressionSyntax expression)" />
          <member def="public static RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)" />
          <member def="public static RefValueExpressionSyntax RefValueExpression(ExpressionSyntax expression, TypeSyntax type)" />
          <member def="public static RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)" />
          <member def="public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken file, bool isActive)" />
          <member def="public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)" />
          <member def="public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(bool isActive)" />
          <member def="public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)" />
          <member def="public static ReturnStatementSyntax ReturnStatement(ExpressionSyntax expression = null)" />
          <member def="public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)" />
          <member def="public static SelectClauseSyntax SelectClause(ExpressionSyntax expression)" />
          <member def="public static SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)" />
          <member def="public static SeparatedSyntaxList&lt;TNode&gt; SeparatedList&lt;TNode&gt;() where TNode : SyntaxNode" />
          <member def="public static SeparatedSyntaxList&lt;TNode&gt; SeparatedList&lt;TNode&gt;(IEnumerable&lt;TNode&gt; nodes) where TNode : SyntaxNode" />
          <member def="public static SeparatedSyntaxList&lt;TNode&gt; SeparatedList&lt;TNode&gt;(IEnumerable&lt;SyntaxNodeOrToken&gt; nodesAndTokens) where TNode : SyntaxNode" />
          <member def="public static SeparatedSyntaxList&lt;TNode&gt; SeparatedList&lt;TNode&gt;(SyntaxNodeOrTokenList nodesAndTokens) where TNode : SyntaxNode" />
          <member def="public static SeparatedSyntaxList&lt;TNode&gt; SeparatedList&lt;TNode&gt;(IEnumerable&lt;TNode&gt; nodes, IEnumerable&lt;SyntaxToken&gt; separators) where TNode : SyntaxNode" />
          <member def="public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(bool isActive)" />
          <member def="public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)" />
          <member def="public static SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type)" />
          <member def="public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(ParameterSyntax parameter, CSharpSyntaxNode body)" />
          <member def="public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body)" />
          <member def="public static SingleVariableDesignationSyntax SingleVariableDesignation(SyntaxToken identifier)" />
          <member def="public static SyntaxList&lt;TNode&gt; SingletonList&lt;TNode&gt;(TNode node) where TNode : SyntaxNode" />
          <member def="public static SeparatedSyntaxList&lt;TNode&gt; SingletonSeparatedList&lt;TNode&gt;(TNode node) where TNode : SyntaxNode" />
          <member def="public static SizeOfExpressionSyntax SizeOfExpression(TypeSyntax type)" />
          <member def="public static SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)" />
          <member def="public static SkippedTokensTriviaSyntax SkippedTokensTrivia()" />
          <member def="public static SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxTokenList tokens)" />
          <member def="public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(TypeSyntax type)" />
          <member def="public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type)" />
          <member def="public static StructDeclarationSyntax StructDeclaration(SyntaxToken identifier)" />
          <member def="public static StructDeclarationSyntax StructDeclaration(string identifier)" />
          <member def="public static StructDeclarationSyntax StructDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, SyntaxList&lt;MemberDeclarationSyntax&gt; members)" />
          <member def="public static StructDeclarationSyntax StructDeclaration(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, SyntaxToken openBraceToken, SyntaxList&lt;MemberDeclarationSyntax&gt; members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)" />
          <member def="public static SwitchSectionSyntax SwitchSection()" />
          <member def="public static SwitchSectionSyntax SwitchSection(SyntaxList&lt;SwitchLabelSyntax&gt; labels, SyntaxList&lt;StatementSyntax&gt; statements)" />
          <member def="public static SwitchStatementSyntax SwitchStatement(ExpressionSyntax expression)" />
          <member def="public static SwitchStatementSyntax SwitchStatement(ExpressionSyntax expression, SyntaxList&lt;SwitchSectionSyntax&gt; sections)" />
          <member def="public static SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList&lt;SwitchSectionSyntax&gt; sections, SyntaxToken closeBraceToken)" />
          <member def="public static SyntaxTree SyntaxTree(SyntaxNode root, ParseOptions options = null, string path = &quot;&quot;, Encoding encoding = null)" />
          <member def="public static SyntaxTrivia SyntaxTrivia(SyntaxKind kind, string text)" />
          <member def="public static ThisExpressionSyntax ThisExpression()" />
          <member def="public static ThisExpressionSyntax ThisExpression(SyntaxToken token)" />
          <member def="public static ThrowExpressionSyntax ThrowExpression(ExpressionSyntax expression)" />
          <member def="public static ThrowExpressionSyntax ThrowExpression(SyntaxToken throwKeyword, ExpressionSyntax expression)" />
          <member def="public static ThrowStatementSyntax ThrowStatement(ExpressionSyntax expression = null)" />
          <member def="public static ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)" />
          <member def="public static SyntaxToken Token(SyntaxKind kind)" />
          <member def="public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing)" />
          <member def="public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, string text, string valueText, SyntaxTriviaList trailing)" />
          <member def="public static SyntaxTokenList TokenList()" />
          <member def="public static SyntaxTokenList TokenList(SyntaxToken token)" />
          <member def="public static SyntaxTokenList TokenList(params SyntaxToken[] tokens)" />
          <member def="public static SyntaxTokenList TokenList(IEnumerable&lt;SyntaxToken&gt; tokens)" />
          <member def="public static SyntaxTrivia Trivia(StructuredTriviaSyntax node)" />
          <member def="public static SyntaxTriviaList TriviaList()" />
          <member def="public static SyntaxTriviaList TriviaList(SyntaxTrivia trivia)" />
          <member def="public static SyntaxTriviaList TriviaList(params SyntaxTrivia[] trivias)" />
          <member def="public static SyntaxTriviaList TriviaList(IEnumerable&lt;SyntaxTrivia&gt; trivias)" />
          <member def="public static TryStatementSyntax TryStatement(SyntaxList&lt;CatchClauseSyntax&gt; catches = default)" />
          <member def="public static TryStatementSyntax TryStatement(BlockSyntax block, SyntaxList&lt;CatchClauseSyntax&gt; catches, FinallyClauseSyntax @finally)" />
          <member def="public static TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList&lt;CatchClauseSyntax&gt; catches, FinallyClauseSyntax @finally)" />
          <member def="public static TupleElementSyntax TupleElement(TypeSyntax type)" />
          <member def="public static TupleElementSyntax TupleElement(TypeSyntax type, SyntaxToken identifier)" />
          <member def="public static TupleExpressionSyntax TupleExpression(SeparatedSyntaxList&lt;ArgumentSyntax&gt; arguments = default)" />
          <member def="public static TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, SeparatedSyntaxList&lt;ArgumentSyntax&gt; arguments, SyntaxToken closeParenToken)" />
          <member def="public static TupleTypeSyntax TupleType(SeparatedSyntaxList&lt;TupleElementSyntax&gt; elements = default)" />
          <member def="public static TupleTypeSyntax TupleType(SyntaxToken openParenToken, SeparatedSyntaxList&lt;TupleElementSyntax&gt; elements, SyntaxToken closeParenToken)" />
          <member def="public static TypeArgumentListSyntax TypeArgumentList(SeparatedSyntaxList&lt;TypeSyntax&gt; arguments = default)" />
          <member def="public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList&lt;TypeSyntax&gt; arguments, SyntaxToken greaterThanToken)" />
          <member def="public static TypeConstraintSyntax TypeConstraint(TypeSyntax type)" />
          <member def="public static TypeCrefSyntax TypeCref(TypeSyntax type)" />
          <member def="public static TypeDeclarationSyntax TypeDeclaration(SyntaxKind kind, SyntaxToken identifier)" />
          <member def="public static TypeDeclarationSyntax TypeDeclaration(SyntaxKind kind, string identifier)" />
          <member def="public static TypeDeclarationSyntax TypeDeclaration(SyntaxKind kind, SyntaxList&lt;AttributeListSyntax&gt; attributes, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses, SyntaxToken openBraceToken, SyntaxList&lt;MemberDeclarationSyntax&gt; members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)" />
          <member def="public static TypeOfExpressionSyntax TypeOfExpression(TypeSyntax type)" />
          <member def="public static TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)" />
          <member def="public static TypeParameterSyntax TypeParameter(SyntaxToken identifier)" />
          <member def="public static TypeParameterSyntax TypeParameter(string identifier)" />
          <member def="public static TypeParameterSyntax TypeParameter(SyntaxList&lt;AttributeListSyntax&gt; attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)" />
          <member def="public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax name)" />
          <member def="public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string name)" />
          <member def="public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax name, SeparatedSyntaxList&lt;TypeParameterConstraintSyntax&gt; constraints)" />
          <member def="public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList&lt;TypeParameterConstraintSyntax&gt; constraints)" />
          <member def="public static TypeParameterListSyntax TypeParameterList(SeparatedSyntaxList&lt;TypeParameterSyntax&gt; parameters = default)" />
          <member def="public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList&lt;TypeParameterSyntax&gt; parameters, SyntaxToken greaterThanToken)" />
          <member def="public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken name, bool isActive)" />
          <member def="public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(string name, bool isActive)" />
          <member def="public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)" />
          <member def="public static UnsafeStatementSyntax UnsafeStatement(BlockSyntax block = null)" />
          <member def="public static UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block)" />
          <member def="public static UsingDirectiveSyntax UsingDirective(NameSyntax name)" />
          <member def="public static UsingDirectiveSyntax UsingDirective(NameEqualsSyntax alias, NameSyntax name)" />
          <member def="public static UsingDirectiveSyntax UsingDirective(SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name)" />
          <member def="public static UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)" />
          <member def="public static UsingStatementSyntax UsingStatement(StatementSyntax statement)" />
          <member def="public static UsingStatementSyntax UsingStatement(VariableDeclarationSyntax declaration, ExpressionSyntax expression, StatementSyntax statement)" />
          <member def="public static UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)" />
          <member def="public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type)" />
          <member def="public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SeparatedSyntaxList&lt;VariableDeclaratorSyntax&gt; variables)" />
          <member def="public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier)" />
          <member def="public static VariableDeclaratorSyntax VariableDeclarator(string identifier)" />
          <member def="public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)" />
          <member def="public static SyntaxToken VerbatimIdentifier(SyntaxTriviaList leading, string text, string valueText, SyntaxTriviaList trailing)" />
          <member def="public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(bool isActive)" />
          <member def="public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)" />
          <member def="public static WhenClauseSyntax WhenClause(ExpressionSyntax condition)" />
          <member def="public static WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionSyntax condition)" />
          <member def="public static WhereClauseSyntax WhereClause(ExpressionSyntax condition)" />
          <member def="public static WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)" />
          <member def="public static WhileStatementSyntax WhileStatement(ExpressionSyntax condition, StatementSyntax statement)" />
          <member def="public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)" />
          <member def="public static SyntaxTrivia Whitespace(string text)" />
          <member def="public static SyntaxTrivia Whitespace(string text, bool elastic)" />
          <member def="public static XmlCDataSectionSyntax XmlCDataSection(SyntaxTokenList textTokens = default)" />
          <member def="public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken)" />
          <member def="public static XmlCommentSyntax XmlComment(SyntaxTokenList textTokens = default)" />
          <member def="public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken)" />
          <member def="public static XmlCrefAttributeSyntax XmlCrefAttribute(CrefSyntax cref)" />
          <member def="public static XmlCrefAttributeSyntax XmlCrefAttribute(CrefSyntax cref, SyntaxKind quoteKind)" />
          <member def="public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)" />
          <member def="public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)" />
          <member def="public static XmlElementSyntax XmlElement(string localName, SyntaxList&lt;XmlNodeSyntax&gt; content)" />
          <member def="public static XmlElementSyntax XmlElement(XmlNameSyntax name, SyntaxList&lt;XmlNodeSyntax&gt; content)" />
          <member def="public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, XmlElementEndTagSyntax endTag)" />
          <member def="public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, SyntaxList&lt;XmlNodeSyntax&gt; content, XmlElementEndTagSyntax endTag)" />
          <member def="public static XmlElementEndTagSyntax XmlElementEndTag(XmlNameSyntax name)" />
          <member def="public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)" />
          <member def="public static XmlElementStartTagSyntax XmlElementStartTag(XmlNameSyntax name)" />
          <member def="public static XmlElementStartTagSyntax XmlElementStartTag(XmlNameSyntax name, SyntaxList&lt;XmlAttributeSyntax&gt; attributes)" />
          <member def="public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList&lt;XmlAttributeSyntax&gt; attributes, SyntaxToken greaterThanToken)" />
          <member def="public static XmlEmptyElementSyntax XmlEmptyElement(string localName)" />
          <member def="public static XmlEmptyElementSyntax XmlEmptyElement(XmlNameSyntax name)" />
          <member def="public static XmlEmptyElementSyntax XmlEmptyElement(XmlNameSyntax name, SyntaxList&lt;XmlAttributeSyntax&gt; attributes)" />
          <member def="public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList&lt;XmlAttributeSyntax&gt; attributes, SyntaxToken slashGreaterThanToken)" />
          <member def="public static SyntaxToken XmlEntity(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)" />
          <member def="public static XmlElementSyntax XmlExampleElement(params XmlNodeSyntax[] content)" />
          <member def="public static XmlElementSyntax XmlExampleElement(SyntaxList&lt;XmlNodeSyntax&gt; content)" />
          <member def="public static XmlElementSyntax XmlExceptionElement(CrefSyntax cref, params XmlNodeSyntax[] content)" />
          <member def="public static XmlElementSyntax XmlExceptionElement(CrefSyntax cref, SyntaxList&lt;XmlNodeSyntax&gt; content)" />
          <member def="public static XmlElementSyntax XmlMultiLineElement(string localName, SyntaxList&lt;XmlNodeSyntax&gt; content)" />
          <member def="public static XmlElementSyntax XmlMultiLineElement(XmlNameSyntax name, SyntaxList&lt;XmlNodeSyntax&gt; content)" />
          <member def="public static XmlNameSyntax XmlName(SyntaxToken localName)" />
          <member def="public static XmlNameSyntax XmlName(string localName)" />
          <member def="public static XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName)" />
          <member def="public static XmlNameAttributeSyntax XmlNameAttribute(string parameterName)" />
          <member def="public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)" />
          <member def="public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, string identifier, SyntaxToken endQuoteToken)" />
          <member def="public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)" />
          <member def="public static XmlTextSyntax XmlNewLine(string text)" />
          <member def="public static XmlEmptyElementSyntax XmlNullKeywordElement()" />
          <member def="public static XmlElementSyntax XmlParaElement(params XmlNodeSyntax[] content)" />
          <member def="public static XmlElementSyntax XmlParaElement(SyntaxList&lt;XmlNodeSyntax&gt; content)" />
          <member def="public static XmlElementSyntax XmlParamElement(string parameterName, params XmlNodeSyntax[] content)" />
          <member def="public static XmlElementSyntax XmlParamElement(string parameterName, SyntaxList&lt;XmlNodeSyntax&gt; content)" />
          <member def="public static XmlEmptyElementSyntax XmlParamRefElement(string parameterName)" />
          <member def="public static XmlElementSyntax XmlPermissionElement(CrefSyntax cref, params XmlNodeSyntax[] content)" />
          <member def="public static XmlElementSyntax XmlPermissionElement(CrefSyntax cref, SyntaxList&lt;XmlNodeSyntax&gt; content)" />
          <member def="public static XmlElementSyntax XmlPlaceholderElement(params XmlNodeSyntax[] content)" />
          <member def="public static XmlElementSyntax XmlPlaceholderElement(SyntaxList&lt;XmlNodeSyntax&gt; content)" />
          <member def="public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix)" />
          <member def="public static XmlPrefixSyntax XmlPrefix(string prefix)" />
          <member def="public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)" />
          <member def="public static XmlEmptyElementSyntax XmlPreliminaryElement()" />
          <member def="public static XmlProcessingInstructionSyntax XmlProcessingInstruction(XmlNameSyntax name)" />
          <member def="public static XmlProcessingInstructionSyntax XmlProcessingInstruction(XmlNameSyntax name, SyntaxTokenList textTokens)" />
          <member def="public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken)" />
          <member def="public static XmlElementSyntax XmlRemarksElement(params XmlNodeSyntax[] content)" />
          <member def="public static XmlElementSyntax XmlRemarksElement(SyntaxList&lt;XmlNodeSyntax&gt; content)" />
          <member def="public static XmlElementSyntax XmlReturnsElement(params XmlNodeSyntax[] content)" />
          <member def="public static XmlElementSyntax XmlReturnsElement(SyntaxList&lt;XmlNodeSyntax&gt; content)" />
          <member def="public static XmlEmptyElementSyntax XmlSeeAlsoElement(CrefSyntax cref)" />
          <member def="public static XmlElementSyntax XmlSeeAlsoElement(Uri linkAddress, SyntaxList&lt;XmlNodeSyntax&gt; linkText)" />
          <member def="public static XmlEmptyElementSyntax XmlSeeElement(CrefSyntax cref)" />
          <member def="public static XmlElementSyntax XmlSummaryElement(params XmlNodeSyntax[] content)" />
          <member def="public static XmlElementSyntax XmlSummaryElement(SyntaxList&lt;XmlNodeSyntax&gt; content)" />
          <member def="public static XmlTextSyntax XmlText()" />
          <member def="public static XmlTextSyntax XmlText(params SyntaxToken[] textTokens)" />
          <member def="public static XmlTextSyntax XmlText(SyntaxTokenList textTokens)" />
          <member def="public static XmlTextSyntax XmlText(string value)" />
          <member def="public static XmlTextAttributeSyntax XmlTextAttribute(string name, params SyntaxToken[] textTokens)" />
          <member def="public static XmlTextAttributeSyntax XmlTextAttribute(string name, string value)" />
          <member def="public static XmlTextAttributeSyntax XmlTextAttribute(string name, SyntaxKind quoteKind, SyntaxTokenList textTokens)" />
          <member def="public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxKind quoteKind, SyntaxTokenList textTokens)" />
          <member def="public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxToken endQuoteToken)" />
          <member def="public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)" />
          <member def="public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)" />
          <member def="public static SyntaxToken XmlTextLiteral(string value)" />
          <member def="public static SyntaxToken XmlTextLiteral(string text, string value)" />
          <member def="public static SyntaxToken XmlTextLiteral(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)" />
          <member def="public static SyntaxToken XmlTextNewLine(string text)" />
          <member def="public static SyntaxToken XmlTextNewLine(string text, bool continueXmlDocumentationComment)" />
          <member def="public static SyntaxToken XmlTextNewLine(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)" />
          <member def="public static XmlEmptyElementSyntax XmlThreadSafetyElement()" />
          <member def="public static XmlEmptyElementSyntax XmlThreadSafetyElement(bool isStatic, bool isInstance)" />
          <member def="public static XmlElementSyntax XmlValueElement(params XmlNodeSyntax[] content)" />
          <member def="public static XmlElementSyntax XmlValueElement(SyntaxList&lt;XmlNodeSyntax&gt; content)" />
          <member def="public static YieldStatementSyntax YieldStatement(SyntaxKind kind, ExpressionSyntax expression = null)" />
          <member def="public static YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.CSharp.SyntaxFacts">
        <members>
          <member def="public static IEqualityComparer&lt;SyntaxKind&gt; EqualityComparer { get; }" />
          <member def="public static SyntaxKind GetAccessorDeclarationKind(SyntaxKind keyword)" />
          <member def="public static SyntaxKind GetAssignmentExpression(SyntaxKind token)" />
          <member def="public static SyntaxKind GetBaseTypeDeclarationKind(SyntaxKind kind)" />
          <member def="public static SyntaxKind GetBinaryExpression(SyntaxKind token)" />
          <member def="public static SyntaxKind GetCheckStatement(SyntaxKind keyword)" />
          <member def="public static SyntaxKind GetContextualKeywordKind(string text)" />
          <member def="public static IEnumerable&lt;SyntaxKind&gt; GetContextualKeywordKinds()" />
          <member def="public static SyntaxKind GetInstanceExpression(SyntaxKind token)" />
          <member def="public static SyntaxKind GetKeywordKind(string text)" />
          <member def="public static IEnumerable&lt;SyntaxKind&gt; GetKeywordKinds()" />
          <member def="public static SyntaxKind GetLiteralExpression(SyntaxKind token)" />
          <member def="public static SyntaxKind GetOperatorKind(string operatorMetadataName)" />
          <member def="public static SyntaxKind GetPostfixUnaryExpression(SyntaxKind token)" />
          <member def="public static SyntaxKind GetPrefixUnaryExpression(SyntaxKind token)" />
          <member def="public static SyntaxKind GetPreprocessorKeywordKind(string text)" />
          <member def="public static IEnumerable&lt;SyntaxKind&gt; GetPreprocessorKeywordKinds()" />
          <member def="public static SyntaxKind GetPrimaryFunction(SyntaxKind keyword)" />
          <member def="public static IEnumerable&lt;SyntaxKind&gt; GetPunctuationKinds()" />
          <member def="public static IEnumerable&lt;SyntaxKind&gt; GetReservedKeywordKinds()" />
          <member def="public static SyntaxKind GetSwitchLabelKind(SyntaxKind keyword)" />
          <member def="public static string GetText(Accessibility accessibility)" />
          <member def="public static string GetText(SyntaxKind kind)" />
          <member def="public static SyntaxKind GetTypeDeclarationKind(SyntaxKind kind)" />
          <member def="public static bool IsAccessibilityModifier(SyntaxKind kind)" />
          <member def="public static bool IsAccessorDeclaration(SyntaxKind kind)" />
          <member def="public static bool IsAccessorDeclarationKeyword(SyntaxKind keyword)" />
          <member def="public static bool IsAliasQualifier(SyntaxNode node)" />
          <member def="public static bool IsAnyOverloadableOperator(SyntaxKind kind)" />
          <member def="public static bool IsAnyToken(SyntaxKind kind)" />
          <member def="public static bool IsAnyUnaryExpression(SyntaxKind token)" />
          <member def="public static bool IsAssignmentExpression(SyntaxKind kind)" />
          <member def="public static bool IsAssignmentExpressionOperatorToken(SyntaxKind token)" />
          <member def="public static bool IsAttributeName(SyntaxNode node)" />
          <member def="public static bool IsAttributeTargetSpecifier(SyntaxKind kind)" />
          <member def="public static bool IsBinaryExpression(SyntaxKind token)" />
          <member def="public static bool IsBinaryExpressionOperatorToken(SyntaxKind token)" />
          <member def="public static bool IsContextualKeyword(SyntaxKind kind)" />
          <member def="public static bool IsDocumentationCommentTrivia(SyntaxKind kind)" />
          <member def="public static bool IsFixedStatementExpression(SyntaxNode node)" />
          <member def="public static bool IsGlobalMemberDeclaration(SyntaxKind kind)" />
          <member def="public static bool IsIdentifierPartCharacter(char ch)" />
          <member def="public static bool IsIdentifierStartCharacter(char ch)" />
          <member def="public static bool IsInNamespaceOrTypeContext(ExpressionSyntax node)" />
          <member def="public static bool IsInTypeOnlyContext(ExpressionSyntax node)" />
          <member def="public static bool IsIndexed(ExpressionSyntax node)" />
          <member def="public static bool IsInstanceExpression(SyntaxKind token)" />
          <member def="public static bool IsInvoked(ExpressionSyntax node)" />
          <member def="public static bool IsKeywordKind(SyntaxKind kind)" />
          <member def="public static bool IsLambdaBody(SyntaxNode node)" />
          <member def="public static bool IsLanguagePunctuation(SyntaxKind kind)" />
          <member def="public static bool IsLiteralExpression(SyntaxKind token)" />
          <member def="public static bool IsName(SyntaxKind kind)" />
          <member def="public static bool IsNamedArgumentName(SyntaxNode node)" />
          <member def="public static bool IsNamespaceAliasQualifier(ExpressionSyntax node)" />
          <member def="public static bool IsNamespaceMemberDeclaration(SyntaxKind kind)" />
          <member def="public static bool IsNewLine(char ch)" />
          <member def="public static bool IsOverloadableBinaryOperator(SyntaxKind kind)" />
          <member def="public static bool IsOverloadableUnaryOperator(SyntaxKind kind)" />
          <member def="public static bool IsPostfixUnaryExpression(SyntaxKind token)" />
          <member def="public static bool IsPostfixUnaryExpressionToken(SyntaxKind token)" />
          <member def="public static bool IsPredefinedType(SyntaxKind kind)" />
          <member def="public static bool IsPrefixUnaryExpression(SyntaxKind token)" />
          <member def="public static bool IsPrefixUnaryExpressionOperatorToken(SyntaxKind token)" />
          <member def="public static bool IsPreprocessorDirective(SyntaxKind kind)" />
          <member def="public static bool IsPreprocessorKeyword(SyntaxKind kind)" />
          <member def="public static bool IsPreprocessorPunctuation(SyntaxKind kind)" />
          <member def="public static bool IsPrimaryFunction(SyntaxKind keyword)" />
          <member def="public static bool IsPunctuation(SyntaxKind kind)" />
          <member def="public static bool IsPunctuationOrKeyword(SyntaxKind kind)" />
          <member def="public static bool IsQueryContextualKeyword(SyntaxKind kind)" />
          <member def="public static bool IsReservedKeyword(SyntaxKind kind)" />
          <member def="public static bool IsReservedTupleElementName(string elementName)" />
          <member def="public static bool IsTrivia(SyntaxKind kind)" />
          <member def="public static bool IsTypeDeclaration(SyntaxKind kind)" />
          <member def="public static bool IsTypeParameterVarianceKeyword(SyntaxKind kind)" />
          <member def="public static bool IsTypeSyntax(SyntaxKind kind)" />
          <member def="public static bool IsUnaryOperatorDeclarationToken(SyntaxKind token)" />
          <member def="public static bool IsValidIdentifier(string name)" />
          <member def="public static bool IsWhitespace(char ch)" />
          <member def="public static string TryGetInferredMemberName(this SyntaxNode syntax)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.CSharp.TypedConstantExtensions">
        <members>
          <member def="public static string ToCSharpString(this TypedConstant constant)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptions">
        <members>
          <member def="public static Option&lt;bool&gt; IndentBlock { get; }" />
          <member def="public static Option&lt;bool&gt; IndentBraces { get; }" />
          <member def="public static Option&lt;bool&gt; IndentSwitchCaseSection { get; }" />
          <member def="public static Option&lt;bool&gt; IndentSwitchSection { get; }" />
          <member def="public static Option&lt;LabelPositionOptions&gt; LabelPositioning { get; }" />
          <member def="public static Option&lt;bool&gt; NewLineForCatch { get; }" />
          <member def="public static Option&lt;bool&gt; NewLineForClausesInQuery { get; }" />
          <member def="public static Option&lt;bool&gt; NewLineForElse { get; }" />
          <member def="public static Option&lt;bool&gt; NewLineForFinally { get; }" />
          <member def="public static Option&lt;bool&gt; NewLineForMembersInAnonymousTypes { get; }" />
          <member def="public static Option&lt;bool&gt; NewLineForMembersInObjectInit { get; }" />
          <member def="public static Option&lt;bool&gt; NewLinesForBracesInAccessors { get; }" />
          <member def="public static Option&lt;bool&gt; NewLinesForBracesInAnonymousMethods { get; }" />
          <member def="public static Option&lt;bool&gt; NewLinesForBracesInAnonymousTypes { get; }" />
          <member def="public static Option&lt;bool&gt; NewLinesForBracesInControlBlocks { get; }" />
          <member def="public static Option&lt;bool&gt; NewLinesForBracesInLambdaExpressionBody { get; }" />
          <member def="public static Option&lt;bool&gt; NewLinesForBracesInMethods { get; }" />
          <member def="public static Option&lt;bool&gt; NewLinesForBracesInObjectCollectionArrayInitializers { get; }" />
          <member def="public static Option&lt;bool&gt; NewLinesForBracesInProperties { get; }" />
          <member def="public static Option&lt;bool&gt; NewLinesForBracesInTypes { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceAfterCast { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceAfterColonInBaseTypeDeclaration { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceAfterComma { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceAfterControlFlowStatementKeyword { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceAfterDot { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceAfterMethodCallName { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceAfterSemicolonsInForStatement { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceBeforeColonInBaseTypeDeclaration { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceBeforeComma { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceBeforeDot { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceBeforeOpenSquareBracket { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceBeforeSemicolonsInForStatement { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceBetweenEmptyMethodCallParentheses { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceBetweenEmptyMethodDeclarationParentheses { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceBetweenEmptySquareBrackets { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceWithinCastParentheses { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceWithinExpressionParentheses { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceWithinMethodCallParentheses { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceWithinMethodDeclarationParenthesis { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceWithinOtherParentheses { get; }" />
          <member def="public static Option&lt;bool&gt; SpaceWithinSquareBrackets { get; }" />
          <member def="public static Option&lt;bool&gt; SpacesIgnoreAroundVariableDeclaration { get; }" />
          <member def="public static Option&lt;bool&gt; SpacingAfterMethodDeclarationName { get; }" />
          <member def="public static Option&lt;BinaryOperatorSpacingOptions&gt; SpacingAroundBinaryOperator { get; }" />
          <member def="public static Option&lt;bool&gt; WrappingKeepStatementsOnSingleLine { get; }" />
          <member def="public static Option&lt;bool&gt; WrappingPreserveSingleLine { get; }" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Classification.ClassificationTypeNames">
        <members>
          <member def="public const string ClassName = &quot;class name&quot;" />
          <member def="public const string Comment = &quot;comment&quot;" />
          <member def="public const string DelegateName = &quot;delegate name&quot;" />
          <member def="public const string EnumName = &quot;enum name&quot;" />
          <member def="public const string ExcludedCode = &quot;excluded code&quot;" />
          <member def="public const string Identifier = &quot;identifier&quot;" />
          <member def="public const string InterfaceName = &quot;interface name&quot;" />
          <member def="public const string Keyword = &quot;keyword&quot;" />
          <member def="public const string ModuleName = &quot;module name&quot;" />
          <member def="public const string NumericLiteral = &quot;number&quot;" />
          <member def="public const string Operator = &quot;operator&quot;" />
          <member def="public const string PreprocessorKeyword = &quot;preprocessor keyword&quot;" />
          <member def="public const string PreprocessorText = &quot;preprocessor text&quot;" />
          <member def="public const string Punctuation = &quot;punctuation&quot;" />
          <member def="public const string StringLiteral = &quot;string&quot;" />
          <member def="public const string StructName = &quot;struct name&quot;" />
          <member def="public const string Text = &quot;text&quot;" />
          <member def="public const string TypeParameterName = &quot;type parameter name&quot;" />
          <member def="public const string VerbatimStringLiteral = &quot;string - verbatim&quot;" />
          <member def="public const string WhiteSpace = &quot;whitespace&quot;" />
          <member def="public const string XmlDocCommentAttributeName = &quot;xml doc comment - attribute name&quot;" />
          <member def="public const string XmlDocCommentAttributeQuotes = &quot;xml doc comment - attribute quotes&quot;" />
          <member def="public const string XmlDocCommentAttributeValue = &quot;xml doc comment - attribute value&quot;" />
          <member def="public const string XmlDocCommentCDataSection = &quot;xml doc comment - cdata section&quot;" />
          <member def="public const string XmlDocCommentComment = &quot;xml doc comment - comment&quot;" />
          <member def="public const string XmlDocCommentDelimiter = &quot;xml doc comment - delimiter&quot;" />
          <member def="public const string XmlDocCommentEntityReference = &quot;xml doc comment - entity reference&quot;" />
          <member def="public const string XmlDocCommentName = &quot;xml doc comment - name&quot;" />
          <member def="public const string XmlDocCommentProcessingInstruction = &quot;xml doc comment - processing instruction&quot;" />
          <member def="public const string XmlDocCommentText = &quot;xml doc comment - text&quot;" />
          <member def="public const string XmlLiteralAttributeName = &quot;xml literal - attribute name&quot;" />
          <member def="public const string XmlLiteralAttributeQuotes = &quot;xml literal - attribute quotes&quot;" />
          <member def="public const string XmlLiteralAttributeValue = &quot;xml literal - attribute value&quot;" />
          <member def="public const string XmlLiteralCDataSection = &quot;xml literal - cdata section&quot;" />
          <member def="public const string XmlLiteralComment = &quot;xml literal - comment&quot;" />
          <member def="public const string XmlLiteralDelimiter = &quot;xml literal - delimiter&quot;" />
          <member def="public const string XmlLiteralEmbeddedExpression = &quot;xml literal - embedded expression&quot;" />
          <member def="public const string XmlLiteralEntityReference = &quot;xml literal - entity reference&quot;" />
          <member def="public const string XmlLiteralName = &quot;xml literal - name&quot;" />
          <member def="public const string XmlLiteralProcessingInstruction = &quot;xml literal - processing instruction&quot;" />
          <member def="public const string XmlLiteralText = &quot;xml literal - text&quot;" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Classification.Classifier">
        <members>
          <member def="public static IEnumerable&lt;ClassifiedSpan&gt; GetClassifiedSpans(SemanticModel semanticModel, TextSpan textSpan, Workspace workspace, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ClassifiedSpan&gt;&gt; GetClassifiedSpansAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.CodeActions.ConflictAnnotation">
        <members>
          <member def="public const string Kind = &quot;CodeAction_Conflict&quot;" />
          <member def="public static SyntaxAnnotation Create(string description)" />
          <member def="public static string GetDescription(SyntaxAnnotation annotation)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.CodeActions.RenameAnnotation">
        <members>
          <member def="public const string Kind = &quot;CodeAction_Rename&quot;" />
          <member def="public static SyntaxAnnotation Create()" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.CodeActions.WarningAnnotation">
        <members>
          <member def="public const string Kind = &quot;CodeAction_Warning&quot;" />
          <member def="public static SyntaxAnnotation Create(string description)" />
          <member def="public static string GetDescription(SyntaxAnnotation annotation)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders">
        <members>
          <member def="public static FixAllProvider BatchFixer { get; }" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions">
        <members>
          <member def="public static CompilationWithAnalyzers WithAnalyzers(this Compilation compilation, ImmutableArray&lt;DiagnosticAnalyzer&gt; analyzers, CompilationWithAnalyzersOptions analysisOptions)" />
          <member def="public static CompilationWithAnalyzers WithAnalyzers(this Compilation compilation, ImmutableArray&lt;DiagnosticAnalyzer&gt; analyzers, AnalyzerOptions options = null, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Editing.ImportAdder">
        <members>
          <member def="public static Task&lt;Document&gt; AddImportsAsync(Document document, OptionSet options = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; AddImportsAsync(Document document, SyntaxAnnotation annotation, OptionSet options = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; AddImportsAsync(Document document, TextSpan span, OptionSet options = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; AddImportsAsync(Document document, IEnumerable&lt;TextSpan&gt; spans, OptionSet options = null, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions">
        <members>
          <member def="public static Task&lt;SyntaxNode&gt; GetBaseOrInterfaceDeclarationReferenceAsync(this SymbolEditor editor, ISymbol symbol, ITypeSymbol baseOrInterfaceType, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;ISymbol&gt; SetBaseTypeAsync(this SymbolEditor editor, INamedTypeSymbol symbol, Func&lt;SyntaxGenerator, SyntaxNode&gt; getNewBaseType, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;ISymbol&gt; SetBaseTypeAsync(this SymbolEditor editor, INamedTypeSymbol symbol, ITypeSymbol newBaseType, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions">
        <members>
          <member def="public static void AddAttribute(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode attribute)" />
          <member def="public static void AddAttributeArgument(this SyntaxEditor editor, SyntaxNode attributeDeclaration, SyntaxNode attributeArgument)" />
          <member def="public static void AddBaseType(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode baseType)" />
          <member def="public static void AddInterfaceType(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode interfaceType)" />
          <member def="public static void AddMember(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode member)" />
          <member def="public static void AddParameter(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode parameter)" />
          <member def="public static void AddReturnAttribute(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode attribute)" />
          <member def="public static void InsertMembers(this SyntaxEditor editor, SyntaxNode declaration, int index, IEnumerable&lt;SyntaxNode&gt; members)" />
          <member def="public static void SetAccessibility(this SyntaxEditor editor, SyntaxNode declaration, Accessibility accessibility)" />
          <member def="public static void SetExpression(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode expression)" />
          <member def="public static void SetGetAccessorStatements(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public static void SetModifiers(this SyntaxEditor editor, SyntaxNode declaration, DeclarationModifiers modifiers)" />
          <member def="public static void SetName(this SyntaxEditor editor, SyntaxNode declaration, string name)" />
          <member def="public static void SetSetAccessorStatements(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public static void SetStatements(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable&lt;SyntaxNode&gt; statements)" />
          <member def="public static void SetType(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode type)" />
          <member def="public static void SetTypeConstraint(this SyntaxEditor editor, SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kind, IEnumerable&lt;SyntaxNode&gt; types)" />
          <member def="public static void SetTypeParameters(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable&lt;string&gt; typeParameters)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.FindSymbols.SymbolFinder">
        <members>
          <member def="public static Task&lt;IEnumerable&lt;SymbolCallerInfo&gt;&gt; FindCallersAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;SymbolCallerInfo&gt;&gt; FindCallersAsync(ISymbol symbol, Solution solution, IImmutableSet&lt;Document&gt; documents, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ISymbol&gt;&gt; FindDeclarationsAsync(Project project, string name, bool ignoreCase, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ISymbol&gt;&gt; FindDeclarationsAsync(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;INamedTypeSymbol&gt;&gt; FindDerivedClassesAsync(INamedTypeSymbol type, Solution solution, IImmutableSet&lt;Project&gt; projects = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ISymbol&gt;&gt; FindImplementationsAsync(ISymbol symbol, Solution solution, IImmutableSet&lt;Project&gt; projects = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ISymbol&gt;&gt; FindImplementedInterfaceMembersAsync(ISymbol symbol, Solution solution, IImmutableSet&lt;Project&gt; projects = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ISymbol&gt;&gt; FindOverridesAsync(ISymbol symbol, Solution solution, IImmutableSet&lt;Project&gt; projects = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ReferencedSymbol&gt;&gt; FindReferencesAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ReferencedSymbol&gt;&gt; FindReferencesAsync(ISymbol symbol, Solution solution, IImmutableSet&lt;Document&gt; documents, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ReferencedSymbol&gt;&gt; FindReferencesAsync(ISymbol symbol, Solution solution, IFindReferencesProgress progress, IImmutableSet&lt;Document&gt; documents, CancellationToken cancellationToken = default)" />
          <member def="public static IEnumerable&lt;TSymbol&gt; FindSimilarSymbols&lt;TSymbol&gt;(TSymbol symbol, Compilation compilation, CancellationToken cancellationToken = default) where TSymbol : ISymbol" />
          <member def="public static Task&lt;IEnumerable&lt;ISymbol&gt;&gt; FindSourceDeclarationsAsync(Project project, Func&lt;string, bool&gt; predicate, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ISymbol&gt;&gt; FindSourceDeclarationsAsync(Solution solution, Func&lt;string, bool&gt; predicate, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ISymbol&gt;&gt; FindSourceDeclarationsAsync(Project project, string name, bool ignoreCase, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ISymbol&gt;&gt; FindSourceDeclarationsAsync(Project project, Func&lt;string, bool&gt; predicate, SymbolFilter filter, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ISymbol&gt;&gt; FindSourceDeclarationsAsync(Solution solution, string name, bool ignoreCase, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ISymbol&gt;&gt; FindSourceDeclarationsAsync(Solution solution, Func&lt;string, bool&gt; predicate, SymbolFilter filter, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ISymbol&gt;&gt; FindSourceDeclarationsAsync(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ISymbol&gt;&gt; FindSourceDeclarationsAsync(Solution solution, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;ISymbol&gt; FindSourceDefinitionAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken = default)" />
          <member def="public static ISymbol FindSymbolAtPosition(SemanticModel semanticModel, int position, Workspace workspace, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;ISymbol&gt; FindSymbolAtPositionAsync(Document document, int position, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;ISymbol&gt; FindSymbolAtPositionAsync(SemanticModel semanticModel, int position, Workspace workspace, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Formatting.Formatter">
        <members>
          <member def="public static SyntaxAnnotation Annotation { get; }" />
          <member def="public static SyntaxNode Format(SyntaxNode node, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)" />
          <member def="public static SyntaxNode Format(SyntaxNode node, SyntaxAnnotation annotation, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)" />
          <member def="public static SyntaxNode Format(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)" />
          <member def="public static SyntaxNode Format(SyntaxNode node, IEnumerable&lt;TextSpan&gt; spans, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; FormatAsync(Document document, OptionSet options = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; FormatAsync(Document document, SyntaxAnnotation annotation, OptionSet options = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; FormatAsync(Document document, TextSpan span, OptionSet options = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; FormatAsync(Document document, IEnumerable&lt;TextSpan&gt; spans, OptionSet options = null, CancellationToken cancellationToken = default)" />
          <member def="public static IList&lt;TextChange&gt; GetFormattedTextChanges(SyntaxNode node, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)" />
          <member def="public static IList&lt;TextChange&gt; GetFormattedTextChanges(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)" />
          <member def="public static IList&lt;TextChange&gt; GetFormattedTextChanges(SyntaxNode node, IEnumerable&lt;TextSpan&gt; spans, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Formatting.FormattingOptions">
        <members>
          <member def="public static PerLanguageOption&lt;int&gt; IndentationSize { get; }" />
          <member def="public static PerLanguageOption&lt;string&gt; NewLine { get; }" />
          <member def="public static PerLanguageOption&lt;FormattingOptions.IndentStyle&gt; SmartIndent { get; }" />
          <member def="public static PerLanguageOption&lt;int&gt; TabSize { get; }" />
          <member def="public static PerLanguageOption&lt;bool&gt; UseTabs { get; }" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Host.Mef.ServiceLayer">
        <members>
          <member def="public const string Default = &quot;Default&quot;" />
          <member def="public const string Desktop = &quot;Desktop&quot;" />
          <member def="public const string Editor = &quot;Editor&quot;" />
          <member def="public const string Host = &quot;Host&quot;" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Recommendations.RecommendationOptions">
        <members>
          <member def="public static PerLanguageOption&lt;bool&gt; FilterOutOfScopeLocals { get; }" />
          <member def="public static PerLanguageOption&lt;bool&gt; HideAdvancedMembers { get; }" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Recommendations.Recommender">
        <members>
          <member def="public static IEnumerable&lt;ISymbol&gt; GetRecommendedSymbolsAtPosition(SemanticModel semanticModel, int position, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;IEnumerable&lt;ISymbol&gt;&gt; GetRecommendedSymbolsAtPositionAsync(SemanticModel semanticModel, int position, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Rename.RenameOptions">
        <members>
          <member def="public static Option&lt;bool&gt; PreviewChanges { get; }" />
          <member def="public static Option&lt;bool&gt; RenameInComments { get; }" />
          <member def="public static Option&lt;bool&gt; RenameInStrings { get; }" />
          <member def="public static Option&lt;bool&gt; RenameOverloads { get; }" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Rename.Renamer">
        <members>
          <member def="public static Task&lt;Solution&gt; RenameSymbolAsync(Solution solution, ISymbol symbol, string newName, OptionSet optionSet, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Semantics.OperationExtensions">
        <members>
          <member def="public static IEnumerable&lt;IOperation&gt; Descendants(this IOperation operation)" />
          <member def="public static IEnumerable&lt;IOperation&gt; DescendantsAndSelf(this IOperation operation)" />
          <member def="public static ImmutableArray&lt;ILocalSymbol&gt; GetDeclaredVariables(this IVariableDeclarationStatement declarationStatement)" />
          <member def="public static IOperation GetRootOperation(this ISymbol symbol, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Semantics.UnaryAndBinaryOperationExtensions">
        <members>
          <member def="public static BinaryOperandsKind GetBinaryOperandsKind(this IBinaryOperatorExpression binary)" />
          <member def="public static BinaryOperandsKind GetBinaryOperandsKind(this ICompoundAssignmentExpression compoundAssignment)" />
          <member def="public static BinaryOperandsKind GetBinaryOperandsKind(BinaryOperationKind kind)" />
          <member def="public static SimpleBinaryOperationKind GetSimpleBinaryOperationKind(this IBinaryOperatorExpression binary)" />
          <member def="public static SimpleBinaryOperationKind GetSimpleBinaryOperationKind(this ICompoundAssignmentExpression compoundAssignment)" />
          <member def="public static SimpleBinaryOperationKind GetSimpleBinaryOperationKind(BinaryOperationKind kind)" />
          <member def="public static SimpleUnaryOperationKind GetSimpleUnaryOperationKind(this IIncrementExpression increment)" />
          <member def="public static SimpleUnaryOperationKind GetSimpleUnaryOperationKind(UnaryOperationKind kind)" />
          <member def="public static SimpleUnaryOperationKind GetSimpleUnaryOperationKind(this IUnaryOperatorExpression unary)" />
          <member def="public static UnaryOperandKind GetUnaryOperandKind(this IIncrementExpression increment)" />
          <member def="public static UnaryOperandKind GetUnaryOperandKind(UnaryOperationKind kind)" />
          <member def="public static UnaryOperandKind GetUnaryOperandKind(this IUnaryOperatorExpression unary)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Simplification.SimplificationOptions">
        <members>
          <member def="public static Option&lt;bool&gt; AllowSimplificationToBaseType { get; }" />
          <member def="public static Option&lt;bool&gt; AllowSimplificationToGenericType { get; }" />
          <member def="public static Option&lt;bool&gt; PreferAliasToQualification { get; }" />
          <member def="public static Option&lt;bool&gt; PreferImplicitTypeInLocalDeclaration { get; }" />
          <member def="public static Option&lt;bool&gt; PreferImplicitTypeInference { get; }" />
          <member def="public static PerLanguageOption&lt;bool&gt; PreferIntrinsicPredefinedTypeKeywordInDeclaration { get; }" />
          <member def="public static PerLanguageOption&lt;bool&gt; PreferIntrinsicPredefinedTypeKeywordInMemberAccess { get; }" />
          <member def="public static Option&lt;bool&gt; PreferOmittingModuleNamesInQualification { get; }" />
          <member def="public static PerLanguageOption&lt;bool&gt; QualifyEventAccess { get; }" />
          <member def="public static PerLanguageOption&lt;bool&gt; QualifyFieldAccess { get; }" />
          <member def="public static PerLanguageOption&lt;bool&gt; QualifyMemberAccessWithThisOrMe { get; }" />
          <member def="public static PerLanguageOption&lt;bool&gt; QualifyMethodAccess { get; }" />
          <member def="public static PerLanguageOption&lt;bool&gt; QualifyPropertyAccess { get; }" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Simplification.Simplifier">
        <members>
          <member def="public static SyntaxAnnotation Annotation { get; }" />
          <member def="public static SyntaxAnnotation SpecialTypeAnnotation { get; }" />
          <member def="public static SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, Workspace workspace, Func&lt;SyntaxNode, bool&gt; expandInsideNode = null, CancellationToken cancellationToken = default)" />
          <member def="public static TNode Expand&lt;TNode&gt;(TNode node, SemanticModel semanticModel, Workspace workspace, Func&lt;SyntaxNode, bool&gt; expandInsideNode = null, bool expandParameter = false, CancellationToken cancellationToken = default) where TNode : SyntaxNode" />
          <member def="public static Task&lt;SyntaxToken&gt; ExpandAsync(SyntaxToken token, Document document, Func&lt;SyntaxNode, bool&gt; expandInsideNode = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;TNode&gt; ExpandAsync&lt;TNode&gt;(TNode node, Document document, Func&lt;SyntaxNode, bool&gt; expandInsideNode = null, bool expandParameter = false, CancellationToken cancellationToken = default) where TNode : SyntaxNode" />
          <member def="public static Task&lt;Document&gt; ReduceAsync(Document document, OptionSet optionSet = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; ReduceAsync(Document document, SyntaxAnnotation annotation, OptionSet optionSet = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; ReduceAsync(Document document, TextSpan span, OptionSet optionSet = null, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; ReduceAsync(Document document, IEnumerable&lt;TextSpan&gt; spans, OptionSet optionSet = null, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Microsoft.CodeAnalysis.Tags.WellKnownTags">
        <members>
          <member def="public const string Assembly = &quot;Assembly&quot;" />
          <member def="public const string Class = &quot;Class&quot;" />
          <member def="public const string Constant = &quot;Constant&quot;" />
          <member def="public const string Delegate = &quot;Delegate&quot;" />
          <member def="public const string Enum = &quot;Enum&quot;" />
          <member def="public const string EnumMember = &quot;EnumMember&quot;" />
          <member def="public const string Error = &quot;Error&quot;" />
          <member def="public const string Event = &quot;Event&quot;" />
          <member def="public const string ExtensionMethod = &quot;ExtensionMethod&quot;" />
          <member def="public const string Field = &quot;Field&quot;" />
          <member def="public const string File = &quot;File&quot;" />
          <member def="public const string Folder = &quot;Folder&quot;" />
          <member def="public const string Interface = &quot;Interface&quot;" />
          <member def="public const string Internal = &quot;Internal&quot;" />
          <member def="public const string Intrinsic = &quot;Intrinsic&quot;" />
          <member def="public const string Keyword = &quot;Keyword&quot;" />
          <member def="public const string Label = &quot;Label&quot;" />
          <member def="public const string Local = &quot;Local&quot;" />
          <member def="public const string Method = &quot;Method&quot;" />
          <member def="public const string Module = &quot;Module&quot;" />
          <member def="public const string Namespace = &quot;Namespace&quot;" />
          <member def="public const string Operator = &quot;Operator&quot;" />
          <member def="public const string Parameter = &quot;Parameter&quot;" />
          <member def="public const string Private = &quot;Private&quot;" />
          <member def="public const string Project = &quot;Project&quot;" />
          <member def="public const string Property = &quot;Property&quot;" />
          <member def="public const string Protected = &quot;Protected&quot;" />
          <member def="public const string Public = &quot;Public&quot;" />
          <member def="public const string RangeVariable = &quot;RangeVariable&quot;" />
          <member def="public const string Reference = &quot;Reference&quot;" />
          <member def="public const string Snippet = &quot;Snippet&quot;" />
          <member def="public const string Structure = &quot;Structure&quot;" />
          <member def="public const string TypeParameter = &quot;TypeParameter&quot;" />
          <member def="public const string Warning = &quot;Warning&quot;" />
        </members>
      </type>
      <type def="public static class Roslynator.DiagnosticsExtensions">
        <members>
          <member def="public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable&lt;Location&gt; additionalLocations, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable&lt;Location&gt; additionalLocations, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable&lt;Location&gt; additionalLocations, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary&lt;string, string&gt; properties, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary&lt;string, string&gt; properties, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary&lt;string, string&gt; properties, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable&lt;Location&gt; additionalLocations, ImmutableDictionary&lt;string, string&gt; properties, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable&lt;Location&gt; additionalLocations, ImmutableDictionary&lt;string, string&gt; properties, params object[] messageArgs)" />
          <member def="public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable&lt;Location&gt; additionalLocations, ImmutableDictionary&lt;string, string&gt; properties, params object[] messageArgs)" />
        </members>
      </type>
      <type def="public static class Roslynator.EnumExtensions">
        <members>
          <member def="public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2)" />
          <member def="public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2)" />
          <member def="public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2)" />
          <member def="public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2)" />
          <member def="public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3)" />
          <member def="public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3)" />
          <member def="public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3)" />
          <member def="public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3)" />
          <member def="public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3, Accessibility accessibility4)" />
          <member def="public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3, MethodKind methodKind4)" />
          <member def="public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3, SpecialType specialType4)" />
          <member def="public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3, TypeKind typeKind4)" />
          <member def="public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3, Accessibility accessibility4, Accessibility accessibility5)" />
          <member def="public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3, MethodKind methodKind4, MethodKind methodKind5)" />
          <member def="public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3, SpecialType specialType4, SpecialType specialType5)" />
          <member def="public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3, TypeKind typeKind4, TypeKind typeKind5)" />
          <member def="public static bool IsMoreRestrictiveThan(this Accessibility accessibility, Accessibility other)" />
        </members>
      </type>
      <type def="public static class Roslynator.FileLinePositionSpanExtensions">
        <members>
          <member def="public static int EndLine(this FileLinePositionSpan fileLinePositionSpan)" />
          <member def="public static bool IsMultiLine(this FileLinePositionSpan fileLinePositionSpan)" />
          <member def="public static bool IsSingleLine(this FileLinePositionSpan fileLinePositionSpan)" />
          <member def="public static int StartLine(this FileLinePositionSpan fileLinePositionSpan)" />
        </members>
      </type>
      <type def="public static class Roslynator.SemanticModelExtensions">
        <members>
          <member def="public static INamedTypeSymbol GetEnclosingNamedType(this SemanticModel semanticModel, int position, CancellationToken cancellationToken = default)" />
          <member def="public static TSymbol GetEnclosingSymbol&lt;TSymbol&gt;(this SemanticModel semanticModel, int position, CancellationToken cancellationToken = default) where TSymbol : ISymbol" />
          <member def="public static ISymbol GetSymbol(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default)" />
          <member def="public static INamedTypeSymbol GetTypeByMetadataName(this SemanticModel semanticModel, string fullyQualifiedMetadataName)" />
          <member def="public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Roslynator.SymbolExtensions">
        <members>
          <member def="public static IEnumerable&lt;INamedTypeSymbol&gt; BaseTypes(this ITypeSymbol type)" />
          <member def="public static IEnumerable&lt;ITypeSymbol&gt; BaseTypesAndSelf(this ITypeSymbol typeSymbol)" />
          <member def="public static bool EqualsOrInheritsFrom(this ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces = false)" />
          <member def="public static bool EqualsOrInheritsFrom(this ITypeSymbol type, in MetadataName baseTypeName, bool includeInterfaces = false)" />
          <member def="public static TSymbol FindMember&lt;TSymbol&gt;(this ITypeSymbol typeSymbol, Func&lt;TSymbol, bool&gt; predicate = null) where TSymbol : ISymbol" />
          <member def="public static TSymbol FindMember&lt;TSymbol&gt;(this ITypeSymbol typeSymbol, string name, Func&lt;TSymbol, bool&gt; predicate = null) where TSymbol : ISymbol" />
          <member def="public static TSymbol FindMember&lt;TSymbol&gt;(this INamedTypeSymbol typeSymbol, Func&lt;TSymbol, bool&gt; predicate, bool includeBaseTypes = false) where TSymbol : ISymbol" />
          <member def="public static TSymbol FindMember&lt;TSymbol&gt;(this INamedTypeSymbol typeSymbol, string name, Func&lt;TSymbol, bool&gt; predicate = null, bool includeBaseTypes = false) where TSymbol : ISymbol" />
          <member def="public static INamedTypeSymbol FindTypeMember(this INamedTypeSymbol typeSymbol, Func&lt;INamedTypeSymbol, bool&gt; predicate, bool includeBaseTypes = false)" />
          <member def="public static INamedTypeSymbol FindTypeMember(this INamedTypeSymbol typeSymbol, string name, Func&lt;INamedTypeSymbol, bool&gt; predicate = null, bool includeBaseTypes = false)" />
          <member def="public static INamedTypeSymbol FindTypeMember(this INamedTypeSymbol typeSymbol, string name, int arity, Func&lt;INamedTypeSymbol, bool&gt; predicate = null, bool includeBaseTypes = false)" />
          <member def="public static AttributeData GetAttribute(this ISymbol symbol, INamedTypeSymbol attributeClass)" />
          <member def="public static AttributeData GetAttribute(this ISymbol symbol, in MetadataName attributeName)" />
          <member def="public static bool HasAttribute(this ISymbol symbol, INamedTypeSymbol attributeClass)" />
          <member def="public static bool HasAttribute(this ISymbol symbol, in MetadataName attributeName)" />
          <member def="public static bool HasAttribute(this ITypeSymbol typeSymbol, INamedTypeSymbol attributeClass, bool includeBaseTypes)" />
          <member def="public static bool HasAttribute(this ITypeSymbol typeSymbol, in MetadataName attributeName, bool includeBaseTypes)" />
          <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, bool value)" />
          <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, char value)" />
          <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, sbyte value)" />
          <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, byte value)" />
          <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, short value)" />
          <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, ushort value)" />
          <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, int value)" />
          <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, uint value)" />
          <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, long value)" />
          <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, ulong value)" />
          <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, decimal value)" />
          <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, float value)" />
          <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, double value)" />
          <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, string value)" />
          <member def="public static bool HasMetadataName(this ISymbol symbol, in MetadataName metadataName)" />
          <member def="public static bool Implements(this ITypeSymbol typeSymbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false)" />
          <member def="public static bool Implements(this ITypeSymbol typeSymbol, SpecialType interfaceType, bool allInterfaces = false)" />
          <member def="public static bool Implements(this ITypeSymbol typeSymbol, in MetadataName interfaceName, bool allInterfaces = false)" />
          <member def="public static bool ImplementsAny(this ITypeSymbol typeSymbol, SpecialType interfaceType1, SpecialType interfaceType2, bool allInterfaces = false)" />
          <member def="public static bool ImplementsAny(this ITypeSymbol typeSymbol, SpecialType interfaceType1, SpecialType interfaceType2, SpecialType interfaceType3, bool allInterfaces = false)" />
          <member def="public static bool ImplementsInterfaceMember(this ISymbol symbol, bool allInterfaces = false)" />
          <member def="public static bool ImplementsInterfaceMember(this ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false)" />
          <member def="public static bool ImplementsInterfaceMember&lt;TSymbol&gt;(this ISymbol symbol, bool allInterfaces = false) where TSymbol : ISymbol" />
          <member def="public static bool ImplementsInterfaceMember&lt;TSymbol&gt;(this ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false) where TSymbol : ISymbol" />
          <member def="public static bool InheritsFrom(this ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces = false)" />
          <member def="public static bool InheritsFrom(this ITypeSymbol type, in MetadataName baseTypeName, bool includeInterfaces = false)" />
          <member def="public static bool IsAsyncMethod(this ISymbol symbol)" />
          <member def="public static bool IsErrorType(this ISymbol symbol)" />
          <member def="public static bool IsIEnumerableOfT(this ITypeSymbol typeSymbol)" />
          <member def="public static bool IsIEnumerableOrIEnumerableOfT(this ITypeSymbol typeSymbol)" />
          <member def="public static bool IsKind(this ISymbol symbol, SymbolKind kind)" />
          <member def="public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2)" />
          <member def="public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3)" />
          <member def="public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3, SymbolKind kind4)" />
          <member def="public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3, SymbolKind kind4, SymbolKind kind5)" />
          <member def="public static bool IsNullableOf(this INamedTypeSymbol namedTypeSymbol, SpecialType specialType)" />
          <member def="public static bool IsNullableOf(this INamedTypeSymbol namedTypeSymbol, ITypeSymbol typeArgument)" />
          <member def="public static bool IsNullableOf(this ITypeSymbol typeSymbol, SpecialType specialType)" />
          <member def="public static bool IsNullableOf(this ITypeSymbol typeSymbol, ITypeSymbol typeArgument)" />
          <member def="public static bool IsNullableType(this ITypeSymbol typeSymbol)" />
          <member def="public static bool IsObject(this ITypeSymbol typeSymbol)" />
          <member def="public static bool IsOrdinaryExtensionMethod(this IMethodSymbol methodSymbol)" />
          <member def="public static bool IsParameterArrayOf(this IParameterSymbol parameterSymbol, SpecialType elementType)" />
          <member def="public static bool IsParameterArrayOf(this IParameterSymbol parameterSymbol, SpecialType elementType1, SpecialType elementType2)" />
          <member def="public static bool IsParameterArrayOf(this IParameterSymbol parameterSymbol, SpecialType elementType1, SpecialType elementType2, SpecialType elementType3)" />
          <member def="public static bool IsPubliclyVisible(this ISymbol symbol)" />
          <member def="public static bool IsReducedExtensionMethod(this IMethodSymbol methodSymbol)" />
          <member def="public static bool IsRefOrOut(this IParameterSymbol parameterSymbol)" />
          <member def="public static bool IsReferenceTypeOrNullableType(this ITypeSymbol typeSymbol)" />
          <member def="public static bool IsString(this ITypeSymbol typeSymbol)" />
          <member def="public static bool IsVoid(this ITypeSymbol typeSymbol)" />
          <member def="public static IMethodSymbol ReducedFromOrSelf(this IMethodSymbol methodSymbol)" />
          <member def="public static bool SupportsExplicitDeclaration(this ITypeSymbol typeSymbol)" />
        </members>
      </type>
      <type def="public static class Roslynator.SyntaxExtensions">
        <members>
          <member def="public static bool All(this SyntaxTokenList list, Func&lt;SyntaxToken, bool&gt; predicate)" />
          <member def="public static bool All(this SyntaxTriviaList list, Func&lt;SyntaxTrivia, bool&gt; predicate)" />
          <member def="public static bool All&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, Func&lt;TNode, bool&gt; predicate) where TNode : SyntaxNode" />
          <member def="public static bool All&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, Func&lt;TNode, bool&gt; predicate) where TNode : SyntaxNode" />
          <member def="public static bool Any(this SyntaxTokenList list, Func&lt;SyntaxToken, bool&gt; predicate)" />
          <member def="public static bool Any(this SyntaxTriviaList list, Func&lt;SyntaxTrivia, bool&gt; predicate)" />
          <member def="public static bool Any&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, Func&lt;TNode, bool&gt; predicate) where TNode : SyntaxNode" />
          <member def="public static bool Any&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, Func&lt;TNode, bool&gt; predicate) where TNode : SyntaxNode" />
          <member def="public static SyntaxToken AppendToLeadingTrivia(this SyntaxToken token, IEnumerable&lt;SyntaxTrivia&gt; trivia)" />
          <member def="public static SyntaxToken AppendToLeadingTrivia(this SyntaxToken token, SyntaxTrivia trivia)" />
          <member def="public static TNode AppendToLeadingTrivia&lt;TNode&gt;(this TNode node, IEnumerable&lt;SyntaxTrivia&gt; trivia) where TNode : SyntaxNode" />
          <member def="public static TNode AppendToLeadingTrivia&lt;TNode&gt;(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode" />
          <member def="public static SyntaxToken AppendToTrailingTrivia(this SyntaxToken token, IEnumerable&lt;SyntaxTrivia&gt; trivia)" />
          <member def="public static SyntaxToken AppendToTrailingTrivia(this SyntaxToken token, SyntaxTrivia trivia)" />
          <member def="public static TNode AppendToTrailingTrivia&lt;TNode&gt;(this TNode node, IEnumerable&lt;SyntaxTrivia&gt; trivia) where TNode : SyntaxNode" />
          <member def="public static TNode AppendToTrailingTrivia&lt;TNode&gt;(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode" />
          <member def="public static bool Contains(this SyntaxTokenList tokens, SyntaxToken token)" />
          <member def="public static bool Contains&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, TNode node) where TNode : SyntaxNode" />
          <member def="public static bool Contains&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, TNode node) where TNode : SyntaxNode" />
          <member def="public static bool ContainsDirectives(this SyntaxNode node, TextSpan span)" />
          <member def="public static IEnumerable&lt;SyntaxTrivia&gt; DescendantTrivia&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode" />
          <member def="public static IEnumerable&lt;SyntaxTrivia&gt; DescendantTrivia&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, TextSpan span, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode" />
          <member def="public static TNode FirstAncestor&lt;TNode&gt;(this SyntaxNode node, Func&lt;TNode, bool&gt; predicate = null, bool ascendOutOfTrivia = true) where TNode : SyntaxNode" />
          <member def="public static TNode FirstDescendant&lt;TNode&gt;(this SyntaxNode node, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode" />
          <member def="public static TNode FirstDescendant&lt;TNode&gt;(this SyntaxNode node, TextSpan span, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode" />
          <member def="public static TNode FirstDescendantOrSelf&lt;TNode&gt;(this SyntaxNode node, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode" />
          <member def="public static TNode FirstDescendantOrSelf&lt;TNode&gt;(this SyntaxNode node, TextSpan span, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode" />
          <member def="public static SyntaxTriviaList GetLeadingAndTrailingTrivia(this SyntaxNode node)" />
          <member def="public static SyntaxToken GetTrailingSeparator&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list) where TNode : SyntaxNode" />
          <member def="public static bool HasTrailingSeparator&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list) where TNode : SyntaxNode" />
          <member def="public static int IndexOf(this SyntaxTokenList tokens, Func&lt;SyntaxToken, bool&gt; predicate)" />
          <member def="public static int IndexOf(this SyntaxTriviaList triviaList, Func&lt;SyntaxTrivia, bool&gt; predicate)" />
          <member def="public static bool IsFirst&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, TNode node) where TNode : SyntaxNode" />
          <member def="public static bool IsFirst&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, TNode node) where TNode : SyntaxNode" />
          <member def="public static bool IsLast&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, TNode node) where TNode : SyntaxNode" />
          <member def="public static bool IsLast&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, TNode node) where TNode : SyntaxNode" />
          <member def="public static SyntaxTriviaList LeadingAndTrailingTrivia(this SyntaxToken token)" />
          <member def="public static SyntaxToken PrependToLeadingTrivia(this SyntaxToken token, IEnumerable&lt;SyntaxTrivia&gt; trivia)" />
          <member def="public static SyntaxToken PrependToLeadingTrivia(this SyntaxToken token, SyntaxTrivia trivia)" />
          <member def="public static TNode PrependToLeadingTrivia&lt;TNode&gt;(this TNode node, IEnumerable&lt;SyntaxTrivia&gt; trivia) where TNode : SyntaxNode" />
          <member def="public static TNode PrependToLeadingTrivia&lt;TNode&gt;(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode" />
          <member def="public static SyntaxToken PrependToTrailingTrivia(this SyntaxToken token, IEnumerable&lt;SyntaxTrivia&gt; trivia)" />
          <member def="public static SyntaxToken PrependToTrailingTrivia(this SyntaxToken token, SyntaxTrivia trivia)" />
          <member def="public static TNode PrependToTrailingTrivia&lt;TNode&gt;(this TNode node, IEnumerable&lt;SyntaxTrivia&gt; trivia) where TNode : SyntaxNode" />
          <member def="public static TNode PrependToTrailingTrivia&lt;TNode&gt;(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode" />
          <member def="public static SyntaxTokenList ReplaceAt(this SyntaxTokenList tokenList, int index, SyntaxToken newToken)" />
          <member def="public static SyntaxTriviaList ReplaceAt(this SyntaxTriviaList triviaList, int index, SyntaxTrivia newTrivia)" />
          <member def="public static SeparatedSyntaxList&lt;TNode&gt; ReplaceAt&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, int index, TNode newNode) where TNode : SyntaxNode" />
          <member def="public static SyntaxList&lt;TNode&gt; ReplaceAt&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, int index, TNode newNode) where TNode : SyntaxNode" />
          <member def="public static bool SpanContainsDirectives(this SyntaxNode node)" />
          <member def="public static bool TryGetContainingList(this SyntaxTrivia trivia, out SyntaxTriviaList triviaList, bool allowLeading = true, bool allowTrailing = true)" />
          <member def="public static SyntaxToken WithTriviaFrom(this SyntaxToken token, SyntaxNode node)" />
          <member def="public static SeparatedSyntaxList&lt;TNode&gt; WithTriviaFrom&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, SyntaxNode node) where TNode : SyntaxNode" />
          <member def="public static SyntaxList&lt;TNode&gt; WithTriviaFrom&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, SyntaxNode node) where TNode : SyntaxNode" />
          <member def="public static TNode WithTriviaFrom&lt;TNode&gt;(this TNode node, SyntaxToken token) where TNode : SyntaxNode" />
          <member def="public static SyntaxNodeOrToken WithoutLeadingTrivia(this SyntaxNodeOrToken nodeOrToken)" />
          <member def="public static SyntaxToken WithoutLeadingTrivia(this SyntaxToken token)" />
          <member def="public static SyntaxNodeOrToken WithoutTrailingTrivia(this SyntaxNodeOrToken nodeOrToken)" />
          <member def="public static SyntaxToken WithoutTrailingTrivia(this SyntaxToken token)" />
          <member def="public static SyntaxNodeOrToken WithoutTrivia(this SyntaxNodeOrToken nodeOrToken)" />
        </members>
      </type>
      <type def="public static class Roslynator.SyntaxTreeExtensions">
        <members>
          <member def="public static int GetEndLine(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default)" />
          <member def="public static int GetStartLine(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default)" />
          <member def="public static bool IsMultiLineSpan(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default)" />
          <member def="public static bool IsSingleLineSpan(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Roslynator.WorkspaceExtensions">
        <members>
          <member def="public static Task&lt;Document&gt; InsertNodeAfterAsync(this Document document, SyntaxNode nodeInList, SyntaxNode newNode, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; InsertNodeBeforeAsync(this Document document, SyntaxNode nodeInList, SyntaxNode newNode, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; InsertNodesAfterAsync(this Document document, SyntaxNode nodeInList, IEnumerable&lt;SyntaxNode&gt; newNodes, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; InsertNodesBeforeAsync(this Document document, SyntaxNode nodeInList, IEnumerable&lt;SyntaxNode&gt; newNodes, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; RemoveNodeAsync(this Document document, SyntaxNode node, SyntaxRemoveOptions options, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; RemoveNodesAsync(this Document document, IEnumerable&lt;SyntaxNode&gt; nodes, SyntaxRemoveOptions options, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; ReplaceNodeAsync(this Document document, SyntaxNode oldNode, SyntaxNode newNode, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; ReplaceNodeAsync(this Document document, SyntaxNode oldNode, IEnumerable&lt;SyntaxNode&gt; newNodes, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Solution&gt; ReplaceNodeAsync&lt;TNode&gt;(this Solution solution, TNode oldNode, TNode newNode, CancellationToken cancellationToken = default) where TNode : SyntaxNode" />
          <member def="public static Task&lt;Document&gt; ReplaceNodesAsync&lt;TNode&gt;(this Document document, IEnumerable&lt;TNode&gt; nodes, Func&lt;TNode, TNode, SyntaxNode&gt; computeReplacementNode, CancellationToken cancellationToken = default) where TNode : SyntaxNode" />
          <member def="public static Task&lt;Solution&gt; ReplaceNodesAsync&lt;TNode&gt;(this Solution solution, IEnumerable&lt;TNode&gt; nodes, Func&lt;TNode, TNode, SyntaxNode&gt; computeReplacementNodes, CancellationToken cancellationToken = default) where TNode : SyntaxNode" />
          <member def="public static Task&lt;Document&gt; ReplaceTokenAsync(this Document document, SyntaxToken oldToken, SyntaxToken newToken, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; ReplaceTokenAsync(this Document document, SyntaxToken oldToken, IEnumerable&lt;SyntaxToken&gt; newTokens, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; ReplaceTriviaAsync(this Document document, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; ReplaceTriviaAsync(this Document document, SyntaxTrivia oldTrivia, IEnumerable&lt;SyntaxTrivia&gt; newTrivia, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; WithTextChangeAsync(this Document document, TextChange textChange, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; WithTextChangesAsync(this Document document, TextChange[] textChanges, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; WithTextChangesAsync(this Document document, IEnumerable&lt;TextChange&gt; textChanges, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Roslynator.CSharp.CSharpExtensions">
        <members>
          <member def="public static IParameterSymbol DetermineParameter(this SemanticModel semanticModel, ArgumentSyntax argument, bool allowParams = false, bool allowCandidate = false, CancellationToken cancellationToken = default)" />
          <member def="public static IParameterSymbol DetermineParameter(this SemanticModel semanticModel, AttributeArgumentSyntax attributeArgument, bool allowParams = false, bool allowCandidate = false, CancellationToken cancellationToken = default)" />
          <member def="public static ExtensionMethodSymbolInfo GetExtensionMethodInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)" />
          <member def="public static IMethodSymbol GetMethodSymbol(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)" />
          <member def="public static ExtensionMethodSymbolInfo GetReducedExtensionMethodInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)" />
          <member def="public static ISymbol GetSymbol(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default)" />
          <member def="public static ISymbol GetSymbol(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default)" />
          <member def="public static ISymbol GetSymbol(this SemanticModel semanticModel, CrefSyntax cref, CancellationToken cancellationToken = default)" />
          <member def="public static ISymbol GetSymbol(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)" />
          <member def="public static ISymbol GetSymbol(this SemanticModel semanticModel, OrderingSyntax ordering, CancellationToken cancellationToken = default)" />
          <member def="public static ISymbol GetSymbol(this SemanticModel semanticModel, SelectOrGroupClauseSyntax selectOrGroupClause, CancellationToken cancellationToken = default)" />
          <member def="public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default)" />
          <member def="public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default)" />
          <member def="public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)" />
          <member def="public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, SelectOrGroupClauseSyntax selectOrGroupClause, CancellationToken cancellationToken = default)" />
          <member def="public static bool HasConstantValue(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)" />
          <member def="public static bool IsDefaultValue(this SemanticModel semanticModel, ITypeSymbol typeSymbol, ExpressionSyntax expression, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Roslynator.CSharp.CSharpFactory">
        <members>
          <member def="public static AccessorListSyntax AccessorList(AccessorDeclarationSyntax accessor)" />
          <member def="public static AccessorListSyntax AccessorList(params AccessorDeclarationSyntax[] accessors)" />
          <member def="public static AccessorDeclarationSyntax AddAccessorDeclaration(BlockSyntax body)" />
          <member def="public static AccessorDeclarationSyntax AddAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static AccessorDeclarationSyntax AddAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body)" />
          <member def="public static AccessorDeclarationSyntax AddAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static AssignmentExpressionSyntax AddAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static AssignmentExpressionSyntax AddAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax AddExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax AddExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static PrefixUnaryExpressionSyntax AddressOfExpression(ExpressionSyntax operand)" />
          <member def="public static PrefixUnaryExpressionSyntax AddressOfExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
          <member def="public static AssignmentExpressionSyntax AndAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static AssignmentExpressionSyntax AndAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static ArgumentSyntax Argument(NameColonSyntax nameColon, ExpressionSyntax expression)" />
          <member def="public static ArgumentListSyntax ArgumentList(ArgumentSyntax argument)" />
          <member def="public static ArgumentListSyntax ArgumentList(params ArgumentSyntax[] arguments)" />
          <member def="public static InitializerExpressionSyntax ArrayInitializerExpression(SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions = default)" />
          <member def="public static InitializerExpressionSyntax ArrayInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions, SyntaxToken closeBraceToken)" />
          <member def="public static BinaryExpressionSyntax AsExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax AsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentSyntax argument)" />
          <member def="public static AttributeArgumentSyntax AttributeArgument(NameColonSyntax nameColon, ExpressionSyntax expression)" />
          <member def="public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, ExpressionSyntax expression)" />
          <member def="public static AttributeArgumentListSyntax AttributeArgumentList(AttributeArgumentSyntax attributeArgument)" />
          <member def="public static AttributeArgumentListSyntax AttributeArgumentList(params AttributeArgumentSyntax[] attributeArguments)" />
          <member def="public static AttributeListSyntax AttributeList(AttributeSyntax attribute)" />
          <member def="public static AttributeListSyntax AttributeList(params AttributeSyntax[] attributes)" />
          <member def="public static AccessorDeclarationSyntax AutoGetAccessorDeclaration(SyntaxTokenList modifiers = default)" />
          <member def="public static AccessorDeclarationSyntax AutoSetAccessorDeclaration(SyntaxTokenList modifiers = default)" />
          <member def="public static ConstructorInitializerSyntax BaseConstructorInitializer(ArgumentListSyntax argumentList = null)" />
          <member def="public static ConstructorInitializerSyntax BaseConstructorInitializer(SyntaxToken semicolonToken, ArgumentListSyntax argumentList)" />
          <member def="public static BaseListSyntax BaseList(BaseTypeSyntax type)" />
          <member def="public static BaseListSyntax BaseList(params BaseTypeSyntax[] types)" />
          <member def="public static BaseListSyntax BaseList(SyntaxToken colonToken, BaseTypeSyntax baseType)" />
          <member def="public static BaseListSyntax BaseList(SyntaxToken colonToken, params BaseTypeSyntax[] types)" />
          <member def="public static BinaryExpressionSyntax BitwiseAndExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax BitwiseAndExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static PrefixUnaryExpressionSyntax BitwiseNotExpression(ExpressionSyntax operand)" />
          <member def="public static PrefixUnaryExpressionSyntax BitwiseNotExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
          <member def="public static BinaryExpressionSyntax BitwiseOrExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax BitwiseOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static BlockSyntax Block(StatementSyntax statement)" />
          <member def="public static BlockSyntax Block(SyntaxToken openBrace, StatementSyntax statement, SyntaxToken closeBrace)" />
          <member def="public static LiteralExpressionSyntax BooleanLiteralExpression(bool value)" />
          <member def="public static BracketedArgumentListSyntax BracketedArgumentList(ArgumentSyntax argument)" />
          <member def="public static BracketedArgumentListSyntax BracketedArgumentList(params ArgumentSyntax[] arguments)" />
          <member def="public static BracketedParameterListSyntax BracketedParameterList(ParameterSyntax parameter)" />
          <member def="public static BracketedParameterListSyntax BracketedParameterList(params ParameterSyntax[] parameters)" />
          <member def="public static LiteralExpressionSyntax CharacterLiteralExpression(char value)" />
          <member def="public static CheckedExpressionSyntax CheckedExpression(ExpressionSyntax expression)" />
          <member def="public static CheckedExpressionSyntax CheckedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)" />
          <member def="public static ClassOrStructConstraintSyntax ClassConstraint()" />
          <member def="public static ClassDeclarationSyntax ClassDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList&lt;MemberDeclarationSyntax&gt; members = default)" />
          <member def="public static ClassDeclarationSyntax ClassDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList&lt;MemberDeclarationSyntax&gt; members = default)" />
          <member def="public static BinaryExpressionSyntax CoalesceExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax CoalesceExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static InitializerExpressionSyntax CollectionInitializerExpression(SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions = default)" />
          <member def="public static InitializerExpressionSyntax CollectionInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions, SyntaxToken closeBraceToken)" />
          <member def="public static CompilationUnitSyntax CompilationUnit(MemberDeclarationSyntax member)" />
          <member def="public static CompilationUnitSyntax CompilationUnit(SyntaxList&lt;UsingDirectiveSyntax&gt; usings, MemberDeclarationSyntax member)" />
          <member def="public static CompilationUnitSyntax CompilationUnit(SyntaxList&lt;UsingDirectiveSyntax&gt; usings, SyntaxList&lt;MemberDeclarationSyntax&gt; members)" />
          <member def="public static InitializerExpressionSyntax ComplexElementInitializerExpression(SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions = default)" />
          <member def="public static InitializerExpressionSyntax ComplexElementInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions, SyntaxToken closeBraceToken)" />
          <member def="public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body)" />
          <member def="public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static LiteralExpressionSyntax DefaultLiteralExpression()" />
          <member def="public static SwitchSectionSyntax DefaultSwitchSection(StatementSyntax statement)" />
          <member def="public static SwitchSectionSyntax DefaultSwitchSection(SyntaxList&lt;StatementSyntax&gt; statements)" />
          <member def="public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, string identifier, ParameterListSyntax parameterList)" />
          <member def="public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList)" />
          <member def="public static AssignmentExpressionSyntax DivideAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static AssignmentExpressionSyntax DivideAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static SyntaxTrivia EmptyWhitespace()" />
          <member def="public static EnumDeclarationSyntax EnumDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SeparatedSyntaxList&lt;EnumMemberDeclarationSyntax&gt; members)" />
          <member def="public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier, ExpressionSyntax value)" />
          <member def="public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier, EqualsValueClauseSyntax value)" />
          <member def="public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string name, ExpressionSyntax value)" />
          <member def="public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string name, EqualsValueClauseSyntax value)" />
          <member def="public static BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static EventDeclarationSyntax EventDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, AccessorListSyntax accessorList)" />
          <member def="public static EventDeclarationSyntax EventDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, AccessorListSyntax accessorList)" />
          <member def="public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier)" />
          <member def="public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier)" />
          <member def="public static AssignmentExpressionSyntax ExclusiveOrAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static AssignmentExpressionSyntax ExclusiveOrAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static ConversionOperatorDeclarationSyntax ExplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body)" />
          <member def="public static ConversionOperatorDeclarationSyntax ExplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static LiteralExpressionSyntax FalseLiteralExpression()" />
          <member def="public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, EqualsValueClauseSyntax initializer)" />
          <member def="public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer)" />
          <member def="public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, ExpressionSyntax value = null)" />
          <member def="public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null)" />
          <member def="public static GenericNameSyntax GenericName(string identifier, TypeSyntax typeArgument)" />
          <member def="public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeSyntax typeArgument)" />
          <member def="public static AccessorDeclarationSyntax GetAccessorDeclaration(BlockSyntax body)" />
          <member def="public static AccessorDeclarationSyntax GetAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static AccessorDeclarationSyntax GetAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body)" />
          <member def="public static AccessorDeclarationSyntax GetAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static ConversionOperatorDeclarationSyntax ImplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body)" />
          <member def="public static ConversionOperatorDeclarationSyntax ImplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxTokenList modifiers, TypeSyntax type, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList)" />
          <member def="public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxTokenList modifiers, TypeSyntax type, BracketedParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList&lt;MemberDeclarationSyntax&gt; members = default)" />
          <member def="public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList&lt;MemberDeclarationSyntax&gt; members = default)" />
          <member def="public static BinaryExpressionSyntax IsExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax IsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static AssignmentExpressionSyntax LeftShiftAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static AssignmentExpressionSyntax LeftShiftAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static LiteralExpressionSyntax LiteralExpression(object value)" />
          <member def="public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, string identifier, EqualsValueClauseSyntax initializer)" />
          <member def="public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer)" />
          <member def="public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, string identifier, ExpressionSyntax value = null)" />
          <member def="public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null)" />
          <member def="public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body)" />
          <member def="public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static BinaryExpressionSyntax LogicalAndExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax LogicalAndExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static PrefixUnaryExpressionSyntax LogicalNotExpression(ExpressionSyntax operand)" />
          <member def="public static PrefixUnaryExpressionSyntax LogicalNotExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
          <member def="public static BinaryExpressionSyntax LogicalOrExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax LogicalOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static MethodDeclarationSyntax MethodDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body)" />
          <member def="public static MethodDeclarationSyntax MethodDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static AssignmentExpressionSyntax ModuloAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static AssignmentExpressionSyntax ModuloAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static AssignmentExpressionSyntax MultiplyAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static AssignmentExpressionSyntax MultiplyAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static InvocationExpressionSyntax NameOfExpression(ExpressionSyntax expression)" />
          <member def="public static InvocationExpressionSyntax NameOfExpression(string identifier)" />
          <member def="public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, MemberDeclarationSyntax member)" />
          <member def="public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, SyntaxList&lt;MemberDeclarationSyntax&gt; members)" />
          <member def="public static SyntaxTrivia NewLine()" />
          <member def="public static BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static LiteralExpressionSyntax NullLiteralExpression()" />
          <member def="public static LiteralExpressionSyntax NumericLiteralExpression(int value)" />
          <member def="public static LiteralExpressionSyntax NumericLiteralExpression(uint value)" />
          <member def="public static LiteralExpressionSyntax NumericLiteralExpression(sbyte value)" />
          <member def="public static LiteralExpressionSyntax NumericLiteralExpression(decimal value)" />
          <member def="public static LiteralExpressionSyntax NumericLiteralExpression(double value)" />
          <member def="public static LiteralExpressionSyntax NumericLiteralExpression(float value)" />
          <member def="public static LiteralExpressionSyntax NumericLiteralExpression(long value)" />
          <member def="public static LiteralExpressionSyntax NumericLiteralExpression(ulong value)" />
          <member def="public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type, ArgumentListSyntax argumentList)" />
          <member def="public static InitializerExpressionSyntax ObjectInitializerExpression(SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions = default)" />
          <member def="public static InitializerExpressionSyntax ObjectInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions, SyntaxToken closeBraceToken)" />
          <member def="public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body)" />
          <member def="public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static AssignmentExpressionSyntax OrAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static AssignmentExpressionSyntax OrAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static ParameterSyntax Parameter(TypeSyntax type, string identifier, ExpressionSyntax @default = null)" />
          <member def="public static ParameterSyntax Parameter(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax @default = null)" />
          <member def="public static ParameterSyntax Parameter(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)" />
          <member def="public static ParameterListSyntax ParameterList(ParameterSyntax parameter)" />
          <member def="public static ParameterListSyntax ParameterList(params ParameterSyntax[] parameters)" />
          <member def="public static PrefixUnaryExpressionSyntax PointerIndirectionExpression(ExpressionSyntax operand)" />
          <member def="public static PrefixUnaryExpressionSyntax PointerIndirectionExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
          <member def="public static PostfixUnaryExpressionSyntax PostDecrementExpression(ExpressionSyntax operand)" />
          <member def="public static PostfixUnaryExpressionSyntax PostDecrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
          <member def="public static PostfixUnaryExpressionSyntax PostIncrementExpression(ExpressionSyntax operand)" />
          <member def="public static PostfixUnaryExpressionSyntax PostIncrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
          <member def="public static PrefixUnaryExpressionSyntax PreDecrementExpression(ExpressionSyntax operand)" />
          <member def="public static PrefixUnaryExpressionSyntax PreDecrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
          <member def="public static PrefixUnaryExpressionSyntax PreIncrementExpression(ExpressionSyntax operand)" />
          <member def="public static PrefixUnaryExpressionSyntax PreIncrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
          <member def="public static PredefinedTypeSyntax PredefinedBoolType()" />
          <member def="public static PredefinedTypeSyntax PredefinedByteType()" />
          <member def="public static PredefinedTypeSyntax PredefinedCharType()" />
          <member def="public static PredefinedTypeSyntax PredefinedDecimalType()" />
          <member def="public static PredefinedTypeSyntax PredefinedDoubleType()" />
          <member def="public static PredefinedTypeSyntax PredefinedFloatType()" />
          <member def="public static PredefinedTypeSyntax PredefinedIntType()" />
          <member def="public static PredefinedTypeSyntax PredefinedLongType()" />
          <member def="public static PredefinedTypeSyntax PredefinedObjectType()" />
          <member def="public static PredefinedTypeSyntax PredefinedSByteType()" />
          <member def="public static PredefinedTypeSyntax PredefinedShortType()" />
          <member def="public static PredefinedTypeSyntax PredefinedStringType()" />
          <member def="public static PredefinedTypeSyntax PredefinedUIntType()" />
          <member def="public static PredefinedTypeSyntax PredefinedULongType()" />
          <member def="public static PredefinedTypeSyntax PredefinedUShortType()" />
          <member def="public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, AccessorListSyntax accessorList, ExpressionSyntax value = null)" />
          <member def="public static AccessorDeclarationSyntax RemoveAccessorDeclaration(BlockSyntax body)" />
          <member def="public static AccessorDeclarationSyntax RemoveAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static AccessorDeclarationSyntax RemoveAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body)" />
          <member def="public static AccessorDeclarationSyntax RemoveAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static AssignmentExpressionSyntax RightShiftAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static AssignmentExpressionSyntax RightShiftAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static AccessorDeclarationSyntax SetAccessorDeclaration(BlockSyntax body)" />
          <member def="public static AccessorDeclarationSyntax SetAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static AccessorDeclarationSyntax SetAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body)" />
          <member def="public static AccessorDeclarationSyntax SetAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody)" />
          <member def="public static AssignmentExpressionSyntax SimpleAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static AssignmentExpressionSyntax SimpleAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static ExpressionStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static ExpressionStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, SimpleNameSyntax name)" />
          <member def="public static MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)" />
          <member def="public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name)" />
          <member def="public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name, ArgumentSyntax argument)" />
          <member def="public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name, ArgumentListSyntax argumentList)" />
          <member def="public static LiteralExpressionSyntax StringLiteralExpression(string value)" />
          <member def="public static ClassOrStructConstraintSyntax StructConstraint()" />
          <member def="public static StructDeclarationSyntax StructDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList&lt;MemberDeclarationSyntax&gt; members = default)" />
          <member def="public static StructDeclarationSyntax StructDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList&lt;MemberDeclarationSyntax&gt; members = default)" />
          <member def="public static AssignmentExpressionSyntax SubtractAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static AssignmentExpressionSyntax SubtractAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, ExpressionSyntax right)" />
          <member def="public static BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
          <member def="public static SwitchSectionSyntax SwitchSection(SwitchLabelSyntax switchLabel, StatementSyntax statement)" />
          <member def="public static SwitchSectionSyntax SwitchSection(SwitchLabelSyntax switchLabel, SyntaxList&lt;StatementSyntax&gt; statements)" />
          <member def="public static SwitchSectionSyntax SwitchSection(SyntaxList&lt;SwitchLabelSyntax&gt; switchLabels, StatementSyntax statement)" />
          <member def="public static ConstructorInitializerSyntax ThisConstructorInitializer(ArgumentListSyntax argumentList = null)" />
          <member def="public static ConstructorInitializerSyntax ThisConstructorInitializer(SyntaxToken semicolonToken, ArgumentListSyntax argumentList)" />
          <member def="public static SyntaxTokenList TokenList(Accessibility accessibility)" />
          <member def="public static SyntaxTokenList TokenList(SyntaxKind kind)" />
          <member def="public static SyntaxTokenList TokenList(SyntaxKind kind1, SyntaxKind kind2)" />
          <member def="public static SyntaxTokenList TokenList(SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)" />
          <member def="public static LiteralExpressionSyntax TrueLiteralExpression()" />
          <member def="public static TryStatementSyntax TryStatement(BlockSyntax block, CatchClauseSyntax @catch, FinallyClauseSyntax @finally = null)" />
          <member def="public static TypeArgumentListSyntax TypeArgumentList(TypeSyntax argument)" />
          <member def="public static TypeArgumentListSyntax TypeArgumentList(params TypeSyntax[] arguments)" />
          <member def="public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax identifierName, TypeParameterConstraintSyntax typeParameterConstraint)" />
          <member def="public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string name, TypeParameterConstraintSyntax typeParameterConstraint)" />
          <member def="public static TypeParameterListSyntax TypeParameterList(TypeParameterSyntax parameter)" />
          <member def="public static TypeParameterListSyntax TypeParameterList(params TypeParameterSyntax[] parameters)" />
          <member def="public static PrefixUnaryExpressionSyntax UnaryMinusExpression(ExpressionSyntax operand)" />
          <member def="public static PrefixUnaryExpressionSyntax UnaryMinusExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
          <member def="public static PrefixUnaryExpressionSyntax UnaryPlusExpression(ExpressionSyntax operand)" />
          <member def="public static PrefixUnaryExpressionSyntax UnaryPlusExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
          <member def="public static CheckedExpressionSyntax UncheckedExpression(ExpressionSyntax expression)" />
          <member def="public static CheckedExpressionSyntax UncheckedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)" />
          <member def="public static UsingDirectiveSyntax UsingStaticDirective(NameSyntax name)" />
          <member def="public static UsingDirectiveSyntax UsingStaticDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameSyntax name, SyntaxToken semicolonToken)" />
          <member def="public static IdentifierNameSyntax VarType()" />
          <member def="public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, VariableDeclaratorSyntax variable)" />
          <member def="public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer)" />
          <member def="public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, string identifier, ExpressionSyntax value = null)" />
          <member def="public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null)" />
          <member def="public static VariableDeclaratorSyntax VariableDeclarator(string identifier, EqualsValueClauseSyntax initializer)" />
          <member def="public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, EqualsValueClauseSyntax initializer)" />
          <member def="public static PredefinedTypeSyntax VoidType()" />
          <member def="public static YieldStatementSyntax YieldBreakStatement()" />
          <member def="public static YieldStatementSyntax YieldReturnStatement(ExpressionSyntax expression)" />
        </members>
      </type>
      <type def="public static class Roslynator.CSharp.CSharpFacts">
        <members>
          <member def="public static bool CanBeEmbeddedStatement(SyntaxKind kind)" />
          <member def="public static bool CanHaveEmbeddedStatement(SyntaxKind kind)" />
          <member def="public static bool CanHaveExpressionBody(SyntaxKind kind)" />
          <member def="public static bool CanHaveMembers(SyntaxKind kind)" />
          <member def="public static bool CanHaveModifiers(SyntaxKind kind)" />
          <member def="public static bool CanHaveStatements(SyntaxKind kind)" />
          <member def="public static bool IsAnonymousFunctionExpression(SyntaxKind kind)" />
          <member def="public static bool IsBooleanExpression(SyntaxKind kind)" />
          <member def="public static bool IsBooleanLiteralExpression(SyntaxKind kind)" />
          <member def="public static bool IsCommentTrivia(SyntaxKind kind)" />
          <member def="public static bool IsCompoundAssignmentExpression(SyntaxKind kind)" />
          <member def="public static bool IsConstraint(SyntaxKind kind)" />
          <member def="public static bool IsFunction(SyntaxKind kind)" />
          <member def="public static bool IsIfElseDirective(SyntaxKind kind)" />
          <member def="public static bool IsIncrementOrDecrementExpression(SyntaxKind kind)" />
          <member def="public static bool IsIterationStatement(SyntaxKind kind)" />
          <member def="public static bool IsJumpStatement(SyntaxKind kind)" />
          <member def="public static bool IsLambdaExpression(SyntaxKind kind)" />
          <member def="public static bool IsLiteralExpression(SyntaxKind kind)" />
          <member def="public static bool IsPredefinedType(SpecialType specialType)" />
          <member def="public static bool IsSimpleType(SpecialType specialType)" />
          <member def="public static bool IsSwitchLabel(SyntaxKind kind)" />
          <member def="public static bool SupportsPrefixOrPostfixUnaryOperator(SpecialType specialType)" />
        </members>
      </type>
      <type def="public static class Roslynator.CSharp.EnumExtensions">
        <members>
          <member def="public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2)" />
          <member def="public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)" />
          <member def="public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)" />
          <member def="public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)" />
          <member def="public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)" />
        </members>
      </type>
      <type def="public static class Roslynator.CSharp.ModifierList">
        <members>
          <member def="public static int GetInsertIndex(SyntaxTokenList tokens, SyntaxKind kind, IComparer&lt;SyntaxKind&gt; comparer = null)" />
          <member def="public static int GetInsertIndex(SyntaxTokenList tokens, SyntaxToken token, IComparer&lt;SyntaxToken&gt; comparer = null)" />
          <member def="public static SyntaxTokenList Insert(SyntaxTokenList modifiers, SyntaxKind kind, IComparer&lt;SyntaxKind&gt; comparer = null)" />
          <member def="public static SyntaxTokenList Insert(SyntaxTokenList modifiers, SyntaxToken modifier, IComparer&lt;SyntaxToken&gt; comparer = null)" />
          <member def="public static TNode Insert&lt;TNode&gt;(TNode node, SyntaxKind kind, IComparer&lt;SyntaxKind&gt; comparer = null) where TNode : SyntaxNode" />
          <member def="public static TNode Insert&lt;TNode&gt;(TNode node, SyntaxToken modifier, IComparer&lt;SyntaxToken&gt; comparer = null) where TNode : SyntaxNode" />
          <member def="public static TNode Remove&lt;TNode&gt;(TNode node, SyntaxKind kind) where TNode : SyntaxNode" />
          <member def="public static TNode Remove&lt;TNode&gt;(TNode node, SyntaxToken modifier) where TNode : SyntaxNode" />
          <member def="public static TNode RemoveAll&lt;TNode&gt;(TNode node) where TNode : SyntaxNode" />
          <member def="public static TNode RemoveAll&lt;TNode&gt;(TNode node, Func&lt;SyntaxToken, bool&gt; predicate) where TNode : SyntaxNode" />
          <member def="public static TNode RemoveAt&lt;TNode&gt;(TNode node, int index) where TNode : SyntaxNode" />
        </members>
      </type>
      <type def="public static class Roslynator.CSharp.Modifiers">
        <members>
          <member def="public static SyntaxTokenList Const()" />
          <member def="public static SyntaxTokenList Internal()" />
          <member def="public static SyntaxTokenList Internal_Abstract()" />
          <member def="public static SyntaxTokenList Internal_Const()" />
          <member def="public static SyntaxTokenList Internal_Override()" />
          <member def="public static SyntaxTokenList Internal_Partial()" />
          <member def="public static SyntaxTokenList Internal_ReadOnly()" />
          <member def="public static SyntaxTokenList Internal_Static()" />
          <member def="public static SyntaxTokenList Internal_Static_Partial()" />
          <member def="public static SyntaxTokenList Internal_Static_ReadOnly()" />
          <member def="public static SyntaxTokenList Internal_Virtual()" />
          <member def="public static SyntaxTokenList Partial()" />
          <member def="public static SyntaxTokenList Private()" />
          <member def="public static SyntaxTokenList Private_Const()" />
          <member def="public static SyntaxTokenList Private_Partial()" />
          <member def="public static SyntaxTokenList Private_Protected()" />
          <member def="public static SyntaxTokenList Private_ReadOnly()" />
          <member def="public static SyntaxTokenList Private_Static()" />
          <member def="public static SyntaxTokenList Private_Static_Partial()" />
          <member def="public static SyntaxTokenList Private_Static_ReadOnly()" />
          <member def="public static SyntaxTokenList Protected()" />
          <member def="public static SyntaxTokenList Protected_Abstract()" />
          <member def="public static SyntaxTokenList Protected_Const()" />
          <member def="public static SyntaxTokenList Protected_Internal()" />
          <member def="public static SyntaxTokenList Protected_Override()" />
          <member def="public static SyntaxTokenList Protected_ReadOnly()" />
          <member def="public static SyntaxTokenList Protected_Static()" />
          <member def="public static SyntaxTokenList Protected_Static_ReadOnly()" />
          <member def="public static SyntaxTokenList Protected_Virtual()" />
          <member def="public static SyntaxTokenList Public()" />
          <member def="public static SyntaxTokenList Public_Abstract()" />
          <member def="public static SyntaxTokenList Public_Const()" />
          <member def="public static SyntaxTokenList Public_Override()" />
          <member def="public static SyntaxTokenList Public_Partial()" />
          <member def="public static SyntaxTokenList Public_ReadOnly()" />
          <member def="public static SyntaxTokenList Public_Static()" />
          <member def="public static SyntaxTokenList Public_Static_Partial()" />
          <member def="public static SyntaxTokenList Public_Static_ReadOnly()" />
          <member def="public static SyntaxTokenList Public_Virtual()" />
          <member def="public static SyntaxTokenList ReadOnly()" />
          <member def="public static SyntaxTokenList Ref_ReadOnly()" />
          <member def="public static SyntaxTokenList Static()" />
          <member def="public static SyntaxTokenList Static_ReadOnly()" />
          <member def="public static SyntaxTokenList Virtual()" />
        </members>
      </type>
      <type def="public static class Roslynator.CSharp.SymbolExtensions">
        <members>
          <member def="public static bool SupportsConstantValue(this ITypeSymbol typeSymbol)" />
          <member def="public static TypeSyntax ToMinimalTypeSyntax(this INamespaceOrTypeSymbol namespaceOrTypeSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)" />
          <member def="public static TypeSyntax ToMinimalTypeSyntax(this INamespaceSymbol namespaceSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)" />
          <member def="public static TypeSyntax ToMinimalTypeSyntax(this ITypeSymbol typeSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)" />
          <member def="public static TypeSyntax ToTypeSyntax(this INamespaceOrTypeSymbol namespaceOrTypeSymbol, SymbolDisplayFormat format = null)" />
          <member def="public static TypeSyntax ToTypeSyntax(this INamespaceSymbol namespaceSymbol, SymbolDisplayFormat format = null)" />
          <member def="public static TypeSyntax ToTypeSyntax(this ITypeSymbol typeSymbol, SymbolDisplayFormat format = null)" />
        </members>
      </type>
      <type def="public static class Roslynator.CSharp.SyntaxAccessibility">
        <members>
          <member def="public static Accessibility GetAccessibility(SyntaxNode declaration)" />
          <member def="public static Accessibility GetDefaultAccessibility(SyntaxNode declaration)" />
          <member def="public static Accessibility GetDefaultExplicitAccessibility(SyntaxNode declaration)" />
          <member def="public static Accessibility GetExplicitAccessibility(SyntaxNode declaration)" />
          <member def="public static Accessibility GetExplicitAccessibility(SyntaxTokenList modifiers)" />
          <member def="public static bool IsPubliclyVisible(MemberDeclarationSyntax declaration)" />
          <member def="public static bool IsValidAccessibility(SyntaxNode node, Accessibility accessibility, bool ignoreOverride = false)" />
          <member def="public static TNode WithExplicitAccessibility&lt;TNode&gt;(TNode node, Accessibility newAccessibility, IComparer&lt;SyntaxKind&gt; comparer = null) where TNode : SyntaxNode" />
          <member def="public static TNode WithoutExplicitAccessibility&lt;TNode&gt;(TNode node) where TNode : SyntaxNode" />
        </members>
      </type>
      <type def="public static class Roslynator.CSharp.SyntaxExtensions">
        <members>
          <member def="public static SyntaxList&lt;StatementSyntax&gt; Add(this SyntaxList&lt;StatementSyntax&gt; statements, StatementSyntax statement, bool ignoreLocalFunctions)" />
          <member def="public static ClassDeclarationSyntax AddAttributeLists(this ClassDeclarationSyntax classDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax[] attributeLists)" />
          <member def="public static InterfaceDeclarationSyntax AddAttributeLists(this InterfaceDeclarationSyntax interfaceDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax[] attributeLists)" />
          <member def="public static StructDeclarationSyntax AddAttributeLists(this StructDeclarationSyntax structDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax[] attributeLists)" />
          <member def="public static CompilationUnitSyntax AddUsings(this CompilationUnitSyntax compilationUnit, bool keepSingleLineCommentsOnTop, params UsingDirectiveSyntax[] usings)" />
          <member def="public static IfStatementCascade AsCascade(this IfStatementSyntax ifStatement)" />
          <member def="public static ExpressionChain AsChain(this BinaryExpressionSyntax binaryExpression, TextSpan? span = null)" />
          <member def="public static CSharpSyntaxNode BodyOrExpressionBody(this AccessorDeclarationSyntax accessorDeclaration)" />
          <member def="public static CSharpSyntaxNode BodyOrExpressionBody(this ConstructorDeclarationSyntax constructorDeclaration)" />
          <member def="public static CSharpSyntaxNode BodyOrExpressionBody(this ConversionOperatorDeclarationSyntax conversionOperatorDeclaration)" />
          <member def="public static CSharpSyntaxNode BodyOrExpressionBody(this DestructorDeclarationSyntax destructorDeclaration)" />
          <member def="public static CSharpSyntaxNode BodyOrExpressionBody(this LocalFunctionStatementSyntax localFunctionStatement)" />
          <member def="public static CSharpSyntaxNode BodyOrExpressionBody(this MethodDeclarationSyntax methodDeclaration)" />
          <member def="public static CSharpSyntaxNode BodyOrExpressionBody(this OperatorDeclarationSyntax operatorDeclaration)" />
          <member def="public static TextSpan BracesSpan(this ClassDeclarationSyntax classDeclaration)" />
          <member def="public static TextSpan BracesSpan(this EnumDeclarationSyntax enumDeclaration)" />
          <member def="public static TextSpan BracesSpan(this InterfaceDeclarationSyntax interfaceDeclaration)" />
          <member def="public static TextSpan BracesSpan(this NamespaceDeclarationSyntax namespaceDeclaration)" />
          <member def="public static TextSpan BracesSpan(this StructDeclarationSyntax structDeclaration)" />
          <member def="public static bool Contains(this SyntaxTokenList tokenList, SyntaxKind kind)" />
          <member def="public static bool Contains(this SyntaxTriviaList triviaList, SyntaxKind kind)" />
          <member def="public static bool Contains&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode" />
          <member def="public static bool Contains&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode" />
          <member def="public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2)" />
          <member def="public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)" />
          <member def="public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)" />
          <member def="public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)" />
          <member def="public static bool ContainsDefaultLabel(this SwitchSectionSyntax switchSection)" />
          <member def="public static bool ContainsYield(this LocalFunctionStatementSyntax localFunctionStatement)" />
          <member def="public static bool ContainsYield(this MethodDeclarationSyntax methodDeclaration)" />
          <member def="public static CSharpSyntaxNode DeclarationOrExpression(this UsingStatementSyntax usingStatement)" />
          <member def="public static SwitchSectionSyntax DefaultSection(this SwitchStatementSyntax switchStatement)" />
          <member def="public static IEnumerable&lt;XmlElementSyntax&gt; Elements(this DocumentationCommentTriviaSyntax documentationComment, string localName)" />
          <member def="public static SyntaxToken Find(this SyntaxTokenList tokenList, SyntaxKind kind)" />
          <member def="public static SyntaxTrivia Find(this SyntaxTriviaList triviaList, SyntaxKind kind)" />
          <member def="public static TNode Find&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode" />
          <member def="public static TNode Find&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode" />
          <member def="public static SyntaxNode FirstAncestor(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true)" />
          <member def="public static SyntaxNode FirstAncestor(this SyntaxNode node, Func&lt;SyntaxNode, bool&gt; predicate, bool ascendOutOfTrivia = true)" />
          <member def="public static SyntaxNode FirstAncestor(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, bool ascendOutOfTrivia = true)" />
          <member def="public static SyntaxNode FirstAncestor(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, bool ascendOutOfTrivia = true)" />
          <member def="public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true)" />
          <member def="public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, Func&lt;SyntaxNode, bool&gt; predicate, bool ascendOutOfTrivia = true)" />
          <member def="public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, bool ascendOutOfTrivia = true)" />
          <member def="public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, bool ascendOutOfTrivia = true)" />
          <member def="public static IfStatementCascadeInfo GetCascadeInfo(this IfStatementSyntax ifStatement)" />
          <member def="public static DocumentationCommentTriviaSyntax GetDocumentationComment(this MemberDeclarationSyntax member)" />
          <member def="public static SyntaxTrivia GetDocumentationCommentTrivia(this MemberDeclarationSyntax member)" />
          <member def="public static EndRegionDirectiveTriviaSyntax GetEndRegionDirective(this RegionDirectiveTriviaSyntax regionDirective)" />
          <member def="public static DirectiveTriviaSyntax GetFirstDirective(this SyntaxNode node, TextSpan span, Func&lt;DirectiveTriviaSyntax, bool&gt; predicate = null)" />
          <member def="public static DirectiveTriviaSyntax GetNextRelatedDirective(this DirectiveTriviaSyntax directiveTrivia)" />
          <member def="public static SyntaxTrivia GetPreprocessingMessageTrivia(this EndRegionDirectiveTriviaSyntax endRegionDirective)" />
          <member def="public static SyntaxTrivia GetPreprocessingMessageTrivia(this RegionDirectiveTriviaSyntax regionDirective)" />
          <member def="public static RegionDirectiveTriviaSyntax GetRegionDirective(this EndRegionDirectiveTriviaSyntax endRegionDirective)" />
          <member def="public static DocumentationCommentTriviaSyntax GetSingleLineDocumentationComment(this MemberDeclarationSyntax member)" />
          <member def="public static SyntaxTrivia GetSingleLineDocumentationCommentTrivia(this MemberDeclarationSyntax member)" />
          <member def="public static IfStatementSyntax GetTopmostIf(this ElseClauseSyntax elseClause)" />
          <member def="public static IfStatementSyntax GetTopmostIf(this IfStatementSyntax ifStatement)" />
          <member def="public static AccessorDeclarationSyntax Getter(this AccessorListSyntax accessorList)" />
          <member def="public static AccessorDeclarationSyntax Getter(this IndexerDeclarationSyntax indexerDeclaration)" />
          <member def="public static AccessorDeclarationSyntax Getter(this PropertyDeclarationSyntax propertyDeclaration)" />
          <member def="public static bool HasDocumentationComment(this MemberDeclarationSyntax member)" />
          <member def="public static bool HasSingleLineDocumentationComment(this MemberDeclarationSyntax member)" />
          <member def="public static bool IsAutoImplemented(this AccessorDeclarationSyntax accessorDeclaration)" />
          <member def="public static bool IsDescendantOf(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true)" />
          <member def="public static bool IsEmbedded(this StatementSyntax statement, bool canBeBlock = false, bool canBeIfInsideElse = true, bool canBeUsingInsideUsing = true)" />
          <member def="public static bool IsEmptyOrWhitespace(this SyntaxTriviaList triviaList)" />
          <member def="public static bool IsEndOfLineTrivia(this SyntaxTrivia trivia)" />
          <member def="public static bool IsHexNumericLiteral(this LiteralExpressionSyntax literalExpression)" />
          <member def="public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2)" />
          <member def="public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2)" />
          <member def="public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2)" />
          <member def="public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)" />
          <member def="public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)" />
          <member def="public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)" />
          <member def="public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)" />
          <member def="public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)" />
          <member def="public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)" />
          <member def="public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)" />
          <member def="public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)" />
          <member def="public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)" />
          <member def="public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)" />
          <member def="public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)" />
          <member def="public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)" />
          <member def="public static bool IsLast(this SyntaxList&lt;StatementSyntax&gt; statements, StatementSyntax statement, bool ignoreLocalFunctions)" />
          <member def="public static bool IsParams(this ParameterSyntax parameter)" />
          <member def="public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind)" />
          <member def="public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind)" />
          <member def="public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2)" />
          <member def="public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2)" />
          <member def="public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)" />
          <member def="public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)" />
          <member def="public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)" />
          <member def="public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)" />
          <member def="public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)" />
          <member def="public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)" />
          <member def="public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)" />
          <member def="public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)" />
          <member def="public static bool IsSimpleIf(this IfStatementSyntax ifStatement)" />
          <member def="public static bool IsTopmostIf(this IfStatementSyntax ifStatement)" />
          <member def="public static bool IsVerbatim(this InterpolatedStringExpressionSyntax interpolatedString)" />
          <member def="public static bool IsVoid(this TypeSyntax type)" />
          <member def="public static bool IsWhitespaceOrEndOfLineTrivia(this SyntaxTrivia trivia)" />
          <member def="public static bool IsWhitespaceTrivia(this SyntaxTrivia trivia)" />
          <member def="public static bool IsYieldBreak(this YieldStatementSyntax yieldStatement)" />
          <member def="public static bool IsYieldReturn(this YieldStatementSyntax yieldStatement)" />
          <member def="public static int LastIndexOf(this SyntaxTriviaList triviaList, SyntaxKind kind)" />
          <member def="public static int LastIndexOf&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode" />
          <member def="public static int LastIndexOf&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode" />
          <member def="public static StatementSyntax NextStatement(this StatementSyntax statement)" />
          <member def="public static TextSpan ParenthesesSpan(this CastExpressionSyntax castExpression)" />
          <member def="public static TextSpan ParenthesesSpan(this CommonForEachStatementSyntax forEachStatement)" />
          <member def="public static TextSpan ParenthesesSpan(this ForStatementSyntax forStatement)" />
          <member def="public static StatementSyntax PreviousStatement(this StatementSyntax statement)" />
          <member def="public static SyntaxTokenList RemoveRange(this SyntaxTokenList list, int index, int count)" />
          <member def="public static SyntaxTriviaList RemoveRange(this SyntaxTriviaList list, int index, int count)" />
          <member def="public static SeparatedSyntaxList&lt;TNode&gt; RemoveRange&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, int index, int count) where TNode : SyntaxNode" />
          <member def="public static SyntaxList&lt;TNode&gt; RemoveRange&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, int index, int count) where TNode : SyntaxNode" />
          <member def="public static TNode RemoveTrivia&lt;TNode&gt;(this TNode node, TextSpan? span = null) where TNode : SyntaxNode" />
          <member def="public static TNode RemoveWhitespace&lt;TNode&gt;(this TNode node, TextSpan? span = null) where TNode : SyntaxNode" />
          <member def="public static SyntaxTokenList ReplaceRange(this SyntaxTokenList list, int index, int count, IEnumerable&lt;SyntaxToken&gt; newTokens)" />
          <member def="public static SyntaxTriviaList ReplaceRange(this SyntaxTriviaList list, int index, int count, IEnumerable&lt;SyntaxTrivia&gt; newTrivia)" />
          <member def="public static SeparatedSyntaxList&lt;TNode&gt; ReplaceRange&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, int index, int count, IEnumerable&lt;TNode&gt; newNodes) where TNode : SyntaxNode" />
          <member def="public static SyntaxList&lt;TNode&gt; ReplaceRange&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, int index, int count, IEnumerable&lt;TNode&gt; newNodes) where TNode : SyntaxNode" />
          <member def="public static TNode ReplaceWhitespace&lt;TNode&gt;(this TNode node, SyntaxTrivia replacement, TextSpan? span = null) where TNode : SyntaxNode" />
          <member def="public static bool ReturnsVoid(this DelegateDeclarationSyntax delegateDeclaration)" />
          <member def="public static bool ReturnsVoid(this LocalFunctionStatementSyntax localFunctionStatement)" />
          <member def="public static bool ReturnsVoid(this MethodDeclarationSyntax methodDeclaration)" />
          <member def="public static AccessorDeclarationSyntax Setter(this AccessorListSyntax accessorList)" />
          <member def="public static AccessorDeclarationSyntax Setter(this IndexerDeclarationSyntax indexerDeclaration)" />
          <member def="public static AccessorDeclarationSyntax Setter(this PropertyDeclarationSyntax propertyDeclaration)" />
          <member def="public static SeparatedSyntaxList&lt;TNode&gt; ToSeparatedSyntaxList&lt;TNode&gt;(this IEnumerable&lt;TNode&gt; nodes) where TNode : SyntaxNode" />
          <member def="public static SeparatedSyntaxList&lt;TNode&gt; ToSeparatedSyntaxList&lt;TNode&gt;(this IEnumerable&lt;SyntaxNodeOrToken&gt; nodesAndTokens) where TNode : SyntaxNode" />
          <member def="public static SyntaxList&lt;TNode&gt; ToSyntaxList&lt;TNode&gt;(this IEnumerable&lt;TNode&gt; nodes) where TNode : SyntaxNode" />
          <member def="public static SyntaxTokenList ToSyntaxTokenList(this IEnumerable&lt;SyntaxToken&gt; tokens)" />
          <member def="public static SyntaxToken TrimLeadingTrivia(this SyntaxToken token)" />
          <member def="public static TNode TrimLeadingTrivia&lt;TNode&gt;(this TNode node) where TNode : SyntaxNode" />
          <member def="public static SyntaxToken TrimTrailingTrivia(this SyntaxToken token)" />
          <member def="public static TNode TrimTrailingTrivia&lt;TNode&gt;(this TNode node) where TNode : SyntaxNode" />
          <member def="public static SyntaxToken TrimTrivia(this SyntaxToken token)" />
          <member def="public static TNode TrimTrivia&lt;TNode&gt;(this TNode node) where TNode : SyntaxNode" />
          <member def="public static bool TryGetContainingList(this StatementSyntax statement, out SyntaxList&lt;StatementSyntax&gt; statements)" />
          <member def="public static ExpressionSyntax WalkDownParentheses(this ExpressionSyntax expression)" />
          <member def="public static ExpressionSyntax WalkUpParentheses(this ExpressionSyntax expression)" />
          <member def="public static ClassDeclarationSyntax WithMembers(this ClassDeclarationSyntax classDeclaration, MemberDeclarationSyntax member)" />
          <member def="public static ClassDeclarationSyntax WithMembers(this ClassDeclarationSyntax classDeclaration, IEnumerable&lt;MemberDeclarationSyntax&gt; members)" />
          <member def="public static CompilationUnitSyntax WithMembers(this CompilationUnitSyntax compilationUnit, MemberDeclarationSyntax member)" />
          <member def="public static CompilationUnitSyntax WithMembers(this CompilationUnitSyntax compilationUnit, IEnumerable&lt;MemberDeclarationSyntax&gt; members)" />
          <member def="public static InterfaceDeclarationSyntax WithMembers(this InterfaceDeclarationSyntax interfaceDeclaration, MemberDeclarationSyntax member)" />
          <member def="public static InterfaceDeclarationSyntax WithMembers(this InterfaceDeclarationSyntax interfaceDeclaration, IEnumerable&lt;MemberDeclarationSyntax&gt; members)" />
          <member def="public static NamespaceDeclarationSyntax WithMembers(this NamespaceDeclarationSyntax namespaceDeclaration, MemberDeclarationSyntax member)" />
          <member def="public static NamespaceDeclarationSyntax WithMembers(this NamespaceDeclarationSyntax namespaceDeclaration, IEnumerable&lt;MemberDeclarationSyntax&gt; members)" />
          <member def="public static StructDeclarationSyntax WithMembers(this StructDeclarationSyntax structDeclaration, MemberDeclarationSyntax member)" />
          <member def="public static StructDeclarationSyntax WithMembers(this StructDeclarationSyntax structDeclaration, IEnumerable&lt;MemberDeclarationSyntax&gt; members)" />
        </members>
      </type>
      <type def="public static class Roslynator.CSharp.SyntaxInfo">
        <members>
          <member def="public static AsExpressionInfo AsExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static AsExpressionInfo AsExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static AssignmentExpressionInfo AssignmentExpressionInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static AssignmentExpressionInfo AssignmentExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static BinaryExpressionInfo BinaryExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static BinaryExpressionInfo BinaryExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static ConditionalExpressionInfo ConditionalExpressionInfo(ConditionalExpressionSyntax conditionalExpression, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static ConditionalExpressionInfo ConditionalExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static GenericInfo GenericInfo(TypeParameterConstraintClauseSyntax constraintClause)" />
          <member def="public static GenericInfo GenericInfo(DelegateDeclarationSyntax delegateDeclaration)" />
          <member def="public static GenericInfo GenericInfo(LocalFunctionStatementSyntax localFunctionStatement)" />
          <member def="public static GenericInfo GenericInfo(MethodDeclarationSyntax methodDeclaration)" />
          <member def="public static GenericInfo GenericInfo(SyntaxNode node)" />
          <member def="public static GenericInfo GenericInfo(TypeDeclarationSyntax typeDeclaration)" />
          <member def="public static GenericInfo GenericInfo(TypeParameterSyntax typeParameter)" />
          <member def="public static GenericInfo GenericInfo(TypeParameterConstraintSyntax typeParameterConstraint)" />
          <member def="public static GenericInfo GenericInfo(TypeParameterListSyntax typeParameterList)" />
          <member def="public static IsExpressionInfo IsExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static IsExpressionInfo IsExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static LocalDeclarationStatementInfo LocalDeclarationStatementInfo(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing = false)" />
          <member def="public static LocalDeclarationStatementInfo LocalDeclarationStatementInfo(ExpressionSyntax value, bool allowMissing = false)" />
          <member def="public static MemberDeclarationListInfo MemberDeclarationListInfo(CompilationUnitSyntax compilationUnit)" />
          <member def="public static MemberDeclarationListInfo MemberDeclarationListInfo(NamespaceDeclarationSyntax declaration)" />
          <member def="public static MemberDeclarationListInfo MemberDeclarationListInfo(TypeDeclarationSyntax declaration)" />
          <member def="public static MemberDeclarationListInfo MemberDeclarationListInfo(ClassDeclarationSyntax declaration)" />
          <member def="public static MemberDeclarationListInfo MemberDeclarationListInfo(StructDeclarationSyntax declaration)" />
          <member def="public static MemberDeclarationListInfo MemberDeclarationListInfo(InterfaceDeclarationSyntax declaration)" />
          <member def="public static MemberDeclarationListInfo MemberDeclarationListInfo(SyntaxNode node)" />
          <member def="public static ModifierListInfo ModifierListInfo(AccessorDeclarationSyntax accessorDeclaration)" />
          <member def="public static ModifierListInfo ModifierListInfo(ClassDeclarationSyntax classDeclaration)" />
          <member def="public static ModifierListInfo ModifierListInfo(ConstructorDeclarationSyntax constructorDeclaration)" />
          <member def="public static ModifierListInfo ModifierListInfo(ConversionOperatorDeclarationSyntax conversionOperatorDeclaration)" />
          <member def="public static ModifierListInfo ModifierListInfo(DelegateDeclarationSyntax delegateDeclaration)" />
          <member def="public static ModifierListInfo ModifierListInfo(DestructorDeclarationSyntax destructorDeclaration)" />
          <member def="public static ModifierListInfo ModifierListInfo(EnumDeclarationSyntax enumDeclaration)" />
          <member def="public static ModifierListInfo ModifierListInfo(EventDeclarationSyntax eventDeclaration)" />
          <member def="public static ModifierListInfo ModifierListInfo(EventFieldDeclarationSyntax eventFieldDeclaration)" />
          <member def="public static ModifierListInfo ModifierListInfo(FieldDeclarationSyntax fieldDeclaration)" />
          <member def="public static ModifierListInfo ModifierListInfo(IncompleteMemberSyntax incompleteMember)" />
          <member def="public static ModifierListInfo ModifierListInfo(IndexerDeclarationSyntax indexerDeclaration)" />
          <member def="public static ModifierListInfo ModifierListInfo(InterfaceDeclarationSyntax interfaceDeclaration)" />
          <member def="public static ModifierListInfo ModifierListInfo(LocalDeclarationStatementSyntax localDeclarationStatement)" />
          <member def="public static ModifierListInfo ModifierListInfo(LocalFunctionStatementSyntax localFunctionStatement)" />
          <member def="public static ModifierListInfo ModifierListInfo(MethodDeclarationSyntax methodDeclaration)" />
          <member def="public static ModifierListInfo ModifierListInfo(SyntaxNode node)" />
          <member def="public static ModifierListInfo ModifierListInfo(OperatorDeclarationSyntax operatorDeclaration)" />
          <member def="public static ModifierListInfo ModifierListInfo(ParameterSyntax parameter)" />
          <member def="public static ModifierListInfo ModifierListInfo(PropertyDeclarationSyntax propertyDeclaration)" />
          <member def="public static ModifierListInfo ModifierListInfo(StructDeclarationSyntax structDeclaration)" />
          <member def="public static NullCheckExpressionInfo NullCheckExpressionInfo(SyntaxNode node, NullCheckStyles allowedStyles = ComparisonToNull | IsPattern, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static NullCheckExpressionInfo NullCheckExpressionInfo(SyntaxNode node, SemanticModel semanticModel, NullCheckStyles allowedStyles = All, bool walkDownParentheses = true, bool allowMissing = false, CancellationToken cancellationToken = default)" />
          <member def="public static RegionInfo RegionInfo(EndRegionDirectiveTriviaSyntax endRegionDirective)" />
          <member def="public static RegionInfo RegionInfo(RegionDirectiveTriviaSyntax regionDirective)" />
          <member def="public static SimpleAssignmentExpressionInfo SimpleAssignmentExpressionInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static SimpleAssignmentExpressionInfo SimpleAssignmentExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(ExpressionStatementSyntax expressionStatement, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(StatementSyntax statement, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static SimpleIfElseInfo SimpleIfElseInfo(IfStatementSyntax ifStatement, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static SimpleIfStatementInfo SimpleIfStatementInfo(IfStatementSyntax ifStatement, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static SimpleIfStatementInfo SimpleIfStatementInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static SimpleMemberInvocationExpressionInfo SimpleMemberInvocationExpressionInfo(InvocationExpressionSyntax invocationExpression, bool allowMissing = false)" />
          <member def="public static SimpleMemberInvocationExpressionInfo SimpleMemberInvocationExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(ExpressionStatementSyntax expressionStatement, bool allowMissing = false)" />
          <member def="public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(InvocationExpressionSyntax invocationExpression, bool allowMissing = false)" />
          <member def="public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(SyntaxNode node, bool allowMissing = false)" />
          <member def="public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(ExpressionSyntax value)" />
          <member def="public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing = false)" />
          <member def="public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(VariableDeclarationSyntax variableDeclaration, bool allowMissing = false)" />
          <member def="public static SingleParameterLambdaExpressionInfo SingleParameterLambdaExpressionInfo(LambdaExpressionSyntax lambdaExpression, bool allowMissing = false)" />
          <member def="public static SingleParameterLambdaExpressionInfo SingleParameterLambdaExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)" />
          <member def="public static StatementListInfo StatementListInfo(StatementSyntax statement)" />
          <member def="public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(BinaryExpressionSyntax binaryExpression, SemanticModel semanticModel, CancellationToken cancellationToken = default)" />
          <member def="public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(in ExpressionChain expressionChain, SemanticModel semanticModel, CancellationToken cancellationToken = default)" />
          <member def="public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(SyntaxNode node, SemanticModel semanticModel, bool walkDownParentheses = true, CancellationToken cancellationToken = default)" />
          <member def="public static StringLiteralExpressionInfo StringLiteralExpressionInfo(LiteralExpressionSyntax literalExpression)" />
          <member def="public static StringLiteralExpressionInfo StringLiteralExpressionInfo(SyntaxNode node, bool walkDownParentheses = true)" />
          <member def="public static UsingDirectiveListInfo UsingDirectiveListInfo(CompilationUnitSyntax compilationUnit)" />
          <member def="public static UsingDirectiveListInfo UsingDirectiveListInfo(NamespaceDeclarationSyntax declaration)" />
          <member def="public static UsingDirectiveListInfo UsingDirectiveListInfo(SyntaxNode node)" />
          <member def="public static XmlElementInfo XmlElementInfo(XmlNodeSyntax xmlNode)" />
        </members>
      </type>
      <type def="public static class Roslynator.CSharp.SyntaxInverter">
        <members>
          <member def="public static ExpressionSyntax LogicallyInvert(ExpressionSyntax expression, CancellationToken cancellationToken = default)" />
          <member def="public static ExpressionSyntax LogicallyInvert(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Roslynator.CSharp.WorkspaceExtensions">
        <members>
          <member def="public static Task&lt;Document&gt; RemoveCommentsAsync(this Document document, CommentKinds kinds, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; RemoveCommentsAsync(this Document document, TextSpan span, CommentKinds kinds, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; RemovePreprocessorDirectivesAsync(this Document document, PreprocessorDirectiveKinds directiveKinds, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; RemovePreprocessorDirectivesAsync(this Document document, TextSpan span, PreprocessorDirectiveKinds directiveKinds, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; RemoveRegionAsync(this Document document, RegionInfo region, CancellationToken cancellationToken = default)" />
          <member def="public static Task&lt;Document&gt; RemoveTriviaAsync(this Document document, TextSpan span, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public static class Roslynator.CSharp.WorkspaceSyntaxExtensions">
        <members>
          <member def="public static ParenthesizedExpressionSyntax Parenthesize(this ExpressionSyntax expression, bool includeElasticTrivia = true, bool simplifiable = true)" />
          <member def="public static SyntaxToken WithFormatterAnnotation(this SyntaxToken token)" />
          <member def="public static TNode WithFormatterAnnotation&lt;TNode&gt;(this TNode node) where TNode : SyntaxNode" />
          <member def="public static SyntaxToken WithRenameAnnotation(this SyntaxToken token)" />
          <member def="public static SyntaxToken WithSimplifierAnnotation(this SyntaxToken token)" />
          <member def="public static TNode WithSimplifierAnnotation&lt;TNode&gt;(this TNode node) where TNode : SyntaxNode" />
        </members>
      </type>
    </type>
    <type def="">
      <type def="public interface Microsoft.CodeAnalysis.IAliasSymbol : IEquatable&lt;ISymbol&gt;, ISymbol">
        <members>
          <member def="INamespaceOrTypeSymbol Target { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader">
        <members>
          <member def="void AddDependencyLocation(string fullPath)" />
          <member def="Assembly LoadFromPath(string fullPath)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.IArrayTypeSymbol : IEquatable&lt;ISymbol&gt;, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol">
        <members>
          <member def="ImmutableArray&lt;CustomModifier&gt; CustomModifiers { get; }" />
          <member def="ITypeSymbol ElementType { get; }" />
          <member def="bool IsSZArray { get; }" />
          <member def="ImmutableArray&lt;int&gt; LowerBounds { get; }" />
          <member def="int Rank { get; }" />
          <member def="ImmutableArray&lt;int&gt; Sizes { get; }" />
          <member def="bool Equals(IArrayTypeSymbol other)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.IAssemblySymbol : IEquatable&lt;ISymbol&gt;, ISymbol">
        <members>
          <member def="INamespaceSymbol GlobalNamespace { get; }" />
          <member def="AssemblyIdentity Identity { get; }" />
          <member def="bool IsInteractive { get; }" />
          <member def="bool MightContainExtensionMethods { get; }" />
          <member def="IEnumerable&lt;IModuleSymbol&gt; Modules { get; }" />
          <member def="ICollection&lt;string&gt; NamespaceNames { get; }" />
          <member def="ICollection&lt;string&gt; TypeNames { get; }" />
          <member def="AssemblyMetadata GetMetadata()" />
          <member def="INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName)" />
          <member def="bool GivesAccessTo(IAssemblySymbol toAssembly)" />
          <member def="INamedTypeSymbol ResolveForwardedType(string fullyQualifiedMetadataName)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.ICompilationUnitSyntax">
        <members>
          <member def="SyntaxToken EndOfFileToken { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.IDiscardSymbol : IEquatable&lt;ISymbol&gt;, ISymbol">
        <members>
          <member def="ITypeSymbol Type { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.IDynamicTypeSymbol : IEquatable&lt;ISymbol&gt;, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol" />
      <type def="public interface Microsoft.CodeAnalysis.IErrorTypeSymbol : IEquatable&lt;ISymbol&gt;, INamedTypeSymbol, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol">
        <members>
          <member def="CandidateReason CandidateReason { get; }" />
          <member def="ImmutableArray&lt;ISymbol&gt; CandidateSymbols { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.IEventSymbol : IEquatable&lt;ISymbol&gt;, ISymbol">
        <members>
          <member def="IMethodSymbol AddMethod { get; }" />
          <member def="ImmutableArray&lt;IEventSymbol&gt; ExplicitInterfaceImplementations { get; }" />
          <member def="bool IsWindowsRuntimeEvent { get; }" />
          <member def="IEventSymbol OriginalDefinition { get; }" />
          <member def="IEventSymbol OverriddenEvent { get; }" />
          <member def="IMethodSymbol RaiseMethod { get; }" />
          <member def="IMethodSymbol RemoveMethod { get; }" />
          <member def="ITypeSymbol Type { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.IFieldSymbol : IEquatable&lt;ISymbol&gt;, ISymbol">
        <members>
          <member def="ISymbol AssociatedSymbol { get; }" />
          <member def="object ConstantValue { get; }" />
          <member def="IFieldSymbol CorrespondingTupleField { get; }" />
          <member def="ImmutableArray&lt;CustomModifier&gt; CustomModifiers { get; }" />
          <member def="bool HasConstantValue { get; }" />
          <member def="bool IsConst { get; }" />
          <member def="bool IsReadOnly { get; }" />
          <member def="bool IsVolatile { get; }" />
          <member def="IFieldSymbol OriginalDefinition { get; }" />
          <member def="ITypeSymbol Type { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.ILabelSymbol : IEquatable&lt;ISymbol&gt;, ISymbol">
        <members>
          <member def="IMethodSymbol ContainingMethod { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.ILocalSymbol : IEquatable&lt;ISymbol&gt;, ISymbol">
        <members>
          <member def="object ConstantValue { get; }" />
          <member def="bool HasConstantValue { get; }" />
          <member def="bool IsConst { get; }" />
          <member def="bool IsFunctionValue { get; }" />
          <member def="bool IsRef { get; }" />
          <member def="ITypeSymbol Type { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.IMethodSymbol : IEquatable&lt;ISymbol&gt;, ISymbol">
        <members>
          <member def="int Arity { get; }" />
          <member def="INamedTypeSymbol AssociatedAnonymousDelegate { get; }" />
          <member def="ISymbol AssociatedSymbol { get; }" />
          <member def="IMethodSymbol ConstructedFrom { get; }" />
          <member def="ImmutableArray&lt;IMethodSymbol&gt; ExplicitInterfaceImplementations { get; }" />
          <member def="bool HidesBaseMethodsByName { get; }" />
          <member def="bool IsAsync { get; }" />
          <member def="bool IsCheckedBuiltin { get; }" />
          <member def="bool IsExtensionMethod { get; }" />
          <member def="bool IsGenericMethod { get; }" />
          <member def="bool IsVararg { get; }" />
          <member def="MethodKind MethodKind { get; }" />
          <member def="IMethodSymbol OriginalDefinition { get; }" />
          <member def="IMethodSymbol OverriddenMethod { get; }" />
          <member def="ImmutableArray&lt;IParameterSymbol&gt; Parameters { get; }" />
          <member def="IMethodSymbol PartialDefinitionPart { get; }" />
          <member def="IMethodSymbol PartialImplementationPart { get; }" />
          <member def="ITypeSymbol ReceiverType { get; }" />
          <member def="IMethodSymbol ReducedFrom { get; }" />
          <member def="ImmutableArray&lt;CustomModifier&gt; RefCustomModifiers { get; }" />
          <member def="ITypeSymbol ReturnType { get; }" />
          <member def="ImmutableArray&lt;CustomModifier&gt; ReturnTypeCustomModifiers { get; }" />
          <member def="bool ReturnsByRef { get; }" />
          <member def="bool ReturnsVoid { get; }" />
          <member def="ImmutableArray&lt;ITypeSymbol&gt; TypeArguments { get; }" />
          <member def="ImmutableArray&lt;ITypeParameterSymbol&gt; TypeParameters { get; }" />
          <member def="IMethodSymbol Construct(params ITypeSymbol[] typeArguments)" />
          <member def="DllImportData GetDllImportData()" />
          <member def="ImmutableArray&lt;AttributeData&gt; GetReturnTypeAttributes()" />
          <member def="ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter)" />
          <member def="IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.IModuleSymbol : IEquatable&lt;ISymbol&gt;, ISymbol">
        <members>
          <member def="INamespaceSymbol GlobalNamespace { get; }" />
          <member def="ImmutableArray&lt;AssemblyIdentity&gt; ReferencedAssemblies { get; }" />
          <member def="ImmutableArray&lt;IAssemblySymbol&gt; ReferencedAssemblySymbols { get; }" />
          <member def="ModuleMetadata GetMetadata()" />
          <member def="INamespaceSymbol GetModuleNamespace(INamespaceSymbol namespaceSymbol)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.INamedTypeSymbol : IEquatable&lt;ISymbol&gt;, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol">
        <members>
          <member def="int Arity { get; }" />
          <member def="ISymbol AssociatedSymbol { get; }" />
          <member def="INamedTypeSymbol ConstructedFrom { get; }" />
          <member def="ImmutableArray&lt;IMethodSymbol&gt; Constructors { get; }" />
          <member def="IMethodSymbol DelegateInvokeMethod { get; }" />
          <member def="INamedTypeSymbol EnumUnderlyingType { get; }" />
          <member def="ImmutableArray&lt;IMethodSymbol&gt; InstanceConstructors { get; }" />
          <member def="bool IsComImport { get; }" />
          <member def="bool IsGenericType { get; }" />
          <member def="bool IsImplicitClass { get; }" />
          <member def="bool IsScriptClass { get; }" />
          <member def="bool IsUnboundGenericType { get; }" />
          <member def="IEnumerable&lt;string&gt; MemberNames { get; }" />
          <member def="bool MightContainExtensionMethods { get; }" />
          <member def="INamedTypeSymbol OriginalDefinition { get; }" />
          <member def="ImmutableArray&lt;IMethodSymbol&gt; StaticConstructors { get; }" />
          <member def="ImmutableArray&lt;IFieldSymbol&gt; TupleElements { get; }" />
          <member def="INamedTypeSymbol TupleUnderlyingType { get; }" />
          <member def="ImmutableArray&lt;ITypeSymbol&gt; TypeArguments { get; }" />
          <member def="ImmutableArray&lt;ITypeParameterSymbol&gt; TypeParameters { get; }" />
          <member def="INamedTypeSymbol Construct(params ITypeSymbol[] typeArguments)" />
          <member def="INamedTypeSymbol ConstructUnboundGenericType()" />
          <member def="ImmutableArray&lt;CustomModifier&gt; GetTypeArgumentCustomModifiers(int ordinal)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.INamespaceOrTypeSymbol : IEquatable&lt;ISymbol&gt;, ISymbol">
        <members>
          <member def="bool IsNamespace { get; }" />
          <member def="bool IsType { get; }" />
          <member def="ImmutableArray&lt;ISymbol&gt; GetMembers()" />
          <member def="ImmutableArray&lt;ISymbol&gt; GetMembers(string name)" />
          <member def="ImmutableArray&lt;INamedTypeSymbol&gt; GetTypeMembers()" />
          <member def="ImmutableArray&lt;INamedTypeSymbol&gt; GetTypeMembers(string name)" />
          <member def="ImmutableArray&lt;INamedTypeSymbol&gt; GetTypeMembers(string name, int arity)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.INamespaceSymbol : IEquatable&lt;ISymbol&gt;, INamespaceOrTypeSymbol, ISymbol">
        <members>
          <member def="ImmutableArray&lt;INamespaceSymbol&gt; ConstituentNamespaces { get; }" />
          <member def="Compilation ContainingCompilation { get; }" />
          <member def="bool IsGlobalNamespace { get; }" />
          <member def="NamespaceKind NamespaceKind { get; }" />
          <member def="IEnumerable&lt;INamespaceOrTypeSymbol&gt; GetMembers()" />
          <member def="IEnumerable&lt;INamespaceOrTypeSymbol&gt; GetMembers(string name)" />
          <member def="IEnumerable&lt;INamespaceSymbol&gt; GetNamespaceMembers()" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.IOperation">
        <members>
          <member def="Optional&lt;object&gt; ConstantValue { get; }" />
          <member def="bool IsInvalid { get; }" />
          <member def="OperationKind Kind { get; }" />
          <member def="SyntaxNode Syntax { get; }" />
          <member def="ITypeSymbol Type { get; }" />
          <member def="void Accept(OperationVisitor visitor)" />
          <member def="TResult Accept&lt;TArgument, TResult&gt;(OperationVisitor&lt;TArgument, TResult&gt; visitor, TArgument argument)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.IParameterSymbol : IEquatable&lt;ISymbol&gt;, ISymbol">
        <members>
          <member def="ImmutableArray&lt;CustomModifier&gt; CustomModifiers { get; }" />
          <member def="object ExplicitDefaultValue { get; }" />
          <member def="bool HasExplicitDefaultValue { get; }" />
          <member def="bool IsOptional { get; }" />
          <member def="bool IsParams { get; }" />
          <member def="bool IsThis { get; }" />
          <member def="int Ordinal { get; }" />
          <member def="IParameterSymbol OriginalDefinition { get; }" />
          <member def="ImmutableArray&lt;CustomModifier&gt; RefCustomModifiers { get; }" />
          <member def="RefKind RefKind { get; }" />
          <member def="ITypeSymbol Type { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.IPointerTypeSymbol : IEquatable&lt;ISymbol&gt;, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol">
        <members>
          <member def="ImmutableArray&lt;CustomModifier&gt; CustomModifiers { get; }" />
          <member def="ITypeSymbol PointedAtType { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.IPreprocessingSymbol : IEquatable&lt;ISymbol&gt;, ISymbol" />
      <type def="public interface Microsoft.CodeAnalysis.IPropertySymbol : IEquatable&lt;ISymbol&gt;, ISymbol">
        <members>
          <member def="ImmutableArray&lt;IPropertySymbol&gt; ExplicitInterfaceImplementations { get; }" />
          <member def="IMethodSymbol GetMethod { get; }" />
          <member def="bool IsIndexer { get; }" />
          <member def="bool IsReadOnly { get; }" />
          <member def="bool IsWithEvents { get; }" />
          <member def="bool IsWriteOnly { get; }" />
          <member def="IPropertySymbol OriginalDefinition { get; }" />
          <member def="IPropertySymbol OverriddenProperty { get; }" />
          <member def="ImmutableArray&lt;IParameterSymbol&gt; Parameters { get; }" />
          <member def="ImmutableArray&lt;CustomModifier&gt; RefCustomModifiers { get; }" />
          <member def="bool ReturnsByRef { get; }" />
          <member def="IMethodSymbol SetMethod { get; }" />
          <member def="ITypeSymbol Type { get; }" />
          <member def="ImmutableArray&lt;CustomModifier&gt; TypeCustomModifiers { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.IRangeVariableSymbol : IEquatable&lt;ISymbol&gt;, ISymbol" />
      <type def="public interface Microsoft.CodeAnalysis.ISkippedTokensTriviaSyntax">
        <members>
          <member def="SyntaxTokenList Tokens { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.ISourceAssemblySymbol : IEquatable&lt;ISymbol&gt;, IAssemblySymbol, ISymbol">
        <members>
          <member def="Compilation Compilation { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.IStructuredTriviaSyntax">
        <members>
          <member def="SyntaxTrivia ParentTrivia { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.ISymbol : IEquatable&lt;ISymbol&gt;">
        <members>
          <member def="bool CanBeReferencedByName { get; }" />
          <member def="IAssemblySymbol ContainingAssembly { get; }" />
          <member def="IModuleSymbol ContainingModule { get; }" />
          <member def="INamespaceSymbol ContainingNamespace { get; }" />
          <member def="ISymbol ContainingSymbol { get; }" />
          <member def="INamedTypeSymbol ContainingType { get; }" />
          <member def="Accessibility DeclaredAccessibility { get; }" />
          <member def="ImmutableArray&lt;SyntaxReference&gt; DeclaringSyntaxReferences { get; }" />
          <member def="bool HasUnsupportedMetadata { get; }" />
          <member def="bool IsAbstract { get; }" />
          <member def="bool IsDefinition { get; }" />
          <member def="bool IsExtern { get; }" />
          <member def="bool IsImplicitlyDeclared { get; }" />
          <member def="bool IsOverride { get; }" />
          <member def="bool IsSealed { get; }" />
          <member def="bool IsStatic { get; }" />
          <member def="bool IsVirtual { get; }" />
          <member def="SymbolKind Kind { get; }" />
          <member def="string Language { get; }" />
          <member def="ImmutableArray&lt;Location&gt; Locations { get; }" />
          <member def="string MetadataName { get; }" />
          <member def="string Name { get; }" />
          <member def="ISymbol OriginalDefinition { get; }" />
          <member def="void Accept(SymbolVisitor visitor)" />
          <member def="TResult Accept&lt;TResult&gt;(SymbolVisitor&lt;TResult&gt; visitor)" />
          <member def="ImmutableArray&lt;AttributeData&gt; GetAttributes()" />
          <member def="string GetDocumentationCommentId()" />
          <member def="string GetDocumentationCommentXml(CultureInfo preferredCulture = null, bool expandIncludes = false, CancellationToken cancellationToken = default)" />
          <member def="ImmutableArray&lt;SymbolDisplayPart&gt; ToDisplayParts(SymbolDisplayFormat format = null)" />
          <member def="string ToDisplayString(SymbolDisplayFormat format = null)" />
          <member def="ImmutableArray&lt;SymbolDisplayPart&gt; ToMinimalDisplayParts(SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)" />
          <member def="string ToMinimalDisplayString(SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.ITypeParameterSymbol : IEquatable&lt;ISymbol&gt;, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol">
        <members>
          <member def="ImmutableArray&lt;ITypeSymbol&gt; ConstraintTypes { get; }" />
          <member def="IMethodSymbol DeclaringMethod { get; }" />
          <member def="INamedTypeSymbol DeclaringType { get; }" />
          <member def="bool HasConstructorConstraint { get; }" />
          <member def="bool HasReferenceTypeConstraint { get; }" />
          <member def="bool HasValueTypeConstraint { get; }" />
          <member def="int Ordinal { get; }" />
          <member def="ITypeParameterSymbol OriginalDefinition { get; }" />
          <member def="ITypeParameterSymbol ReducedFrom { get; }" />
          <member def="TypeParameterKind TypeParameterKind { get; }" />
          <member def="VarianceKind Variance { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.ITypeSymbol : IEquatable&lt;ISymbol&gt;, INamespaceOrTypeSymbol, ISymbol">
        <members>
          <member def="ImmutableArray&lt;INamedTypeSymbol&gt; AllInterfaces { get; }" />
          <member def="INamedTypeSymbol BaseType { get; }" />
          <member def="ImmutableArray&lt;INamedTypeSymbol&gt; Interfaces { get; }" />
          <member def="bool IsAnonymousType { get; }" />
          <member def="bool IsReferenceType { get; }" />
          <member def="bool IsTupleType { get; }" />
          <member def="bool IsValueType { get; }" />
          <member def="ITypeSymbol OriginalDefinition { get; }" />
          <member def="SpecialType SpecialType { get; }" />
          <member def="TypeKind TypeKind { get; }" />
          <member def="ISymbol FindImplementationForInterfaceMember(ISymbol interfaceMember)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.FindSymbols.IFindReferencesProgress">
        <members>
          <member def="void OnCompleted()" />
          <member def="void OnDefinitionFound(ISymbol symbol)" />
          <member def="void OnFindInDocumentCompleted(Document document)" />
          <member def="void OnFindInDocumentStarted(Document document)" />
          <member def="void OnReferenceFound(ISymbol symbol, ReferenceLocation location)" />
          <member def="void OnStarted()" />
          <member def="void ReportProgress(int current, int maximum)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Host.IAnalyzerService : IWorkspaceService">
        <members>
          <member def="IAnalyzerAssemblyLoader GetLoader()" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Host.ILanguageService" />
      <type def="public interface Microsoft.CodeAnalysis.Host.IPersistentStorage : IDisposable">
        <members>
          <member def="Task&lt;Stream&gt; ReadStreamAsync(string name, CancellationToken cancellationToken = default)" />
          <member def="Task&lt;Stream&gt; ReadStreamAsync(Document document, string name, CancellationToken cancellationToken = default)" />
          <member def="Task&lt;Stream&gt; ReadStreamAsync(Project project, string name, CancellationToken cancellationToken = default)" />
          <member def="Task&lt;bool&gt; WriteStreamAsync(string name, Stream stream, CancellationToken cancellationToken = default)" />
          <member def="Task&lt;bool&gt; WriteStreamAsync(Document document, string name, Stream stream, CancellationToken cancellationToken = default)" />
          <member def="Task&lt;bool&gt; WriteStreamAsync(Project project, string name, Stream stream, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Host.IPersistentStorageService : IWorkspaceService">
        <members>
          <member def="IPersistentStorage GetStorage(Solution solution)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Host.ITemporaryStorageService : IWorkspaceService">
        <members>
          <member def="ITemporaryStreamStorage CreateTemporaryStreamStorage(CancellationToken cancellationToken = default)" />
          <member def="ITemporaryTextStorage CreateTemporaryTextStorage(CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Host.ITemporaryStreamStorage : IDisposable">
        <members>
          <member def="Stream ReadStream(CancellationToken cancellationToken = default)" />
          <member def="Task&lt;Stream&gt; ReadStreamAsync(CancellationToken cancellationToken = default)" />
          <member def="void WriteStream(Stream stream, CancellationToken cancellationToken = default)" />
          <member def="Task WriteStreamAsync(Stream stream, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Host.ITemporaryTextStorage : IDisposable">
        <members>
          <member def="SourceText ReadText(CancellationToken cancellationToken = default)" />
          <member def="Task&lt;SourceText&gt; ReadTextAsync(CancellationToken cancellationToken = default)" />
          <member def="void WriteText(SourceText text, CancellationToken cancellationToken = default)" />
          <member def="Task WriteTextAsync(SourceText text, CancellationToken cancellationToken = default)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Host.IWorkspaceService" />
      <type def="public interface Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory">
        <members>
          <member def="ILanguageService CreateLanguageService(HostLanguageServices languageServices)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory">
        <members>
          <member def="IWorkspaceService CreateService(HostWorkspaceServices workspaceServices)" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Options.IOption">
        <members>
          <member def="object DefaultValue { get; }" />
          <member def="string Feature { get; }" />
          <member def="bool IsPerLanguage { get; }" />
          <member def="string Name { get; }" />
          <member def="ImmutableArray&lt;OptionStorageLocation&gt; StorageLocations { get; }" />
          <member def="Type Type { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IAddressOfExpression : IOperation">
        <members>
          <member def="IOperation Reference { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IArgument : IOperation">
        <members>
          <member def="ArgumentKind ArgumentKind { get; }" />
          <member def="IOperation InConversion { get; }" />
          <member def="IOperation OutConversion { get; }" />
          <member def="IParameterSymbol Parameter { get; }" />
          <member def="IOperation Value { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IArrayCreationExpression : IOperation">
        <members>
          <member def="ImmutableArray&lt;IOperation&gt; DimensionSizes { get; }" />
          <member def="ITypeSymbol ElementType { get; }" />
          <member def="IArrayInitializer Initializer { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IArrayElementReferenceExpression : IOperation">
        <members>
          <member def="IOperation ArrayReference { get; }" />
          <member def="ImmutableArray&lt;IOperation&gt; Indices { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IArrayInitializer : IOperation">
        <members>
          <member def="ImmutableArray&lt;IOperation&gt; ElementValues { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IAssignmentExpression : IOperation">
        <members>
          <member def="IOperation Target { get; }" />
          <member def="IOperation Value { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IAwaitExpression : IOperation">
        <members>
          <member def="IOperation AwaitedValue { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IBinaryOperatorExpression : IOperation, IHasOperatorMethodExpression">
        <members>
          <member def="BinaryOperationKind BinaryOperationKind { get; }" />
          <member def="IOperation LeftOperand { get; }" />
          <member def="IOperation RightOperand { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IBlockStatement : IOperation">
        <members>
          <member def="ImmutableArray&lt;ILocalSymbol&gt; Locals { get; }" />
          <member def="ImmutableArray&lt;IOperation&gt; Statements { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IBranchStatement : IOperation">
        <members>
          <member def="BranchKind BranchKind { get; }" />
          <member def="ILabelSymbol Target { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ICaseClause : IOperation">
        <members>
          <member def="CaseKind CaseKind { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ICatchClause : IOperation">
        <members>
          <member def="ITypeSymbol CaughtType { get; }" />
          <member def="ILocalSymbol ExceptionLocal { get; }" />
          <member def="IOperation Filter { get; }" />
          <member def="IBlockStatement Handler { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ICompoundAssignmentExpression : IOperation, IAssignmentExpression, IHasOperatorMethodExpression">
        <members>
          <member def="BinaryOperationKind BinaryOperationKind { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IConditionalAccessExpression : IOperation">
        <members>
          <member def="IOperation ConditionalInstance { get; }" />
          <member def="IOperation ConditionalValue { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IConditionalAccessInstanceExpression : IOperation" />
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IConditionalChoiceExpression : IOperation">
        <members>
          <member def="IOperation Condition { get; }" />
          <member def="IOperation IfFalseValue { get; }" />
          <member def="IOperation IfTrueValue { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IConversionExpression : IOperation, IHasOperatorMethodExpression">
        <members>
          <member def="ConversionKind ConversionKind { get; }" />
          <member def="bool IsExplicit { get; }" />
          <member def="IOperation Operand { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IDefaultValueExpression : IOperation" />
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IEmptyStatement : IOperation" />
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IEndStatement : IOperation" />
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IEventAssignmentExpression : IOperation">
        <members>
          <member def="bool Adds { get; }" />
          <member def="IEventSymbol Event { get; }" />
          <member def="IOperation EventInstance { get; }" />
          <member def="IOperation HandlerValue { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IEventReferenceExpression : IOperation, IMemberReferenceExpression">
        <members>
          <member def="IEventSymbol Event { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IExpressionStatement : IOperation">
        <members>
          <member def="IOperation Expression { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IFieldInitializer : IOperation, ISymbolInitializer">
        <members>
          <member def="ImmutableArray&lt;IFieldSymbol&gt; InitializedFields { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IFieldReferenceExpression : IOperation, IMemberReferenceExpression">
        <members>
          <member def="IFieldSymbol Field { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IFixedStatement : IOperation">
        <members>
          <member def="IOperation Body { get; }" />
          <member def="IVariableDeclarationStatement Variables { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IForEachLoopStatement : IOperation, ILoopStatement">
        <members>
          <member def="IOperation Collection { get; }" />
          <member def="ILocalSymbol IterationVariable { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IForLoopStatement : IOperation, IForWhileUntilLoopStatement, ILoopStatement">
        <members>
          <member def="ImmutableArray&lt;IOperation&gt; AtLoopBottom { get; }" />
          <member def="ImmutableArray&lt;IOperation&gt; Before { get; }" />
          <member def="ImmutableArray&lt;ILocalSymbol&gt; Locals { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IForWhileUntilLoopStatement : IOperation, ILoopStatement">
        <members>
          <member def="IOperation Condition { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression : IOperation">
        <members>
          <member def="ImmutableArray&lt;IArgument&gt; ArgumentsInEvaluationOrder { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression : IOperation">
        <members>
          <member def="IMethodSymbol OperatorMethod { get; }" />
          <member def="bool UsesOperatorMethod { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IIfStatement : IOperation">
        <members>
          <member def="IOperation Condition { get; }" />
          <member def="IOperation IfFalseStatement { get; }" />
          <member def="IOperation IfTrueStatement { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IIncrementExpression : IOperation, IAssignmentExpression, ICompoundAssignmentExpression, IHasOperatorMethodExpression">
        <members>
          <member def="UnaryOperationKind IncrementOperationKind { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IIndexedPropertyReferenceExpression : IOperation, IHasArgumentsExpression, IMemberReferenceExpression, IPropertyReferenceExpression" />
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IInstanceReferenceExpression : IOperation">
        <members>
          <member def="InstanceReferenceKind InstanceReferenceKind { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IInvalidExpression : IOperation">
        <members>
          <member def="ImmutableArray&lt;IOperation&gt; Children { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IInvalidStatement : IOperation">
        <members>
          <member def="ImmutableArray&lt;IOperation&gt; Children { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IInvocationExpression : IOperation, IHasArgumentsExpression">
        <members>
          <member def="IOperation Instance { get; }" />
          <member def="bool IsVirtual { get; }" />
          <member def="IMethodSymbol TargetMethod { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IIsTypeExpression : IOperation">
        <members>
          <member def="ITypeSymbol IsType { get; }" />
          <member def="IOperation Operand { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ILabelStatement : IOperation">
        <members>
          <member def="ILabelSymbol Label { get; }" />
          <member def="IOperation LabeledStatement { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ILambdaExpression : IOperation">
        <members>
          <member def="IBlockStatement Body { get; }" />
          <member def="IMethodSymbol Signature { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ILateBoundMemberReferenceExpression : IOperation">
        <members>
          <member def="IOperation Instance { get; }" />
          <member def="string MemberName { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ILiteralExpression : IOperation">
        <members>
          <member def="string Text { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ILocalReferenceExpression : IOperation">
        <members>
          <member def="ILocalSymbol Local { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ILockStatement : IOperation">
        <members>
          <member def="IOperation Body { get; }" />
          <member def="IOperation LockedObject { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ILoopStatement : IOperation">
        <members>
          <member def="IOperation Body { get; }" />
          <member def="LoopKind LoopKind { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression : IOperation">
        <members>
          <member def="IOperation Instance { get; }" />
          <member def="ISymbol Member { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IMethodBindingExpression : IOperation, IMemberReferenceExpression">
        <members>
          <member def="bool IsVirtual { get; }" />
          <member def="IMethodSymbol Method { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.INullCoalescingExpression : IOperation">
        <members>
          <member def="IOperation PrimaryOperand { get; }" />
          <member def="IOperation SecondaryOperand { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IObjectCreationExpression : IOperation, IHasArgumentsExpression">
        <members>
          <member def="IMethodSymbol Constructor { get; }" />
          <member def="ImmutableArray&lt;IOperation&gt; Initializers { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IOmittedArgumentExpression : IOperation" />
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IParameterInitializer : IOperation, ISymbolInitializer">
        <members>
          <member def="IParameterSymbol Parameter { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IParameterReferenceExpression : IOperation">
        <members>
          <member def="IParameterSymbol Parameter { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IParenthesizedExpression : IOperation">
        <members>
          <member def="IOperation Operand { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IPlaceholderExpression : IOperation" />
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IPointerIndirectionReferenceExpression : IOperation">
        <members>
          <member def="IOperation Pointer { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IPropertyInitializer : IOperation, ISymbolInitializer">
        <members>
          <member def="IPropertySymbol InitializedProperty { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IPropertyReferenceExpression : IOperation, IMemberReferenceExpression">
        <members>
          <member def="IPropertySymbol Property { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IRangeCaseClause : IOperation, ICaseClause">
        <members>
          <member def="IOperation MaximumValue { get; }" />
          <member def="IOperation MinimumValue { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IRelationalCaseClause : IOperation, ICaseClause">
        <members>
          <member def="BinaryOperationKind Relation { get; }" />
          <member def="IOperation Value { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IReturnStatement : IOperation">
        <members>
          <member def="IOperation ReturnedValue { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ISingleValueCaseClause : IOperation, ICaseClause">
        <members>
          <member def="BinaryOperationKind Equality { get; }" />
          <member def="IOperation Value { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ISizeOfExpression : IOperation, ITypeOperationExpression" />
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IStopStatement : IOperation" />
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ISwitchCase : IOperation">
        <members>
          <member def="ImmutableArray&lt;IOperation&gt; Body { get; }" />
          <member def="ImmutableArray&lt;ICaseClause&gt; Clauses { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ISwitchStatement : IOperation">
        <members>
          <member def="ImmutableArray&lt;ISwitchCase&gt; Cases { get; }" />
          <member def="IOperation Value { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ISymbolInitializer : IOperation">
        <members>
          <member def="IOperation Value { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ISyntheticLocalReferenceExpression : IOperation">
        <members>
          <member def="IOperation ContainingStatement { get; }" />
          <member def="SyntheticLocalKind SyntheticLocalKind { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IThrowStatement : IOperation">
        <members>
          <member def="IOperation ThrownObject { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ITryStatement : IOperation">
        <members>
          <member def="IBlockStatement Body { get; }" />
          <member def="ImmutableArray&lt;ICatchClause&gt; Catches { get; }" />
          <member def="IBlockStatement FinallyHandler { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ITypeOfExpression : IOperation, ITypeOperationExpression" />
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ITypeOperationExpression : IOperation">
        <members>
          <member def="ITypeSymbol TypeOperand { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.ITypeParameterObjectCreationExpression : IOperation" />
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IUnaryOperatorExpression : IOperation, IHasOperatorMethodExpression">
        <members>
          <member def="IOperation Operand { get; }" />
          <member def="UnaryOperationKind UnaryOperationKind { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IUnboundLambdaExpression : IOperation" />
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IUsingStatement : IOperation">
        <members>
          <member def="IOperation Body { get; }" />
          <member def="IVariableDeclarationStatement Declaration { get; }" />
          <member def="IOperation Value { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IVariableDeclaration : IOperation">
        <members>
          <member def="IOperation Initializer { get; }" />
          <member def="ImmutableArray&lt;ILocalSymbol&gt; Variables { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IVariableDeclarationStatement : IOperation">
        <members>
          <member def="ImmutableArray&lt;IVariableDeclaration&gt; Declarations { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IWhileUntilLoopStatement : IOperation, IForWhileUntilLoopStatement, ILoopStatement">
        <members>
          <member def="bool IsTopTest { get; }" />
          <member def="bool IsWhile { get; }" />
        </members>
      </type>
      <type def="public interface Microsoft.CodeAnalysis.Semantics.IWithStatement : IOperation">
        <members>
          <member def="IOperation Body { get; }" />
          <member def="IOperation Value { get; }" />
        </members>
      </type>
      <type def="public interface Roslynator.ISelection&lt;T&gt; : IReadOnlyList&lt;T&gt;">
        <members>
          <member def="int FirstIndex { get; }" />
          <member def="int LastIndex { get; }" />
          <member def="T First()" />
          <member def="T Last()" />
        </members>
      </type>
    </type>
  </types>
</root>