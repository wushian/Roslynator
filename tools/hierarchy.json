{
  "assemblies": [
    {
      "assembly": "Microsoft.CodeAnalysis, Version=2.3.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
      "attributes": [
        "AssemblyCompany(\"Microsoft Corporation\")",
        "AssemblyCopyright(\"© Microsoft Corporation. All rights reserved.\")",
        "AssemblyFileVersion(\"2.3.0.61908\")",
        "AssemblyInformationalVersion(\"2.3.0-beta4-61908-01. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c\")",
        "AssemblyMetadata(\"Serviceable\", \"True\")",
        "RuntimeCompatibility(WrapNonExceptionThrows = true)",
        "TargetFramework(\".NETStandard,Version=v1.3\", FrameworkDisplayName = \"\")"
      ]
    },
    {
      "assembly": "Microsoft.CodeAnalysis.CSharp, Version=2.3.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
      "attributes": [
        "AssemblyCompany(\"Microsoft Corporation\")",
        "AssemblyCopyright(\"© Microsoft Corporation. All rights reserved.\")",
        "AssemblyFileVersion(\"2.3.0.61908\")",
        "AssemblyInformationalVersion(\"2.3.0-beta4-61908-01. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c\")",
        "AssemblyMetadata(\"Serviceable\", \"True\")",
        "CommitHash(\"281ac90b8b5dd9fd923a353afd4af74f3246ca5c\")",
        "RuntimeCompatibility(WrapNonExceptionThrows = true)",
        "TargetFramework(\".NETStandard,Version=v1.3\", FrameworkDisplayName = \"\")"
      ]
    },
    {
      "assembly": "Microsoft.CodeAnalysis.CSharp.Workspaces, Version=2.3.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
      "attributes": [
        "AssemblyCompany(\"Microsoft Corporation\")",
        "AssemblyCopyright(\"© Microsoft Corporation. All rights reserved.\")",
        "AssemblyFileVersion(\"2.3.0.61908\")",
        "AssemblyInformationalVersion(\"2.3.0-beta4-61908-01. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c\")",
        "AssemblyMetadata(\"Serviceable\", \"True\")",
        "RuntimeCompatibility(WrapNonExceptionThrows = true)",
        "TargetFramework(\".NETStandard,Version=v1.3\", FrameworkDisplayName = \"\")"
      ]
    },
    {
      "assembly": "Microsoft.CodeAnalysis.Workspaces, Version=2.3.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
      "attributes": [
        "AssemblyCompany(\"Microsoft Corporation\")",
        "AssemblyCopyright(\"© Microsoft Corporation. All rights reserved.\")",
        "AssemblyFileVersion(\"2.3.0.61908\")",
        "AssemblyInformationalVersion(\"2.3.0-beta4-61908-01. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c\")",
        "AssemblyMetadata(\"Serviceable\", \"True\")",
        "RuntimeCompatibility(WrapNonExceptionThrows = true)",
        "TargetFramework(\".NETStandard,Version=v1.3\", FrameworkDisplayName = \"\")"
      ]
    },
    {
      "assembly": "Roslynator.Core, Version=1.0.0.10, Culture=neutral, PublicKeyToken=3aeedfaf14b2cebf",
      "attributes": [
        "AssemblyCompany(\"Josef Pihrt\")",
        "AssemblyConfiguration(\"Debug\")",
        "AssemblyCopyright(\"Copyright (c) 2017-2018 Josef Pihrt\")",
        "AssemblyDescription(\"This library extends functionality of package Microsoft.CodeAnalysis.Common.\")",
        "AssemblyFileVersion(\"1.0.0.10\")",
        "AssemblyInformationalVersion(\"1.0.0.10\")",
        "AssemblyProduct(\"Roslynator.Core\")",
        "AssemblyTitle(\"Roslynator.Core\")",
        "AssemblyVersion(\"1.0.0.10\")",
        "TargetFramework(\".NETStandard,Version=v1.3\", FrameworkDisplayName = \"\")"
      ]
    },
    {
      "assembly": "Roslynator.CSharp, Version=1.0.0.10, Culture=neutral, PublicKeyToken=390be46f77b79f52",
      "attributes": [
        "AssemblyCompany(\"Josef Pihrt\")",
        "AssemblyConfiguration(\"Debug\")",
        "AssemblyCopyright(\"Copyright (c) 2017-2018 Josef Pihrt\")",
        "AssemblyDescription(\"This library extends functionality of package Microsoft.CodeAnalysis.CSharp\\n\\nCommonly Used Types:\\nRoslynator.CSharp.CSharpFactory\\nRoslynator.CSharp.CSharpFacts\\nRoslynator.CSharp.SyntaxInfo\\nRoslynator.NameGenerator\")",
        "AssemblyFileVersion(\"1.0.0.10\")",
        "AssemblyInformationalVersion(\"1.0.0.10\")",
        "AssemblyProduct(\"Roslynator.CSharp\")",
        "AssemblyTitle(\"Roslynator.CSharp\")",
        "AssemblyVersion(\"1.0.0.10\")",
        "TargetFramework(\".NETStandard,Version=v1.3\", FrameworkDisplayName = \"\")"
      ]
    },
    {
      "assembly": "Roslynator.CSharp.Workspaces, Version=1.0.0.10, Culture=neutral, PublicKeyToken=ec3f0c29a7973f23",
      "attributes": [
        "AssemblyCompany(\"Josef Pihrt\")",
        "AssemblyConfiguration(\"Debug\")",
        "AssemblyCopyright(\"Copyright (c) 2017-2018 Josef Pihrt\")",
        "AssemblyDescription(\"This library extends functionality of package Microsoft.CodeAnalysis.CSharp.Workspaces\\n\\nCommonly Used Types:\\nRoslynator.CSharp.CSharpFactory\\nRoslynator.CSharp.CSharpFacts\\nRoslynator.CSharp.SyntaxInfo\\nRoslynator.NameGenerator\")",
        "AssemblyFileVersion(\"1.0.0.10\")",
        "AssemblyInformationalVersion(\"1.0.0.10\")",
        "AssemblyProduct(\"Roslynator.CSharp.Workspaces\")",
        "AssemblyTitle(\"Roslynator.CSharp.Workspaces\")",
        "AssemblyVersion(\"1.0.0.10\")",
        "TargetFramework(\".NETStandard,Version=v1.3\", FrameworkDisplayName = \"\")"
      ]
    },
    {
      "assembly": "Roslynator.Workspaces.Core, Version=1.0.0.10, Culture=neutral, PublicKeyToken=be1ec334fe31b7bb",
      "attributes": [
        "AssemblyCompany(\"Josef Pihrt\")",
        "AssemblyConfiguration(\"Debug\")",
        "AssemblyCopyright(\"Copyright (c) 2017-2018 Josef Pihrt\")",
        "AssemblyDescription(\"This library extends functionality of package Microsoft.CodeAnalysis.Workspaces.Common.\")",
        "AssemblyFileVersion(\"1.0.0.10\")",
        "AssemblyInformationalVersion(\"1.0.0.10\")",
        "AssemblyProduct(\"Roslynator.Workspaces.Core\")",
        "AssemblyTitle(\"Roslynator.Workspaces.Core\")",
        "AssemblyVersion(\"1.0.0.10\")",
        "TargetFramework(\".NETStandard,Version=v1.3\", FrameworkDisplayName = \"\")"
      ]
    }
  ],
  "types": [
    {
      "type": "public class System.Object",
      "types": [
        {
          "type": "public abstract class System.Attribute",
          "types": [
            {
              "type": "public class System.Composition.ExportAttribute : Attribute",
              "types": [
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute : ExportAttribute",
                  "members": [
                    "public ExportCodeFixProviderAttribute(string firstLanguage, params string[] additionalLanguages)",
                    "public string[] Languages { get; }",
                    "public string Name { get; set; }"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute : ExportAttribute",
                  "members": [
                    "public ExportCodeRefactoringProviderAttribute(string firstLanguage, params string[] additionalLanguages)",
                    "public string[] Languages { get; }",
                    "public string Name { get; set; }"
                  ]
                },
                {
                  "type": "public class Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute : ExportAttribute",
                  "members": [
                    "public ExportLanguageServiceAttribute(Type type, string language, string layer = \"Default\")",
                    "public string Language { get; }",
                    "public string Layer { get; }",
                    "public string ServiceType { get; }"
                  ]
                },
                {
                  "type": "public class Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute : ExportAttribute",
                  "members": [
                    "public ExportLanguageServiceFactoryAttribute(Type type, string language, string layer = \"Default\")",
                    "public string Language { get; }",
                    "public string Layer { get; }",
                    "public string ServiceType { get; }"
                  ]
                },
                {
                  "type": "public class Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute : ExportAttribute",
                  "members": [
                    "public ExportWorkspaceServiceAttribute(Type serviceType, string layer = \"Default\")",
                    "public string Layer { get; }",
                    "public string ServiceType { get; }"
                  ]
                },
                {
                  "type": "public class Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute : ExportAttribute",
                  "members": [
                    "public ExportWorkspaceServiceFactoryAttribute(Type serviceType, string layer = \"Default\")",
                    "public string Layer { get; }",
                    "public string ServiceType { get; }"
                  ]
                }
              ]
            },
            {
              "type": "public sealed class Microsoft.CodeAnalysis.ExtensionOrderAttribute : Attribute",
              "members": [
                "public ExtensionOrderAttribute()",
                "public string After { get; set; }",
                "public string Before { get; set; }"
              ]
            },
            {
              "type": "public sealed class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerAttribute : Attribute",
              "members": [
                "public DiagnosticAnalyzerAttribute(string firstLanguage, params string[] additionalLanguages)",
                "public string[] Languages { get; }"
              ]
            }
          ]
        },
        {
          "type": "public abstract class System.Delegate",
          "types": [
            {
              "type": "public abstract class System.MulticastDelegate : Delegate",
              "types": [
                "public delegate Task Microsoft.CodeAnalysis.Editing.SymbolEditor.AsyncDeclarationEditAction(DocumentEditor editor, SyntaxNode declaration, CancellationToken cancellationToken)",
                "public delegate void Microsoft.CodeAnalysis.Editing.SymbolEditor.DeclarationEditAction(DocumentEditor editor, SyntaxNode declaration)",
                "public delegate bool Microsoft.CodeAnalysis.Host.HostWorkspaceServices.MetadataFilter(IReadOnlyDictionary<string, object> metadata)"
              ]
            }
          ]
        },
        {
          "type": "public class System.EventArgs",
          "types": [
            {
              "type": "public sealed class Microsoft.CodeAnalysis.DocumentActiveContextChangedEventArgs : EventArgs",
              "members": [
                "public DocumentActiveContextChangedEventArgs(Solution solution, SourceTextContainer sourceTextContainer, DocumentId oldActiveContextDocumentId, DocumentId newActiveContextDocumentId)",
                "public DocumentId NewActiveContextDocumentId { get; }",
                "public DocumentId OldActiveContextDocumentId { get; }",
                "public Solution Solution { get; }",
                "public SourceTextContainer SourceTextContainer { get; }"
              ]
            },
            {
              "type": "public class Microsoft.CodeAnalysis.DocumentEventArgs : EventArgs",
              "members": [
                "public DocumentEventArgs(Document document)",
                "public Document Document { get; }"
              ]
            },
            {
              "type": "public class Microsoft.CodeAnalysis.WorkspaceChangeEventArgs : EventArgs",
              "members": [
                "public WorkspaceChangeEventArgs(WorkspaceChangeKind kind, Solution oldSolution, Solution newSolution, ProjectId projectId = null, DocumentId documentId = null)",
                "public DocumentId DocumentId { get; }",
                "public WorkspaceChangeKind Kind { get; }",
                "public Solution NewSolution { get; }",
                "public Solution OldSolution { get; }",
                "public ProjectId ProjectId { get; }"
              ]
            },
            {
              "type": "public class Microsoft.CodeAnalysis.WorkspaceDiagnosticEventArgs : EventArgs",
              "members": [
                "public WorkspaceDiagnosticEventArgs(WorkspaceDiagnostic diagnostic)",
                "public WorkspaceDiagnostic Diagnostic { get; }"
              ]
            },
            {
              "type": "public sealed class Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs : EventArgs",
              "members": [
                "public AnalyzerLoadFailureEventArgs(AnalyzerLoadFailureEventArgs.FailureErrorCode errorCode, string message, Exception exceptionOpt = null, string typeNameOpt = null)",
                "public AnalyzerLoadFailureEventArgs.FailureErrorCode ErrorCode { get; }",
                "public Exception Exception { get; }",
                "public string Message { get; }",
                "public string TypeName { get; }"
              ]
            },
            {
              "type": "public class Microsoft.CodeAnalysis.Text.TextChangeEventArgs : EventArgs",
              "members": [
                "public TextChangeEventArgs(SourceText oldText, SourceText newText, IEnumerable<TextChangeRange> changes)",
                "public TextChangeEventArgs(SourceText oldText, SourceText newText, params TextChangeRange[] changes)",
                "public IReadOnlyList<TextChangeRange> Changes { get; }",
                "public SourceText NewText { get; }",
                "public SourceText OldText { get; }"
              ]
            }
          ]
        },
        {
          "type": "public abstract class System.ValueType",
          "types": [
            {
              "type": "public abstract class System.Enum : ValueType, IComparable, IConvertible, IFormattable",
              "types": [
                {
                  "type": "public enum Microsoft.CodeAnalysis.Accessibility",
                  "members": [
                    "NotApplicable = 0",
                    "Private = 1",
                    "ProtectedAndInternal = 2",
                    "ProtectedAndFriend = 2",
                    "Protected = 3",
                    "Internal = 4",
                    "Friend = 4",
                    "ProtectedOrInternal = 5",
                    "ProtectedOrFriend = 5",
                    "Public = 6"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.ApplyChangesKind",
                  "members": [
                    "AddProject = 0",
                    "RemoveProject = 1",
                    "AddProjectReference = 2",
                    "RemoveProjectReference = 3",
                    "AddMetadataReference = 4",
                    "RemoveMetadataReference = 5",
                    "AddDocument = 6",
                    "RemoveDocument = 7",
                    "ChangeDocument = 8",
                    "AddAnalyzerReference = 9",
                    "RemoveAnalyzerReference = 10",
                    "AddAdditionalDocument = 11",
                    "RemoveAdditionalDocument = 12",
                    "ChangeAdditionalDocument = 13",
                    "ChangeCompilationOptions = 14",
                    "ChangeParseOptions = 15",
                    "ChangeDocumentInfo = 16"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.AssemblyIdentityComparer.ComparisonResult",
                  "members": [
                    "NotEquivalent = 0",
                    "Equivalent = 1",
                    "EquivalentIgnoringVersion = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.AssemblyIdentityParts",
                  "members": [
                    "Name = 1",
                    "Version = VersionMajor | VersionMinor | VersionBuild | VersionRevision",
                    "VersionMajor = 2",
                    "VersionMinor = 4",
                    "VersionBuild = 8",
                    "VersionRevision = 16",
                    "Culture = 32",
                    "PublicKey = 64",
                    "PublicKeyToken = 128",
                    "PublicKeyOrToken = PublicKey | PublicKeyToken",
                    "Retargetability = 256",
                    "ContentType = 512",
                    "Unknown = 1024"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.CandidateReason",
                  "members": [
                    "None = 0",
                    "NotATypeOrNamespace = 1",
                    "NotAnEvent = 2",
                    "NotAWithEventsMember = 3",
                    "NotAnAttributeType = 4",
                    "WrongArity = 5",
                    "NotCreatable = 6",
                    "NotReferencable = 7",
                    "Inaccessible = 8",
                    "NotAValue = 9",
                    "NotAVariable = 10",
                    "NotInvocable = 11",
                    "StaticInstanceMismatch = 12",
                    "OverloadResolutionFailure = 13",
                    "LateBound = 14",
                    "Ambiguous = 15",
                    "MemberGroup = 16"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.DiagnosticSeverity",
                  "members": [
                    "Hidden = 0",
                    "Info = 1",
                    "Warning = 2",
                    "Error = 3"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.DocumentationMode",
                  "members": [
                    "None = 0",
                    "Parse = 1",
                    "Diagnose = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.LineVisibility",
                  "members": [
                    "BeforeFirstLineDirective = 0",
                    "Hidden = 1",
                    "Visible = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.LocationKind",
                  "members": [
                    "None = 0",
                    "SourceFile = 1",
                    "MetadataFile = 2",
                    "XmlFile = 3",
                    "ExternalFile = 4"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.MetadataImageKind",
                  "members": [
                    "Assembly = 0",
                    "Module = 1"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.MethodKind",
                  "members": [
                    "AnonymousFunction = 0",
                    "LambdaMethod = 0",
                    "Constructor = 1",
                    "Conversion = 2",
                    "DelegateInvoke = 3",
                    "Destructor = 4",
                    "EventAdd = 5",
                    "EventRaise = 6",
                    "EventRemove = 7",
                    "ExplicitInterfaceImplementation = 8",
                    "UserDefinedOperator = 9",
                    "Ordinary = 10",
                    "PropertyGet = 11",
                    "PropertySet = 12",
                    "ReducedExtension = 13",
                    "StaticConstructor = 14",
                    "SharedConstructor = 14",
                    "BuiltinOperator = 15",
                    "DeclareMethod = 16",
                    "LocalFunction = 17"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.NamespaceKind",
                  "members": [
                    "Module = 1",
                    "Assembly = 2",
                    "Compilation = 3"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.OperationKind",
                  "members": [
                    "None = 0",
                    "InvalidStatement = 1",
                    "BlockStatement = 2",
                    "VariableDeclarationStatement = 3",
                    "SwitchStatement = 4",
                    "IfStatement = 5",
                    "LoopStatement = 6",
                    "LabelStatement = 7",
                    "BranchStatement = 8",
                    "EmptyStatement = 9",
                    "ThrowStatement = 10",
                    "ReturnStatement = 11",
                    "YieldBreakStatement = 12",
                    "LockStatement = 13",
                    "TryStatement = 14",
                    "UsingStatement = 15",
                    "YieldReturnStatement = 16",
                    "ExpressionStatement = 17",
                    "FixedStatement = 48",
                    "LocalFunctionStatement = 49",
                    "StopStatement = 80",
                    "EndStatement = 81",
                    "WithStatement = 82",
                    "InvalidExpression = 256",
                    "LiteralExpression = 257",
                    "ConversionExpression = 258",
                    "InvocationExpression = 259",
                    "ArrayElementReferenceExpression = 260",
                    "LocalReferenceExpression = 261",
                    "ParameterReferenceExpression = 262",
                    "SyntheticLocalReferenceExpression = 263",
                    "FieldReferenceExpression = 264",
                    "MethodBindingExpression = 265",
                    "PropertyReferenceExpression = 266",
                    "IndexedPropertyReferenceExpression = 267",
                    "EventReferenceExpression = 268",
                    "UnaryOperatorExpression = 269",
                    "BinaryOperatorExpression = 270",
                    "ConditionalChoiceExpression = 271",
                    "NullCoalescingExpression = 272",
                    "LambdaExpression = 273",
                    "ObjectCreationExpression = 274",
                    "TypeParameterObjectCreationExpression = 275",
                    "ArrayCreationExpression = 276",
                    "InstanceReferenceExpression = 277",
                    "IsTypeExpression = 278",
                    "AwaitExpression = 279",
                    "AssignmentExpression = 280",
                    "CompoundAssignmentExpression = 281",
                    "ParenthesizedExpression = 282",
                    "EventAssignmentExpression = 283",
                    "ConditionalAccessExpression = 284",
                    "ConditionalAccessInstanceExpression = 285",
                    "DefaultValueExpression = 512",
                    "TypeOfExpression = 513",
                    "SizeOfExpression = 514",
                    "AddressOfExpression = 515",
                    "PointerIndirectionReferenceExpression = 516",
                    "UnboundLambdaExpression = 517",
                    "IncrementExpression = 518",
                    "OmittedArgumentExpression = 768",
                    "LateBoundMemberReferenceExpression = 769",
                    "PlaceholderExpression = 770",
                    "FieldInitializerInCreation = 1024",
                    "FieldInitializerAtDeclaration = 1025",
                    "PropertyInitializerInCreation = 1026",
                    "PropertyInitializerAtDeclaration = 1027",
                    "ParameterInitializerAtDeclaration = 1028",
                    "ArrayInitializer = 1029",
                    "VariableDeclaration = 1030",
                    "Argument = 1031",
                    "CatchClause = 1032",
                    "SwitchCase = 1033",
                    "SingleValueCaseClause = 1034",
                    "RelationalCaseClause = 1035",
                    "RangeCaseClause = 1036"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.OptimizationLevel",
                  "members": [
                    "Debug = 0",
                    "Release = 1"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.OutputKind",
                  "members": [
                    "ConsoleApplication = 0",
                    "WindowsApplication = 1",
                    "DynamicallyLinkedLibrary = 2",
                    "NetModule = 3",
                    "WindowsRuntimeMetadata = 4",
                    "WindowsRuntimeApplication = 5"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Platform",
                  "members": [
                    "AnyCpu = 0",
                    "X86 = 1",
                    "X64 = 2",
                    "Itanium = 3",
                    "AnyCpu32BitPreferred = 4",
                    "Arm = 5"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.PreservationMode",
                  "members": [
                    "PreserveValue = 0",
                    "PreserveIdentity = 1"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.RefKind",
                  "members": [
                    "None = 0",
                    "Ref = 1",
                    "Out = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.ReportDiagnostic",
                  "members": [
                    "Default = 0",
                    "Error = 1",
                    "Warn = 2",
                    "Info = 3",
                    "Hidden = 4",
                    "Suppress = 5"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SourceCodeKind",
                  "members": [
                    "Regular = 0",
                    "Script = 1",
                    "Interactive = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SpecialType",
                  "members": [
                    "None = 0",
                    "System_Object = 1",
                    "System_Enum = 2",
                    "System_MulticastDelegate = 3",
                    "System_Delegate = 4",
                    "System_ValueType = 5",
                    "System_Void = 6",
                    "System_Boolean = 7",
                    "System_Char = 8",
                    "System_SByte = 9",
                    "System_Byte = 10",
                    "System_Int16 = 11",
                    "System_UInt16 = 12",
                    "System_Int32 = 13",
                    "System_UInt32 = 14",
                    "System_Int64 = 15",
                    "System_UInt64 = 16",
                    "System_Decimal = 17",
                    "System_Single = 18",
                    "System_Double = 19",
                    "System_String = 20",
                    "System_IntPtr = 21",
                    "System_UIntPtr = 22",
                    "System_Array = 23",
                    "System_Collections_IEnumerable = 24",
                    "System_Collections_Generic_IEnumerable_T = 25",
                    "System_Collections_Generic_IList_T = 26",
                    "System_Collections_Generic_ICollection_T = 27",
                    "System_Collections_IEnumerator = 28",
                    "System_Collections_Generic_IEnumerator_T = 29",
                    "System_Collections_Generic_IReadOnlyList_T = 30",
                    "System_Collections_Generic_IReadOnlyCollection_T = 31",
                    "System_Nullable_T = 32",
                    "System_DateTime = 33",
                    "System_Runtime_CompilerServices_IsVolatile = 34",
                    "System_IDisposable = 35",
                    "System_TypedReference = 36",
                    "System_ArgIterator = 37",
                    "System_RuntimeArgumentHandle = 38",
                    "System_RuntimeFieldHandle = 39",
                    "System_RuntimeMethodHandle = 40",
                    "System_RuntimeTypeHandle = 41",
                    "System_IAsyncResult = 42",
                    "System_AsyncCallback = 43",
                    "Count = 43"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SpeculativeBindingOption",
                  "members": [
                    "BindAsExpression = 0",
                    "BindAsTypeOrNamespace = 1"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle",
                  "members": [
                    "NameOnly = 0",
                    "NameAndParameters = 1",
                    "NameAndSignature = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle",
                  "members": [
                    "Default = 0",
                    "InstanceMethod = 1",
                    "StaticMethod = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions",
                  "members": [
                    "None = 0",
                    "IncludeTypeParameters = 1",
                    "IncludeTypeConstraints = 2",
                    "IncludeVariance = 4"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle",
                  "members": [
                    "Omitted = 0",
                    "OmittedAsContaining = 1",
                    "Included = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SymbolDisplayKindOptions",
                  "members": [
                    "None = 0",
                    "IncludeNamespaceKeyword = 1",
                    "IncludeTypeKeyword = 2",
                    "IncludeMemberKeyword = 4"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SymbolDisplayLocalOptions",
                  "members": [
                    "None = 0",
                    "IncludeType = 1",
                    "IncludeConstantValue = 2",
                    "IncludeRef = 4"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SymbolDisplayMemberOptions",
                  "members": [
                    "None = 0",
                    "IncludeType = 1",
                    "IncludeModifiers = 2",
                    "IncludeAccessibility = 4",
                    "IncludeExplicitInterface = 8",
                    "IncludeParameters = 16",
                    "IncludeContainingType = 32",
                    "IncludeConstantValue = 64",
                    "IncludeRef = 128"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions",
                  "members": [
                    "None = 0",
                    "UseSpecialTypes = 1",
                    "EscapeKeywordIdentifiers = 2",
                    "UseAsterisksInMultiDimensionalArrays = 4",
                    "UseErrorTypeSymbolName = 8",
                    "RemoveAttributeSuffix = 16",
                    "ExpandNullable = 32"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SymbolDisplayParameterOptions",
                  "members": [
                    "None = 0",
                    "IncludeExtensionThis = 1",
                    "IncludeParamsRefOut = 2",
                    "IncludeType = 4",
                    "IncludeName = 8",
                    "IncludeDefaultValue = 16",
                    "IncludeOptionalBrackets = 32"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SymbolDisplayPartKind",
                  "members": [
                    "AliasName = 0",
                    "AssemblyName = 1",
                    "ClassName = 2",
                    "DelegateName = 3",
                    "EnumName = 4",
                    "ErrorTypeName = 5",
                    "EventName = 6",
                    "FieldName = 7",
                    "InterfaceName = 8",
                    "Keyword = 9",
                    "LabelName = 10",
                    "LineBreak = 11",
                    "NumericLiteral = 12",
                    "StringLiteral = 13",
                    "LocalName = 14",
                    "MethodName = 15",
                    "ModuleName = 16",
                    "NamespaceName = 17",
                    "Operator = 18",
                    "ParameterName = 19",
                    "PropertyName = 20",
                    "Punctuation = 21",
                    "Space = 22",
                    "StructName = 23",
                    "AnonymousTypeIndicator = 24",
                    "Text = 25",
                    "TypeParameterName = 26",
                    "RangeVariableName = 27"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle",
                  "members": [
                    "NameOnly = 0",
                    "ShowReadWriteDescriptor = 1"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle",
                  "members": [
                    "NameOnly = 0",
                    "NameAndContainingTypes = 1",
                    "NameAndContainingTypesAndNamespaces = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SymbolFilter",
                  "members": [
                    "None = 0",
                    "Namespace = 1",
                    "Type = 2",
                    "Member = 4",
                    "TypeAndMember = Type | Member",
                    "All = Namespace | TypeAndMember"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SymbolKind",
                  "members": [
                    "Alias = 0",
                    "ArrayType = 1",
                    "Assembly = 2",
                    "DynamicType = 3",
                    "ErrorType = 4",
                    "Event = 5",
                    "Field = 6",
                    "Label = 7",
                    "Local = 8",
                    "Method = 9",
                    "NetModule = 10",
                    "NamedType = 11",
                    "Namespace = 12",
                    "Parameter = 13",
                    "PointerType = 14",
                    "Property = 15",
                    "RangeVariable = 16",
                    "TypeParameter = 17",
                    "Preprocessing = 18",
                    "Discard = 19"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SyntaxRemoveOptions",
                  "members": [
                    "KeepNoTrivia = 0",
                    "KeepLeadingTrivia = 1",
                    "KeepTrailingTrivia = 2",
                    "KeepExteriorTrivia = KeepLeadingTrivia | KeepTrailingTrivia",
                    "KeepUnbalancedDirectives = 4",
                    "KeepDirectives = 8",
                    "KeepEndOfLine = 16",
                    "AddElasticMarker = 32"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.SyntaxWalkerDepth",
                  "members": [
                    "Node = 0",
                    "Token = 1",
                    "Trivia = 2",
                    "StructuredTrivia = 3"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.TypeKind",
                  "members": [
                    "Unknown = 0",
                    "Array = 1",
                    "Class = 2",
                    "Delegate = 3",
                    "Dynamic = 4",
                    "Enum = 5",
                    "Error = 6",
                    "Interface = 7",
                    "Module = 8",
                    "Pointer = 9",
                    "Struct = 10",
                    "Structure = 10",
                    "TypeParameter = 11",
                    "Submission = 12"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.TypeParameterKind",
                  "members": [
                    "Type = 0",
                    "Method = 1",
                    "Cref = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.TypedConstantKind",
                  "members": [
                    "Error = 0",
                    "Primitive = 1",
                    "Enum = 2",
                    "Type = 3",
                    "Array = 4"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.VarianceKind",
                  "members": [
                    "None = 0",
                    "Out = 1",
                    "In = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.WorkspaceChangeKind",
                  "members": [
                    "SolutionChanged = 0",
                    "SolutionAdded = 1",
                    "SolutionRemoved = 2",
                    "SolutionCleared = 3",
                    "SolutionReloaded = 4",
                    "ProjectAdded = 5",
                    "ProjectRemoved = 6",
                    "ProjectChanged = 7",
                    "ProjectReloaded = 8",
                    "DocumentAdded = 9",
                    "DocumentRemoved = 10",
                    "DocumentReloaded = 11",
                    "DocumentChanged = 12",
                    "AdditionalDocumentAdded = 13",
                    "AdditionalDocumentRemoved = 14",
                    "AdditionalDocumentReloaded = 15",
                    "AdditionalDocumentChanged = 16",
                    "DocumentInfoChanged = 17"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.WorkspaceDiagnosticKind",
                  "members": [
                    "Failure = 0",
                    "Warning = 1"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.CSharp.LanguageVersion",
                  "members": [
                    "Default = 0",
                    "CSharp1 = 1",
                    "CSharp2 = 2",
                    "CSharp3 = 3",
                    "CSharp4 = 4",
                    "CSharp5 = 5",
                    "CSharp6 = 6",
                    "CSharp7 = 7",
                    "CSharp7_1 = 701",
                    "Latest = 2147483647"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.CSharp.SyntaxKind",
                  "members": [
                    "None = 0",
                    "List = 1",
                    "TildeToken = 8193",
                    "ExclamationToken = 8194",
                    "DollarToken = 8195",
                    "PercentToken = 8196",
                    "CaretToken = 8197",
                    "AmpersandToken = 8198",
                    "AsteriskToken = 8199",
                    "OpenParenToken = 8200",
                    "CloseParenToken = 8201",
                    "MinusToken = 8202",
                    "PlusToken = 8203",
                    "EqualsToken = 8204",
                    "OpenBraceToken = 8205",
                    "CloseBraceToken = 8206",
                    "OpenBracketToken = 8207",
                    "CloseBracketToken = 8208",
                    "BarToken = 8209",
                    "BackslashToken = 8210",
                    "ColonToken = 8211",
                    "SemicolonToken = 8212",
                    "DoubleQuoteToken = 8213",
                    "SingleQuoteToken = 8214",
                    "LessThanToken = 8215",
                    "CommaToken = 8216",
                    "GreaterThanToken = 8217",
                    "DotToken = 8218",
                    "QuestionToken = 8219",
                    "HashToken = 8220",
                    "SlashToken = 8221",
                    "SlashGreaterThanToken = 8232",
                    "LessThanSlashToken = 8233",
                    "XmlCommentStartToken = 8234",
                    "XmlCommentEndToken = 8235",
                    "XmlCDataStartToken = 8236",
                    "XmlCDataEndToken = 8237",
                    "XmlProcessingInstructionStartToken = 8238",
                    "XmlProcessingInstructionEndToken = 8239",
                    "BarBarToken = 8260",
                    "AmpersandAmpersandToken = 8261",
                    "MinusMinusToken = 8262",
                    "PlusPlusToken = 8263",
                    "ColonColonToken = 8264",
                    "QuestionQuestionToken = 8265",
                    "MinusGreaterThanToken = 8266",
                    "ExclamationEqualsToken = 8267",
                    "EqualsEqualsToken = 8268",
                    "EqualsGreaterThanToken = 8269",
                    "LessThanEqualsToken = 8270",
                    "LessThanLessThanToken = 8271",
                    "LessThanLessThanEqualsToken = 8272",
                    "GreaterThanEqualsToken = 8273",
                    "GreaterThanGreaterThanToken = 8274",
                    "GreaterThanGreaterThanEqualsToken = 8275",
                    "SlashEqualsToken = 8276",
                    "AsteriskEqualsToken = 8277",
                    "BarEqualsToken = 8278",
                    "AmpersandEqualsToken = 8279",
                    "PlusEqualsToken = 8280",
                    "MinusEqualsToken = 8281",
                    "CaretEqualsToken = 8282",
                    "PercentEqualsToken = 8283",
                    "BoolKeyword = 8304",
                    "ByteKeyword = 8305",
                    "SByteKeyword = 8306",
                    "ShortKeyword = 8307",
                    "UShortKeyword = 8308",
                    "IntKeyword = 8309",
                    "UIntKeyword = 8310",
                    "LongKeyword = 8311",
                    "ULongKeyword = 8312",
                    "DoubleKeyword = 8313",
                    "FloatKeyword = 8314",
                    "DecimalKeyword = 8315",
                    "StringKeyword = 8316",
                    "CharKeyword = 8317",
                    "VoidKeyword = 8318",
                    "ObjectKeyword = 8319",
                    "TypeOfKeyword = 8320",
                    "SizeOfKeyword = 8321",
                    "NullKeyword = 8322",
                    "TrueKeyword = 8323",
                    "FalseKeyword = 8324",
                    "IfKeyword = 8325",
                    "ElseKeyword = 8326",
                    "WhileKeyword = 8327",
                    "ForKeyword = 8328",
                    "ForEachKeyword = 8329",
                    "DoKeyword = 8330",
                    "SwitchKeyword = 8331",
                    "CaseKeyword = 8332",
                    "DefaultKeyword = 8333",
                    "TryKeyword = 8334",
                    "CatchKeyword = 8335",
                    "FinallyKeyword = 8336",
                    "LockKeyword = 8337",
                    "GotoKeyword = 8338",
                    "BreakKeyword = 8339",
                    "ContinueKeyword = 8340",
                    "ReturnKeyword = 8341",
                    "ThrowKeyword = 8342",
                    "PublicKeyword = 8343",
                    "PrivateKeyword = 8344",
                    "InternalKeyword = 8345",
                    "ProtectedKeyword = 8346",
                    "StaticKeyword = 8347",
                    "ReadOnlyKeyword = 8348",
                    "SealedKeyword = 8349",
                    "ConstKeyword = 8350",
                    "FixedKeyword = 8351",
                    "StackAllocKeyword = 8352",
                    "VolatileKeyword = 8353",
                    "NewKeyword = 8354",
                    "OverrideKeyword = 8355",
                    "AbstractKeyword = 8356",
                    "VirtualKeyword = 8357",
                    "EventKeyword = 8358",
                    "ExternKeyword = 8359",
                    "RefKeyword = 8360",
                    "OutKeyword = 8361",
                    "InKeyword = 8362",
                    "IsKeyword = 8363",
                    "AsKeyword = 8364",
                    "ParamsKeyword = 8365",
                    "ArgListKeyword = 8366",
                    "MakeRefKeyword = 8367",
                    "RefTypeKeyword = 8368",
                    "RefValueKeyword = 8369",
                    "ThisKeyword = 8370",
                    "BaseKeyword = 8371",
                    "NamespaceKeyword = 8372",
                    "UsingKeyword = 8373",
                    "ClassKeyword = 8374",
                    "StructKeyword = 8375",
                    "InterfaceKeyword = 8376",
                    "EnumKeyword = 8377",
                    "DelegateKeyword = 8378",
                    "CheckedKeyword = 8379",
                    "UncheckedKeyword = 8380",
                    "UnsafeKeyword = 8381",
                    "OperatorKeyword = 8382",
                    "ExplicitKeyword = 8383",
                    "ImplicitKeyword = 8384",
                    "YieldKeyword = 8405",
                    "PartialKeyword = 8406",
                    "AliasKeyword = 8407",
                    "GlobalKeyword = 8408",
                    "AssemblyKeyword = 8409",
                    "ModuleKeyword = 8410",
                    "TypeKeyword = 8411",
                    "FieldKeyword = 8412",
                    "MethodKeyword = 8413",
                    "ParamKeyword = 8414",
                    "PropertyKeyword = 8415",
                    "TypeVarKeyword = 8416",
                    "GetKeyword = 8417",
                    "SetKeyword = 8418",
                    "AddKeyword = 8419",
                    "RemoveKeyword = 8420",
                    "WhereKeyword = 8421",
                    "FromKeyword = 8422",
                    "GroupKeyword = 8423",
                    "JoinKeyword = 8424",
                    "IntoKeyword = 8425",
                    "LetKeyword = 8426",
                    "ByKeyword = 8427",
                    "SelectKeyword = 8428",
                    "OrderByKeyword = 8429",
                    "OnKeyword = 8430",
                    "EqualsKeyword = 8431",
                    "AscendingKeyword = 8432",
                    "DescendingKeyword = 8433",
                    "NameOfKeyword = 8434",
                    "AsyncKeyword = 8435",
                    "AwaitKeyword = 8436",
                    "WhenKeyword = 8437",
                    "ElifKeyword = 8467",
                    "EndIfKeyword = 8468",
                    "RegionKeyword = 8469",
                    "EndRegionKeyword = 8470",
                    "DefineKeyword = 8471",
                    "UndefKeyword = 8472",
                    "WarningKeyword = 8473",
                    "ErrorKeyword = 8474",
                    "LineKeyword = 8475",
                    "PragmaKeyword = 8476",
                    "HiddenKeyword = 8477",
                    "ChecksumKeyword = 8478",
                    "DisableKeyword = 8479",
                    "RestoreKeyword = 8480",
                    "ReferenceKeyword = 8481",
                    "LoadKeyword = 8485",
                    "InterpolatedStringStartToken = 8482",
                    "InterpolatedStringEndToken = 8483",
                    "InterpolatedVerbatimStringStartToken = 8484",
                    "UnderscoreToken = 8491",
                    "OmittedTypeArgumentToken = 8492",
                    "OmittedArraySizeExpressionToken = 8493",
                    "EndOfDirectiveToken = 8494",
                    "EndOfDocumentationCommentToken = 8495",
                    "EndOfFileToken = 8496",
                    "BadToken = 8507",
                    "IdentifierToken = 8508",
                    "NumericLiteralToken = 8509",
                    "CharacterLiteralToken = 8510",
                    "StringLiteralToken = 8511",
                    "XmlEntityLiteralToken = 8512",
                    "XmlTextLiteralToken = 8513",
                    "XmlTextLiteralNewLineToken = 8514",
                    "InterpolatedStringToken = 8515",
                    "InterpolatedStringTextToken = 8517",
                    "EndOfLineTrivia = 8539",
                    "WhitespaceTrivia = 8540",
                    "SingleLineCommentTrivia = 8541",
                    "MultiLineCommentTrivia = 8542",
                    "DocumentationCommentExteriorTrivia = 8543",
                    "SingleLineDocumentationCommentTrivia = 8544",
                    "MultiLineDocumentationCommentTrivia = 8545",
                    "DisabledTextTrivia = 8546",
                    "PreprocessingMessageTrivia = 8547",
                    "IfDirectiveTrivia = 8548",
                    "ElifDirectiveTrivia = 8549",
                    "ElseDirectiveTrivia = 8550",
                    "EndIfDirectiveTrivia = 8551",
                    "RegionDirectiveTrivia = 8552",
                    "EndRegionDirectiveTrivia = 8553",
                    "DefineDirectiveTrivia = 8554",
                    "UndefDirectiveTrivia = 8555",
                    "ErrorDirectiveTrivia = 8556",
                    "WarningDirectiveTrivia = 8557",
                    "LineDirectiveTrivia = 8558",
                    "PragmaWarningDirectiveTrivia = 8559",
                    "PragmaChecksumDirectiveTrivia = 8560",
                    "ReferenceDirectiveTrivia = 8561",
                    "BadDirectiveTrivia = 8562",
                    "SkippedTokensTrivia = 8563",
                    "ConflictMarkerTrivia = 8564",
                    "XmlElement = 8574",
                    "XmlElementStartTag = 8575",
                    "XmlElementEndTag = 8576",
                    "XmlEmptyElement = 8577",
                    "XmlTextAttribute = 8578",
                    "XmlCrefAttribute = 8579",
                    "XmlNameAttribute = 8580",
                    "XmlName = 8581",
                    "XmlPrefix = 8582",
                    "XmlText = 8583",
                    "XmlCDataSection = 8584",
                    "XmlComment = 8585",
                    "XmlProcessingInstruction = 8586",
                    "TypeCref = 8597",
                    "QualifiedCref = 8598",
                    "NameMemberCref = 8599",
                    "IndexerMemberCref = 8600",
                    "OperatorMemberCref = 8601",
                    "ConversionOperatorMemberCref = 8602",
                    "CrefParameterList = 8603",
                    "CrefBracketedParameterList = 8604",
                    "CrefParameter = 8605",
                    "IdentifierName = 8616",
                    "QualifiedName = 8617",
                    "GenericName = 8618",
                    "TypeArgumentList = 8619",
                    "AliasQualifiedName = 8620",
                    "PredefinedType = 8621",
                    "ArrayType = 8622",
                    "ArrayRankSpecifier = 8623",
                    "PointerType = 8624",
                    "NullableType = 8625",
                    "OmittedTypeArgument = 8626",
                    "ParenthesizedExpression = 8632",
                    "ConditionalExpression = 8633",
                    "InvocationExpression = 8634",
                    "ElementAccessExpression = 8635",
                    "ArgumentList = 8636",
                    "BracketedArgumentList = 8637",
                    "Argument = 8638",
                    "NameColon = 8639",
                    "CastExpression = 8640",
                    "AnonymousMethodExpression = 8641",
                    "SimpleLambdaExpression = 8642",
                    "ParenthesizedLambdaExpression = 8643",
                    "ObjectInitializerExpression = 8644",
                    "CollectionInitializerExpression = 8645",
                    "ArrayInitializerExpression = 8646",
                    "AnonymousObjectMemberDeclarator = 8647",
                    "ComplexElementInitializerExpression = 8648",
                    "ObjectCreationExpression = 8649",
                    "AnonymousObjectCreationExpression = 8650",
                    "ArrayCreationExpression = 8651",
                    "ImplicitArrayCreationExpression = 8652",
                    "StackAllocArrayCreationExpression = 8653",
                    "OmittedArraySizeExpression = 8654",
                    "InterpolatedStringExpression = 8655",
                    "ImplicitElementAccess = 8656",
                    "IsPatternExpression = 8657",
                    "AddExpression = 8668",
                    "SubtractExpression = 8669",
                    "MultiplyExpression = 8670",
                    "DivideExpression = 8671",
                    "ModuloExpression = 8672",
                    "LeftShiftExpression = 8673",
                    "RightShiftExpression = 8674",
                    "LogicalOrExpression = 8675",
                    "LogicalAndExpression = 8676",
                    "BitwiseOrExpression = 8677",
                    "BitwiseAndExpression = 8678",
                    "ExclusiveOrExpression = 8679",
                    "EqualsExpression = 8680",
                    "NotEqualsExpression = 8681",
                    "LessThanExpression = 8682",
                    "LessThanOrEqualExpression = 8683",
                    "GreaterThanExpression = 8684",
                    "GreaterThanOrEqualExpression = 8685",
                    "IsExpression = 8686",
                    "AsExpression = 8687",
                    "CoalesceExpression = 8688",
                    "SimpleMemberAccessExpression = 8689",
                    "PointerMemberAccessExpression = 8690",
                    "ConditionalAccessExpression = 8691",
                    "MemberBindingExpression = 8707",
                    "ElementBindingExpression = 8708",
                    "SimpleAssignmentExpression = 8714",
                    "AddAssignmentExpression = 8715",
                    "SubtractAssignmentExpression = 8716",
                    "MultiplyAssignmentExpression = 8717",
                    "DivideAssignmentExpression = 8718",
                    "ModuloAssignmentExpression = 8719",
                    "AndAssignmentExpression = 8720",
                    "ExclusiveOrAssignmentExpression = 8721",
                    "OrAssignmentExpression = 8722",
                    "LeftShiftAssignmentExpression = 8723",
                    "RightShiftAssignmentExpression = 8724",
                    "UnaryPlusExpression = 8730",
                    "UnaryMinusExpression = 8731",
                    "BitwiseNotExpression = 8732",
                    "LogicalNotExpression = 8733",
                    "PreIncrementExpression = 8734",
                    "PreDecrementExpression = 8735",
                    "PointerIndirectionExpression = 8736",
                    "AddressOfExpression = 8737",
                    "PostIncrementExpression = 8738",
                    "PostDecrementExpression = 8739",
                    "AwaitExpression = 8740",
                    "ThisExpression = 8746",
                    "BaseExpression = 8747",
                    "ArgListExpression = 8748",
                    "NumericLiteralExpression = 8749",
                    "StringLiteralExpression = 8750",
                    "CharacterLiteralExpression = 8751",
                    "TrueLiteralExpression = 8752",
                    "FalseLiteralExpression = 8753",
                    "NullLiteralExpression = 8754",
                    "DefaultLiteralExpression = 8755",
                    "TypeOfExpression = 8760",
                    "SizeOfExpression = 8761",
                    "CheckedExpression = 8762",
                    "UncheckedExpression = 8763",
                    "DefaultExpression = 8764",
                    "MakeRefExpression = 8765",
                    "RefValueExpression = 8766",
                    "RefTypeExpression = 8767",
                    "QueryExpression = 8774",
                    "QueryBody = 8775",
                    "FromClause = 8776",
                    "LetClause = 8777",
                    "JoinClause = 8778",
                    "JoinIntoClause = 8779",
                    "WhereClause = 8780",
                    "OrderByClause = 8781",
                    "AscendingOrdering = 8782",
                    "DescendingOrdering = 8783",
                    "SelectClause = 8784",
                    "GroupClause = 8785",
                    "QueryContinuation = 8786",
                    "Block = 8792",
                    "LocalDeclarationStatement = 8793",
                    "VariableDeclaration = 8794",
                    "VariableDeclarator = 8795",
                    "EqualsValueClause = 8796",
                    "ExpressionStatement = 8797",
                    "EmptyStatement = 8798",
                    "LabeledStatement = 8799",
                    "GotoStatement = 8800",
                    "GotoCaseStatement = 8801",
                    "GotoDefaultStatement = 8802",
                    "BreakStatement = 8803",
                    "ContinueStatement = 8804",
                    "ReturnStatement = 8805",
                    "YieldReturnStatement = 8806",
                    "YieldBreakStatement = 8807",
                    "ThrowStatement = 8808",
                    "WhileStatement = 8809",
                    "DoStatement = 8810",
                    "ForStatement = 8811",
                    "ForEachStatement = 8812",
                    "UsingStatement = 8813",
                    "FixedStatement = 8814",
                    "CheckedStatement = 8815",
                    "UncheckedStatement = 8816",
                    "UnsafeStatement = 8817",
                    "LockStatement = 8818",
                    "IfStatement = 8819",
                    "ElseClause = 8820",
                    "SwitchStatement = 8821",
                    "SwitchSection = 8822",
                    "CaseSwitchLabel = 8823",
                    "DefaultSwitchLabel = 8824",
                    "TryStatement = 8825",
                    "CatchClause = 8826",
                    "CatchDeclaration = 8827",
                    "CatchFilterClause = 8828",
                    "FinallyClause = 8829",
                    "LocalFunctionStatement = 8830",
                    "CompilationUnit = 8840",
                    "GlobalStatement = 8841",
                    "NamespaceDeclaration = 8842",
                    "UsingDirective = 8843",
                    "ExternAliasDirective = 8844",
                    "AttributeList = 8847",
                    "AttributeTargetSpecifier = 8848",
                    "Attribute = 8849",
                    "AttributeArgumentList = 8850",
                    "AttributeArgument = 8851",
                    "NameEquals = 8852",
                    "ClassDeclaration = 8855",
                    "StructDeclaration = 8856",
                    "InterfaceDeclaration = 8857",
                    "EnumDeclaration = 8858",
                    "DelegateDeclaration = 8859",
                    "BaseList = 8864",
                    "SimpleBaseType = 8865",
                    "TypeParameterConstraintClause = 8866",
                    "ConstructorConstraint = 8867",
                    "ClassConstraint = 8868",
                    "StructConstraint = 8869",
                    "TypeConstraint = 8870",
                    "ExplicitInterfaceSpecifier = 8871",
                    "EnumMemberDeclaration = 8872",
                    "FieldDeclaration = 8873",
                    "EventFieldDeclaration = 8874",
                    "MethodDeclaration = 8875",
                    "OperatorDeclaration = 8876",
                    "ConversionOperatorDeclaration = 8877",
                    "ConstructorDeclaration = 8878",
                    "BaseConstructorInitializer = 8889",
                    "ThisConstructorInitializer = 8890",
                    "DestructorDeclaration = 8891",
                    "PropertyDeclaration = 8892",
                    "EventDeclaration = 8893",
                    "IndexerDeclaration = 8894",
                    "AccessorList = 8895",
                    "GetAccessorDeclaration = 8896",
                    "SetAccessorDeclaration = 8897",
                    "AddAccessorDeclaration = 8898",
                    "RemoveAccessorDeclaration = 8899",
                    "UnknownAccessorDeclaration = 8900",
                    "ParameterList = 8906",
                    "BracketedParameterList = 8907",
                    "Parameter = 8908",
                    "TypeParameterList = 8909",
                    "TypeParameter = 8910",
                    "IncompleteMember = 8916",
                    "ArrowExpressionClause = 8917",
                    "Interpolation = 8918",
                    "InterpolatedStringText = 8919",
                    "InterpolationAlignmentClause = 8920",
                    "InterpolationFormatClause = 8921",
                    "ShebangDirectiveTrivia = 8922",
                    "LoadDirectiveTrivia = 8923",
                    "TupleType = 8924",
                    "TupleElement = 8925",
                    "TupleExpression = 8926",
                    "SingleVariableDesignation = 8927",
                    "ParenthesizedVariableDesignation = 8928",
                    "ForEachVariableStatement = 8929",
                    "DeclarationPattern = 9000",
                    "ConstantPattern = 9002",
                    "CasePatternSwitchLabel = 9009",
                    "WhenClause = 9013",
                    "DiscardDesignation = 9014",
                    "DeclarationExpression = 9040",
                    "RefExpression = 9050",
                    "RefType = 9051",
                    "ThrowExpression = 9052"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.CSharp.Formatting.BinaryOperatorSpacingOptions",
                  "members": [
                    "Single = 0",
                    "Ignore = 1",
                    "Remove = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.CSharp.Formatting.LabelPositionOptions",
                  "members": [
                    "LeftMost = 0",
                    "OneLess = 1",
                    "NoIndent = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeElementKind",
                  "members": [
                    "Parameter = 0",
                    "ParameterReference = 1",
                    "TypeParameter = 2",
                    "TypeParameterReference = 3"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.CodeFixes.FixAllScope",
                  "members": [
                    "Document = 0",
                    "Project = 1",
                    "Solution = 2",
                    "Custom = 3"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs.FailureErrorCode",
                  "members": [
                    "None = 0",
                    "UnableToLoadAnalyzer = 1",
                    "UnableToCreateAnalyzer = 2",
                    "NoAnalyzers = 3"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Diagnostics.GeneratedCodeAnalysisFlags",
                  "members": [
                    "None = 0",
                    "Analyze = 1",
                    "ReportDiagnostics = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Differencing.EditKind",
                  "members": [
                    "None = 0",
                    "Update = 1",
                    "Insert = 2",
                    "Delete = 3",
                    "Move = 4",
                    "Reorder = 5"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Editing.DeclarationKind",
                  "members": [
                    "None = 0",
                    "CompilationUnit = 1",
                    "Class = 2",
                    "Struct = 3",
                    "Interface = 4",
                    "Enum = 5",
                    "Delegate = 6",
                    "Method = 7",
                    "Operator = 8",
                    "ConversionOperator = 9",
                    "Constructor = 10",
                    "Destructor = 11",
                    "Field = 12",
                    "Property = 13",
                    "Indexer = 14",
                    "EnumMember = 15",
                    "Event = 16",
                    "CustomEvent = 17",
                    "Namespace = 18",
                    "NamespaceImport = 19",
                    "Parameter = 20",
                    "Variable = 21",
                    "Attribute = 22",
                    "LambdaExpression = 23",
                    "GetAccessor = 24",
                    "SetAccessor = 25",
                    "AddAccessor = 26",
                    "RemoveAccessor = 27",
                    "RaiseAccessor = 28"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Editing.OperatorKind",
                  "members": [
                    "ImplicitConversion = 0",
                    "ExplicitConversion = 1",
                    "Addition = 2",
                    "BitwiseAnd = 3",
                    "BitwiseOr = 4",
                    "Decrement = 5",
                    "Division = 6",
                    "Equality = 7",
                    "ExclusiveOr = 8",
                    "False = 9",
                    "GreaterThan = 10",
                    "GreaterThanOrEqual = 11",
                    "Increment = 12",
                    "Inequality = 13",
                    "LeftShift = 14",
                    "LessThan = 15",
                    "LessThanOrEqual = 16",
                    "LogicalNot = 17",
                    "Modulus = 18",
                    "Multiply = 19",
                    "OnesComplement = 20",
                    "RightShift = 21",
                    "Subtraction = 22",
                    "True = 23",
                    "UnaryNegation = 24",
                    "UnaryPlus = 25"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind",
                  "members": [
                    "None = 0",
                    "ReferenceType = 1",
                    "ValueType = 2",
                    "Constructor = 4"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Emit.DebugInformationFormat",
                  "members": [
                    "Pdb = 1",
                    "PortablePdb = 2",
                    "Embedded = 3"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Emit.InstrumentationKind",
                  "members": [
                    "None = 0",
                    "TestCoverage = 1"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Emit.SemanticEditKind",
                  "members": [
                    "None = 0",
                    "Update = 1",
                    "Insert = 2",
                    "Delete = 3"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Formatting.FormattingOptions.IndentStyle",
                  "members": [
                    "None = 0",
                    "Block = 1",
                    "Smart = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Rename.RenameEntityKind",
                  "members": [
                    "BaseSymbol = 0",
                    "OverloadedSymbols = 1"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Semantics.ArgumentKind",
                  "members": [
                    "None = 0",
                    "Explicit = 1",
                    "ParamArray = 2",
                    "DefaultValue = 3"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Semantics.BinaryOperandsKind",
                  "members": [
                    "None = 0",
                    "OperatorMethod = 256",
                    "Integer = 512",
                    "Unsigned = 768",
                    "Floating = 1024",
                    "Decimal = 1280",
                    "Boolean = 1536",
                    "Enum = 1792",
                    "Dynamic = 2048",
                    "Object = 2304",
                    "Pointer = 2560",
                    "PointerInteger = 2816",
                    "IntegerPointer = 3072",
                    "String = 3328",
                    "Delegate = 3584",
                    "Nullable = 3840",
                    "Invalid = 65280"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Semantics.BinaryOperationKind",
                  "members": [
                    "None = 0",
                    "OperatorMethodAdd = 257",
                    "OperatorMethodSubtract = 258",
                    "OperatorMethodMultiply = 259",
                    "OperatorMethodDivide = 260",
                    "OperatorMethodIntegerDivide = 261",
                    "OperatorMethodRemainder = 262",
                    "OperatorMethodLeftShift = 264",
                    "OperatorMethodRightShift = 265",
                    "OperatorMethodAnd = 266",
                    "OperatorMethodOr = 267",
                    "OperatorMethodExclusiveOr = 268",
                    "OperatorMethodConditionalAnd = 269",
                    "OperatorMethodConditionalOr = 270",
                    "IntegerAdd = 513",
                    "IntegerSubtract = 514",
                    "IntegerMultiply = 515",
                    "IntegerDivide = 516",
                    "IntegerRemainder = 518",
                    "IntegerLeftShift = 520",
                    "IntegerRightShift = 521",
                    "IntegerAnd = 522",
                    "IntegerOr = 523",
                    "IntegerExclusiveOr = 524",
                    "UnsignedAdd = 769",
                    "UnsignedSubtract = 770",
                    "UnsignedMultiply = 771",
                    "UnsignedDivide = 772",
                    "UnsignedRemainder = 774",
                    "UnsignedLeftShift = 776",
                    "UnsignedRightShift = 777",
                    "UnsignedAnd = 778",
                    "UnsignedOr = 779",
                    "UnsignedExclusiveOr = 780",
                    "FloatingAdd = 1025",
                    "FloatingSubtract = 1026",
                    "FloatingMultiply = 1027",
                    "FloatingDivide = 1028",
                    "FloatingRemainder = 1030",
                    "FloatingPower = 1031",
                    "DecimalAdd = 1281",
                    "DecimalSubtract = 1282",
                    "DecimalMultiply = 1283",
                    "DecimalDivide = 1284",
                    "BooleanAnd = 1546",
                    "BooleanOr = 1547",
                    "BooleanExclusiveOr = 1548",
                    "BooleanConditionalAnd = 1549",
                    "BooleanConditionalOr = 1550",
                    "EnumAdd = 1793",
                    "EnumSubtract = 1794",
                    "EnumAnd = 1802",
                    "EnumOr = 1803",
                    "EnumExclusiveOr = 1804",
                    "PointerIntegerAdd = 2817",
                    "IntegerPointerAdd = 3073",
                    "PointerIntegerSubtract = 2818",
                    "PointerSubtract = 2562",
                    "DynamicAdd = 2049",
                    "DynamicSubtract = 2050",
                    "DynamicMultiply = 2051",
                    "DynamicDivide = 2052",
                    "DynamicRemainder = 2054",
                    "DynamicLeftShift = 2056",
                    "DynamicRightShift = 2057",
                    "DynamicAnd = 2058",
                    "DynamicOr = 2059",
                    "DynamicExclusiveOr = 2060",
                    "ObjectAdd = 2305",
                    "ObjectSubtract = 2306",
                    "ObjectMultiply = 2307",
                    "ObjectDivide = 2308",
                    "ObjectIntegerDivide = 2309",
                    "ObjectRemainder = 2310",
                    "ObjectPower = 2311",
                    "ObjectLeftShift = 2312",
                    "ObjectRightShift = 2313",
                    "ObjectAnd = 2314",
                    "ObjectOr = 2315",
                    "ObjectExclusiveOr = 2316",
                    "ObjectConditionalAnd = 2317",
                    "ObjectConditionalOr = 2318",
                    "ObjectConcatenate = 2319",
                    "StringConcatenate = 3343",
                    "OperatorMethodEquals = 272",
                    "OperatorMethodNotEquals = 274",
                    "OperatorMethodLessThan = 276",
                    "OperatorMethodLessThanOrEqual = 277",
                    "OperatorMethodGreaterThanOrEqual = 278",
                    "OperatorMethodGreaterThan = 279",
                    "OperatorMethodPower = 263",
                    "IntegerEquals = 528",
                    "IntegerNotEquals = 530",
                    "IntegerLessThan = 532",
                    "IntegerLessThanOrEqual = 533",
                    "IntegerGreaterThanOrEqual = 534",
                    "IntegerGreaterThan = 535",
                    "UnsignedLessThan = 788",
                    "UnsignedLessThanOrEqual = 789",
                    "UnsignedGreaterThanOrEqual = 790",
                    "UnsignedGreaterThan = 791",
                    "FloatingEquals = 1040",
                    "FloatingNotEquals = 1042",
                    "FloatingLessThan = 1044",
                    "FloatingLessThanOrEqual = 1045",
                    "FloatingGreaterThanOrEqual = 1046",
                    "FloatingGreaterThan = 1047",
                    "DecimalEquals = 1296",
                    "DecimalNotEquals = 1298",
                    "DecimalLessThan = 1300",
                    "DecimalLessThanOrEqual = 1301",
                    "DecimalGreaterThanOrEqual = 1302",
                    "DecimalGreaterThan = 1303",
                    "BooleanEquals = 1552",
                    "BooleanNotEquals = 1554",
                    "StringEquals = 3344",
                    "StringNotEquals = 3346",
                    "StringLike = 3352",
                    "DelegateEquals = 3600",
                    "DelegateNotEquals = 3602",
                    "NullableEquals = 3856",
                    "NullableNotEquals = 3858",
                    "ObjectEquals = 2320",
                    "ObjectNotEquals = 2322",
                    "ObjectVBEquals = 2321",
                    "ObjectVBNotEquals = 2323",
                    "ObjectLike = 2328",
                    "ObjectLessThan = 2324",
                    "ObjectLessThanOrEqual = 2325",
                    "ObjectGreaterThanOrEqual = 2326",
                    "ObjectGreaterThan = 2327",
                    "EnumEquals = 1808",
                    "EnumNotEquals = 1810",
                    "EnumLessThan = 1812",
                    "EnumLessThanOrEqual = 1813",
                    "EnumGreaterThanOrEqual = 1814",
                    "EnumGreaterThan = 1815",
                    "PointerEquals = 2576",
                    "PointerNotEquals = 2578",
                    "PointerLessThan = 2580",
                    "PointerLessThanOrEqual = 2581",
                    "PointerGreaterThanOrEqual = 2582",
                    "PointerGreaterThan = 2583",
                    "DynamicEquals = 2064",
                    "DynamicNotEquals = 2066",
                    "DynamicLessThan = 2068",
                    "DynamicLessThanOrEqual = 2069",
                    "DynamicGreaterThanOrEqual = 2070",
                    "DynamicGreaterThan = 2071",
                    "Invalid = 65535"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Semantics.BranchKind",
                  "members": [
                    "None = 0",
                    "Continue = 1",
                    "Break = 2",
                    "GoTo = 3"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Semantics.CaseKind",
                  "members": [
                    "None = 0",
                    "SingleValue = 1",
                    "Relational = 2",
                    "Range = 3",
                    "Default = 4"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Semantics.ConversionKind",
                  "members": [
                    "None = 0",
                    "Cast = 1",
                    "TryCast = 2",
                    "Basic = 3",
                    "CSharp = 4",
                    "OperatorMethod = 5",
                    "Invalid = 15"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Semantics.InstanceReferenceKind",
                  "members": [
                    "None = 0",
                    "Implicit = 1",
                    "Explicit = 2",
                    "BaseClass = 3",
                    "ThisClass = 4"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Semantics.LoopKind",
                  "members": [
                    "None = 0",
                    "WhileUntil = 1",
                    "For = 2",
                    "ForEach = 3"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Semantics.SimpleBinaryOperationKind",
                  "members": [
                    "None = 0",
                    "Add = 1",
                    "Subtract = 2",
                    "Multiply = 3",
                    "Divide = 4",
                    "IntegerDivide = 5",
                    "Remainder = 6",
                    "Power = 7",
                    "LeftShift = 8",
                    "RightShift = 9",
                    "And = 10",
                    "Or = 11",
                    "ExclusiveOr = 12",
                    "ConditionalAnd = 13",
                    "ConditionalOr = 14",
                    "Concatenate = 15",
                    "Equals = 16",
                    "ObjectValueEquals = 17",
                    "NotEquals = 18",
                    "ObjectValueNotEquals = 19",
                    "LessThan = 20",
                    "LessThanOrEqual = 21",
                    "GreaterThanOrEqual = 22",
                    "GreaterThan = 23",
                    "Like = 24",
                    "Invalid = 255"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Semantics.SimpleUnaryOperationKind",
                  "members": [
                    "None = 0",
                    "BitwiseNegation = 1",
                    "LogicalNot = 2",
                    "PostfixIncrement = 3",
                    "PostfixDecrement = 4",
                    "PrefixIncrement = 5",
                    "PrefixDecrement = 6",
                    "Plus = 7",
                    "Minus = 8",
                    "True = 9",
                    "False = 10",
                    "BitwiseOrLogicalNot = 11",
                    "Invalid = 255"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Semantics.SyntheticLocalKind",
                  "members": [
                    "None = 0",
                    "ForLoopStepValue = 1",
                    "ForLoopLimitValue = 2"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Semantics.UnaryOperandKind",
                  "members": [
                    "None = 0",
                    "OperatorMethod = 256",
                    "Integer = 512",
                    "Unsigned = 768",
                    "Floating = 1024",
                    "Decimal = 1280",
                    "Boolean = 1536",
                    "Enum = 1792",
                    "Dynamic = 2048",
                    "Object = 2304",
                    "Pointer = 2560",
                    "Invalid = 65280"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Semantics.UnaryOperationKind",
                  "members": [
                    "None = 0",
                    "OperatorMethodBitwiseNegation = 257",
                    "OperatorMethodLogicalNot = 258",
                    "OperatorMethodPostfixIncrement = 259",
                    "OperatorMethodPostfixDecrement = 260",
                    "OperatorMethodPrefixIncrement = 261",
                    "OperatorMethodPrefixDecrement = 262",
                    "OperatorMethodPlus = 263",
                    "OperatorMethodMinus = 264",
                    "OperatorMethodTrue = 265",
                    "OperatorMethodFalse = 266",
                    "IntegerBitwiseNegation = 513",
                    "IntegerPlus = 519",
                    "IntegerMinus = 520",
                    "IntegerPostfixIncrement = 515",
                    "IntegerPostfixDecrement = 516",
                    "IntegerPrefixIncrement = 517",
                    "IntegerPrefixDecrement = 518",
                    "UnsignedPostfixIncrement = 771",
                    "UnsignedPostfixDecrement = 772",
                    "UnsignedPrefixIncrement = 773",
                    "UnsignedPrefixDecrement = 774",
                    "FloatingPlus = 1031",
                    "FloatingMinus = 1032",
                    "FloatingPostfixIncrement = 1027",
                    "FloatingPostfixDecrement = 1028",
                    "FloatingPrefixIncrement = 1029",
                    "FloatingPrefixDecrement = 1030",
                    "DecimalPlus = 1287",
                    "DecimalMinus = 1288",
                    "DecimalPostfixIncrement = 1283",
                    "DecimalPostfixDecrement = 1284",
                    "DecimalPrefixIncrement = 1285",
                    "DecimalPrefixDecrement = 1286",
                    "BooleanBitwiseNegation = 1537",
                    "BooleanLogicalNot = 1538",
                    "EnumPostfixIncrement = 1795",
                    "EnumPostfixDecrement = 1796",
                    "EnumPrefixIncrement = 1797",
                    "EnumPrefixDecrement = 1798",
                    "PointerPostfixIncrement = 2563",
                    "PointerPostfixDecrement = 2564",
                    "PointerPrefixIncrement = 2565",
                    "PointerPrefixDecrement = 2566",
                    "DynamicBitwiseNegation = 2049",
                    "DynamicLogicalNot = 2050",
                    "DynamicTrue = 2057",
                    "DynamicFalse = 2058",
                    "DynamicPlus = 2055",
                    "DynamicMinus = 2056",
                    "DynamicPostfixIncrement = 2051",
                    "DynamicPostfixDecrement = 2052",
                    "DynamicPrefixIncrement = 2053",
                    "DynamicPrefixDecrement = 2054",
                    "ObjectPlus = 2311",
                    "ObjectMinus = 2312",
                    "ObjectNot = 2315",
                    "Invalid = 65535"
                  ]
                },
                {
                  "type": "public enum Microsoft.CodeAnalysis.Text.SourceHashAlgorithm",
                  "members": [
                    "None = 0",
                    "Sha1 = 1",
                    "Sha256 = 2"
                  ]
                },
                {
                  "type": "public enum Roslynator.Visibility",
                  "members": [
                    "NotApplicable = 0",
                    "Private = 1",
                    "Internal = 2",
                    "Public = 3"
                  ]
                },
                {
                  "type": "public enum Roslynator.CSharp.CommentKinds",
                  "members": [
                    "None = 0",
                    "SingleLine = 1",
                    "MultiLine = 2",
                    "NonDocumentation = SingleLine | MultiLine",
                    "SingleLineDocumentation = 4",
                    "MultiLineDocumentation = 8",
                    "Documentation = SingleLineDocumentation | MultiLineDocumentation",
                    "All = NonDocumentation | Documentation"
                  ]
                },
                {
                  "type": "public enum Roslynator.CSharp.ModifierKinds",
                  "members": [
                    "None = 0",
                    "New = 1",
                    "Public = 2",
                    "Private = 4",
                    "Protected = 8",
                    "Internal = 16",
                    "Accessibility = Public | Private | Protected | Internal",
                    "Const = 32",
                    "Static = 64",
                    "Virtual = 128",
                    "Sealed = 256",
                    "Override = 512",
                    "Abstract = 1024",
                    "AbstractVirtualOverride = Virtual | Override | Abstract",
                    "ReadOnly = 2048",
                    "Extern = 4096",
                    "Unsafe = 8192",
                    "Volatile = 16384",
                    "Async = 32768",
                    "Partial = 65536",
                    "Ref = 131072",
                    "Out = 262144",
                    "In = 524288",
                    "Params = 1048576",
                    "This = 2097152"
                  ]
                },
                {
                  "type": "public enum Roslynator.CSharp.NullCheckStyles",
                  "members": [
                    "None = 0",
                    "EqualsToNull = 1",
                    "NotEqualsToNull = 2",
                    "ComparisonToNull = EqualsToNull | NotEqualsToNull",
                    "IsNull = 4",
                    "NotIsNull = 8",
                    "IsPattern = IsNull | NotIsNull",
                    "NotHasValue = 16",
                    "CheckingNull = EqualsToNull | IsNull | NotHasValue",
                    "HasValue = 32",
                    "CheckingNotNull = NotEqualsToNull | NotIsNull | HasValue",
                    "HasValueProperty = NotHasValue | HasValue",
                    "All = ComparisonToNull | IsPattern | HasValueProperty"
                  ]
                },
                {
                  "type": "public enum Roslynator.CSharp.PreprocessorDirectiveKinds",
                  "members": [
                    "None = 0",
                    "If = 1",
                    "Elif = 2",
                    "Else = 4",
                    "EndIf = 8",
                    "Region = 16",
                    "EndRegion = 32",
                    "Define = 64",
                    "Undef = 128",
                    "Error = 256",
                    "Warning = 512",
                    "Line = 1024",
                    "PragmaWarning = 2048",
                    "PragmaChecksum = 4096",
                    "Pragma = PragmaWarning | PragmaChecksum",
                    "Reference = 8192",
                    "Load = 16384",
                    "Bad = 32768",
                    "Shebang = 65536",
                    "All = If | Elif | Else | EndIf | Region | EndRegion | Define | Undef | Error | Warning | Line | Pragma | Reference | Load | Bad | Shebang"
                  ]
                }
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.ChildSyntaxList : IEquatable<ChildSyntaxList>, IEnumerable<SyntaxNodeOrToken>, IReadOnlyCollection<SyntaxNodeOrToken>, IReadOnlyList<SyntaxNodeOrToken>",
              "members": [
                "public int Count { get; }",
                "public SyntaxNodeOrToken this[int index] { get; }",
                "public bool Any()",
                "public override bool Equals(object obj)",
                "public bool Equals(ChildSyntaxList other)",
                "public SyntaxNodeOrToken First()",
                "public ChildSyntaxList.Enumerator GetEnumerator()",
                "public override int GetHashCode()",
                "public SyntaxNodeOrToken Last()",
                "public ChildSyntaxList.Reversed Reverse()",
                "public static bool operator ==(ChildSyntaxList list1, ChildSyntaxList list2)",
                "public static bool operator !=(ChildSyntaxList list1, ChildSyntaxList list2)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.ChildSyntaxList.Enumerator",
              "members": [
                "public SyntaxNodeOrToken Current { get; }",
                "public bool MoveNext()",
                "public void Reset()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.ChildSyntaxList.Reversed : IEquatable<ChildSyntaxList.Reversed>, IEnumerable<SyntaxNodeOrToken>",
              "members": [
                "public override bool Equals(object obj)",
                "public bool Equals(ChildSyntaxList.Reversed other)",
                "public ChildSyntaxList.Reversed.Enumerator GetEnumerator()",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.ChildSyntaxList.Reversed.Enumerator",
              "members": [
                "public SyntaxNodeOrToken Current { get; }",
                "public bool MoveNext()",
                "public void Reset()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.CommandLineAnalyzerReference : IEquatable<CommandLineAnalyzerReference>",
              "members": [
                "public CommandLineAnalyzerReference(string path)",
                "public string FilePath { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(CommandLineAnalyzerReference other)",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.CommandLineReference : IEquatable<CommandLineReference>",
              "members": [
                "public CommandLineReference(string reference, MetadataReferenceProperties properties)",
                "public MetadataReferenceProperties Properties { get; }",
                "public string Reference { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(CommandLineReference other)",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.CommandLineSourceFile",
              "members": [
                "public CommandLineSourceFile(string path, bool isScript)",
                "public bool IsScript { get; }",
                "public string Path { get; }"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.FileLinePositionSpan : IEquatable<FileLinePositionSpan>",
              "members": [
                "public FileLinePositionSpan(string path, LinePositionSpan span)",
                "public FileLinePositionSpan(string path, LinePosition start, LinePosition end)",
                "public LinePosition EndLinePosition { get; }",
                "public bool HasMappedPath { get; }",
                "public bool IsValid { get; }",
                "public string Path { get; }",
                "public LinePositionSpan Span { get; }",
                "public LinePosition StartLinePosition { get; }",
                "public bool Equals(FileLinePositionSpan other)",
                "public override bool Equals(object other)",
                "public override int GetHashCode()",
                "public override string ToString()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.MetadataReferenceProperties : IEquatable<MetadataReferenceProperties>",
              "members": [
                "public MetadataReferenceProperties(MetadataImageKind kind = Assembly, ImmutableArray<string> aliases = default, bool embedInteropTypes = false)",
                "public ImmutableArray<string> Aliases { get; }",
                "public static MetadataReferenceProperties Assembly { get; }",
                "public bool EmbedInteropTypes { get; }",
                "public static string GlobalAlias { get; }",
                "public MetadataImageKind Kind { get; }",
                "public static MetadataReferenceProperties Module { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(MetadataReferenceProperties other)",
                "public override int GetHashCode()",
                "public MetadataReferenceProperties WithAliases(IEnumerable<string> aliases)",
                "public MetadataReferenceProperties WithAliases(ImmutableArray<string> aliases)",
                "public MetadataReferenceProperties WithEmbedInteropTypes(bool embedInteropTypes)",
                "public static bool operator ==(MetadataReferenceProperties left, MetadataReferenceProperties right)",
                "public static bool operator !=(MetadataReferenceProperties left, MetadataReferenceProperties right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Optional<T>",
              "members": [
                "public Optional(T value)",
                "public bool HasValue { get; }",
                "public T Value { get; }",
                "public static implicit operator Optional<T>(T value)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.PreprocessingSymbolInfo : IEquatable<PreprocessingSymbolInfo>",
              "members": [
                "public bool IsDefined { get; }",
                "public IPreprocessingSymbol Symbol { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(PreprocessingSymbolInfo other)",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.ProjectChanges",
              "members": [
                "public Project NewProject { get; }",
                "public Project OldProject { get; }",
                "public ProjectId ProjectId { get; }",
                "public IEnumerable<DocumentId> GetAddedAdditionalDocuments()",
                "public IEnumerable<AnalyzerReference> GetAddedAnalyzerReferences()",
                "public IEnumerable<DocumentId> GetAddedDocuments()",
                "public IEnumerable<MetadataReference> GetAddedMetadataReferences()",
                "public IEnumerable<ProjectReference> GetAddedProjectReferences()",
                "public IEnumerable<DocumentId> GetChangedAdditionalDocuments()",
                "public IEnumerable<DocumentId> GetChangedDocuments()",
                "public IEnumerable<DocumentId> GetRemovedAdditionalDocuments()",
                "public IEnumerable<AnalyzerReference> GetRemovedAnalyzerReferences()",
                "public IEnumerable<DocumentId> GetRemovedDocuments()",
                "public IEnumerable<MetadataReference> GetRemovedMetadataReferences()",
                "public IEnumerable<ProjectReference> GetRemovedProjectReferences()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> : IEquatable<SeparatedSyntaxList<TNode>>, IEnumerable<TNode>, IReadOnlyCollection<TNode>, IReadOnlyList<TNode> where TNode : SyntaxNode",
              "members": [
                "public int Count { get; }",
                "public TextSpan FullSpan { get; }",
                "public int SeparatorCount { get; }",
                "public TextSpan Span { get; }",
                "public TNode this[int index] { get; }",
                "public SeparatedSyntaxList<TNode> Add(TNode node)",
                "public SeparatedSyntaxList<TNode> AddRange(IEnumerable<TNode> nodes)",
                "public bool Any()",
                "public bool Contains(TNode node)",
                "public override bool Equals(object obj)",
                "public bool Equals(SeparatedSyntaxList<TNode> other)",
                "public TNode First()",
                "public TNode FirstOrDefault()",
                "public SeparatedSyntaxList<TNode>.Enumerator GetEnumerator()",
                "public override int GetHashCode()",
                "public SyntaxToken GetSeparator(int index)",
                "public IEnumerable<SyntaxToken> GetSeparators()",
                "public SyntaxNodeOrTokenList GetWithSeparators()",
                "public int IndexOf(TNode node)",
                "public int IndexOf(Func<TNode, bool> predicate)",
                "public SeparatedSyntaxList<TNode> Insert(int index, TNode node)",
                "public SeparatedSyntaxList<TNode> InsertRange(int index, IEnumerable<TNode> nodes)",
                "public TNode Last()",
                "public int LastIndexOf(TNode node)",
                "public int LastIndexOf(Func<TNode, bool> predicate)",
                "public TNode LastOrDefault()",
                "public SeparatedSyntaxList<TNode> Remove(TNode node)",
                "public SeparatedSyntaxList<TNode> RemoveAt(int index)",
                "public SeparatedSyntaxList<TNode> Replace(TNode nodeInList, TNode newNode)",
                "public SeparatedSyntaxList<TNode> ReplaceRange(TNode nodeInList, IEnumerable<TNode> newNodes)",
                "public SeparatedSyntaxList<TNode> ReplaceSeparator(SyntaxToken separatorToken, SyntaxToken newSeparator)",
                "public string ToFullString()",
                "public override string ToString()",
                "public static implicit operator SeparatedSyntaxList<SyntaxNode>(SeparatedSyntaxList<TNode> nodes)",
                "public static implicit operator SeparatedSyntaxList<TNode>(SeparatedSyntaxList<SyntaxNode> nodes)",
                "public static bool operator ==(SeparatedSyntaxList<TNode> left, SeparatedSyntaxList<TNode> right)",
                "public static bool operator !=(SeparatedSyntaxList<TNode> left, SeparatedSyntaxList<TNode> right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode>.Enumerator",
              "members": [
                "public TNode Current { get; }",
                "public override bool Equals(object obj)",
                "public override int GetHashCode()",
                "public bool MoveNext()",
                "public void Reset()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SolutionChanges",
              "members": [
                "public IEnumerable<Project> GetAddedProjects()",
                "public IEnumerable<ProjectChanges> GetProjectChanges()",
                "public IEnumerable<Project> GetRemovedProjects()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SubsystemVersion : IEquatable<SubsystemVersion>",
              "members": [
                "public bool IsValid { get; }",
                "public int Major { get; }",
                "public int Minor { get; }",
                "public static SubsystemVersion None { get; }",
                "public static SubsystemVersion Windows2000 { get; }",
                "public static SubsystemVersion Windows7 { get; }",
                "public static SubsystemVersion Windows8 { get; }",
                "public static SubsystemVersion WindowsVista { get; }",
                "public static SubsystemVersion WindowsXP { get; }",
                "public static SubsystemVersion Create(int major, int minor)",
                "public override bool Equals(object obj)",
                "public bool Equals(SubsystemVersion other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool TryParse(string str, out SubsystemVersion version)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SymbolDisplayPart",
              "members": [
                "public SymbolDisplayPart(SymbolDisplayPartKind kind, ISymbol symbol, string text)",
                "public SymbolDisplayPartKind Kind { get; }",
                "public ISymbol Symbol { get; }",
                "public override string ToString()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SymbolInfo : IEquatable<SymbolInfo>",
              "members": [
                "public CandidateReason CandidateReason { get; }",
                "public ImmutableArray<ISymbol> CandidateSymbols { get; }",
                "public ISymbol Symbol { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(SymbolInfo other)",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SyntaxList<TNode> : IEquatable<SyntaxList<TNode>>, IEnumerable<TNode>, IReadOnlyCollection<TNode>, IReadOnlyList<TNode> where TNode : SyntaxNode",
              "members": [
                "public int Count { get; }",
                "public TextSpan FullSpan { get; }",
                "public TextSpan Span { get; }",
                "public TNode this[int index] { get; }",
                "public SyntaxList<TNode> Add(TNode node)",
                "public SyntaxList<TNode> AddRange(IEnumerable<TNode> nodes)",
                "public bool Any()",
                "public override bool Equals(object obj)",
                "public bool Equals(SyntaxList<TNode> other)",
                "public TNode First()",
                "public TNode FirstOrDefault()",
                "public SyntaxList<TNode>.Enumerator GetEnumerator()",
                "public override int GetHashCode()",
                "public int IndexOf(TNode node)",
                "public int IndexOf(Func<TNode, bool> predicate)",
                "public SyntaxList<TNode> Insert(int index, TNode node)",
                "public SyntaxList<TNode> InsertRange(int index, IEnumerable<TNode> nodes)",
                "public TNode Last()",
                "public int LastIndexOf(TNode node)",
                "public int LastIndexOf(Func<TNode, bool> predicate)",
                "public TNode LastOrDefault()",
                "public SyntaxList<TNode> Remove(TNode node)",
                "public SyntaxList<TNode> RemoveAt(int index)",
                "public SyntaxList<TNode> Replace(TNode nodeInList, TNode newNode)",
                "public SyntaxList<TNode> ReplaceRange(TNode nodeInList, IEnumerable<TNode> newNodes)",
                "public string ToFullString()",
                "public override string ToString()",
                "public static implicit operator SyntaxList<TNode>(SyntaxList<SyntaxNode> nodes)",
                "public static implicit operator SyntaxList<SyntaxNode>(SyntaxList<TNode> nodes)",
                "public static bool operator ==(SyntaxList<TNode> left, SyntaxList<TNode> right)",
                "public static bool operator !=(SyntaxList<TNode> left, SyntaxList<TNode> right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SyntaxList<TNode>.Enumerator",
              "members": [
                "public TNode Current { get; }",
                "public override bool Equals(object obj)",
                "public override int GetHashCode()",
                "public bool MoveNext()",
                "public void Reset()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SyntaxNodeOrToken : IEquatable<SyntaxNodeOrToken>",
              "members": [
                "public bool ContainsAnnotations { get; }",
                "public bool ContainsDiagnostics { get; }",
                "public bool ContainsDirectives { get; }",
                "public TextSpan FullSpan { get; }",
                "public bool HasLeadingTrivia { get; }",
                "public bool HasTrailingTrivia { get; }",
                "public bool IsMissing { get; }",
                "public bool IsNode { get; }",
                "public bool IsToken { get; }",
                "public string Language { get; }",
                "public SyntaxNode Parent { get; }",
                "public int RawKind { get; }",
                "public TextSpan Span { get; }",
                "public int SpanStart { get; }",
                "public SyntaxTree SyntaxTree { get; }",
                "public SyntaxNode AsNode()",
                "public SyntaxToken AsToken()",
                "public ChildSyntaxList ChildNodesAndTokens()",
                "public override bool Equals(object obj)",
                "public bool Equals(SyntaxNodeOrToken other)",
                "public IEnumerable<SyntaxAnnotation> GetAnnotations(string annotationKind)",
                "public IEnumerable<SyntaxAnnotation> GetAnnotations(IEnumerable<string> annotationKinds)",
                "public IEnumerable<Diagnostic> GetDiagnostics()",
                "public static int GetFirstChildIndexSpanningPosition(SyntaxNode node, int position)",
                "public override int GetHashCode()",
                "public SyntaxTriviaList GetLeadingTrivia()",
                "public Location GetLocation()",
                "public SyntaxNodeOrToken GetNextSibling()",
                "public SyntaxNodeOrToken GetPreviousSibling()",
                "public SyntaxTriviaList GetTrailingTrivia()",
                "public bool HasAnnotation(SyntaxAnnotation annotation)",
                "public bool HasAnnotations(string annotationKind)",
                "public bool HasAnnotations(IEnumerable<string> annotationKinds)",
                "public bool IsEquivalentTo(SyntaxNodeOrToken other)",
                "public string ToFullString()",
                "public override string ToString()",
                "public SyntaxNodeOrToken WithAdditionalAnnotations(params SyntaxAnnotation[] annotations)",
                "public SyntaxNodeOrToken WithAdditionalAnnotations(IEnumerable<SyntaxAnnotation> annotations)",
                "public SyntaxNodeOrToken WithLeadingTrivia(IEnumerable<SyntaxTrivia> trivia)",
                "public SyntaxNodeOrToken WithLeadingTrivia(params SyntaxTrivia[] trivia)",
                "public SyntaxNodeOrToken WithTrailingTrivia(IEnumerable<SyntaxTrivia> trivia)",
                "public SyntaxNodeOrToken WithTrailingTrivia(params SyntaxTrivia[] trivia)",
                "public SyntaxNodeOrToken WithoutAnnotations(string annotationKind)",
                "public SyntaxNodeOrToken WithoutAnnotations(params SyntaxAnnotation[] annotations)",
                "public SyntaxNodeOrToken WithoutAnnotations(IEnumerable<SyntaxAnnotation> annotations)",
                "public void WriteTo(TextWriter writer)",
                "public static explicit operator SyntaxToken(SyntaxNodeOrToken nodeOrToken)",
                "public static explicit operator SyntaxNode(SyntaxNodeOrToken nodeOrToken)",
                "public static implicit operator SyntaxNodeOrToken(SyntaxToken token)",
                "public static implicit operator SyntaxNodeOrToken(SyntaxNode node)",
                "public static bool operator ==(SyntaxNodeOrToken left, SyntaxNodeOrToken right)",
                "public static bool operator !=(SyntaxNodeOrToken left, SyntaxNodeOrToken right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SyntaxNodeOrTokenList : IEquatable<SyntaxNodeOrTokenList>, IEnumerable<SyntaxNodeOrToken>, IReadOnlyCollection<SyntaxNodeOrToken>",
              "members": [
                "public int Count { get; }",
                "public TextSpan FullSpan { get; }",
                "public TextSpan Span { get; }",
                "public SyntaxNodeOrToken this[int index] { get; }",
                "public SyntaxNodeOrTokenList Add(SyntaxNodeOrToken nodeOrToken)",
                "public SyntaxNodeOrTokenList AddRange(IEnumerable<SyntaxNodeOrToken> nodesOrTokens)",
                "public bool Any()",
                "public override bool Equals(object obj)",
                "public bool Equals(SyntaxNodeOrTokenList other)",
                "public SyntaxNodeOrToken First()",
                "public SyntaxNodeOrToken FirstOrDefault()",
                "public SyntaxNodeOrTokenList.Enumerator GetEnumerator()",
                "public override int GetHashCode()",
                "public int IndexOf(SyntaxNodeOrToken nodeOrToken)",
                "public SyntaxNodeOrTokenList Insert(int index, SyntaxNodeOrToken nodeOrToken)",
                "public SyntaxNodeOrTokenList InsertRange(int index, IEnumerable<SyntaxNodeOrToken> nodesAndTokens)",
                "public SyntaxNodeOrToken Last()",
                "public SyntaxNodeOrToken LastOrDefault()",
                "public SyntaxNodeOrTokenList Remove(SyntaxNodeOrToken nodeOrTokenInList)",
                "public SyntaxNodeOrTokenList RemoveAt(int index)",
                "public SyntaxNodeOrTokenList Replace(SyntaxNodeOrToken nodeOrTokenInList, SyntaxNodeOrToken newNodeOrToken)",
                "public SyntaxNodeOrTokenList ReplaceRange(SyntaxNodeOrToken nodeOrTokenInList, IEnumerable<SyntaxNodeOrToken> newNodesAndTokens)",
                "public string ToFullString()",
                "public override string ToString()",
                "public static bool operator ==(SyntaxNodeOrTokenList left, SyntaxNodeOrTokenList right)",
                "public static bool operator !=(SyntaxNodeOrTokenList left, SyntaxNodeOrTokenList right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator : IDisposable, IEnumerator, IEnumerator<SyntaxNodeOrToken>",
              "members": [
                "public SyntaxNodeOrToken Current { get; }",
                "public override bool Equals(object obj)",
                "public override int GetHashCode()",
                "public bool MoveNext()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SyntaxToken : IEquatable<SyntaxToken>",
              "members": [
                "public bool ContainsAnnotations { get; }",
                "public bool ContainsDiagnostics { get; }",
                "public bool ContainsDirectives { get; }",
                "public TextSpan FullSpan { get; }",
                "public bool HasLeadingTrivia { get; }",
                "public bool HasStructuredTrivia { get; }",
                "public bool HasTrailingTrivia { get; }",
                "public bool IsMissing { get; }",
                "public string Language { get; }",
                "public SyntaxTriviaList LeadingTrivia { get; }",
                "public SyntaxNode Parent { get; }",
                "public int RawKind { get; }",
                "public TextSpan Span { get; }",
                "public int SpanStart { get; }",
                "public SyntaxTree SyntaxTree { get; }",
                "public string Text { get; }",
                "public SyntaxTriviaList TrailingTrivia { get; }",
                "public object Value { get; }",
                "public string ValueText { get; }",
                "public SyntaxToken CopyAnnotationsTo(SyntaxToken token)",
                "public override bool Equals(object obj)",
                "public bool Equals(SyntaxToken other)",
                "public IEnumerable<SyntaxTrivia> GetAllTrivia()",
                "public IEnumerable<SyntaxAnnotation> GetAnnotations(string annotationKind)",
                "public IEnumerable<SyntaxAnnotation> GetAnnotations(params string[] annotationKinds)",
                "public IEnumerable<SyntaxAnnotation> GetAnnotations(IEnumerable<string> annotationKinds)",
                "public IEnumerable<Diagnostic> GetDiagnostics()",
                "public override int GetHashCode()",
                "public Location GetLocation()",
                "public SyntaxToken GetNextToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false)",
                "public SyntaxToken GetPreviousToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false)",
                "public bool HasAnnotation(SyntaxAnnotation annotation)",
                "public bool HasAnnotations(string annotationKind)",
                "public bool HasAnnotations(params string[] annotationKinds)",
                "public bool IsEquivalentTo(SyntaxToken token)",
                "public bool IsPartOfStructuredTrivia()",
                "public string ToFullString()",
                "public override string ToString()",
                "public SyntaxToken WithAdditionalAnnotations(params SyntaxAnnotation[] annotations)",
                "public SyntaxToken WithAdditionalAnnotations(IEnumerable<SyntaxAnnotation> annotations)",
                "public SyntaxToken WithLeadingTrivia(SyntaxTriviaList trivia)",
                "public SyntaxToken WithLeadingTrivia(params SyntaxTrivia[] trivia)",
                "public SyntaxToken WithLeadingTrivia(IEnumerable<SyntaxTrivia> trivia)",
                "public SyntaxToken WithTrailingTrivia(SyntaxTriviaList trivia)",
                "public SyntaxToken WithTrailingTrivia(params SyntaxTrivia[] trivia)",
                "public SyntaxToken WithTrailingTrivia(IEnumerable<SyntaxTrivia> trivia)",
                "public SyntaxToken WithTriviaFrom(SyntaxToken token)",
                "public SyntaxToken WithoutAnnotations(string annotationKind)",
                "public SyntaxToken WithoutAnnotations(params SyntaxAnnotation[] annotations)",
                "public SyntaxToken WithoutAnnotations(IEnumerable<SyntaxAnnotation> annotations)",
                "public void WriteTo(TextWriter writer)",
                "public static bool operator ==(SyntaxToken left, SyntaxToken right)",
                "public static bool operator !=(SyntaxToken left, SyntaxToken right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SyntaxTokenList : IEquatable<SyntaxTokenList>, IEnumerable<SyntaxToken>, IReadOnlyCollection<SyntaxToken>, IReadOnlyList<SyntaxToken>",
              "members": [
                "public int Count { get; }",
                "public TextSpan FullSpan { get; }",
                "public TextSpan Span { get; }",
                "public SyntaxToken this[int index] { get; }",
                "public SyntaxTokenList Add(SyntaxToken token)",
                "public SyntaxTokenList AddRange(IEnumerable<SyntaxToken> tokens)",
                "public bool Any()",
                "public static SyntaxTokenList Create(SyntaxToken token)",
                "public override bool Equals(object obj)",
                "public bool Equals(SyntaxTokenList other)",
                "public SyntaxToken First()",
                "public SyntaxTokenList.Enumerator GetEnumerator()",
                "public override int GetHashCode()",
                "public int IndexOf(SyntaxToken tokenInList)",
                "public SyntaxTokenList Insert(int index, SyntaxToken token)",
                "public SyntaxTokenList InsertRange(int index, IEnumerable<SyntaxToken> tokens)",
                "public SyntaxToken Last()",
                "public SyntaxTokenList Remove(SyntaxToken tokenInList)",
                "public SyntaxTokenList RemoveAt(int index)",
                "public SyntaxTokenList Replace(SyntaxToken tokenInList, SyntaxToken newToken)",
                "public SyntaxTokenList ReplaceRange(SyntaxToken tokenInList, IEnumerable<SyntaxToken> newTokens)",
                "public SyntaxTokenList.Reversed Reverse()",
                "public string ToFullString()",
                "public override string ToString()",
                "public static bool operator ==(SyntaxTokenList left, SyntaxTokenList right)",
                "public static bool operator !=(SyntaxTokenList left, SyntaxTokenList right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SyntaxTokenList.Enumerator",
              "members": [
                "public SyntaxToken Current { get; }",
                "public override bool Equals(object obj)",
                "public override int GetHashCode()",
                "public bool MoveNext()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SyntaxTokenList.Reversed : IEquatable<SyntaxTokenList.Reversed>, IEnumerable<SyntaxToken>",
              "members": [
                "public Reversed(SyntaxTokenList list)",
                "public override bool Equals(object obj)",
                "public bool Equals(SyntaxTokenList.Reversed other)",
                "public SyntaxTokenList.Reversed.Enumerator GetEnumerator()",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SyntaxTokenList.Reversed.Enumerator",
              "members": [
                "public Enumerator(ref SyntaxTokenList list)",
                "public SyntaxToken Current { get; }",
                "public override bool Equals(object obj)",
                "public override int GetHashCode()",
                "public bool MoveNext()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SyntaxTrivia : IEquatable<SyntaxTrivia>",
              "members": [
                "public bool ContainsDiagnostics { get; }",
                "public TextSpan FullSpan { get; }",
                "public bool HasStructure { get; }",
                "public bool IsDirective { get; }",
                "public string Language { get; }",
                "public int RawKind { get; }",
                "public TextSpan Span { get; }",
                "public int SpanStart { get; }",
                "public SyntaxTree SyntaxTree { get; }",
                "public SyntaxToken Token { get; }",
                "public SyntaxTrivia CopyAnnotationsTo(SyntaxTrivia trivia)",
                "public override bool Equals(object obj)",
                "public bool Equals(SyntaxTrivia other)",
                "public IEnumerable<SyntaxAnnotation> GetAnnotations(string annotationKind)",
                "public IEnumerable<SyntaxAnnotation> GetAnnotations(params string[] annotationKinds)",
                "public IEnumerable<Diagnostic> GetDiagnostics()",
                "public override int GetHashCode()",
                "public Location GetLocation()",
                "public SyntaxNode GetStructure()",
                "public bool HasAnnotation(SyntaxAnnotation annotation)",
                "public bool HasAnnotations(string annotationKind)",
                "public bool HasAnnotations(params string[] annotationKinds)",
                "public bool IsEquivalentTo(SyntaxTrivia trivia)",
                "public bool IsPartOfStructuredTrivia()",
                "public string ToFullString()",
                "public override string ToString()",
                "public SyntaxTrivia WithAdditionalAnnotations(params SyntaxAnnotation[] annotations)",
                "public SyntaxTrivia WithAdditionalAnnotations(IEnumerable<SyntaxAnnotation> annotations)",
                "public SyntaxTrivia WithoutAnnotations(string annotationKind)",
                "public SyntaxTrivia WithoutAnnotations(params SyntaxAnnotation[] annotations)",
                "public SyntaxTrivia WithoutAnnotations(IEnumerable<SyntaxAnnotation> annotations)",
                "public void WriteTo(TextWriter writer)",
                "public static bool operator ==(SyntaxTrivia left, SyntaxTrivia right)",
                "public static bool operator !=(SyntaxTrivia left, SyntaxTrivia right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SyntaxTriviaList : IEquatable<SyntaxTriviaList>, IEnumerable<SyntaxTrivia>, IReadOnlyCollection<SyntaxTrivia>, IReadOnlyList<SyntaxTrivia>",
              "members": [
                "public int Count { get; }",
                "public static SyntaxTriviaList Empty { get; }",
                "public TextSpan FullSpan { get; }",
                "public TextSpan Span { get; }",
                "public SyntaxTrivia this[int index] { get; }",
                "public SyntaxTriviaList Add(SyntaxTrivia trivia)",
                "public SyntaxTriviaList AddRange(IEnumerable<SyntaxTrivia> trivia)",
                "public bool Any()",
                "public static SyntaxTriviaList Create(SyntaxTrivia trivia)",
                "public SyntaxTrivia ElementAt(int index)",
                "public override bool Equals(object obj)",
                "public bool Equals(SyntaxTriviaList other)",
                "public SyntaxTrivia First()",
                "public SyntaxTriviaList.Enumerator GetEnumerator()",
                "public override int GetHashCode()",
                "public int IndexOf(SyntaxTrivia triviaInList)",
                "public SyntaxTriviaList Insert(int index, SyntaxTrivia trivia)",
                "public SyntaxTriviaList InsertRange(int index, IEnumerable<SyntaxTrivia> trivia)",
                "public SyntaxTrivia Last()",
                "public SyntaxTriviaList Remove(SyntaxTrivia triviaInList)",
                "public SyntaxTriviaList RemoveAt(int index)",
                "public SyntaxTriviaList Replace(SyntaxTrivia triviaInList, SyntaxTrivia newTrivia)",
                "public SyntaxTriviaList ReplaceRange(SyntaxTrivia triviaInList, IEnumerable<SyntaxTrivia> newTrivia)",
                "public SyntaxTriviaList.Reversed Reverse()",
                "public string ToFullString()",
                "public override string ToString()",
                "public static bool operator ==(SyntaxTriviaList left, SyntaxTriviaList right)",
                "public static bool operator !=(SyntaxTriviaList left, SyntaxTriviaList right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SyntaxTriviaList.Enumerator",
              "members": [
                "public SyntaxTrivia Current { get; }",
                "public bool MoveNext()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SyntaxTriviaList.Reversed : IEquatable<SyntaxTriviaList.Reversed>, IEnumerable<SyntaxTrivia>",
              "members": [
                "public Reversed(SyntaxTriviaList list)",
                "public override bool Equals(object obj)",
                "public bool Equals(SyntaxTriviaList.Reversed other)",
                "public SyntaxTriviaList.Reversed.Enumerator GetEnumerator()",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.SyntaxTriviaList.Reversed.Enumerator",
              "members": [
                "public Enumerator(ref SyntaxTriviaList list)",
                "public SyntaxTrivia Current { get; }",
                "public bool MoveNext()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.TypeInfo : IEquatable<TypeInfo>",
              "members": [
                "public ITypeSymbol ConvertedType { get; }",
                "public ITypeSymbol Type { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(TypeInfo other)",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.TypedConstant : IEquatable<TypedConstant>",
              "members": [
                "public bool IsNull { get; }",
                "public TypedConstantKind Kind { get; }",
                "public ITypeSymbol Type { get; }",
                "public object Value { get; }",
                "public ImmutableArray<TypedConstant> Values { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(TypedConstant other)",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.VersionStamp : IEquatable<VersionStamp>, IObjectWritable",
              "members": [
                "public static VersionStamp Default { get; }",
                "public static VersionStamp Create()",
                "public static VersionStamp Create(DateTime utcTimeLastModified)",
                "public override bool Equals(object obj)",
                "public bool Equals(VersionStamp version)",
                "public override int GetHashCode()",
                "public VersionStamp GetNewerVersion()",
                "public VersionStamp GetNewerVersion(VersionStamp version)",
                "public override string ToString()",
                "public static bool operator ==(VersionStamp left, VersionStamp right)",
                "public static bool operator !=(VersionStamp left, VersionStamp right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo : IEquatable<AwaitExpressionInfo>",
              "members": [
                "public IMethodSymbol GetAwaiterMethod { get; }",
                "public IMethodSymbol GetResultMethod { get; }",
                "public IPropertySymbol IsCompletedProperty { get; }",
                "public bool IsDynamic { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(AwaitExpressionInfo other)",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.CSharp.Conversion : IEquatable<Conversion>",
              "members": [
                "public bool Exists { get; }",
                "public bool IsAnonymousFunction { get; }",
                "public bool IsBoxing { get; }",
                "public bool IsConstantExpression { get; }",
                "public bool IsDynamic { get; }",
                "public bool IsEnumeration { get; }",
                "public bool IsExplicit { get; }",
                "public bool IsIdentity { get; }",
                "public bool IsImplicit { get; }",
                "public bool IsIntPtr { get; }",
                "public bool IsInterpolatedString { get; }",
                "public bool IsMethodGroup { get; }",
                "public bool IsNullLiteral { get; }",
                "public bool IsNullable { get; }",
                "public bool IsNumeric { get; }",
                "public bool IsPointer { get; }",
                "public bool IsReference { get; }",
                "public bool IsThrow { get; }",
                "public bool IsTupleConversion { get; }",
                "public bool IsTupleLiteralConversion { get; }",
                "public bool IsUnboxing { get; }",
                "public bool IsUserDefined { get; }",
                "public IMethodSymbol MethodSymbol { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(Conversion other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(Conversion left, Conversion right)",
                "public static bool operator !=(Conversion left, Conversion right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo : IEquatable<ForEachStatementInfo>",
              "members": [
                "public Conversion CurrentConversion { get; }",
                "public IPropertySymbol CurrentProperty { get; }",
                "public IMethodSymbol DisposeMethod { get; }",
                "public Conversion ElementConversion { get; }",
                "public ITypeSymbol ElementType { get; }",
                "public IMethodSymbol GetEnumeratorMethod { get; }",
                "public IMethodSymbol MoveNextMethod { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(ForEachStatementInfo other)",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.CSharp.QueryClauseInfo : IEquatable<QueryClauseInfo>",
              "members": [
                "public SymbolInfo CastInfo { get; }",
                "public SymbolInfo OperationInfo { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(QueryClauseInfo other)",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Classification.ClassifiedSpan : IEquatable<ClassifiedSpan>",
              "members": [
                "public ClassifiedSpan(string classificationType, TextSpan textSpan)",
                "public ClassifiedSpan(TextSpan textSpan, string classificationType)",
                "public string ClassificationType { get; }",
                "public TextSpan TextSpan { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(ClassifiedSpan other)",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.CodeFixes.CodeFixContext",
              "members": [
                "public CodeFixContext(Document document, Diagnostic diagnostic, Action<CodeAction, ImmutableArray<Diagnostic>> registerCodeFix, CancellationToken cancellationToken)",
                "public CodeFixContext(Document document, TextSpan span, ImmutableArray<Diagnostic> diagnostics, Action<CodeAction, ImmutableArray<Diagnostic>> registerCodeFix, CancellationToken cancellationToken)",
                "public CancellationToken CancellationToken { get; }",
                "public ImmutableArray<Diagnostic> Diagnostics { get; }",
                "public Document Document { get; }",
                "public TextSpan Span { get; }",
                "public void RegisterCodeFix(CodeAction action, Diagnostic diagnostic)",
                "public void RegisterCodeFix(CodeAction action, IEnumerable<Diagnostic> diagnostics)",
                "public void RegisterCodeFix(CodeAction action, ImmutableArray<Diagnostic> diagnostics)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext",
              "members": [
                "public CodeRefactoringContext(Document document, TextSpan span, Action<CodeAction> registerRefactoring, CancellationToken cancellationToken)",
                "public CancellationToken CancellationToken { get; }",
                "public Document Document { get; }",
                "public TextSpan Span { get; }",
                "public void RegisterRefactoring(CodeAction action)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext",
              "members": [
                "public CodeBlockAnalysisContext(SyntaxNode codeBlock, ISymbol owningSymbol, SemanticModel semanticModel, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken)",
                "public CancellationToken CancellationToken { get; }",
                "public SyntaxNode CodeBlock { get; }",
                "public AnalyzerOptions Options { get; }",
                "public ISymbol OwningSymbol { get; }",
                "public SemanticModel SemanticModel { get; }",
                "public void ReportDiagnostic(Diagnostic diagnostic)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext",
              "members": [
                "public CompilationAnalysisContext(Compilation compilation, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken)",
                "public CancellationToken CancellationToken { get; }",
                "public Compilation Compilation { get; }",
                "public AnalyzerOptions Options { get; }",
                "public void ReportDiagnostic(Diagnostic diagnostic)",
                "public bool TryGetValue<TValue>(SourceText text, SourceTextValueProvider<TValue> valueProvider, out TValue value)",
                "public bool TryGetValue<TValue>(SyntaxTree tree, SyntaxTreeValueProvider<TValue> valueProvider, out TValue value)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext",
              "members": [
                "public OperationAnalysisContext(IOperation operation, ISymbol containingSymbol, Compilation compilation, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken)",
                "public CancellationToken CancellationToken { get; }",
                "public Compilation Compilation { get; }",
                "public ISymbol ContainingSymbol { get; }",
                "public IOperation Operation { get; }",
                "public AnalyzerOptions Options { get; }",
                "public void ReportDiagnostic(Diagnostic diagnostic)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext",
              "members": [
                "public OperationBlockAnalysisContext(ImmutableArray<IOperation> operationBlocks, ISymbol owningSymbol, Compilation compilation, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken)",
                "public CancellationToken CancellationToken { get; }",
                "public Compilation Compilation { get; }",
                "public ImmutableArray<IOperation> OperationBlocks { get; }",
                "public AnalyzerOptions Options { get; }",
                "public ISymbol OwningSymbol { get; }",
                "public void ReportDiagnostic(Diagnostic diagnostic)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext",
              "members": [
                "public SemanticModelAnalysisContext(SemanticModel semanticModel, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken)",
                "public CancellationToken CancellationToken { get; }",
                "public AnalyzerOptions Options { get; }",
                "public SemanticModel SemanticModel { get; }",
                "public void ReportDiagnostic(Diagnostic diagnostic)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext",
              "members": [
                "public SymbolAnalysisContext(ISymbol symbol, Compilation compilation, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken)",
                "public CancellationToken CancellationToken { get; }",
                "public Compilation Compilation { get; }",
                "public AnalyzerOptions Options { get; }",
                "public ISymbol Symbol { get; }",
                "public void ReportDiagnostic(Diagnostic diagnostic)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext",
              "members": [
                "public SyntaxNodeAnalysisContext(SyntaxNode node, SemanticModel semanticModel, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken)",
                "public SyntaxNodeAnalysisContext(SyntaxNode node, ISymbol containingSymbol, SemanticModel semanticModel, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken)",
                "public CancellationToken CancellationToken { get; }",
                "public Compilation Compilation { get; }",
                "public ISymbol ContainingSymbol { get; }",
                "public SyntaxNode Node { get; }",
                "public AnalyzerOptions Options { get; }",
                "public SemanticModel SemanticModel { get; }",
                "public void ReportDiagnostic(Diagnostic diagnostic)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext",
              "members": [
                "public SyntaxTreeAnalysisContext(SyntaxTree tree, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken)",
                "public CancellationToken CancellationToken { get; }",
                "public AnalyzerOptions Options { get; }",
                "public SyntaxTree Tree { get; }",
                "public void ReportDiagnostic(Diagnostic diagnostic)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Differencing.Edit<TNode> : IEquatable<Edit<TNode>>",
              "members": [
                "public EditKind Kind { get; }",
                "public TNode NewNode { get; }",
                "public TNode OldNode { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(Edit<TNode> other)",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Editing.DeclarationModifiers : IEquatable<DeclarationModifiers>",
              "members": [
                "public static DeclarationModifiers Abstract { get; }",
                "public static DeclarationModifiers Async { get; }",
                "public static DeclarationModifiers Const { get; }",
                "public bool IsAbstract { get; }",
                "public bool IsAsync { get; }",
                "public bool IsConst { get; }",
                "public bool IsNew { get; }",
                "public bool IsOverride { get; }",
                "public bool IsPartial { get; }",
                "public bool IsReadOnly { get; }",
                "public bool IsSealed { get; }",
                "public bool IsStatic { get; }",
                "public bool IsUnsafe { get; }",
                "public bool IsVirtual { get; }",
                "public bool IsWithEvents { get; }",
                "public bool IsWriteOnly { get; }",
                "public static DeclarationModifiers New { get; }",
                "public static DeclarationModifiers None { get; }",
                "public static DeclarationModifiers Override { get; }",
                "public static DeclarationModifiers Partial { get; }",
                "public static DeclarationModifiers ReadOnly { get; }",
                "public static DeclarationModifiers Sealed { get; }",
                "public static DeclarationModifiers Static { get; }",
                "public static DeclarationModifiers Unsafe { get; }",
                "public static DeclarationModifiers Virtual { get; }",
                "public static DeclarationModifiers WithEvents { get; }",
                "public static DeclarationModifiers WriteOnly { get; }",
                "public bool Equals(DeclarationModifiers modifiers)",
                "public override bool Equals(object obj)",
                "public static DeclarationModifiers From(ISymbol symbol)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool TryParse(string value, out DeclarationModifiers modifiers)",
                "public DeclarationModifiers WithAsync(bool isAsync)",
                "public DeclarationModifiers WithIsAbstract(bool isAbstract)",
                "public DeclarationModifiers WithIsConst(bool isConst)",
                "public DeclarationModifiers WithIsNew(bool isNew)",
                "public DeclarationModifiers WithIsOverride(bool isOverride)",
                "public DeclarationModifiers WithIsReadOnly(bool isReadOnly)",
                "public DeclarationModifiers WithIsSealed(bool isSealed)",
                "public DeclarationModifiers WithIsStatic(bool isStatic)",
                "public DeclarationModifiers WithIsUnsafe(bool isUnsafe)",
                "public DeclarationModifiers WithIsVirtual(bool isVirtual)",
                "public DeclarationModifiers WithIsWriteOnly(bool isWriteOnly)",
                "public DeclarationModifiers WithPartial(bool isPartial)",
                "public DeclarationModifiers WithWithEvents(bool withEvents)",
                "public static DeclarationModifiers operator +(DeclarationModifiers left, DeclarationModifiers right)",
                "public static DeclarationModifiers operator &(DeclarationModifiers left, DeclarationModifiers right)",
                "public static DeclarationModifiers operator |(DeclarationModifiers left, DeclarationModifiers right)",
                "public static bool operator ==(DeclarationModifiers left, DeclarationModifiers right)",
                "public static bool operator !=(DeclarationModifiers left, DeclarationModifiers right)",
                "public static DeclarationModifiers operator -(DeclarationModifiers left, DeclarationModifiers right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation",
              "members": [
                "public static EditAndContinueMethodDebugInformation Create(ImmutableArray<byte> compressedSlotMap, ImmutableArray<byte> compressedLambdaMap)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Emit.SemanticEdit : IEquatable<SemanticEdit>",
              "members": [
                "public SemanticEdit(SemanticEditKind kind, ISymbol oldSymbol, ISymbol newSymbol, Func<SyntaxNode, SyntaxNode> syntaxMap = null, bool preserveLocalVariables = false)",
                "public SemanticEditKind Kind { get; }",
                "public ISymbol NewSymbol { get; }",
                "public ISymbol OldSymbol { get; }",
                "public bool PreserveLocalVariables { get; }",
                "public Func<SyntaxNode, SyntaxNode> SyntaxMap { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(SemanticEdit other)",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation : IComparable<ReferenceLocation>, IEquatable<ReferenceLocation>",
              "members": [
                "public IAliasSymbol Alias { get; }",
                "public CandidateReason CandidateReason { get; }",
                "public Document Document { get; }",
                "public bool IsCandidateLocation { get; }",
                "public bool IsImplicit { get; }",
                "public Location Location { get; }",
                "public int CompareTo(ReferenceLocation other)",
                "public override bool Equals(object obj)",
                "public bool Equals(ReferenceLocation other)",
                "public override int GetHashCode()",
                "public static bool operator ==(ReferenceLocation left, ReferenceLocation right)",
                "public static bool operator !=(ReferenceLocation left, ReferenceLocation right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo",
              "members": [
                "public ISymbol CalledSymbol { get; }",
                "public ISymbol CallingSymbol { get; }",
                "public bool IsDirect { get; }",
                "public IEnumerable<Location> Locations { get; }"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Options.OptionKey : IEquatable<OptionKey>",
              "members": [
                "public OptionKey(IOption option, string language = null)",
                "public string Language { get; }",
                "public IOption Option { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(OptionKey other)",
                "public override int GetHashCode()",
                "public static bool operator ==(OptionKey left, OptionKey right)",
                "public static bool operator !=(OptionKey left, OptionKey right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Text.LinePosition : IComparable<LinePosition>, IEquatable<LinePosition>",
              "members": [
                "public LinePosition(int line, int character)",
                "public int Character { get; }",
                "public int Line { get; }",
                "public static LinePosition Zero { get; }",
                "public int CompareTo(LinePosition other)",
                "public override bool Equals(object obj)",
                "public bool Equals(LinePosition other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(LinePosition left, LinePosition right)",
                "public static bool operator >(LinePosition left, LinePosition right)",
                "public static bool operator >=(LinePosition left, LinePosition right)",
                "public static bool operator !=(LinePosition left, LinePosition right)",
                "public static bool operator <(LinePosition left, LinePosition right)",
                "public static bool operator <=(LinePosition left, LinePosition right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Text.LinePositionSpan : IEquatable<LinePositionSpan>",
              "members": [
                "public LinePositionSpan(LinePosition start, LinePosition end)",
                "public LinePosition End { get; }",
                "public LinePosition Start { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(LinePositionSpan other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(LinePositionSpan left, LinePositionSpan right)",
                "public static bool operator !=(LinePositionSpan left, LinePositionSpan right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Text.TextChange : IEquatable<TextChange>",
              "members": [
                "public TextChange(TextSpan span, string newText)",
                "public string NewText { get; }",
                "public static IReadOnlyList<TextChange> NoChanges { get; }",
                "public TextSpan Span { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(TextChange other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static implicit operator TextChangeRange(TextChange change)",
                "public static bool operator ==(TextChange left, TextChange right)",
                "public static bool operator !=(TextChange left, TextChange right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Text.TextChangeRange : IEquatable<TextChangeRange>",
              "members": [
                "public TextChangeRange(TextSpan span, int newLength)",
                "public int NewLength { get; }",
                "public static IReadOnlyList<TextChangeRange> NoChanges { get; }",
                "public TextSpan Span { get; }",
                "public static TextChangeRange Collapse(IEnumerable<TextChangeRange> changes)",
                "public override bool Equals(object obj)",
                "public bool Equals(TextChangeRange other)",
                "public override int GetHashCode()",
                "public static bool operator ==(TextChangeRange left, TextChangeRange right)",
                "public static bool operator !=(TextChangeRange left, TextChangeRange right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Text.TextLine : IEquatable<TextLine>",
              "members": [
                "public int End { get; }",
                "public int EndIncludingLineBreak { get; }",
                "public int LineNumber { get; }",
                "public TextSpan Span { get; }",
                "public TextSpan SpanIncludingLineBreak { get; }",
                "public int Start { get; }",
                "public SourceText Text { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(TextLine other)",
                "public static TextLine FromSpan(SourceText text, TextSpan span)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(TextLine left, TextLine right)",
                "public static bool operator !=(TextLine left, TextLine right)"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Text.TextLineCollection.Enumerator : IDisposable, IEnumerator, IEnumerator<TextLine>",
              "members": [
                "public TextLine Current { get; }",
                "public override bool Equals(object obj)",
                "public override int GetHashCode()",
                "public bool MoveNext()"
              ]
            },
            {
              "type": "public struct Microsoft.CodeAnalysis.Text.TextSpan : IComparable<TextSpan>, IEquatable<TextSpan>",
              "members": [
                "public TextSpan(int start, int length)",
                "public int End { get; }",
                "public bool IsEmpty { get; }",
                "public int Length { get; }",
                "public int Start { get; }",
                "public int CompareTo(TextSpan other)",
                "public bool Contains(int position)",
                "public bool Contains(TextSpan span)",
                "public override bool Equals(object obj)",
                "public bool Equals(TextSpan other)",
                "public static TextSpan FromBounds(int start, int end)",
                "public override int GetHashCode()",
                "public TextSpan? Intersection(TextSpan span)",
                "public bool IntersectsWith(int position)",
                "public bool IntersectsWith(TextSpan span)",
                "public TextSpan? Overlap(TextSpan span)",
                "public bool OverlapsWith(TextSpan span)",
                "public override string ToString()",
                "public static bool operator ==(TextSpan left, TextSpan right)",
                "public static bool operator !=(TextSpan left, TextSpan right)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.ExtensionMethodSymbolInfo : IEquatable<ExtensionMethodSymbolInfo>",
              "members": [
                "public bool IsReduced { get; }",
                "public IMethodSymbol ReducedSymbol { get; }",
                "public IMethodSymbol ReducedSymbolOrSymbol { get; }",
                "public IMethodSymbol Symbol { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(ExtensionMethodSymbolInfo other)",
                "public override int GetHashCode()",
                "public static bool operator ==(in ExtensionMethodSymbolInfo info1, in ExtensionMethodSymbolInfo info2)",
                "public static bool operator !=(in ExtensionMethodSymbolInfo info1, in ExtensionMethodSymbolInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.MetadataName : IEquatable<MetadataName>",
              "members": [
                "public MetadataName(IEnumerable<string> containingNamespaces, string name)",
                "public MetadataName(ImmutableArray<string> containingNamespaces, string name)",
                "public MetadataName(IEnumerable<string> containingNamespaces, IEnumerable<string> containingTypes, string name)",
                "public MetadataName(ImmutableArray<string> containingNamespaces, ImmutableArray<string> containingTypes, string name)",
                "public ImmutableArray<string> ContainingNamespaces { get; }",
                "public ImmutableArray<string> ContainingTypes { get; }",
                "public bool IsDefault { get; }",
                "public string Name { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(MetadataName other)",
                "public override int GetHashCode()",
                "public static MetadataName Parse(string name)",
                "public override string ToString()",
                "public static bool TryParse(string name, out MetadataName metadataName)",
                "public static bool operator ==(in MetadataName metadataName1, in MetadataName metadataName2)",
                "public static bool operator !=(in MetadataName metadataName1, in MetadataName metadataName2)"
              ]
            },
            {
              "type": "public struct Roslynator.SeparatedSyntaxListSelection<TNode>.Enumerator",
              "members": [
                "public TNode Current { get; }",
                "public override bool Equals(object obj)",
                "public override int GetHashCode()",
                "public bool MoveNext()",
                "public void Reset()"
              ]
            },
            {
              "type": "public struct Roslynator.SyntaxListSelection<TNode>.Enumerator",
              "members": [
                "public TNode Current { get; }",
                "public override bool Equals(object obj)",
                "public override int GetHashCode()",
                "public bool MoveNext()",
                "public void Reset()"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.ExpressionChain : IEquatable<ExpressionChain>, IEnumerable<ExpressionSyntax>",
              "members": [
                "public BinaryExpressionSyntax BinaryExpression { get; }",
                "public TextSpan? Span { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(ExpressionChain other)",
                "public ExpressionChain.Enumerator GetEnumerator()",
                "public override int GetHashCode()",
                "public ExpressionChain.Reversed Reverse()",
                "public override string ToString()",
                "public static bool operator ==(in ExpressionChain info1, in ExpressionChain info2)",
                "public static bool operator !=(in ExpressionChain info1, in ExpressionChain info2)"
              ]
            },
            {
              "type": "public struct Roslynator.CSharp.ExpressionChain.Enumerator",
              "members": [
                "public ExpressionSyntax Current { get; }",
                "public override bool Equals(object obj)",
                "public override int GetHashCode()",
                "public bool MoveNext()",
                "public void Reset()"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.ExpressionChain.Reversed : IEquatable<ExpressionChain.Reversed>, IEnumerable<ExpressionSyntax>",
              "members": [
                "public Reversed(in ExpressionChain chain)",
                "public override bool Equals(object obj)",
                "public bool Equals(ExpressionChain.Reversed other)",
                "public ExpressionChain.Reversed.Enumerator GetEnumerator()",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in ExpressionChain.Reversed reversed1, in ExpressionChain.Reversed reversed2)",
                "public static bool operator !=(in ExpressionChain.Reversed reversed1, in ExpressionChain.Reversed reversed2)"
              ]
            },
            {
              "type": "public struct Roslynator.CSharp.ExpressionChain.Reversed.Enumerator",
              "members": [
                "public ExpressionSyntax Current { get; }",
                "public override bool Equals(object obj)",
                "public override int GetHashCode()",
                "public bool MoveNext()",
                "public void Reset()"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.IfStatementCascade : IEquatable<IfStatementCascade>, IEnumerable<IfStatementOrElseClause>",
              "members": [
                "public IfStatementSyntax IfStatement { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(IfStatementCascade other)",
                "public IfStatementCascade.Enumerator GetEnumerator()",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in IfStatementCascade cascade1, in IfStatementCascade cascade2)",
                "public static bool operator !=(in IfStatementCascade cascade1, in IfStatementCascade cascade2)"
              ]
            },
            {
              "type": "public struct Roslynator.CSharp.IfStatementCascade.Enumerator",
              "members": [
                "public IfStatementOrElseClause Current { get; }",
                "public override bool Equals(object obj)",
                "public override int GetHashCode()",
                "public bool MoveNext()",
                "public void Reset()"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.IfStatementCascadeInfo : IEquatable<IfStatementCascadeInfo>",
              "members": [
                "public IfStatementCascadeInfo(IfStatementSyntax ifStatement)",
                "public int Count { get; }",
                "public bool EndsWithElse { get; }",
                "public bool EndsWithIf { get; }",
                "public IfStatementSyntax IfStatement { get; }",
                "public bool IsSimpleIf { get; }",
                "public bool IsSimpleIfElse { get; }",
                "public IfStatementOrElseClause Last { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(IfStatementCascadeInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in IfStatementCascadeInfo info1, in IfStatementCascadeInfo info2)",
                "public static bool operator !=(in IfStatementCascadeInfo info1, in IfStatementCascadeInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.IfStatementOrElseClause : IEquatable<IfStatementOrElseClause>",
              "members": [
                "public IfStatementOrElseClause(ElseClauseSyntax elseClause)",
                "public IfStatementOrElseClause(IfStatementSyntax ifStatement)",
                "public TextSpan FullSpan { get; }",
                "public bool IsElse { get; }",
                "public bool IsIf { get; }",
                "public SyntaxKind Kind { get; }",
                "public SyntaxNode Parent { get; }",
                "public TextSpan Span { get; }",
                "public StatementSyntax Statement { get; }",
                "public ElseClauseSyntax AsElse()",
                "public IfStatementSyntax AsIf()",
                "public override bool Equals(object obj)",
                "public bool Equals(IfStatementOrElseClause other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static implicit operator IfStatementOrElseClause(IfStatementSyntax ifStatement)",
                "public static implicit operator IfStatementSyntax(in IfStatementOrElseClause ifOrElse)",
                "public static implicit operator IfStatementOrElseClause(ElseClauseSyntax elseClause)",
                "public static implicit operator ElseClauseSyntax(in IfStatementOrElseClause ifOrElse)",
                "public static bool operator ==(in IfStatementOrElseClause left, in IfStatementOrElseClause right)",
                "public static bool operator !=(in IfStatementOrElseClause left, in IfStatementOrElseClause right)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.AsExpressionInfo : IEquatable<AsExpressionInfo>",
              "members": [
                "public BinaryExpressionSyntax AsExpression { get; }",
                "public ExpressionSyntax Expression { get; }",
                "public SyntaxToken OperatorToken { get; }",
                "public bool Success { get; }",
                "public TypeSyntax Type { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(AsExpressionInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in AsExpressionInfo info1, in AsExpressionInfo info2)",
                "public static bool operator !=(in AsExpressionInfo info1, in AsExpressionInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.AssignmentExpressionInfo : IEquatable<AssignmentExpressionInfo>",
              "members": [
                "public AssignmentExpressionSyntax AssignmentExpression { get; }",
                "public SyntaxKind Kind { get; }",
                "public ExpressionSyntax Left { get; }",
                "public SyntaxToken OperatorToken { get; }",
                "public ExpressionSyntax Right { get; }",
                "public bool Success { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(AssignmentExpressionInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in AssignmentExpressionInfo info1, in AssignmentExpressionInfo info2)",
                "public static bool operator !=(in AssignmentExpressionInfo info1, in AssignmentExpressionInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.BinaryExpressionInfo : IEquatable<BinaryExpressionInfo>",
              "members": [
                "public BinaryExpressionSyntax BinaryExpression { get; }",
                "public SyntaxKind Kind { get; }",
                "public ExpressionSyntax Left { get; }",
                "public SyntaxToken OperatorToken { get; }",
                "public ExpressionSyntax Right { get; }",
                "public bool Success { get; }",
                "public ExpressionChain AsChain()",
                "public override bool Equals(object obj)",
                "public bool Equals(BinaryExpressionInfo other)",
                "public IEnumerable<ExpressionSyntax> Expressions(bool leftToRight = false)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in BinaryExpressionInfo info1, in BinaryExpressionInfo info2)",
                "public static bool operator !=(in BinaryExpressionInfo info1, in BinaryExpressionInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.ConditionalExpressionInfo : IEquatable<ConditionalExpressionInfo>",
              "members": [
                "public SyntaxToken ColonToken { get; }",
                "public ExpressionSyntax Condition { get; }",
                "public ConditionalExpressionSyntax ConditionalExpression { get; }",
                "public SyntaxToken QuestionToken { get; }",
                "public bool Success { get; }",
                "public ExpressionSyntax WhenFalse { get; }",
                "public ExpressionSyntax WhenTrue { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(ConditionalExpressionInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in ConditionalExpressionInfo info1, in ConditionalExpressionInfo info2)",
                "public static bool operator !=(in ConditionalExpressionInfo info1, in ConditionalExpressionInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.GenericInfo : IEquatable<GenericInfo>",
              "members": [
                "public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }",
                "public SyntaxKind Kind { get; }",
                "public SyntaxNode Node { get; }",
                "public bool Success { get; }",
                "public TypeParameterListSyntax TypeParameterList { get; }",
                "public SeparatedSyntaxList<TypeParameterSyntax> TypeParameters { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(GenericInfo other)",
                "public TypeParameterConstraintClauseSyntax FindConstraintClause(string typeParameterName)",
                "public TypeParameterSyntax FindTypeParameter(string name)",
                "public override int GetHashCode()",
                "public GenericInfo RemoveAllConstraintClauses()",
                "public GenericInfo RemoveConstraintClause(TypeParameterConstraintClauseSyntax constraintClause)",
                "public GenericInfo RemoveTypeParameter(TypeParameterSyntax typeParameter)",
                "public override string ToString()",
                "public GenericInfo WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)",
                "public GenericInfo WithTypeParameterList(TypeParameterListSyntax typeParameterList)",
                "public static bool operator ==(in GenericInfo info1, in GenericInfo info2)",
                "public static bool operator !=(in GenericInfo info1, in GenericInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.IsExpressionInfo : IEquatable<IsExpressionInfo>",
              "members": [
                "public ExpressionSyntax Expression { get; }",
                "public BinaryExpressionSyntax IsExpression { get; }",
                "public SyntaxToken OperatorToken { get; }",
                "public bool Success { get; }",
                "public TypeSyntax Type { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(IsExpressionInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in IsExpressionInfo info1, in IsExpressionInfo info2)",
                "public static bool operator !=(in IsExpressionInfo info1, in IsExpressionInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.LocalDeclarationStatementInfo : IEquatable<LocalDeclarationStatementInfo>",
              "members": [
                "public VariableDeclarationSyntax Declaration { get; }",
                "public SyntaxTokenList Modifiers { get; }",
                "public SyntaxToken SemicolonToken { get; }",
                "public LocalDeclarationStatementSyntax Statement { get; }",
                "public bool Success { get; }",
                "public TypeSyntax Type { get; }",
                "public SeparatedSyntaxList<VariableDeclaratorSyntax> Variables { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(LocalDeclarationStatementInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in LocalDeclarationStatementInfo info1, in LocalDeclarationStatementInfo info2)",
                "public static bool operator !=(in LocalDeclarationStatementInfo info1, in LocalDeclarationStatementInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.MemberDeclarationListInfo : IEquatable<MemberDeclarationListInfo>, IReadOnlyList<MemberDeclarationSyntax>",
              "members": [
                "public int Count { get; }",
                "public SyntaxList<MemberDeclarationSyntax> Members { get; }",
                "public SyntaxNode Parent { get; }",
                "public bool Success { get; }",
                "public MemberDeclarationSyntax this[int index] { get; }",
                "public MemberDeclarationListInfo Add(MemberDeclarationSyntax member)",
                "public MemberDeclarationListInfo AddRange(IEnumerable<MemberDeclarationSyntax> members)",
                "public bool Any()",
                "public override bool Equals(object obj)",
                "public bool Equals(MemberDeclarationListInfo other)",
                "public MemberDeclarationSyntax First()",
                "public MemberDeclarationSyntax FirstOrDefault()",
                "public SyntaxList<MemberDeclarationSyntax>.Enumerator GetEnumerator()",
                "public override int GetHashCode()",
                "public int IndexOf(MemberDeclarationSyntax member)",
                "public int IndexOf(Func<MemberDeclarationSyntax, bool> predicate)",
                "public MemberDeclarationListInfo Insert(int index, MemberDeclarationSyntax member)",
                "public MemberDeclarationListInfo InsertRange(int index, IEnumerable<MemberDeclarationSyntax> members)",
                "public MemberDeclarationSyntax Last()",
                "public int LastIndexOf(MemberDeclarationSyntax member)",
                "public int LastIndexOf(Func<MemberDeclarationSyntax, bool> predicate)",
                "public MemberDeclarationSyntax LastOrDefault()",
                "public MemberDeclarationListInfo Remove(MemberDeclarationSyntax member)",
                "public MemberDeclarationListInfo RemoveAt(int index)",
                "public MemberDeclarationListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options)",
                "public MemberDeclarationListInfo Replace(MemberDeclarationSyntax memberInList, MemberDeclarationSyntax newMember)",
                "public MemberDeclarationListInfo ReplaceAt(int index, MemberDeclarationSyntax newMember)",
                "public MemberDeclarationListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode)",
                "public MemberDeclarationListInfo ReplaceRange(MemberDeclarationSyntax memberInList, IEnumerable<MemberDeclarationSyntax> newMembers)",
                "public override string ToString()",
                "public MemberDeclarationListInfo WithMembers(IEnumerable<MemberDeclarationSyntax> members)",
                "public MemberDeclarationListInfo WithMembers(SyntaxList<MemberDeclarationSyntax> members)",
                "public static bool operator ==(in MemberDeclarationListInfo info1, in MemberDeclarationListInfo info2)",
                "public static bool operator !=(in MemberDeclarationListInfo info1, in MemberDeclarationListInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.ModifierListInfo : IEquatable<ModifierListInfo>",
              "members": [
                "public Accessibility ExplicitAccessibility { get; }",
                "public bool IsAbstract { get; }",
                "public bool IsAsync { get; }",
                "public bool IsConst { get; }",
                "public bool IsExtern { get; }",
                "public bool IsIn { get; }",
                "public bool IsNew { get; }",
                "public bool IsOut { get; }",
                "public bool IsOverride { get; }",
                "public bool IsParams { get; }",
                "public bool IsPartial { get; }",
                "public bool IsReadOnly { get; }",
                "public bool IsRef { get; }",
                "public bool IsSealed { get; }",
                "public bool IsStatic { get; }",
                "public bool IsUnsafe { get; }",
                "public bool IsVirtual { get; }",
                "public bool IsVolatile { get; }",
                "public SyntaxTokenList Modifiers { get; }",
                "public SyntaxNode Parent { get; }",
                "public bool Success { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(ModifierListInfo other)",
                "public override int GetHashCode()",
                "public ModifierKinds GetKinds()",
                "public override string ToString()",
                "public ModifierListInfo WithExplicitAccessibility(Accessibility newAccessibility, IComparer<SyntaxKind> comparer = null)",
                "public ModifierListInfo WithModifiers(SyntaxTokenList modifiers)",
                "public ModifierListInfo WithoutExplicitAccessibility()",
                "public static bool operator ==(in ModifierListInfo info1, in ModifierListInfo info2)",
                "public static bool operator !=(in ModifierListInfo info1, in ModifierListInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.NullCheckExpressionInfo : IEquatable<NullCheckExpressionInfo>",
              "members": [
                "public ExpressionSyntax Expression { get; }",
                "public bool IsCheckingNotNull { get; }",
                "public bool IsCheckingNull { get; }",
                "public ExpressionSyntax NullCheckExpression { get; }",
                "public NullCheckStyles Style { get; }",
                "public bool Success { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(NullCheckExpressionInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in NullCheckExpressionInfo info1, in NullCheckExpressionInfo info2)",
                "public static bool operator !=(in NullCheckExpressionInfo info1, in NullCheckExpressionInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.RegionInfo : IEquatable<RegionInfo>",
              "members": [
                "public RegionDirectiveTriviaSyntax Directive { get; }",
                "public EndRegionDirectiveTriviaSyntax EndDirective { get; }",
                "public TextSpan FullSpan { get; }",
                "public bool IsEmpty { get; }",
                "public TextSpan Span { get; }",
                "public bool Success { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(RegionInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in RegionInfo info1, in RegionInfo info2)",
                "public static bool operator !=(in RegionInfo info1, in RegionInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.SimpleAssignmentExpressionInfo : IEquatable<SimpleAssignmentExpressionInfo>",
              "members": [
                "public AssignmentExpressionSyntax AssignmentExpression { get; }",
                "public ExpressionSyntax Left { get; }",
                "public SyntaxToken OperatorToken { get; }",
                "public ExpressionSyntax Right { get; }",
                "public bool Success { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(SimpleAssignmentExpressionInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in SimpleAssignmentExpressionInfo info1, in SimpleAssignmentExpressionInfo info2)",
                "public static bool operator !=(in SimpleAssignmentExpressionInfo info1, in SimpleAssignmentExpressionInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.SimpleAssignmentStatementInfo : IEquatable<SimpleAssignmentStatementInfo>",
              "members": [
                "public AssignmentExpressionSyntax AssignmentExpression { get; }",
                "public ExpressionSyntax Left { get; }",
                "public SyntaxToken OperatorToken { get; }",
                "public ExpressionSyntax Right { get; }",
                "public ExpressionStatementSyntax Statement { get; }",
                "public bool Success { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(SimpleAssignmentStatementInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in SimpleAssignmentStatementInfo info1, in SimpleAssignmentStatementInfo info2)",
                "public static bool operator !=(in SimpleAssignmentStatementInfo info1, in SimpleAssignmentStatementInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.SimpleIfElseInfo : IEquatable<SimpleIfElseInfo>",
              "members": [
                "public ExpressionSyntax Condition { get; }",
                "public ElseClauseSyntax Else { get; }",
                "public IfStatementSyntax IfStatement { get; }",
                "public bool Success { get; }",
                "public StatementSyntax WhenFalse { get; }",
                "public StatementSyntax WhenTrue { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(SimpleIfElseInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in SimpleIfElseInfo info1, in SimpleIfElseInfo info2)",
                "public static bool operator !=(in SimpleIfElseInfo info1, in SimpleIfElseInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.SimpleIfStatementInfo : IEquatable<SimpleIfStatementInfo>",
              "members": [
                "public ExpressionSyntax Condition { get; }",
                "public IfStatementSyntax IfStatement { get; }",
                "public StatementSyntax Statement { get; }",
                "public bool Success { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(SimpleIfStatementInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in SimpleIfStatementInfo info1, in SimpleIfStatementInfo info2)",
                "public static bool operator !=(in SimpleIfStatementInfo info1, in SimpleIfStatementInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.SimpleMemberInvocationExpressionInfo : IEquatable<SimpleMemberInvocationExpressionInfo>",
              "members": [
                "public ArgumentListSyntax ArgumentList { get; }",
                "public SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }",
                "public ExpressionSyntax Expression { get; }",
                "public InvocationExpressionSyntax InvocationExpression { get; }",
                "public MemberAccessExpressionSyntax MemberAccessExpression { get; }",
                "public SimpleNameSyntax Name { get; }",
                "public string NameText { get; }",
                "public SyntaxToken OperatorToken { get; }",
                "public bool Success { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(SimpleMemberInvocationExpressionInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in SimpleMemberInvocationExpressionInfo info1, in SimpleMemberInvocationExpressionInfo info2)",
                "public static bool operator !=(in SimpleMemberInvocationExpressionInfo info1, in SimpleMemberInvocationExpressionInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.SimpleMemberInvocationStatementInfo : IEquatable<SimpleMemberInvocationStatementInfo>",
              "members": [
                "public ArgumentListSyntax ArgumentList { get; }",
                "public SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }",
                "public ExpressionSyntax Expression { get; }",
                "public InvocationExpressionSyntax InvocationExpression { get; }",
                "public MemberAccessExpressionSyntax MemberAccessExpression { get; }",
                "public SimpleNameSyntax Name { get; }",
                "public string NameText { get; }",
                "public ExpressionStatementSyntax Statement { get; }",
                "public bool Success { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(SimpleMemberInvocationStatementInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in SimpleMemberInvocationStatementInfo info1, in SimpleMemberInvocationStatementInfo info2)",
                "public static bool operator !=(in SimpleMemberInvocationStatementInfo info1, in SimpleMemberInvocationStatementInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.SingleLocalDeclarationStatementInfo : IEquatable<SingleLocalDeclarationStatementInfo>",
              "members": [
                "public VariableDeclarationSyntax Declaration { get; }",
                "public VariableDeclaratorSyntax Declarator { get; }",
                "public SyntaxToken EqualsToken { get; }",
                "public SyntaxToken Identifier { get; }",
                "public string IdentifierText { get; }",
                "public EqualsValueClauseSyntax Initializer { get; }",
                "public SyntaxTokenList Modifiers { get; }",
                "public SyntaxToken SemicolonToken { get; }",
                "public LocalDeclarationStatementSyntax Statement { get; }",
                "public bool Success { get; }",
                "public TypeSyntax Type { get; }",
                "public ExpressionSyntax Value { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(SingleLocalDeclarationStatementInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in SingleLocalDeclarationStatementInfo info1, in SingleLocalDeclarationStatementInfo info2)",
                "public static bool operator !=(in SingleLocalDeclarationStatementInfo info1, in SingleLocalDeclarationStatementInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.SingleParameterLambdaExpressionInfo : IEquatable<SingleParameterLambdaExpressionInfo>",
              "members": [
                "public CSharpSyntaxNode Body { get; }",
                "public bool IsParenthesizedLambda { get; }",
                "public bool IsSimpleLambda { get; }",
                "public LambdaExpressionSyntax LambdaExpression { get; }",
                "public ParameterSyntax Parameter { get; }",
                "public ParameterListSyntax ParameterList { get; }",
                "public bool Success { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(SingleParameterLambdaExpressionInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in SingleParameterLambdaExpressionInfo info1, in SingleParameterLambdaExpressionInfo info2)",
                "public static bool operator !=(in SingleParameterLambdaExpressionInfo info1, in SingleParameterLambdaExpressionInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.StatementListInfo : IEquatable<StatementListInfo>, IReadOnlyList<StatementSyntax>",
              "members": [
                "public int Count { get; }",
                "public bool IsParentBlock { get; }",
                "public bool IsParentSwitchSection { get; }",
                "public SyntaxNode Parent { get; }",
                "public BlockSyntax ParentAsBlock { get; }",
                "public SwitchSectionSyntax ParentAsSwitchSection { get; }",
                "public SyntaxList<StatementSyntax> Statements { get; }",
                "public bool Success { get; }",
                "public StatementSyntax this[int index] { get; }",
                "public StatementListInfo Add(StatementSyntax statement)",
                "public StatementListInfo AddRange(IEnumerable<StatementSyntax> statements)",
                "public bool Any()",
                "public override bool Equals(object obj)",
                "public bool Equals(StatementListInfo other)",
                "public StatementSyntax First()",
                "public StatementSyntax FirstOrDefault()",
                "public SyntaxList<StatementSyntax>.Enumerator GetEnumerator()",
                "public override int GetHashCode()",
                "public int IndexOf(Func<StatementSyntax, bool> predicate)",
                "public int IndexOf(StatementSyntax statement)",
                "public StatementListInfo Insert(int index, StatementSyntax statement)",
                "public StatementListInfo InsertRange(int index, IEnumerable<StatementSyntax> statements)",
                "public StatementSyntax Last()",
                "public int LastIndexOf(Func<StatementSyntax, bool> predicate)",
                "public int LastIndexOf(StatementSyntax statement)",
                "public StatementSyntax LastOrDefault()",
                "public StatementListInfo Remove(StatementSyntax statement)",
                "public StatementListInfo RemoveAt(int index)",
                "public StatementListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options)",
                "public StatementListInfo Replace(StatementSyntax statementInList, StatementSyntax newStatement)",
                "public StatementListInfo ReplaceAt(int index, StatementSyntax newStatement)",
                "public StatementListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode)",
                "public StatementListInfo ReplaceRange(StatementSyntax statementInList, IEnumerable<StatementSyntax> newStatements)",
                "public override string ToString()",
                "public StatementListInfo WithStatements(IEnumerable<StatementSyntax> statements)",
                "public StatementListInfo WithStatements(SyntaxList<StatementSyntax> statements)",
                "public static bool operator ==(in StatementListInfo info1, in StatementListInfo info2)",
                "public static bool operator !=(in StatementListInfo info1, in StatementListInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.StringConcatenationExpressionInfo : IEquatable<StringConcatenationExpressionInfo>",
              "members": [
                "public BinaryExpressionSyntax BinaryExpression { get; }",
                "public bool Success { get; }",
                "public ExpressionChain AsChain()",
                "public override bool Equals(object obj)",
                "public bool Equals(StringConcatenationExpressionInfo other)",
                "public IEnumerable<ExpressionSyntax> Expressions(bool leftToRight = false)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in StringConcatenationExpressionInfo info1, in StringConcatenationExpressionInfo info2)",
                "public static bool operator !=(in StringConcatenationExpressionInfo info1, in StringConcatenationExpressionInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.StringLiteralExpressionInfo : IEquatable<StringLiteralExpressionInfo>",
              "members": [
                "public bool ContainsEscapeSequence { get; }",
                "public bool ContainsLinefeed { get; }",
                "public LiteralExpressionSyntax Expression { get; }",
                "public string InnerText { get; }",
                "public bool IsRegular { get; }",
                "public bool IsVerbatim { get; }",
                "public bool Success { get; }",
                "public string Text { get; }",
                "public SyntaxToken Token { get; }",
                "public string ValueText { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(StringLiteralExpressionInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in StringLiteralExpressionInfo info1, in StringLiteralExpressionInfo info2)",
                "public static bool operator !=(in StringLiteralExpressionInfo info1, in StringLiteralExpressionInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.UsingDirectiveListInfo : IEquatable<UsingDirectiveListInfo>, IReadOnlyList<UsingDirectiveSyntax>",
              "members": [
                "public int Count { get; }",
                "public SyntaxNode Parent { get; }",
                "public bool Success { get; }",
                "public SyntaxList<UsingDirectiveSyntax> Usings { get; }",
                "public UsingDirectiveSyntax this[int index] { get; }",
                "public UsingDirectiveListInfo Add(UsingDirectiveSyntax usingDirective)",
                "public UsingDirectiveListInfo AddRange(IEnumerable<UsingDirectiveSyntax> usings)",
                "public bool Any()",
                "public override bool Equals(object obj)",
                "public bool Equals(UsingDirectiveListInfo other)",
                "public UsingDirectiveSyntax First()",
                "public UsingDirectiveSyntax FirstOrDefault()",
                "public SyntaxList<UsingDirectiveSyntax>.Enumerator GetEnumerator()",
                "public override int GetHashCode()",
                "public int IndexOf(Func<UsingDirectiveSyntax, bool> predicate)",
                "public int IndexOf(UsingDirectiveSyntax usingDirective)",
                "public UsingDirectiveListInfo Insert(int index, UsingDirectiveSyntax usingDirective)",
                "public UsingDirectiveListInfo InsertRange(int index, IEnumerable<UsingDirectiveSyntax> usings)",
                "public UsingDirectiveSyntax Last()",
                "public int LastIndexOf(Func<UsingDirectiveSyntax, bool> predicate)",
                "public int LastIndexOf(UsingDirectiveSyntax usingDirective)",
                "public UsingDirectiveSyntax LastOrDefault()",
                "public UsingDirectiveListInfo Remove(UsingDirectiveSyntax usingDirective)",
                "public UsingDirectiveListInfo RemoveAt(int index)",
                "public UsingDirectiveListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options)",
                "public UsingDirectiveListInfo Replace(UsingDirectiveSyntax usingInLine, UsingDirectiveSyntax newUsingDirective)",
                "public UsingDirectiveListInfo ReplaceAt(int index, UsingDirectiveSyntax newUsingDirective)",
                "public UsingDirectiveListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode)",
                "public UsingDirectiveListInfo ReplaceRange(UsingDirectiveSyntax usingInLine, IEnumerable<UsingDirectiveSyntax> newUsingDirectives)",
                "public override string ToString()",
                "public UsingDirectiveListInfo WithUsings(IEnumerable<UsingDirectiveSyntax> usings)",
                "public UsingDirectiveListInfo WithUsings(SyntaxList<UsingDirectiveSyntax> usings)",
                "public static bool operator ==(in UsingDirectiveListInfo info1, in UsingDirectiveListInfo info2)",
                "public static bool operator !=(in UsingDirectiveListInfo info1, in UsingDirectiveListInfo info2)"
              ]
            },
            {
              "type": "public readonly struct Roslynator.CSharp.Syntax.XmlElementInfo : IEquatable<XmlElementInfo>",
              "members": [
                "public XmlNodeSyntax Element { get; }",
                "public bool IsEmptyElement { get; }",
                "public SyntaxKind Kind { get; }",
                "public string LocalName { get; }",
                "public bool Success { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(XmlElementInfo other)",
                "public override int GetHashCode()",
                "public override string ToString()",
                "public static bool operator ==(in XmlElementInfo info1, in XmlElementInfo info2)",
                "public static bool operator !=(in XmlElementInfo info1, in XmlElementInfo info2)"
              ]
            },
            {
              "type": "public struct Roslynator.Text.TextLineCollectionSelection.Enumerator",
              "members": [
                "public TextLine Current { get; }",
                "public override bool Equals(object obj)",
                "public override int GetHashCode()",
                "public bool MoveNext()",
                "public void Reset()"
              ]
            }
          ]
        },
        {
          "type": "public abstract class System.Collections.Generic.EqualityComparer<T> : IEqualityComparer, IEqualityComparer<T>",
          "types": [
            {
              "type": "public sealed class Roslynator.MetadataNameEqualityComparer<TSymbol> : EqualityComparer<TSymbol> where TSymbol : ISymbol",
              "members": [
                "public static MetadataNameEqualityComparer<TSymbol> Instance { get; }",
                "public override bool Equals(TSymbol x, TSymbol y)",
                "public override int GetHashCode(TSymbol obj)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.AdditionalText",
          "members": [
            "protected AdditionalText()",
            "public abstract string Path { get; }",
            "public abstract SourceText GetText(CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.AssemblyIdentity : IEquatable<AssemblyIdentity>",
          "members": [
            "public AssemblyIdentity(string name, Version version = null, string cultureName = null, ImmutableArray<byte> publicKeyOrToken = default, bool hasPublicKey = false, bool isRetargetable = false, AssemblyContentType contentType = Default)",
            "public AssemblyContentType ContentType { get; }",
            "public string CultureName { get; }",
            "public AssemblyNameFlags Flags { get; }",
            "public bool HasPublicKey { get; }",
            "public bool IsRetargetable { get; }",
            "public bool IsStrongName { get; }",
            "public string Name { get; }",
            "public ImmutableArray<byte> PublicKey { get; }",
            "public ImmutableArray<byte> PublicKeyToken { get; }",
            "public Version Version { get; }",
            "public bool Equals(AssemblyIdentity obj)",
            "public override bool Equals(object obj)",
            "public static AssemblyIdentity FromAssemblyDefinition(Assembly assembly)",
            "public string GetDisplayName(bool fullKey = false)",
            "public override int GetHashCode()",
            "public override string ToString()",
            "public static bool TryParseDisplayName(string displayName, out AssemblyIdentity identity)",
            "public static bool TryParseDisplayName(string displayName, out AssemblyIdentity identity, out AssemblyIdentityParts parts)",
            "public static bool operator ==(AssemblyIdentity left, AssemblyIdentity right)",
            "public static bool operator !=(AssemblyIdentity left, AssemblyIdentity right)"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.AssemblyIdentityComparer",
          "members": [
            "public static StringComparer CultureComparer { get; }",
            "public static AssemblyIdentityComparer Default { get; }",
            "public static StringComparer SimpleNameComparer { get; }",
            "public AssemblyIdentityComparer.ComparisonResult Compare(AssemblyIdentity reference, AssemblyIdentity definition)",
            "public bool ReferenceMatchesDefinition(AssemblyIdentity reference, AssemblyIdentity definition)",
            "public bool ReferenceMatchesDefinition(string referenceDisplayName, AssemblyIdentity definition)"
          ],
          "types": [
            {
              "type": "public sealed class Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer : AssemblyIdentityComparer",
              "members": [
                "public static DesktopAssemblyIdentityComparer Default { get; }",
                "public static DesktopAssemblyIdentityComparer LoadFromXml(Stream input)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.AttributeData",
          "members": [
            "protected AttributeData()",
            "public SyntaxReference ApplicationSyntaxReference { get; }",
            "public INamedTypeSymbol AttributeClass { get; }",
            "public IMethodSymbol AttributeConstructor { get; }",
            "protected abstract SyntaxReference CommonApplicationSyntaxReference { get; }",
            "protected abstract INamedTypeSymbol CommonAttributeClass { get; }",
            "protected abstract IMethodSymbol CommonAttributeConstructor { get; }",
            "protected internal abstract ImmutableArray<TypedConstant> CommonConstructorArguments { get; }",
            "protected internal abstract ImmutableArray<KeyValuePair<string, TypedConstant>> CommonNamedArguments { get; }",
            "public ImmutableArray<TypedConstant> ConstructorArguments { get; }",
            "public ImmutableArray<KeyValuePair<string, TypedConstant>> NamedArguments { get; }"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.CommandLineArguments",
          "members": [
            "public ImmutableArray<CommandLineSourceFile> AdditionalFiles { get; }",
            "public ImmutableArray<CommandLineAnalyzerReference> AnalyzerReferences { get; }",
            "public string AppConfigPath { get; }",
            "public string BaseDirectory { get; }",
            "public SourceHashAlgorithm ChecksumAlgorithm { get; }",
            "public string CompilationName { get; }",
            "public CompilationOptions CompilationOptions { get; }",
            "protected abstract CompilationOptions CompilationOptionsCore { get; }",
            "public bool DisplayHelp { get; }",
            "public bool DisplayLogo { get; }",
            "public bool DisplayVersion { get; }",
            "public string DocumentationPath { get; }",
            "public ImmutableArray<CommandLineSourceFile> EmbeddedFiles { get; }",
            "public EmitOptions EmitOptions { get; }",
            "public bool EmitPdb { get; }",
            "public Encoding Encoding { get; }",
            "public string ErrorLogPath { get; }",
            "public ImmutableArray<Diagnostic> Errors { get; }",
            "public bool InteractiveMode { get; }",
            "public ImmutableArray<string> KeyFileSearchPaths { get; }",
            "public ImmutableArray<ResourceDescription> ManifestResources { get; }",
            "public ImmutableArray<CommandLineReference> MetadataReferences { get; }",
            "public bool NoWin32Manifest { get; }",
            "public string OutputDirectory { get; }",
            "public string OutputFileName { get; }",
            "public string OutputRefFilePath { get; }",
            "public ParseOptions ParseOptions { get; }",
            "protected abstract ParseOptions ParseOptionsCore { get; }",
            "public ImmutableArray<KeyValuePair<string, string>> PathMap { get; }",
            "public string PdbPath { get; }",
            "public CultureInfo PreferredUILang { get; }",
            "public bool PrintFullPaths { get; }",
            "public ImmutableArray<string> ReferencePaths { get; }",
            "public bool ReportAnalyzer { get; }",
            "public string RuleSetPath { get; }",
            "public ImmutableArray<string> ScriptArguments { get; }",
            "public ImmutableArray<CommandLineSourceFile> SourceFiles { get; }",
            "public string SourceLink { get; }",
            "public ImmutableArray<string> SourcePaths { get; }",
            "public string TouchedFilesPath { get; }",
            "public bool Utf8Output { get; }",
            "public string Win32Icon { get; }",
            "public string Win32Manifest { get; }",
            "public string Win32ResourceFile { get; }",
            "public IEnumerable<AnalyzerReference> ResolveAnalyzerReferences(IAnalyzerAssemblyLoader analyzerLoader)",
            "public IEnumerable<MetadataReference> ResolveMetadataReferences(MetadataReferenceResolver metadataResolver)"
          ],
          "types": [
            {
              "type": "public sealed class Microsoft.CodeAnalysis.CSharp.CSharpCommandLineArguments : CommandLineArguments",
              "members": [
                "public CSharpCompilationOptions CompilationOptions { get; }",
                "protected override CompilationOptions CompilationOptionsCore { get; }",
                "public CSharpParseOptions ParseOptions { get; }",
                "protected override ParseOptions ParseOptionsCore { get; }"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.CommandLineParser",
          "members": [
            "protected abstract string RegularFileExtension { get; }",
            "protected abstract string ScriptFileExtension { get; }",
            "public CommandLineArguments Parse(IEnumerable<string> args, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories)",
            "protected ImmutableArray<KeyValuePair<string, string>> ParsePathMap(string pathMap, IList<Diagnostic> errors)",
            "public static IEnumerable<string> SplitCommandLineIntoArguments(string commandLine, bool removeHashComments)"
          ],
          "types": [
            {
              "type": "public class Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParser : CommandLineParser",
              "members": [
                "public static CSharpCommandLineParser Default { get; }",
                "protected override string RegularFileExtension { get; }",
                "protected override string ScriptFileExtension { get; }",
                "public CSharpCommandLineArguments Parse(IEnumerable<string> args, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories = null)",
                "public static IEnumerable<string> ParseConditionalCompilationSymbols(string value, out IEnumerable<Diagnostic> diagnostics)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Compilation",
          "members": [
            "public IAssemblySymbol Assembly { get; }",
            "public string AssemblyName { get; }",
            "protected abstract IAssemblySymbol CommonAssembly { get; }",
            "protected abstract ITypeSymbol CommonDynamicType { get; }",
            "protected abstract INamespaceSymbol CommonGlobalNamespace { get; }",
            "protected abstract INamedTypeSymbol CommonObjectType { get; }",
            "protected abstract CompilationOptions CommonOptions { get; }",
            "protected abstract INamedTypeSymbol CommonScriptClass { get; }",
            "protected abstract IModuleSymbol CommonSourceModule { get; }",
            "protected abstract IEnumerable<SyntaxTree> CommonSyntaxTrees { get; }",
            "public abstract ImmutableArray<MetadataReference> DirectiveReferences { get; }",
            "public ITypeSymbol DynamicType { get; }",
            "public ImmutableArray<MetadataReference> ExternalReferences { get; }",
            "public INamespaceSymbol GlobalNamespace { get; }",
            "public abstract bool IsCaseSensitive { get; }",
            "public abstract string Language { get; }",
            "public INamedTypeSymbol ObjectType { get; }",
            "public CompilationOptions Options { get; }",
            "public abstract IEnumerable<AssemblyIdentity> ReferencedAssemblyNames { get; }",
            "public IEnumerable<MetadataReference> References { get; }",
            "public INamedTypeSymbol ScriptClass { get; }",
            "public ScriptCompilationInfo ScriptCompilationInfo { get; }",
            "public IModuleSymbol SourceModule { get; }",
            "public IEnumerable<SyntaxTree> SyntaxTrees { get; }",
            "public Compilation AddReferences(params MetadataReference[] references)",
            "public Compilation AddReferences(IEnumerable<MetadataReference> references)",
            "public Compilation AddSyntaxTrees(params SyntaxTree[] trees)",
            "public Compilation AddSyntaxTrees(IEnumerable<SyntaxTree> trees)",
            "protected abstract void AppendDefaultVersionResource(Stream resourceStream)",
            "protected static void CheckTupleElementLocations(int cardinality, ImmutableArray<Location> elementLocations)",
            "protected static ImmutableArray<string> CheckTupleElementNames(int cardinality, ImmutableArray<string> elementNames)",
            "public Compilation Clone()",
            "protected abstract Compilation CommonAddSyntaxTrees(IEnumerable<SyntaxTree> trees)",
            "protected INamedTypeSymbol CommonBindScriptClass()",
            "protected abstract Compilation CommonClone()",
            "protected abstract bool CommonContainsSyntaxTree(SyntaxTree syntaxTree)",
            "protected abstract INamedTypeSymbol CommonCreateAnonymousTypeSymbol(ImmutableArray<ITypeSymbol> memberTypes, ImmutableArray<string> memberNames, ImmutableArray<Location> memberLocations, ImmutableArray<bool> memberIsReadOnly)",
            "protected abstract IArrayTypeSymbol CommonCreateArrayTypeSymbol(ITypeSymbol elementType, int rank)",
            "protected abstract INamespaceSymbol CommonCreateErrorNamespaceSymbol(INamespaceSymbol container, string name)",
            "protected abstract INamedTypeSymbol CommonCreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity)",
            "protected abstract IPointerTypeSymbol CommonCreatePointerTypeSymbol(ITypeSymbol elementType)",
            "protected abstract INamedTypeSymbol CommonCreateTupleTypeSymbol(ImmutableArray<ITypeSymbol> elementTypes, ImmutableArray<string> elementNames, ImmutableArray<Location> elementLocations)",
            "protected abstract INamedTypeSymbol CommonCreateTupleTypeSymbol(INamedTypeSymbol underlyingType, ImmutableArray<string> elementNames, ImmutableArray<Location> elementLocations)",
            "protected abstract ISymbol CommonGetAssemblyOrModuleSymbol(MetadataReference reference)",
            "protected abstract INamespaceSymbol CommonGetCompilationNamespace(INamespaceSymbol namespaceSymbol)",
            "protected abstract IMethodSymbol CommonGetEntryPoint(CancellationToken cancellationToken)",
            "protected abstract SemanticModel CommonGetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility)",
            "protected abstract INamedTypeSymbol CommonGetSpecialType(SpecialType specialType)",
            "protected abstract INamedTypeSymbol CommonGetTypeByMetadataName(string metadataName)",
            "protected abstract Compilation CommonRemoveAllSyntaxTrees()",
            "protected abstract Compilation CommonRemoveSyntaxTrees(IEnumerable<SyntaxTree> trees)",
            "protected abstract Compilation CommonReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree)",
            "protected abstract Compilation CommonWithAssemblyName(string outputName)",
            "protected abstract Compilation CommonWithOptions(CompilationOptions options)",
            "protected abstract Compilation CommonWithReferences(IEnumerable<MetadataReference> newReferences)",
            "protected abstract Compilation CommonWithScriptCompilationInfo(ScriptCompilationInfo info)",
            "public abstract bool ContainsSymbolsWithName(Func<string, bool> predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default)",
            "public bool ContainsSyntaxTree(SyntaxTree syntaxTree)",
            "public INamedTypeSymbol CreateAnonymousTypeSymbol(ImmutableArray<ITypeSymbol> memberTypes, ImmutableArray<string> memberNames, ImmutableArray<bool> memberIsReadOnly = default, ImmutableArray<Location> memberLocations = default)",
            "public IArrayTypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank = 1)",
            "public Stream CreateDefaultWin32Resources(bool versionResource, bool noManifest, Stream manifestContents, Stream iconInIcoFormat)",
            "public INamespaceSymbol CreateErrorNamespaceSymbol(INamespaceSymbol container, string name)",
            "public INamedTypeSymbol CreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity)",
            "public IPointerTypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType)",
            "public INamedTypeSymbol CreateTupleTypeSymbol(ImmutableArray<ITypeSymbol> elementTypes, ImmutableArray<string> elementNames = default, ImmutableArray<Location> elementLocations = default)",
            "public INamedTypeSymbol CreateTupleTypeSymbol(INamedTypeSymbol underlyingType, ImmutableArray<string> elementNames = default, ImmutableArray<Location> elementLocations = default)",
            "public EmitResult Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable<ResourceDescription> manifestResources, EmitOptions options, CancellationToken cancellationToken)",
            "public EmitResult Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable<ResourceDescription> manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, CancellationToken cancellationToken)",
            "public EmitResult Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable<ResourceDescription> manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable<EmbeddedText> embeddedTexts, CancellationToken cancellationToken)",
            "public EmitResult Emit(Stream peStream, Stream pdbStream = null, Stream xmlDocumentationStream = null, Stream win32Resources = null, IEnumerable<ResourceDescription> manifestResources = null, EmitOptions options = null, IMethodSymbol debugEntryPoint = null, Stream sourceLinkStream = null, IEnumerable<EmbeddedText> embeddedTexts = null, Stream metadataPEStream = null, CancellationToken cancellationToken = default)",
            "public EmitDifferenceResult EmitDifference(EmitBaseline baseline, IEnumerable<SemanticEdit> edits, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection<MethodDefinitionHandle> updatedMethods, CancellationToken cancellationToken = default)",
            "public EmitDifferenceResult EmitDifference(EmitBaseline baseline, IEnumerable<SemanticEdit> edits, Func<ISymbol, bool> isAddedSymbol, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection<MethodDefinitionHandle> updatedMethods, CancellationToken cancellationToken = default)",
            "public ISymbol GetAssemblyOrModuleSymbol(MetadataReference reference)",
            "public INamespaceSymbol GetCompilationNamespace(INamespaceSymbol namespaceSymbol)",
            "public abstract ImmutableArray<Diagnostic> GetDeclarationDiagnostics(CancellationToken cancellationToken = default)",
            "public abstract ImmutableArray<Diagnostic> GetDiagnostics(CancellationToken cancellationToken = default)",
            "public IMethodSymbol GetEntryPoint(CancellationToken cancellationToken)",
            "public MetadataReference GetMetadataReference(IAssemblySymbol assemblySymbol)",
            "public abstract ImmutableArray<Diagnostic> GetMethodBodyDiagnostics(CancellationToken cancellationToken = default)",
            "public abstract ImmutableArray<Diagnostic> GetParseDiagnostics(CancellationToken cancellationToken = default)",
            "public static string GetRequiredLanguageVersion(Diagnostic diagnostic)",
            "public SemanticModel GetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility = false)",
            "public INamedTypeSymbol GetSpecialType(SpecialType specialType)",
            "public abstract IEnumerable<ISymbol> GetSymbolsWithName(Func<string, bool> predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default)",
            "public INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName)",
            "public ImmutableArray<AssemblyIdentity> GetUnreferencedAssemblyIdentities(Diagnostic diagnostic)",
            "public Compilation RemoveAllReferences()",
            "public Compilation RemoveAllSyntaxTrees()",
            "public Compilation RemoveReferences(params MetadataReference[] references)",
            "public Compilation RemoveReferences(IEnumerable<MetadataReference> references)",
            "public Compilation RemoveSyntaxTrees(params SyntaxTree[] trees)",
            "public Compilation RemoveSyntaxTrees(IEnumerable<SyntaxTree> trees)",
            "public Compilation ReplaceReference(MetadataReference oldReference, MetadataReference newReference)",
            "public Compilation ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree)",
            "protected static IReadOnlyDictionary<string, string> SyntaxTreeCommonFeatures(IEnumerable<SyntaxTree> trees)",
            "public abstract CompilationReference ToMetadataReference(ImmutableArray<string> aliases = default, bool embedInteropTypes = false)",
            "public Compilation WithAssemblyName(string assemblyName)",
            "public Compilation WithOptions(CompilationOptions options)",
            "public Compilation WithReferences(IEnumerable<MetadataReference> newReferences)",
            "public Compilation WithReferences(params MetadataReference[] newReferences)",
            "public Compilation WithScriptCompilationInfo(ScriptCompilationInfo info)"
          ],
          "types": [
            {
              "type": "public sealed class Microsoft.CodeAnalysis.CSharp.CSharpCompilation : Compilation",
              "members": [
                "protected override IAssemblySymbol CommonAssembly { get; }",
                "protected override ITypeSymbol CommonDynamicType { get; }",
                "protected override INamespaceSymbol CommonGlobalNamespace { get; }",
                "protected override INamedTypeSymbol CommonObjectType { get; }",
                "protected override CompilationOptions CommonOptions { get; }",
                "protected override INamedTypeSymbol CommonScriptClass { get; }",
                "protected override IModuleSymbol CommonSourceModule { get; }",
                "protected override IEnumerable<SyntaxTree> CommonSyntaxTrees { get; }",
                "public override ImmutableArray<MetadataReference> DirectiveReferences { get; }",
                "public override bool IsCaseSensitive { get; }",
                "public override string Language { get; }",
                "public LanguageVersion LanguageVersion { get; }",
                "public CSharpCompilationOptions Options { get; }",
                "public override IEnumerable<AssemblyIdentity> ReferencedAssemblyNames { get; }",
                "public CSharpScriptCompilationInfo ScriptCompilationInfo { get; }",
                "public ImmutableArray<SyntaxTree> SyntaxTrees { get; }",
                "public CSharpCompilation AddReferences(params MetadataReference[] references)",
                "public CSharpCompilation AddReferences(IEnumerable<MetadataReference> references)",
                "public CSharpCompilation AddSyntaxTrees(params SyntaxTree[] trees)",
                "public CSharpCompilation AddSyntaxTrees(IEnumerable<SyntaxTree> trees)",
                "protected override void AppendDefaultVersionResource(Stream resourceStream)",
                "public Conversion ClassifyConversion(ITypeSymbol source, ITypeSymbol destination)",
                "public CSharpCompilation Clone()",
                "protected override Compilation CommonAddSyntaxTrees(IEnumerable<SyntaxTree> trees)",
                "protected override Compilation CommonClone()",
                "protected override bool CommonContainsSyntaxTree(SyntaxTree syntaxTree)",
                "protected override INamedTypeSymbol CommonCreateAnonymousTypeSymbol(ImmutableArray<ITypeSymbol> memberTypes, ImmutableArray<string> memberNames, ImmutableArray<Location> memberLocations, ImmutableArray<bool> memberIsReadOnly)",
                "protected override IArrayTypeSymbol CommonCreateArrayTypeSymbol(ITypeSymbol elementType, int rank)",
                "protected override INamespaceSymbol CommonCreateErrorNamespaceSymbol(INamespaceSymbol container, string name)",
                "protected override INamedTypeSymbol CommonCreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity)",
                "protected override IPointerTypeSymbol CommonCreatePointerTypeSymbol(ITypeSymbol elementType)",
                "protected override INamedTypeSymbol CommonCreateTupleTypeSymbol(ImmutableArray<ITypeSymbol> elementTypes, ImmutableArray<string> elementNames, ImmutableArray<Location> elementLocations)",
                "protected override INamedTypeSymbol CommonCreateTupleTypeSymbol(INamedTypeSymbol underlyingType, ImmutableArray<string> elementNames, ImmutableArray<Location> elementLocations)",
                "protected override ISymbol CommonGetAssemblyOrModuleSymbol(MetadataReference reference)",
                "protected override INamespaceSymbol CommonGetCompilationNamespace(INamespaceSymbol namespaceSymbol)",
                "protected override IMethodSymbol CommonGetEntryPoint(CancellationToken cancellationToken)",
                "protected override SemanticModel CommonGetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility)",
                "protected override INamedTypeSymbol CommonGetSpecialType(SpecialType specialType)",
                "protected override INamedTypeSymbol CommonGetTypeByMetadataName(string metadataName)",
                "protected override Compilation CommonRemoveAllSyntaxTrees()",
                "protected override Compilation CommonRemoveSyntaxTrees(IEnumerable<SyntaxTree> trees)",
                "protected override Compilation CommonReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree)",
                "protected override Compilation CommonWithAssemblyName(string assemblyName)",
                "protected override Compilation CommonWithOptions(CompilationOptions options)",
                "protected override Compilation CommonWithReferences(IEnumerable<MetadataReference> newReferences)",
                "protected override Compilation CommonWithScriptCompilationInfo(ScriptCompilationInfo info)",
                "public override bool ContainsSymbolsWithName(Func<string, bool> predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default)",
                "public bool ContainsSyntaxTree(SyntaxTree syntaxTree)",
                "public static CSharpCompilation Create(string assemblyName, IEnumerable<SyntaxTree> syntaxTrees = null, IEnumerable<MetadataReference> references = null, CSharpCompilationOptions options = null)",
                "public static CSharpCompilation CreateScriptCompilation(string assemblyName, SyntaxTree syntaxTree = null, IEnumerable<MetadataReference> references = null, CSharpCompilationOptions options = null, CSharpCompilation previousScriptCompilation = null, Type returnType = null, Type globalsType = null)",
                "public override ImmutableArray<Diagnostic> GetDeclarationDiagnostics(CancellationToken cancellationToken = default)",
                "public override ImmutableArray<Diagnostic> GetDiagnostics(CancellationToken cancellationToken = default)",
                "public MetadataReference GetDirectiveReference(ReferenceDirectiveTriviaSyntax directive)",
                "public MetadataReference GetMetadataReference(IAssemblySymbol assemblySymbol)",
                "public override ImmutableArray<Diagnostic> GetMethodBodyDiagnostics(CancellationToken cancellationToken = default)",
                "public override ImmutableArray<Diagnostic> GetParseDiagnostics(CancellationToken cancellationToken = default)",
                "public SemanticModel GetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility)",
                "public override IEnumerable<ISymbol> GetSymbolsWithName(Func<string, bool> predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default)",
                "public CSharpCompilation RemoveAllReferences()",
                "public CSharpCompilation RemoveAllSyntaxTrees()",
                "public CSharpCompilation RemoveReferences(params MetadataReference[] references)",
                "public CSharpCompilation RemoveReferences(IEnumerable<MetadataReference> references)",
                "public CSharpCompilation RemoveSyntaxTrees(params SyntaxTree[] trees)",
                "public CSharpCompilation RemoveSyntaxTrees(IEnumerable<SyntaxTree> trees)",
                "public CSharpCompilation ReplaceReference(MetadataReference oldReference, MetadataReference newReference)",
                "public CSharpCompilation ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree)",
                "public override CompilationReference ToMetadataReference(ImmutableArray<string> aliases = default, bool embedInteropTypes = false)",
                "public CSharpCompilation WithAssemblyName(string assemblyName)",
                "public CSharpCompilation WithOptions(CSharpCompilationOptions options)",
                "public CSharpCompilation WithReferences(IEnumerable<MetadataReference> references)",
                "public CSharpCompilation WithReferences(params MetadataReference[] references)",
                "public CSharpCompilation WithScriptCompilationInfo(CSharpScriptCompilationInfo info)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.CompilationOptions",
          "members": [
            "public AssemblyIdentityComparer AssemblyIdentityComparer { get; protected set; }",
            "public bool CheckOverflow { get; protected set; }",
            "public bool ConcurrentBuild { get; protected set; }",
            "public string CryptoKeyContainer { get; protected set; }",
            "public string CryptoKeyFile { get; protected set; }",
            "public ImmutableArray<byte> CryptoPublicKey { get; protected set; }",
            "public bool? DelaySign { get; protected set; }",
            "public bool Deterministic { get; protected set; }",
            "public ImmutableArray<Diagnostic> Errors { get; }",
            "protected internal ImmutableArray<string> Features { get; protected set; }",
            "public ReportDiagnostic GeneralDiagnosticOption { get; protected set; }",
            "public abstract string Language { get; }",
            "public string MainTypeName { get; protected set; }",
            "public MetadataReferenceResolver MetadataReferenceResolver { get; protected set; }",
            "public string ModuleName { get; protected set; }",
            "public OptimizationLevel OptimizationLevel { get; protected set; }",
            "public OutputKind OutputKind { get; protected set; }",
            "public Platform Platform { get; protected set; }",
            "public bool PublicSign { get; protected set; }",
            "public bool ReportSuppressedDiagnostics { get; protected set; }",
            "public string ScriptClassName { get; protected set; }",
            "public SourceReferenceResolver SourceReferenceResolver { get; protected set; }",
            "public ImmutableDictionary<string, ReportDiagnostic> SpecificDiagnosticOptions { get; protected set; }",
            "public StrongNameProvider StrongNameProvider { get; protected set; }",
            "public int WarningLevel { get; protected set; }",
            "public XmlReferenceResolver XmlReferenceResolver { get; protected set; }",
            "protected abstract CompilationOptions CommonWithAssemblyIdentityComparer(AssemblyIdentityComparer comparer)",
            "protected abstract CompilationOptions CommonWithCheckOverflow(bool checkOverflow)",
            "protected abstract CompilationOptions CommonWithConcurrentBuild(bool concurrent)",
            "protected abstract CompilationOptions CommonWithCryptoKeyContainer(string cryptoKeyContainer)",
            "protected abstract CompilationOptions CommonWithCryptoKeyFile(string cryptoKeyFile)",
            "protected abstract CompilationOptions CommonWithCryptoPublicKey(ImmutableArray<byte> cryptoPublicKey)",
            "protected abstract CompilationOptions CommonWithDelaySign(bool? delaySign)",
            "protected abstract CompilationOptions CommonWithDeterministic(bool deterministic)",
            "protected abstract CompilationOptions CommonWithFeatures(ImmutableArray<string> features)",
            "protected abstract CompilationOptions CommonWithGeneralDiagnosticOption(ReportDiagnostic generalDiagnosticOption)",
            "protected abstract CompilationOptions CommonWithMainTypeName(string mainTypeName)",
            "protected abstract CompilationOptions CommonWithMetadataReferenceResolver(MetadataReferenceResolver resolver)",
            "protected abstract CompilationOptions CommonWithModuleName(string moduleName)",
            "protected abstract CompilationOptions CommonWithOptimizationLevel(OptimizationLevel value)",
            "protected abstract CompilationOptions CommonWithOutputKind(OutputKind kind)",
            "protected abstract CompilationOptions CommonWithPlatform(Platform platform)",
            "protected abstract CompilationOptions CommonWithPublicSign(bool publicSign)",
            "protected abstract CompilationOptions CommonWithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics)",
            "protected abstract CompilationOptions CommonWithScriptClassName(string scriptClassName)",
            "protected abstract CompilationOptions CommonWithSourceReferenceResolver(SourceReferenceResolver resolver)",
            "protected abstract CompilationOptions CommonWithSpecificDiagnosticOptions(ImmutableDictionary<string, ReportDiagnostic> specificDiagnosticOptions)",
            "protected abstract CompilationOptions CommonWithSpecificDiagnosticOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions)",
            "protected abstract CompilationOptions CommonWithStrongNameProvider(StrongNameProvider provider)",
            "protected abstract CompilationOptions CommonWithXmlReferenceResolver(XmlReferenceResolver resolver)",
            "public override abstract bool Equals(object obj)",
            "protected bool EqualsHelper(CompilationOptions other)",
            "public override abstract int GetHashCode()",
            "protected int GetHashCodeHelper()",
            "public CompilationOptions WithAssemblyIdentityComparer(AssemblyIdentityComparer comparer)",
            "public CompilationOptions WithConcurrentBuild(bool concurrent)",
            "public CompilationOptions WithCryptoKeyContainer(string cryptoKeyContainer)",
            "public CompilationOptions WithCryptoKeyFile(string cryptoKeyFile)",
            "public CompilationOptions WithCryptoPublicKey(ImmutableArray<byte> cryptoPublicKey)",
            "public CompilationOptions WithDelaySign(bool? delaySign)",
            "public CompilationOptions WithDeterministic(bool deterministic)",
            "public CompilationOptions WithGeneralDiagnosticOption(ReportDiagnostic value)",
            "public CompilationOptions WithMainTypeName(string mainTypeName)",
            "public CompilationOptions WithMetadataReferenceResolver(MetadataReferenceResolver resolver)",
            "public CompilationOptions WithModuleName(string moduleName)",
            "public CompilationOptions WithOptimizationLevel(OptimizationLevel value)",
            "public CompilationOptions WithOutputKind(OutputKind kind)",
            "public CompilationOptions WithOverflowChecks(bool checkOverflow)",
            "public CompilationOptions WithPlatform(Platform platform)",
            "public CompilationOptions WithPublicSign(bool publicSign)",
            "public CompilationOptions WithReportSuppressedDiagnostics(bool value)",
            "public CompilationOptions WithScriptClassName(string scriptClassName)",
            "public CompilationOptions WithSourceReferenceResolver(SourceReferenceResolver resolver)",
            "public CompilationOptions WithSpecificDiagnosticOptions(ImmutableDictionary<string, ReportDiagnostic> value)",
            "public CompilationOptions WithSpecificDiagnosticOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>> value)",
            "public CompilationOptions WithStrongNameProvider(StrongNameProvider provider)",
            "public CompilationOptions WithXmlReferenceResolver(XmlReferenceResolver resolver)",
            "public static bool operator ==(CompilationOptions left, CompilationOptions right)",
            "public static bool operator !=(CompilationOptions left, CompilationOptions right)"
          ],
          "types": [
            {
              "type": "public sealed class Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions : CompilationOptions, IEquatable<CSharpCompilationOptions>",
              "members": [
                "public CSharpCompilationOptions(OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, IEnumerable<string> usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider)",
                "public CSharpCompilationOptions(OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, IEnumerable<string> usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider)",
                "public CSharpCompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics, string moduleName, string mainTypeName, string scriptClassName, IEnumerable<string> usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider)",
                "public CSharpCompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics = false, string moduleName = null, string mainTypeName = null, string scriptClassName = null, IEnumerable<string> usings = null, OptimizationLevel optimizationLevel = Debug, bool checkOverflow = false, bool allowUnsafe = false, string cryptoKeyContainer = null, string cryptoKeyFile = null, ImmutableArray<byte> cryptoPublicKey = default, bool? delaySign = null, Platform platform = AnyCpu, ReportDiagnostic generalDiagnosticOption = Default, int warningLevel = 4, IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions = null, bool concurrentBuild = true, bool deterministic = false, XmlReferenceResolver xmlReferenceResolver = null, SourceReferenceResolver sourceReferenceResolver = null, MetadataReferenceResolver metadataReferenceResolver = null, AssemblyIdentityComparer assemblyIdentityComparer = null, StrongNameProvider strongNameProvider = null, bool publicSign = false)",
                "public bool AllowUnsafe { get; }",
                "public override string Language { get; }",
                "public ImmutableArray<string> Usings { get; }",
                "protected override CompilationOptions CommonWithAssemblyIdentityComparer(AssemblyIdentityComparer comparer)",
                "protected override CompilationOptions CommonWithCheckOverflow(bool checkOverflow)",
                "protected override CompilationOptions CommonWithConcurrentBuild(bool concurrent)",
                "protected override CompilationOptions CommonWithCryptoKeyContainer(string cryptoKeyContainer)",
                "protected override CompilationOptions CommonWithCryptoKeyFile(string cryptoKeyFile)",
                "protected override CompilationOptions CommonWithCryptoPublicKey(ImmutableArray<byte> cryptoPublicKey)",
                "protected override CompilationOptions CommonWithDelaySign(bool? delaySign)",
                "protected override CompilationOptions CommonWithDeterministic(bool deterministic)",
                "protected override CompilationOptions CommonWithFeatures(ImmutableArray<string> features)",
                "protected override CompilationOptions CommonWithGeneralDiagnosticOption(ReportDiagnostic value)",
                "protected override CompilationOptions CommonWithMainTypeName(string mainTypeName)",
                "protected override CompilationOptions CommonWithMetadataReferenceResolver(MetadataReferenceResolver resolver)",
                "protected override CompilationOptions CommonWithModuleName(string moduleName)",
                "protected override CompilationOptions CommonWithOptimizationLevel(OptimizationLevel value)",
                "protected override CompilationOptions CommonWithOutputKind(OutputKind kind)",
                "protected override CompilationOptions CommonWithPlatform(Platform platform)",
                "protected override CompilationOptions CommonWithPublicSign(bool publicSign)",
                "protected override CompilationOptions CommonWithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics)",
                "protected override CompilationOptions CommonWithScriptClassName(string scriptClassName)",
                "protected override CompilationOptions CommonWithSourceReferenceResolver(SourceReferenceResolver resolver)",
                "protected override CompilationOptions CommonWithSpecificDiagnosticOptions(ImmutableDictionary<string, ReportDiagnostic> specificDiagnosticOptions)",
                "protected override CompilationOptions CommonWithSpecificDiagnosticOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions)",
                "protected override CompilationOptions CommonWithStrongNameProvider(StrongNameProvider provider)",
                "protected override CompilationOptions CommonWithXmlReferenceResolver(XmlReferenceResolver resolver)",
                "public override bool Equals(object obj)",
                "public bool Equals(CSharpCompilationOptions other)",
                "public override int GetHashCode()",
                "public CSharpCompilationOptions WithAllowUnsafe(bool enabled)",
                "public CSharpCompilationOptions WithAssemblyIdentityComparer(AssemblyIdentityComparer comparer)",
                "public CSharpCompilationOptions WithConcurrentBuild(bool concurrentBuild)",
                "public CSharpCompilationOptions WithCryptoKeyContainer(string name)",
                "public CSharpCompilationOptions WithCryptoKeyFile(string path)",
                "public CSharpCompilationOptions WithCryptoPublicKey(ImmutableArray<byte> value)",
                "public CSharpCompilationOptions WithDelaySign(bool? value)",
                "public CSharpCompilationOptions WithDeterministic(bool deterministic)",
                "public CSharpCompilationOptions WithGeneralDiagnosticOption(ReportDiagnostic value)",
                "public CSharpCompilationOptions WithMainTypeName(string name)",
                "public CSharpCompilationOptions WithMetadataReferenceResolver(MetadataReferenceResolver resolver)",
                "public CSharpCompilationOptions WithModuleName(string moduleName)",
                "public CSharpCompilationOptions WithOptimizationLevel(OptimizationLevel value)",
                "public CSharpCompilationOptions WithOutputKind(OutputKind kind)",
                "public CSharpCompilationOptions WithOverflowChecks(bool enabled)",
                "public CSharpCompilationOptions WithPlatform(Platform platform)",
                "public CSharpCompilationOptions WithPublicSign(bool publicSign)",
                "public CSharpCompilationOptions WithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics)",
                "public CSharpCompilationOptions WithScriptClassName(string name)",
                "public CSharpCompilationOptions WithSourceReferenceResolver(SourceReferenceResolver resolver)",
                "public CSharpCompilationOptions WithSpecificDiagnosticOptions(ImmutableDictionary<string, ReportDiagnostic> values)",
                "public CSharpCompilationOptions WithSpecificDiagnosticOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>> values)",
                "public CSharpCompilationOptions WithStrongNameProvider(StrongNameProvider provider)",
                "public CSharpCompilationOptions WithUsings(ImmutableArray<string> usings)",
                "public CSharpCompilationOptions WithUsings(IEnumerable<string> usings)",
                "public CSharpCompilationOptions WithUsings(params string[] usings)",
                "public CSharpCompilationOptions WithWarningLevel(int warningLevel)",
                "public CSharpCompilationOptions WithXmlReferenceResolver(XmlReferenceResolver resolver)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.ControlFlowAnalysis",
          "members": [
            "protected ControlFlowAnalysis()",
            "public abstract bool EndPointIsReachable { get; }",
            "public abstract ImmutableArray<SyntaxNode> EntryPoints { get; }",
            "public abstract ImmutableArray<SyntaxNode> ExitPoints { get; }",
            "public abstract ImmutableArray<SyntaxNode> ReturnStatements { get; }",
            "public abstract bool StartPointIsReachable { get; }",
            "public abstract bool Succeeded { get; }"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.CustomModifier : ICustomModifier",
          "members": [
            "protected CustomModifier()",
            "public abstract bool IsOptional { get; }",
            "public abstract INamedTypeSymbol Modifier { get; }"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.DataFlowAnalysis",
          "members": [
            "protected DataFlowAnalysis()",
            "public abstract ImmutableArray<ISymbol> AlwaysAssigned { get; }",
            "public abstract ImmutableArray<ISymbol> Captured { get; }",
            "public abstract ImmutableArray<ISymbol> DataFlowsIn { get; }",
            "public abstract ImmutableArray<ISymbol> DataFlowsOut { get; }",
            "public abstract ImmutableArray<ISymbol> ReadInside { get; }",
            "public abstract ImmutableArray<ISymbol> ReadOutside { get; }",
            "public abstract bool Succeeded { get; }",
            "public abstract ImmutableArray<ISymbol> UnsafeAddressTaken { get; }",
            "public abstract ImmutableArray<ISymbol> VariablesDeclared { get; }",
            "public abstract ImmutableArray<ISymbol> WrittenInside { get; }",
            "public abstract ImmutableArray<ISymbol> WrittenOutside { get; }"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Diagnostic : IEquatable<Diagnostic>, IFormattable",
          "members": [
            "protected Diagnostic()",
            "public abstract IReadOnlyList<Location> AdditionalLocations { get; }",
            "public virtual DiagnosticSeverity DefaultSeverity { get; }",
            "public abstract DiagnosticDescriptor Descriptor { get; }",
            "public abstract string Id { get; }",
            "public abstract bool IsSuppressed { get; }",
            "public bool IsWarningAsError { get; }",
            "public abstract Location Location { get; }",
            "public virtual ImmutableDictionary<string, string> Properties { get; }",
            "public abstract DiagnosticSeverity Severity { get; }",
            "public abstract int WarningLevel { get; }",
            "public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, params object[] messageArgs)",
            "public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, params object[] messageArgs)",
            "public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, ImmutableDictionary<string, string> properties, params object[] messageArgs)",
            "public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, ImmutableDictionary<string, string> properties, params object[] messageArgs)",
            "public static Diagnostic Create(string id, string category, LocalizableString message, DiagnosticSeverity severity, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, LocalizableString title = null, LocalizableString description = null, string helpLink = null, Location location = null, IEnumerable<Location> additionalLocations = null, IEnumerable<string> customTags = null, ImmutableDictionary<string, string> properties = null)",
            "public static Diagnostic Create(string id, string category, LocalizableString message, DiagnosticSeverity severity, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, bool isSuppressed, LocalizableString title = null, LocalizableString description = null, string helpLink = null, Location location = null, IEnumerable<Location> additionalLocations = null, IEnumerable<string> customTags = null, ImmutableDictionary<string, string> properties = null)",
            "public override abstract bool Equals(object obj)",
            "public abstract bool Equals(Diagnostic obj)",
            "public override abstract int GetHashCode()",
            "public abstract string GetMessage(IFormatProvider formatProvider = null)",
            "public SuppressionInfo GetSuppressionInfo(Compilation compilation)",
            "public override string ToString()"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.DiagnosticDescriptor : IEquatable<DiagnosticDescriptor>",
          "members": [
            "public DiagnosticDescriptor(string id, string title, string messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, string description = null, string helpLinkUri = null, params string[] customTags)",
            "public DiagnosticDescriptor(string id, LocalizableString title, LocalizableString messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, LocalizableString description = null, string helpLinkUri = null, params string[] customTags)",
            "public string Category { get; }",
            "public IEnumerable<string> CustomTags { get; }",
            "public DiagnosticSeverity DefaultSeverity { get; }",
            "public LocalizableString Description { get; }",
            "public string HelpLinkUri { get; }",
            "public string Id { get; }",
            "public bool IsEnabledByDefault { get; }",
            "public LocalizableString MessageFormat { get; }",
            "public LocalizableString Title { get; }",
            "public override bool Equals(object obj)",
            "public bool Equals(DiagnosticDescriptor other)",
            "public ReportDiagnostic GetEffectiveSeverity(CompilationOptions compilationOptions)",
            "public override int GetHashCode()"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.DiagnosticFormatter",
          "members": [
            "public DiagnosticFormatter()",
            "public virtual string Format(Diagnostic diagnostic, IFormatProvider formatter = null)"
          ],
          "types": [
            {
              "type": "public class Microsoft.CodeAnalysis.CSharp.CSharpDiagnosticFormatter : DiagnosticFormatter",
              "members": [
                "public static CSharpDiagnosticFormatter Instance { get; }"
              ]
            }
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.DllImportData : IPlatformInvokeInformation",
          "members": [
            "public bool? BestFitMapping { get; }",
            "public CallingConvention CallingConvention { get; }",
            "public CharSet CharacterSet { get; }",
            "public string EntryPointName { get; }",
            "public bool ExactSpelling { get; }",
            "public string ModuleName { get; }",
            "public bool SetLastError { get; }",
            "public bool? ThrowOnUnmappableCharacter { get; }"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.DocumentId : IEquatable<DocumentId>, IObjectWritable",
          "members": [
            "public Guid Id { get; }",
            "public ProjectId ProjectId { get; }",
            "public static DocumentId CreateFromSerialized(ProjectId projectId, Guid id, string debugName = null)",
            "public static DocumentId CreateNewId(ProjectId projectId, string debugName = null)",
            "public override bool Equals(object obj)",
            "public bool Equals(DocumentId other)",
            "public override int GetHashCode()",
            "public override string ToString()",
            "public static bool operator ==(DocumentId left, DocumentId right)",
            "public static bool operator !=(DocumentId left, DocumentId right)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.DocumentInfo",
          "members": [
            "public string FilePath { get; }",
            "public IReadOnlyList<string> Folders { get; }",
            "public DocumentId Id { get; }",
            "public bool IsGenerated { get; }",
            "public string Name { get; }",
            "public SourceCodeKind SourceCodeKind { get; }",
            "public TextLoader TextLoader { get; }",
            "public static DocumentInfo Create(DocumentId id, string name, IEnumerable<string> folders = null, SourceCodeKind sourceCodeKind = Regular, TextLoader loader = null, string filePath = null, bool isGenerated = false)",
            "public DocumentInfo WithFilePath(string filePath)",
            "public DocumentInfo WithFolders(IEnumerable<string> folders)",
            "public DocumentInfo WithId(DocumentId id)",
            "public DocumentInfo WithName(string name)",
            "public DocumentInfo WithSourceCodeKind(SourceCodeKind kind)",
            "public DocumentInfo WithTextLoader(TextLoader loader)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.DocumentationProvider",
          "members": [
            "protected DocumentationProvider()",
            "public static DocumentationProvider Default { get; }",
            "public override abstract bool Equals(object obj)",
            "protected internal abstract string GetDocumentationForSymbol(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken = default)",
            "public override abstract int GetHashCode()"
          ],
          "types": [
            {
              "type": "public abstract class Microsoft.CodeAnalysis.XmlDocumentationProvider : DocumentationProvider",
              "members": [
                "protected XmlDocumentationProvider()",
                "public static XmlDocumentationProvider CreateFromBytes(byte[] xmlDocCommentBytes)",
                "public static XmlDocumentationProvider CreateFromFile(string xmlDocCommentFilePath)",
                "protected override string GetDocumentationForSymbol(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken = default)",
                "protected abstract Stream GetSourceStream(CancellationToken cancellationToken)"
              ]
            }
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.EmbeddedText",
          "members": [
            "public ImmutableArray<byte> Checksum { get; }",
            "public SourceHashAlgorithm ChecksumAlgorithm { get; }",
            "public string FilePath { get; }",
            "public static EmbeddedText FromBytes(string filePath, ArraySegment<byte> bytes, SourceHashAlgorithm checksumAlgorithm = Sha1)",
            "public static EmbeddedText FromSource(string filePath, SourceText text)",
            "public static EmbeddedText FromStream(string filePath, Stream stream, SourceHashAlgorithm checksumAlgorithm = Sha1)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.LocalizableString : IEquatable<LocalizableString>, IFormattable",
          "members": [
            "protected LocalizableString()",
            "public event EventHandler<Exception> OnException",
            "protected abstract bool AreEqual(object other)",
            "public override sealed bool Equals(object other)",
            "public bool Equals(LocalizableString other)",
            "protected abstract int GetHash()",
            "public override sealed int GetHashCode()",
            "protected abstract string GetText(IFormatProvider formatProvider)",
            "public override sealed string ToString()",
            "public string ToString(IFormatProvider formatProvider)",
            "public static explicit operator string(LocalizableString localizableResource)",
            "public static implicit operator LocalizableString(string fixedResource)"
          ],
          "types": [
            {
              "type": "public sealed class Microsoft.CodeAnalysis.LocalizableResourceString : LocalizableString, IObjectWritable",
              "members": [
                "public LocalizableResourceString(string nameOfLocalizableResource, ResourceManager resourceManager, Type resourceSource)",
                "public LocalizableResourceString(string nameOfLocalizableResource, ResourceManager resourceManager, Type resourceSource, params string[] formatArguments)",
                "protected override bool AreEqual(object other)",
                "protected override int GetHash()",
                "protected override string GetText(IFormatProvider formatProvider)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Location",
          "members": [
            "public bool IsInMetadata { get; }",
            "public bool IsInSource { get; }",
            "public abstract LocationKind Kind { get; }",
            "public virtual IModuleSymbol MetadataModule { get; }",
            "public static Location None { get; }",
            "public virtual TextSpan SourceSpan { get; }",
            "public virtual SyntaxTree SourceTree { get; }",
            "public static Location Create(SyntaxTree syntaxTree, TextSpan textSpan)",
            "public static Location Create(string filePath, TextSpan textSpan, LinePositionSpan lineSpan)",
            "public override abstract bool Equals(object obj)",
            "protected virtual string GetDebuggerDisplay()",
            "public override abstract int GetHashCode()",
            "public virtual FileLinePositionSpan GetLineSpan()",
            "public virtual FileLinePositionSpan GetMappedLineSpan()",
            "public override string ToString()",
            "public static bool operator ==(Location left, Location right)",
            "public static bool operator !=(Location left, Location right)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Metadata : IDisposable",
          "members": [
            "public MetadataId Id { get; }",
            "public abstract MetadataImageKind Kind { get; }",
            "protected abstract Metadata CommonCopy()",
            "public Metadata Copy()",
            "public abstract void Dispose()"
          ],
          "types": [
            {
              "type": "public sealed class Microsoft.CodeAnalysis.AssemblyMetadata : Metadata",
              "members": [
                "public override MetadataImageKind Kind { get; }",
                "protected override Metadata CommonCopy()",
                "public static AssemblyMetadata Create(ModuleMetadata module)",
                "public static AssemblyMetadata Create(ImmutableArray<ModuleMetadata> modules)",
                "public static AssemblyMetadata Create(IEnumerable<ModuleMetadata> modules)",
                "public static AssemblyMetadata Create(params ModuleMetadata[] modules)",
                "public static AssemblyMetadata CreateFromFile(string path)",
                "public static AssemblyMetadata CreateFromImage(ImmutableArray<byte> peImage)",
                "public static AssemblyMetadata CreateFromImage(IEnumerable<byte> peImage)",
                "public static AssemblyMetadata CreateFromStream(Stream peStream, bool leaveOpen = false)",
                "public static AssemblyMetadata CreateFromStream(Stream peStream, PEStreamOptions options)",
                "public override void Dispose()",
                "public ImmutableArray<ModuleMetadata> GetModules()",
                "public PortableExecutableReference GetReference(DocumentationProvider documentation = null, ImmutableArray<string> aliases = default, bool embedInteropTypes = false, string filePath = null, string display = null)"
              ]
            },
            {
              "type": "public sealed class Microsoft.CodeAnalysis.ModuleMetadata : Metadata",
              "members": [
                "public override MetadataImageKind Kind { get; }",
                "public string Name { get; }",
                "protected override Metadata CommonCopy()",
                "public static ModuleMetadata CreateFromFile(string path)",
                "public static ModuleMetadata CreateFromImage(IEnumerable<byte> peImage)",
                "public static ModuleMetadata CreateFromImage(ImmutableArray<byte> peImage)",
                "public static ModuleMetadata CreateFromImage(IntPtr peImage, int size)",
                "public static ModuleMetadata CreateFromMetadata(IntPtr metadata, int size)",
                "public static ModuleMetadata CreateFromStream(Stream peStream, bool leaveOpen = false)",
                "public static ModuleMetadata CreateFromStream(Stream peStream, PEStreamOptions options)",
                "public override void Dispose()",
                "public MetadataReader GetMetadataReader()",
                "public ImmutableArray<string> GetModuleNames()",
                "public Guid GetModuleVersionId()",
                "public PortableExecutableReference GetReference(DocumentationProvider documentation = null, string filePath = null, string display = null)"
              ]
            }
          ]
        },
        "public sealed class Microsoft.CodeAnalysis.MetadataId",
        {
          "type": "public abstract class Microsoft.CodeAnalysis.MetadataReference",
          "members": [
            "protected MetadataReference(MetadataReferenceProperties properties)",
            "public virtual string Display { get; }",
            "public MetadataReferenceProperties Properties { get; }",
            "public static MetadataReference CreateFromAssembly(Assembly assembly)",
            "public static MetadataReference CreateFromAssembly(Assembly assembly, MetadataReferenceProperties properties, DocumentationProvider documentation = null)",
            "public static PortableExecutableReference CreateFromFile(string path, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null)",
            "public static PortableExecutableReference CreateFromImage(ImmutableArray<byte> peImage, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null, string filePath = null)",
            "public static PortableExecutableReference CreateFromImage(IEnumerable<byte> peImage, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null, string filePath = null)",
            "public static PortableExecutableReference CreateFromStream(Stream peStream, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null, string filePath = null)",
            "public MetadataReference WithAliases(IEnumerable<string> aliases)",
            "public MetadataReference WithAliases(ImmutableArray<string> aliases)",
            "public MetadataReference WithEmbedInteropTypes(bool value)",
            "public MetadataReference WithProperties(MetadataReferenceProperties properties)"
          ],
          "types": [
            {
              "type": "public abstract class Microsoft.CodeAnalysis.CompilationReference : MetadataReference, IEquatable<CompilationReference>",
              "members": [
                "public Compilation Compilation { get; }",
                "public override string Display { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(CompilationReference other)",
                "public override int GetHashCode()",
                "public CompilationReference WithAliases(IEnumerable<string> aliases)",
                "public CompilationReference WithAliases(ImmutableArray<string> aliases)",
                "public CompilationReference WithEmbedInteropTypes(bool value)",
                "public CompilationReference WithProperties(MetadataReferenceProperties properties)"
              ]
            },
            {
              "type": "public abstract class Microsoft.CodeAnalysis.PortableExecutableReference : MetadataReference",
              "members": [
                "protected PortableExecutableReference(MetadataReferenceProperties properties, string fullPath = null, DocumentationProvider initialDocumentation = null)",
                "public override string Display { get; }",
                "public string FilePath { get; }",
                "protected abstract DocumentationProvider CreateDocumentationProvider()",
                "public Metadata GetMetadata()",
                "public MetadataId GetMetadataId()",
                "protected abstract Metadata GetMetadataImpl()",
                "public PortableExecutableReference WithAliases(IEnumerable<string> aliases)",
                "public PortableExecutableReference WithAliases(ImmutableArray<string> aliases)",
                "public PortableExecutableReference WithEmbedInteropTypes(bool value)",
                "public PortableExecutableReference WithProperties(MetadataReferenceProperties properties)",
                "protected abstract PortableExecutableReference WithPropertiesImpl(MetadataReferenceProperties properties)"
              ]
            },
            {
              "type": "public sealed class Microsoft.CodeAnalysis.UnresolvedMetadataReference : MetadataReference",
              "members": [
                "public override string Display { get; }",
                "public string Reference { get; }"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.MetadataReferenceResolver",
          "members": [
            "protected MetadataReferenceResolver()",
            "public virtual bool ResolveMissingAssemblies { get; }",
            "public override abstract bool Equals(object other)",
            "public override abstract int GetHashCode()",
            "public virtual PortableExecutableReference ResolveMissingAssembly(MetadataReference definition, AssemblyIdentity referenceIdentity)",
            "public abstract ImmutableArray<PortableExecutableReference> ResolveReference(string reference, string baseFilePath, MetadataReferenceProperties properties)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.ParseOptions",
          "members": [
            "public DocumentationMode DocumentationMode { get; protected set; }",
            "public ImmutableArray<Diagnostic> Errors { get; }",
            "public abstract IReadOnlyDictionary<string, string> Features { get; }",
            "public SourceCodeKind Kind { get; protected set; }",
            "public abstract string Language { get; }",
            "public abstract IEnumerable<string> PreprocessorSymbolNames { get; }",
            "public SourceCodeKind SpecifiedKind { get; protected set; }",
            "protected abstract ParseOptions CommonWithDocumentationMode(DocumentationMode documentationMode)",
            "protected abstract ParseOptions CommonWithFeatures(IEnumerable<KeyValuePair<string, string>> features)",
            "public abstract ParseOptions CommonWithKind(SourceCodeKind kind)",
            "public override abstract bool Equals(object obj)",
            "protected bool EqualsHelper(ParseOptions other)",
            "public override abstract int GetHashCode()",
            "protected int GetHashCodeHelper()",
            "public ParseOptions WithDocumentationMode(DocumentationMode documentationMode)",
            "public ParseOptions WithFeatures(IEnumerable<KeyValuePair<string, string>> features)",
            "public ParseOptions WithKind(SourceCodeKind kind)",
            "public static bool operator ==(ParseOptions left, ParseOptions right)",
            "public static bool operator !=(ParseOptions left, ParseOptions right)"
          ],
          "types": [
            {
              "type": "public sealed class Microsoft.CodeAnalysis.CSharp.CSharpParseOptions : ParseOptions, IEquatable<CSharpParseOptions>",
              "members": [
                "public CSharpParseOptions(LanguageVersion languageVersion = Default, DocumentationMode documentationMode = Parse, SourceCodeKind kind = Regular, IEnumerable<string> preprocessorSymbols = null)",
                "public static CSharpParseOptions Default { get; }",
                "public override IReadOnlyDictionary<string, string> Features { get; }",
                "public override string Language { get; }",
                "public LanguageVersion LanguageVersion { get; }",
                "public override IEnumerable<string> PreprocessorSymbolNames { get; }",
                "public LanguageVersion SpecifiedLanguageVersion { get; }",
                "protected override ParseOptions CommonWithDocumentationMode(DocumentationMode documentationMode)",
                "protected override ParseOptions CommonWithFeatures(IEnumerable<KeyValuePair<string, string>> features)",
                "public override ParseOptions CommonWithKind(SourceCodeKind kind)",
                "public override bool Equals(object obj)",
                "public bool Equals(CSharpParseOptions other)",
                "public override int GetHashCode()",
                "public CSharpParseOptions WithDocumentationMode(DocumentationMode documentationMode)",
                "public CSharpParseOptions WithFeatures(IEnumerable<KeyValuePair<string, string>> features)",
                "public CSharpParseOptions WithKind(SourceCodeKind kind)",
                "public CSharpParseOptions WithLanguageVersion(LanguageVersion version)",
                "public CSharpParseOptions WithPreprocessorSymbols(IEnumerable<string> preprocessorSymbols)",
                "public CSharpParseOptions WithPreprocessorSymbols(params string[] preprocessorSymbols)",
                "public CSharpParseOptions WithPreprocessorSymbols(ImmutableArray<string> symbols)"
              ]
            }
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.Project",
          "members": [
            "public IReadOnlyList<DocumentId> AdditionalDocumentIds { get; }",
            "public IEnumerable<TextDocument> AdditionalDocuments { get; }",
            "public IReadOnlyList<ProjectReference> AllProjectReferences { get; }",
            "public AnalyzerOptions AnalyzerOptions { get; }",
            "public IReadOnlyList<AnalyzerReference> AnalyzerReferences { get; }",
            "public string AssemblyName { get; }",
            "public CompilationOptions CompilationOptions { get; }",
            "public IReadOnlyList<DocumentId> DocumentIds { get; }",
            "public IEnumerable<Document> Documents { get; }",
            "public string FilePath { get; }",
            "public bool HasDocuments { get; }",
            "public ProjectId Id { get; }",
            "public bool IsSubmission { get; }",
            "public string Language { get; }",
            "public HostLanguageServices LanguageServices { get; }",
            "public IReadOnlyList<MetadataReference> MetadataReferences { get; }",
            "public string Name { get; }",
            "public string OutputFilePath { get; }",
            "public ParseOptions ParseOptions { get; }",
            "public IEnumerable<ProjectReference> ProjectReferences { get; }",
            "public Solution Solution { get; }",
            "public bool SupportsCompilation { get; }",
            "public VersionStamp Version { get; }",
            "public TextDocument AddAdditionalDocument(string name, SourceText text, IEnumerable<string> folders = null, string filePath = null)",
            "public TextDocument AddAdditionalDocument(string name, string text, IEnumerable<string> folders = null, string filePath = null)",
            "public Project AddAnalyzerReference(AnalyzerReference analyzerReference)",
            "public Project AddAnalyzerReferences(IEnumerable<AnalyzerReference> analyzerReferences)",
            "public Document AddDocument(string name, SyntaxNode syntaxRoot, IEnumerable<string> folders = null, string filePath = null)",
            "public Document AddDocument(string name, SourceText text, IEnumerable<string> folders = null, string filePath = null)",
            "public Document AddDocument(string name, string text, IEnumerable<string> folders = null, string filePath = null)",
            "public Project AddMetadataReference(MetadataReference metadataReference)",
            "public Project AddMetadataReferences(IEnumerable<MetadataReference> metadataReferences)",
            "public Project AddProjectReference(ProjectReference projectReference)",
            "public Project AddProjectReferences(IEnumerable<ProjectReference> projectReferences)",
            "public bool ContainsAdditionalDocument(DocumentId documentId)",
            "public bool ContainsDocument(DocumentId documentId)",
            "public TextDocument GetAdditionalDocument(DocumentId documentId)",
            "public ProjectChanges GetChanges(Project oldProject)",
            "public Task<Compilation> GetCompilationAsync(CancellationToken cancellationToken = default)",
            "public Task<VersionStamp> GetDependentSemanticVersionAsync(CancellationToken cancellationToken = default)",
            "public Task<VersionStamp> GetDependentVersionAsync(CancellationToken cancellationToken = default)",
            "public Document GetDocument(DocumentId documentId)",
            "public Document GetDocument(SyntaxTree syntaxTree)",
            "public DocumentId GetDocumentId(SyntaxTree syntaxTree)",
            "public Task<VersionStamp> GetLatestDocumentVersionAsync(CancellationToken cancellationToken = default)",
            "public Task<VersionStamp> GetSemanticVersionAsync(CancellationToken cancellationToken = default)",
            "public Project RemoveAdditionalDocument(DocumentId documentId)",
            "public Project RemoveAnalyzerReference(AnalyzerReference analyzerReference)",
            "public Project RemoveDocument(DocumentId documentId)",
            "public Project RemoveMetadataReference(MetadataReference metadataReference)",
            "public Project RemoveProjectReference(ProjectReference projectReference)",
            "public bool TryGetCompilation(out Compilation compilation)",
            "public Project WithAnalyzerReferences(IEnumerable<AnalyzerReference> analyzerReferencs)",
            "public Project WithAssemblyName(string assemblyName)",
            "public Project WithCompilationOptions(CompilationOptions options)",
            "public Project WithMetadataReferences(IEnumerable<MetadataReference> metadataReferences)",
            "public Project WithParseOptions(ParseOptions options)",
            "public Project WithProjectReferences(IEnumerable<ProjectReference> projectReferences)"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.ProjectDependencyGraph",
          "members": [
            "public IEnumerable<IEnumerable<ProjectId>> GetDependencySets(CancellationToken cancellationToken = default)",
            "public IImmutableSet<ProjectId> GetProjectsThatDirectlyDependOnThisProject(ProjectId projectId)",
            "public IImmutableSet<ProjectId> GetProjectsThatThisProjectDirectlyDependsOn(ProjectId projectId)",
            "public IImmutableSet<ProjectId> GetProjectsThatThisProjectTransitivelyDependsOn(ProjectId projectId)",
            "public IEnumerable<ProjectId> GetProjectsThatTransitivelyDependOnThisProject(ProjectId projectId)",
            "public IEnumerable<ProjectId> GetTopologicallySortedProjects(CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.ProjectId : IEquatable<ProjectId>, IObjectWritable",
          "members": [
            "public Guid Id { get; }",
            "public static ProjectId CreateFromSerialized(Guid id, string debugName = null)",
            "public static ProjectId CreateNewId(string debugName = null)",
            "public override bool Equals(object obj)",
            "public bool Equals(ProjectId other)",
            "public override int GetHashCode()",
            "public override string ToString()",
            "public static bool operator ==(ProjectId left, ProjectId right)",
            "public static bool operator !=(ProjectId left, ProjectId right)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.ProjectInfo",
          "members": [
            "public IReadOnlyList<DocumentInfo> AdditionalDocuments { get; }",
            "public IReadOnlyList<AnalyzerReference> AnalyzerReferences { get; }",
            "public string AssemblyName { get; }",
            "public CompilationOptions CompilationOptions { get; }",
            "public IReadOnlyList<DocumentInfo> Documents { get; }",
            "public string FilePath { get; }",
            "public Type HostObjectType { get; }",
            "public ProjectId Id { get; }",
            "public bool IsSubmission { get; }",
            "public string Language { get; }",
            "public IReadOnlyList<MetadataReference> MetadataReferences { get; }",
            "public string Name { get; }",
            "public string OutputFilePath { get; }",
            "public ParseOptions ParseOptions { get; }",
            "public IReadOnlyList<ProjectReference> ProjectReferences { get; }",
            "public VersionStamp Version { get; }",
            "public static ProjectInfo Create(ProjectId id, VersionStamp version, string name, string assemblyName, string language, string filePath = null, string outputFilePath = null, CompilationOptions compilationOptions = null, ParseOptions parseOptions = null, IEnumerable<DocumentInfo> documents = null, IEnumerable<ProjectReference> projectReferences = null, IEnumerable<MetadataReference> metadataReferences = null, IEnumerable<AnalyzerReference> analyzerReferences = null, IEnumerable<DocumentInfo> additionalDocuments = null, bool isSubmission = false, Type hostObjectType = null)",
            "public ProjectInfo WithAdditionalDocuments(IEnumerable<DocumentInfo> additionalDocuments)",
            "public ProjectInfo WithAnalyzerReferences(IEnumerable<AnalyzerReference> analyzerReferences)",
            "public ProjectInfo WithAssemblyName(string assemblyName)",
            "public ProjectInfo WithCompilationOptions(CompilationOptions compilationOptions)",
            "public ProjectInfo WithDocuments(IEnumerable<DocumentInfo> documents)",
            "public ProjectInfo WithFilePath(string filePath)",
            "public ProjectInfo WithMetadataReferences(IEnumerable<MetadataReference> metadataReferences)",
            "public ProjectInfo WithName(string name)",
            "public ProjectInfo WithOutputFilePath(string outputFilePath)",
            "public ProjectInfo WithParseOptions(ParseOptions parseOptions)",
            "public ProjectInfo WithProjectReferences(IEnumerable<ProjectReference> projectReferences)",
            "public ProjectInfo WithVersion(VersionStamp version)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.ProjectReference : IEquatable<ProjectReference>",
          "members": [
            "public ProjectReference(ProjectId projectId, ImmutableArray<string> aliases = default, bool embedInteropTypes = false)",
            "public ImmutableArray<string> Aliases { get; }",
            "public bool EmbedInteropTypes { get; }",
            "public ProjectId ProjectId { get; }",
            "public override bool Equals(object obj)",
            "public bool Equals(ProjectReference reference)",
            "public override int GetHashCode()",
            "public static bool operator ==(ProjectReference left, ProjectReference right)",
            "public static bool operator !=(ProjectReference left, ProjectReference right)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.ResourceDescription : IFileReference",
          "members": [
            "public ResourceDescription(string resourceName, Func<Stream> dataProvider, bool isPublic)",
            "public ResourceDescription(string resourceName, string fileName, Func<Stream> dataProvider, bool isPublic)"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.RuleSet",
          "members": [
            "public RuleSet(string filePath, ReportDiagnostic generalOption, ImmutableDictionary<string, ReportDiagnostic> specificOptions, ImmutableArray<RuleSetInclude> includes)",
            "public string FilePath { get; }",
            "public ReportDiagnostic GeneralDiagnosticOption { get; }",
            "public ImmutableArray<RuleSetInclude> Includes { get; }",
            "public ImmutableDictionary<string, ReportDiagnostic> SpecificDiagnosticOptions { get; }",
            "public static ReportDiagnostic GetDiagnosticOptionsFromRulesetFile(string rulesetFileFullPath, out Dictionary<string, ReportDiagnostic> specificDiagnosticOptions)",
            "public static ImmutableArray<string> GetEffectiveIncludesFromFile(string filePath)",
            "public static RuleSet LoadEffectiveRuleSetFromFile(string filePath)",
            "public RuleSet WithEffectiveAction(ReportDiagnostic action)"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.RuleSetInclude",
          "members": [
            "public RuleSetInclude(string includePath, ReportDiagnostic action)",
            "public ReportDiagnostic Action { get; }",
            "public string IncludePath { get; }",
            "public RuleSet LoadRuleSet(RuleSet parent)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.ScriptCompilationInfo",
          "members": [
            "public Type GlobalsType { get; }",
            "public Compilation PreviousScriptCompilation { get; }",
            "public Type ReturnType { get; }",
            "public ScriptCompilationInfo WithPreviousScriptCompilation(Compilation compilation)"
          ],
          "types": [
            {
              "type": "public sealed class Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo : ScriptCompilationInfo",
              "members": [
                "public CSharpCompilation PreviousScriptCompilation { get; }",
                "public CSharpScriptCompilationInfo WithPreviousScriptCompilation(CSharpCompilation compilation)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.SemanticModel",
          "members": [
            "protected SemanticModel()",
            "public Compilation Compilation { get; }",
            "protected abstract Compilation CompilationCore { get; }",
            "public virtual bool IgnoresAccessibility { get; }",
            "public abstract bool IsSpeculativeSemanticModel { get; }",
            "public abstract string Language { get; }",
            "public abstract int OriginalPositionForSpeculation { get; }",
            "public SemanticModel ParentModel { get; }",
            "protected abstract SemanticModel ParentModelCore { get; }",
            "public SyntaxTree SyntaxTree { get; }",
            "protected abstract SyntaxTree SyntaxTreeCore { get; }",
            "protected abstract ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode statement)",
            "protected abstract ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement)",
            "protected abstract DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode statementOrExpression)",
            "protected abstract DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement)",
            "protected abstract IAliasSymbol GetAliasInfoCore(SyntaxNode nameSyntax, CancellationToken cancellationToken = default)",
            "public Optional<object> GetConstantValue(SyntaxNode node, CancellationToken cancellationToken = default)",
            "protected abstract Optional<object> GetConstantValueCore(SyntaxNode node, CancellationToken cancellationToken = default)",
            "public abstract ImmutableArray<Diagnostic> GetDeclarationDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default)",
            "protected abstract ISymbol GetDeclaredSymbolCore(SyntaxNode declaration, CancellationToken cancellationToken = default)",
            "protected abstract ImmutableArray<ISymbol> GetDeclaredSymbolsCore(SyntaxNode declaration, CancellationToken cancellationToken = default)",
            "public abstract ImmutableArray<Diagnostic> GetDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default)",
            "public ISymbol GetEnclosingSymbol(int position, CancellationToken cancellationToken = default)",
            "protected abstract ISymbol GetEnclosingSymbolCore(int position, CancellationToken cancellationToken = default)",
            "protected abstract ImmutableArray<ISymbol> GetMemberGroupCore(SyntaxNode node, CancellationToken cancellationToken = default)",
            "public abstract ImmutableArray<Diagnostic> GetMethodBodyDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default)",
            "public IOperation GetOperation(SyntaxNode node, CancellationToken cancellationToken = default)",
            "protected abstract IOperation GetOperationCore(SyntaxNode node, CancellationToken cancellationToken)",
            "public PreprocessingSymbolInfo GetPreprocessingSymbolInfo(SyntaxNode nameSyntax)",
            "protected abstract PreprocessingSymbolInfo GetPreprocessingSymbolInfoCore(SyntaxNode nameSyntax)",
            "protected abstract IAliasSymbol GetSpeculativeAliasInfoCore(int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption)",
            "protected abstract SymbolInfo GetSpeculativeSymbolInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption)",
            "protected abstract TypeInfo GetSpeculativeTypeInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption)",
            "protected abstract SymbolInfo GetSymbolInfoCore(SyntaxNode node, CancellationToken cancellationToken = default)",
            "public abstract ImmutableArray<Diagnostic> GetSyntaxDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default)",
            "protected internal virtual SyntaxNode GetTopmostNodeForDiagnosticAnalysis(ISymbol symbol, SyntaxNode declaringSyntax)",
            "protected abstract TypeInfo GetTypeInfoCore(SyntaxNode node, CancellationToken cancellationToken = default)",
            "public bool IsAccessible(int position, ISymbol symbol)",
            "protected abstract bool IsAccessibleCore(int position, ISymbol symbol)",
            "public bool IsEventUsableAsField(int position, IEventSymbol eventSymbol)",
            "protected abstract bool IsEventUsableAsFieldCore(int position, IEventSymbol eventSymbol)",
            "public ImmutableArray<ISymbol> LookupBaseMembers(int position, string name = null)",
            "protected abstract ImmutableArray<ISymbol> LookupBaseMembersCore(int position, string name)",
            "public ImmutableArray<ISymbol> LookupLabels(int position, string name = null)",
            "protected abstract ImmutableArray<ISymbol> LookupLabelsCore(int position, string name)",
            "public ImmutableArray<ISymbol> LookupNamespacesAndTypes(int position, INamespaceOrTypeSymbol container = null, string name = null)",
            "protected abstract ImmutableArray<ISymbol> LookupNamespacesAndTypesCore(int position, INamespaceOrTypeSymbol container, string name)",
            "public ImmutableArray<ISymbol> LookupStaticMembers(int position, INamespaceOrTypeSymbol container = null, string name = null)",
            "protected abstract ImmutableArray<ISymbol> LookupStaticMembersCore(int position, INamespaceOrTypeSymbol container, string name)",
            "public ImmutableArray<ISymbol> LookupSymbols(int position, INamespaceOrTypeSymbol container = null, string name = null, bool includeReducedExtensionMethods = false)",
            "protected abstract ImmutableArray<ISymbol> LookupSymbolsCore(int position, INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods)"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.Solution",
          "members": [
            "public string FilePath { get; }",
            "public SolutionId Id { get; }",
            "public OptionSet Options { get; }",
            "public IReadOnlyList<ProjectId> ProjectIds { get; }",
            "public IEnumerable<Project> Projects { get; }",
            "public VersionStamp Version { get; }",
            "public Workspace Workspace { get; }",
            "public Solution AddAdditionalDocument(DocumentInfo documentInfo)",
            "public Solution AddAdditionalDocument(DocumentId documentId, string name, string text, IEnumerable<string> folders = null, string filePath = null)",
            "public Solution AddAdditionalDocument(DocumentId documentId, string name, SourceText text, IEnumerable<string> folders = null, string filePath = null)",
            "public Solution AddAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference)",
            "public Solution AddAnalyzerReferences(ProjectId projectId, IEnumerable<AnalyzerReference> analyzerReferences)",
            "public Solution AddDocument(DocumentInfo documentInfo)",
            "public Solution AddDocument(DocumentId documentId, string name, TextLoader loader, IEnumerable<string> folders = null)",
            "public Solution AddDocument(DocumentId documentId, string name, string text, IEnumerable<string> folders = null, string filePath = null)",
            "public Solution AddDocument(DocumentId documentId, string name, SourceText text, IEnumerable<string> folders = null, string filePath = null, bool isGenerated = false)",
            "public Solution AddDocument(DocumentId documentId, string name, SyntaxNode syntaxRoot, IEnumerable<string> folders = null, string filePath = null, bool isGenerated = false, PreservationMode preservationMode = PreserveValue)",
            "public Solution AddMetadataReference(ProjectId projectId, MetadataReference metadataReference)",
            "public Solution AddMetadataReferences(ProjectId projectId, IEnumerable<MetadataReference> metadataReferences)",
            "public Solution AddProject(ProjectInfo projectInfo)",
            "public Project AddProject(string name, string assemblyName, string language)",
            "public Solution AddProject(ProjectId projectId, string name, string assemblyName, string language)",
            "public Solution AddProjectReference(ProjectId projectId, ProjectReference projectReference)",
            "public Solution AddProjectReferences(ProjectId projectId, IEnumerable<ProjectReference> projectReferences)",
            "public bool ContainsAdditionalDocument(DocumentId documentId)",
            "public bool ContainsDocument(DocumentId documentId)",
            "public bool ContainsProject(ProjectId projectId)",
            "public TextDocument GetAdditionalDocument(DocumentId documentId)",
            "public SolutionChanges GetChanges(Solution oldSolution)",
            "public Document GetDocument(DocumentId documentId)",
            "public Document GetDocument(SyntaxTree syntaxTree)",
            "public DocumentId GetDocumentId(SyntaxTree syntaxTree)",
            "public DocumentId GetDocumentId(SyntaxTree syntaxTree, ProjectId projectId)",
            "public ImmutableArray<DocumentId> GetDocumentIdsWithFilePath(string filePath)",
            "public Solution GetIsolatedSolution()",
            "public VersionStamp GetLatestProjectVersion()",
            "public Project GetProject(ProjectId projectId)",
            "public Project GetProject(IAssemblySymbol assemblySymbol, CancellationToken cancellationToken = default)",
            "public ProjectDependencyGraph GetProjectDependencyGraph()",
            "public Solution RemoveAdditionalDocument(DocumentId documentId)",
            "public Solution RemoveAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference)",
            "public Solution RemoveDocument(DocumentId documentId)",
            "public Solution RemoveMetadataReference(ProjectId projectId, MetadataReference metadataReference)",
            "public Solution RemoveProject(ProjectId projectId)",
            "public Solution RemoveProjectReference(ProjectId projectId, ProjectReference projectReference)",
            "public Solution WithAdditionalDocumentText(DocumentId documentId, SourceText text, PreservationMode mode = PreserveValue)",
            "public Solution WithAdditionalDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode = PreserveValue)",
            "public Solution WithAdditionalDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode)",
            "public Solution WithDocumentFilePath(DocumentId documentId, string filePath)",
            "public Solution WithDocumentFolders(DocumentId documentId, IEnumerable<string> folders)",
            "public Solution WithDocumentName(DocumentId documentId, string name)",
            "public Solution WithDocumentSourceCodeKind(DocumentId documentId, SourceCodeKind sourceCodeKind)",
            "public Solution WithDocumentSyntaxRoot(DocumentId documentId, SyntaxNode root, PreservationMode mode = PreserveValue)",
            "public Solution WithDocumentText(DocumentId documentId, SourceText text, PreservationMode mode = PreserveValue)",
            "public Solution WithDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode = PreserveValue)",
            "public Solution WithDocumentText(IEnumerable<DocumentId> documentIds, SourceText text, PreservationMode mode = PreserveValue)",
            "public Solution WithDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode)",
            "public Solution WithProjectAnalyzerReferences(ProjectId projectId, IEnumerable<AnalyzerReference> analyzerReferences)",
            "public Solution WithProjectAssemblyName(ProjectId projectId, string assemblyName)",
            "public Solution WithProjectCompilationOptions(ProjectId projectId, CompilationOptions options)",
            "public Solution WithProjectFilePath(ProjectId projectId, string filePath)",
            "public Solution WithProjectMetadataReferences(ProjectId projectId, IEnumerable<MetadataReference> metadataReferences)",
            "public Solution WithProjectName(ProjectId projectId, string name)",
            "public Solution WithProjectOutputFilePath(ProjectId projectId, string outputFilePath)",
            "public Solution WithProjectParseOptions(ProjectId projectId, ParseOptions options)",
            "public Solution WithProjectReferences(ProjectId projectId, IEnumerable<ProjectReference> projectReferences)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.SolutionId : IEquatable<SolutionId>, IObjectWritable",
          "members": [
            "public Guid Id { get; }",
            "public static SolutionId CreateFromSerialized(Guid id, string debugName = null)",
            "public static SolutionId CreateNewId(string debugName = null)",
            "public override bool Equals(object obj)",
            "public bool Equals(SolutionId other)",
            "public override int GetHashCode()",
            "public static bool operator ==(SolutionId left, SolutionId right)",
            "public static bool operator !=(SolutionId left, SolutionId right)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.SolutionInfo",
          "members": [
            "public string FilePath { get; }",
            "public SolutionId Id { get; }",
            "public IReadOnlyList<ProjectInfo> Projects { get; }",
            "public VersionStamp Version { get; }",
            "public static SolutionInfo Create(SolutionId id, VersionStamp version, string filePath = null, IEnumerable<ProjectInfo> projects = null)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.SourceReferenceResolver",
          "members": [
            "protected SourceReferenceResolver()",
            "public override abstract bool Equals(object other)",
            "public override abstract int GetHashCode()",
            "public abstract string NormalizePath(string path, string baseFilePath)",
            "public abstract Stream OpenRead(string resolvedPath)",
            "public virtual SourceText ReadText(string resolvedPath)",
            "public abstract string ResolveReference(string path, string baseFilePath)"
          ],
          "types": [
            {
              "type": "public class Microsoft.CodeAnalysis.SourceFileResolver : SourceReferenceResolver, IEquatable<SourceFileResolver>",
              "members": [
                "public SourceFileResolver(IEnumerable<string> searchPaths, string baseDirectory)",
                "public SourceFileResolver(ImmutableArray<string> searchPaths, string baseDirectory)",
                "public SourceFileResolver(ImmutableArray<string> searchPaths, string baseDirectory, ImmutableArray<KeyValuePair<string, string>> pathMap)",
                "public string BaseDirectory { get; }",
                "public static SourceFileResolver Default { get; }",
                "public ImmutableArray<KeyValuePair<string, string>> PathMap { get; }",
                "public ImmutableArray<string> SearchPaths { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(SourceFileResolver other)",
                "protected virtual bool FileExists(string resolvedPath)",
                "public override int GetHashCode()",
                "public override string NormalizePath(string path, string baseFilePath)",
                "public override Stream OpenRead(string resolvedPath)",
                "public override string ResolveReference(string path, string baseFilePath)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.StrongNameProvider",
          "members": [
            "protected StrongNameProvider()",
            "public override abstract bool Equals(object other)",
            "public override abstract int GetHashCode()"
          ],
          "types": [
            {
              "type": "public class Microsoft.CodeAnalysis.DesktopStrongNameProvider : StrongNameProvider",
              "members": [
                "public DesktopStrongNameProvider(ImmutableArray<string> keyFileSearchPaths)",
                "public DesktopStrongNameProvider(ImmutableArray<string> keyFileSearchPaths = default, string tempPath = null)",
                "public override bool Equals(object obj)",
                "public override int GetHashCode()"
              ]
            }
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.SymbolDisplayFormat",
          "members": [
            "public SymbolDisplayFormat(SymbolDisplayGlobalNamespaceStyle globalNamespaceStyle = Omitted, SymbolDisplayTypeQualificationStyle typeQualificationStyle = NameOnly, SymbolDisplayGenericsOptions genericsOptions = None, SymbolDisplayMemberOptions memberOptions = None, SymbolDisplayDelegateStyle delegateStyle = NameOnly, SymbolDisplayExtensionMethodStyle extensionMethodStyle = Default, SymbolDisplayParameterOptions parameterOptions = None, SymbolDisplayPropertyStyle propertyStyle = NameOnly, SymbolDisplayLocalOptions localOptions = None, SymbolDisplayKindOptions kindOptions = None, SymbolDisplayMiscellaneousOptions miscellaneousOptions = None)",
            "public static SymbolDisplayFormat CSharpErrorMessageFormat { get; }",
            "public static SymbolDisplayFormat CSharpShortErrorMessageFormat { get; }",
            "public SymbolDisplayDelegateStyle DelegateStyle { get; }",
            "public SymbolDisplayExtensionMethodStyle ExtensionMethodStyle { get; }",
            "public static SymbolDisplayFormat FullyQualifiedFormat { get; }",
            "public SymbolDisplayGenericsOptions GenericsOptions { get; }",
            "public SymbolDisplayGlobalNamespaceStyle GlobalNamespaceStyle { get; }",
            "public SymbolDisplayKindOptions KindOptions { get; }",
            "public SymbolDisplayLocalOptions LocalOptions { get; }",
            "public SymbolDisplayMemberOptions MemberOptions { get; }",
            "public static SymbolDisplayFormat MinimallyQualifiedFormat { get; }",
            "public SymbolDisplayMiscellaneousOptions MiscellaneousOptions { get; }",
            "public SymbolDisplayParameterOptions ParameterOptions { get; }",
            "public SymbolDisplayPropertyStyle PropertyStyle { get; }",
            "public SymbolDisplayTypeQualificationStyle TypeQualificationStyle { get; }",
            "public static SymbolDisplayFormat VisualBasicErrorMessageFormat { get; }",
            "public static SymbolDisplayFormat VisualBasicShortErrorMessageFormat { get; }",
            "public SymbolDisplayFormat AddGenericsOptions(SymbolDisplayGenericsOptions options)",
            "public SymbolDisplayFormat AddKindOptions(SymbolDisplayKindOptions options)",
            "public SymbolDisplayFormat AddLocalOptions(SymbolDisplayLocalOptions options)",
            "public SymbolDisplayFormat AddMemberOptions(SymbolDisplayMemberOptions options)",
            "public SymbolDisplayFormat AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options)",
            "public SymbolDisplayFormat AddParameterOptions(SymbolDisplayParameterOptions options)",
            "public SymbolDisplayFormat RemoveGenericsOptions(SymbolDisplayGenericsOptions options)",
            "public SymbolDisplayFormat RemoveKindOptions(SymbolDisplayKindOptions options)",
            "public SymbolDisplayFormat RemoveLocalOptions(SymbolDisplayLocalOptions options)",
            "public SymbolDisplayFormat RemoveMemberOptions(SymbolDisplayMemberOptions options)",
            "public SymbolDisplayFormat RemoveMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options)",
            "public SymbolDisplayFormat RemoveParameterOptions(SymbolDisplayParameterOptions options)",
            "public SymbolDisplayFormat WithGenericsOptions(SymbolDisplayGenericsOptions options)",
            "public SymbolDisplayFormat WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle style)",
            "public SymbolDisplayFormat WithKindOptions(SymbolDisplayKindOptions options)",
            "public SymbolDisplayFormat WithLocalOptions(SymbolDisplayLocalOptions options)",
            "public SymbolDisplayFormat WithMemberOptions(SymbolDisplayMemberOptions options)",
            "public SymbolDisplayFormat WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options)",
            "public SymbolDisplayFormat WithParameterOptions(SymbolDisplayParameterOptions options)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.SymbolVisitor",
          "members": [
            "protected SymbolVisitor()",
            "public virtual void DefaultVisit(ISymbol symbol)",
            "public virtual void Visit(ISymbol symbol)",
            "public virtual void VisitAlias(IAliasSymbol symbol)",
            "public virtual void VisitArrayType(IArrayTypeSymbol symbol)",
            "public virtual void VisitAssembly(IAssemblySymbol symbol)",
            "public virtual void VisitDiscard(IDiscardSymbol symbol)",
            "public virtual void VisitDynamicType(IDynamicTypeSymbol symbol)",
            "public virtual void VisitEvent(IEventSymbol symbol)",
            "public virtual void VisitField(IFieldSymbol symbol)",
            "public virtual void VisitLabel(ILabelSymbol symbol)",
            "public virtual void VisitLocal(ILocalSymbol symbol)",
            "public virtual void VisitMethod(IMethodSymbol symbol)",
            "public virtual void VisitModule(IModuleSymbol symbol)",
            "public virtual void VisitNamedType(INamedTypeSymbol symbol)",
            "public virtual void VisitNamespace(INamespaceSymbol symbol)",
            "public virtual void VisitParameter(IParameterSymbol symbol)",
            "public virtual void VisitPointerType(IPointerTypeSymbol symbol)",
            "public virtual void VisitProperty(IPropertySymbol symbol)",
            "public virtual void VisitRangeVariable(IRangeVariableSymbol symbol)",
            "public virtual void VisitTypeParameter(ITypeParameterSymbol symbol)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.SymbolVisitor<TResult>",
          "members": [
            "protected SymbolVisitor()",
            "public virtual TResult DefaultVisit(ISymbol symbol)",
            "public virtual TResult Visit(ISymbol symbol)",
            "public virtual TResult VisitAlias(IAliasSymbol symbol)",
            "public virtual TResult VisitArrayType(IArrayTypeSymbol symbol)",
            "public virtual TResult VisitAssembly(IAssemblySymbol symbol)",
            "public virtual TResult VisitDiscard(IDiscardSymbol symbol)",
            "public virtual TResult VisitDynamicType(IDynamicTypeSymbol symbol)",
            "public virtual TResult VisitEvent(IEventSymbol symbol)",
            "public virtual TResult VisitField(IFieldSymbol symbol)",
            "public virtual TResult VisitLabel(ILabelSymbol symbol)",
            "public virtual TResult VisitLocal(ILocalSymbol symbol)",
            "public virtual TResult VisitMethod(IMethodSymbol symbol)",
            "public virtual TResult VisitModule(IModuleSymbol symbol)",
            "public virtual TResult VisitNamedType(INamedTypeSymbol symbol)",
            "public virtual TResult VisitNamespace(INamespaceSymbol symbol)",
            "public virtual TResult VisitParameter(IParameterSymbol symbol)",
            "public virtual TResult VisitPointerType(IPointerTypeSymbol symbol)",
            "public virtual TResult VisitProperty(IPropertySymbol symbol)",
            "public virtual TResult VisitRangeVariable(IRangeVariableSymbol symbol)",
            "public virtual TResult VisitTypeParameter(ITypeParameterSymbol symbol)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.SyntaxAnnotation : IEquatable<SyntaxAnnotation>, IObjectWritable",
          "members": [
            "public SyntaxAnnotation()",
            "public SyntaxAnnotation(string kind)",
            "public SyntaxAnnotation(string kind, string data)",
            "public string Data { get; }",
            "public static SyntaxAnnotation ElasticAnnotation { get; }",
            "public string Kind { get; }",
            "public override bool Equals(object obj)",
            "public bool Equals(SyntaxAnnotation other)",
            "public override int GetHashCode()",
            "public static bool operator ==(SyntaxAnnotation left, SyntaxAnnotation right)",
            "public static bool operator !=(SyntaxAnnotation left, SyntaxAnnotation right)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.SyntaxNode",
          "members": [
            "public bool ContainsAnnotations { get; }",
            "public bool ContainsDiagnostics { get; }",
            "public bool ContainsDirectives { get; }",
            "public bool ContainsSkippedText { get; }",
            "public TextSpan FullSpan { get; }",
            "public bool HasLeadingTrivia { get; }",
            "public bool HasStructuredTrivia { get; }",
            "public bool HasTrailingTrivia { get; }",
            "public bool IsMissing { get; }",
            "public bool IsStructuredTrivia { get; }",
            "protected string KindText { get; }",
            "public abstract string Language { get; }",
            "public SyntaxNode Parent { get; }",
            "public virtual SyntaxTrivia ParentTrivia { get; }",
            "public int RawKind { get; }",
            "public TextSpan Span { get; }",
            "public int SpanStart { get; }",
            "public SyntaxTree SyntaxTree { get; }",
            "protected abstract SyntaxTree SyntaxTreeCore { get; }",
            "public IEnumerable<SyntaxNode> Ancestors(bool ascendOutOfTrivia = true)",
            "public IEnumerable<SyntaxNode> AncestorsAndSelf(bool ascendOutOfTrivia = true)",
            "public IEnumerable<SyntaxNode> ChildNodes()",
            "public ChildSyntaxList ChildNodesAndTokens()",
            "public virtual SyntaxNodeOrToken ChildThatContainsPosition(int position)",
            "public IEnumerable<SyntaxToken> ChildTokens()",
            "public bool Contains(SyntaxNode node)",
            "public T CopyAnnotationsTo<T>(T node) where T : SyntaxNode",
            "public IEnumerable<SyntaxNode> DescendantNodes(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
            "public IEnumerable<SyntaxNode> DescendantNodes(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
            "public IEnumerable<SyntaxNode> DescendantNodesAndSelf(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
            "public IEnumerable<SyntaxNode> DescendantNodesAndSelf(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
            "public IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokens(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
            "public IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokens(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
            "public IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
            "public IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
            "public IEnumerable<SyntaxToken> DescendantTokens(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
            "public IEnumerable<SyntaxToken> DescendantTokens(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
            "public IEnumerable<SyntaxTrivia> DescendantTrivia(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
            "public IEnumerable<SyntaxTrivia> DescendantTrivia(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
            "protected virtual bool EquivalentToCore(SyntaxNode other)",
            "public SyntaxNode FindNode(TextSpan span, bool findInsideTrivia = false, bool getInnermostNodeForTie = false)",
            "public SyntaxToken FindToken(int position, bool findInsideTrivia = false)",
            "protected virtual SyntaxToken FindTokenCore(int position, bool findInsideTrivia)",
            "protected virtual SyntaxToken FindTokenCore(int position, Func<SyntaxTrivia, bool> stepInto)",
            "public SyntaxTrivia FindTrivia(int position, bool findInsideTrivia = false)",
            "public SyntaxTrivia FindTrivia(int position, Func<SyntaxTrivia, bool> stepInto)",
            "protected virtual SyntaxTrivia FindTriviaCore(int position, bool findInsideTrivia)",
            "public TNode FirstAncestorOrSelf<TNode>(Func<TNode, bool> predicate = null, bool ascendOutOfTrivia = true) where TNode : SyntaxNode",
            "public IEnumerable<SyntaxNode> GetAnnotatedNodes(string annotationKind)",
            "public IEnumerable<SyntaxNode> GetAnnotatedNodes(SyntaxAnnotation syntaxAnnotation)",
            "public IEnumerable<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(SyntaxAnnotation annotation)",
            "public IEnumerable<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(string annotationKind)",
            "public IEnumerable<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(params string[] annotationKinds)",
            "public IEnumerable<SyntaxToken> GetAnnotatedTokens(string annotationKind)",
            "public IEnumerable<SyntaxToken> GetAnnotatedTokens(SyntaxAnnotation syntaxAnnotation)",
            "public IEnumerable<SyntaxTrivia> GetAnnotatedTrivia(SyntaxAnnotation annotation)",
            "public IEnumerable<SyntaxTrivia> GetAnnotatedTrivia(string annotationKind)",
            "public IEnumerable<SyntaxTrivia> GetAnnotatedTrivia(params string[] annotationKinds)",
            "public IEnumerable<SyntaxAnnotation> GetAnnotations(string annotationKind)",
            "public IEnumerable<SyntaxAnnotation> GetAnnotations(IEnumerable<string> annotationKinds)",
            "public IEnumerable<Diagnostic> GetDiagnostics()",
            "public SyntaxToken GetFirstToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false)",
            "public SyntaxToken GetLastToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false)",
            "public SyntaxTriviaList GetLeadingTrivia()",
            "public Location GetLocation()",
            "protected T GetRed<T>(ref T field, int slot) where T : SyntaxNode",
            "protected T GetRedAtZero<T>(ref T field) where T : SyntaxNode",
            "public SyntaxReference GetReference()",
            "public SourceText GetText(Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1)",
            "public SyntaxTriviaList GetTrailingTrivia()",
            "public bool HasAnnotation(SyntaxAnnotation annotation)",
            "public bool HasAnnotations(string annotationKind)",
            "public bool HasAnnotations(IEnumerable<string> annotationKinds)",
            "protected internal abstract SyntaxNode InsertNodesInListCore(SyntaxNode nodeInList, IEnumerable<SyntaxNode> nodesToInsert, bool insertBefore)",
            "protected internal abstract SyntaxNode InsertTokensInListCore(SyntaxToken originalToken, IEnumerable<SyntaxToken> newTokens, bool insertBefore)",
            "protected internal abstract SyntaxNode InsertTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable<SyntaxTrivia> newTrivia, bool insertBefore)",
            "public bool IsEquivalentTo(SyntaxNode other)",
            "public bool IsEquivalentTo(SyntaxNode node, bool topLevel = false)",
            "protected abstract bool IsEquivalentToCore(SyntaxNode node, bool topLevel = false)",
            "public bool IsPartOfStructuredTrivia()",
            "protected internal abstract SyntaxNode NormalizeWhitespaceCore(string indentation, string eol, bool elasticTrivia)",
            "protected internal abstract SyntaxNode RemoveNodesCore(IEnumerable<SyntaxNode> nodes, SyntaxRemoveOptions options)",
            "protected internal abstract SyntaxNode ReplaceCore<TNode>(IEnumerable<TNode> nodes = null, Func<TNode, TNode, SyntaxNode> computeReplacementNode = null, IEnumerable<SyntaxToken> tokens = null, Func<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken = null, IEnumerable<SyntaxTrivia> trivia = null, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia = null) where TNode : SyntaxNode",
            "protected internal abstract SyntaxNode ReplaceNodeInListCore(SyntaxNode originalNode, IEnumerable<SyntaxNode> replacementNodes)",
            "protected internal abstract SyntaxNode ReplaceTokenInListCore(SyntaxToken originalToken, IEnumerable<SyntaxToken> newTokens)",
            "protected internal abstract SyntaxNode ReplaceTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable<SyntaxTrivia> newTrivia)",
            "public virtual void SerializeTo(Stream stream, CancellationToken cancellationToken = default)",
            "public virtual string ToFullString()",
            "public override string ToString()",
            "public virtual void WriteTo(TextWriter writer)"
          ],
          "types": [
            {
              "type": "public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode : SyntaxNode, IMessageSerializable",
              "members": [
                "public override string Language { get; }",
                "protected override SyntaxTree SyntaxTreeCore { get; }",
                "public abstract void Accept(CSharpSyntaxVisitor visitor)",
                "public abstract TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                "public static SyntaxNode DeserializeFrom(Stream stream, CancellationToken cancellationToken = default)",
                "protected override bool EquivalentToCore(SyntaxNode other)",
                "public SyntaxToken FindToken(int position, bool findInsideTrivia = false)",
                "public SyntaxTrivia FindTrivia(int position, bool findInsideTrivia = false)",
                "public SyntaxTrivia FindTrivia(int position, Func<SyntaxTrivia, bool> stepInto)",
                "public IEnumerable<Diagnostic> GetDiagnostics()",
                "public DirectiveTriviaSyntax GetFirstDirective(Func<DirectiveTriviaSyntax, bool> predicate = null)",
                "public SyntaxToken GetFirstToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false)",
                "public DirectiveTriviaSyntax GetLastDirective(Func<DirectiveTriviaSyntax, bool> predicate = null)",
                "public SyntaxToken GetLastToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false)",
                "public SyntaxTriviaList GetLeadingTrivia()",
                "public Location GetLocation()",
                "public SyntaxTriviaList GetTrailingTrivia()",
                "protected internal override SyntaxNode InsertNodesInListCore(SyntaxNode nodeInList, IEnumerable<SyntaxNode> nodesToInsert, bool insertBefore)",
                "protected internal override SyntaxNode InsertTokensInListCore(SyntaxToken originalToken, IEnumerable<SyntaxToken> newTokens, bool insertBefore)",
                "protected internal override SyntaxNode InsertTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable<SyntaxTrivia> newTrivia, bool insertBefore)",
                "protected override bool IsEquivalentToCore(SyntaxNode node, bool topLevel = false)",
                "public SyntaxKind Kind()",
                "protected internal override SyntaxNode NormalizeWhitespaceCore(string indentation, string eol, bool elasticTrivia)",
                "protected internal override SyntaxNode RemoveNodesCore(IEnumerable<SyntaxNode> nodes, SyntaxRemoveOptions options)",
                "protected internal override SyntaxNode ReplaceCore<TNode>(IEnumerable<TNode> nodes = null, Func<TNode, TNode, SyntaxNode> computeReplacementNode = null, IEnumerable<SyntaxToken> tokens = null, Func<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken = null, IEnumerable<SyntaxTrivia> trivia = null, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia = null) where TNode : SyntaxNode",
                "protected internal override SyntaxNode ReplaceNodeInListCore(SyntaxNode originalNode, IEnumerable<SyntaxNode> replacementNodes)",
                "protected internal override SyntaxNode ReplaceTokenInListCore(SyntaxToken originalToken, IEnumerable<SyntaxToken> newTokens)",
                "protected internal override SyntaxNode ReplaceTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable<SyntaxTrivia> newTrivia)"
              ],
              "types": [
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                    "public BlockSyntax Body { get; }",
                    "public ArrowExpressionClauseSyntax ExpressionBody { get; }",
                    "public SyntaxToken Keyword { get; }",
                    "public SyntaxTokenList Modifiers { get; }",
                    "public SyntaxToken SemicolonToken { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public AccessorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                    "public AccessorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)",
                    "public AccessorDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                    "public AccessorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken)",
                    "public AccessorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
                    "public AccessorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                    "public AccessorDeclarationSyntax WithBody(BlockSyntax body)",
                    "public AccessorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)",
                    "public AccessorDeclarationSyntax WithKeyword(SyntaxToken keyword)",
                    "public AccessorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                    "public AccessorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxList<AccessorDeclarationSyntax> Accessors { get; }",
                    "public SyntaxToken CloseBraceToken { get; }",
                    "public SyntaxToken OpenBraceToken { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public AccessorListSyntax AddAccessors(params AccessorDeclarationSyntax[] items)",
                    "public AccessorListSyntax Update(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)",
                    "public AccessorListSyntax WithAccessors(SyntaxList<AccessorDeclarationSyntax> accessors)",
                    "public AccessorListSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)",
                    "public AccessorListSyntax WithOpenBraceToken(SyntaxToken openBraceToken)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax : CSharpSyntaxNode",
                  "members": [
                    "public ExpressionSyntax Expression { get; }",
                    "public NameEqualsSyntax NameEquals { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public AnonymousObjectMemberDeclaratorSyntax Update(NameEqualsSyntax nameEquals, ExpressionSyntax expression)",
                    "public AnonymousObjectMemberDeclaratorSyntax WithExpression(ExpressionSyntax expression)",
                    "public AnonymousObjectMemberDeclaratorSyntax WithNameEquals(NameEqualsSyntax nameEquals)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax : CSharpSyntaxNode",
                  "members": [
                    "public ExpressionSyntax Expression { get; }",
                    "public NameColonSyntax NameColon { get; }",
                    "public SyntaxToken RefOrOutKeyword { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public ArgumentSyntax Update(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)",
                    "public ArgumentSyntax WithExpression(ExpressionSyntax expression)",
                    "public ArgumentSyntax WithNameColon(NameColonSyntax nameColon)",
                    "public ArgumentSyntax WithRefOrOutKeyword(SyntaxToken refOrOutKeyword)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken CloseBracketToken { get; }",
                    "public SyntaxToken OpenBracketToken { get; }",
                    "public int Rank { get; }",
                    "public SeparatedSyntaxList<ExpressionSyntax> Sizes { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public ArrayRankSpecifierSyntax AddSizes(params ExpressionSyntax[] items)",
                    "public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)",
                    "public ArrayRankSpecifierSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)",
                    "public ArrayRankSpecifierSyntax WithOpenBracketToken(SyntaxToken openBracketToken)",
                    "public ArrayRankSpecifierSyntax WithSizes(SeparatedSyntaxList<ExpressionSyntax> sizes)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken ArrowToken { get; }",
                    "public ExpressionSyntax Expression { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public ArrowExpressionClauseSyntax Update(SyntaxToken arrowToken, ExpressionSyntax expression)",
                    "public ArrowExpressionClauseSyntax WithArrowToken(SyntaxToken arrowToken)",
                    "public ArrowExpressionClauseSyntax WithExpression(ExpressionSyntax expression)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SeparatedSyntaxList<AttributeArgumentSyntax> Arguments { get; }",
                    "public SyntaxToken CloseParenToken { get; }",
                    "public SyntaxToken OpenParenToken { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public AttributeArgumentListSyntax AddArguments(params AttributeArgumentSyntax[] items)",
                    "public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)",
                    "public AttributeArgumentListSyntax WithArguments(SeparatedSyntaxList<AttributeArgumentSyntax> arguments)",
                    "public AttributeArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                    "public AttributeArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax : CSharpSyntaxNode",
                  "members": [
                    "public ExpressionSyntax Expression { get; }",
                    "public NameColonSyntax NameColon { get; }",
                    "public NameEqualsSyntax NameEquals { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public AttributeArgumentSyntax Update(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)",
                    "public AttributeArgumentSyntax WithExpression(ExpressionSyntax expression)",
                    "public AttributeArgumentSyntax WithNameColon(NameColonSyntax nameColon)",
                    "public AttributeArgumentSyntax WithNameEquals(NameEqualsSyntax nameEquals)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SeparatedSyntaxList<AttributeSyntax> Attributes { get; }",
                    "public SyntaxToken CloseBracketToken { get; }",
                    "public SyntaxToken OpenBracketToken { get; }",
                    "public AttributeTargetSpecifierSyntax Target { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public AttributeListSyntax AddAttributes(params AttributeSyntax[] items)",
                    "public AttributeListSyntax Update(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)",
                    "public AttributeListSyntax WithAttributes(SeparatedSyntaxList<AttributeSyntax> attributes)",
                    "public AttributeListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)",
                    "public AttributeListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)",
                    "public AttributeListSyntax WithTarget(AttributeTargetSpecifierSyntax target)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax : CSharpSyntaxNode",
                  "members": [
                    "public AttributeArgumentListSyntax ArgumentList { get; }",
                    "public NameSyntax Name { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public AttributeSyntax AddArgumentListArguments(params AttributeArgumentSyntax[] items)",
                    "public AttributeSyntax Update(NameSyntax name, AttributeArgumentListSyntax argumentList)",
                    "public AttributeSyntax WithArgumentList(AttributeArgumentListSyntax argumentList)",
                    "public AttributeSyntax WithName(NameSyntax name)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken ColonToken { get; }",
                    "public SyntaxToken Identifier { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public AttributeTargetSpecifierSyntax Update(SyntaxToken identifier, SyntaxToken colonToken)",
                    "public AttributeTargetSpecifierSyntax WithColonToken(SyntaxToken colonToken)",
                    "public AttributeTargetSpecifierSyntax WithIdentifier(SyntaxToken identifier)"
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax : CSharpSyntaxNode",
                  "members": [
                    "public abstract SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }"
                  ],
                  "types": [
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax : BaseArgumentListSyntax",
                      "members": [
                        "public override SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }",
                        "public SyntaxToken CloseParenToken { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ArgumentListSyntax AddArguments(params ArgumentSyntax[] items)",
                        "public ArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)",
                        "public ArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments)",
                        "public ArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public ArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax : BaseArgumentListSyntax",
                      "members": [
                        "public override SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }",
                        "public SyntaxToken CloseBracketToken { get; }",
                        "public SyntaxToken OpenBracketToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public BracketedArgumentListSyntax AddArguments(params ArgumentSyntax[] items)",
                        "public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)",
                        "public BracketedArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments)",
                        "public BracketedArgumentListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)",
                        "public BracketedArgumentListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax : CSharpSyntaxNode",
                  "members": [
                    "public abstract SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }"
                  ],
                  "types": [
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax",
                      "members": [
                        "public SyntaxToken CloseBracketToken { get; }",
                        "public SyntaxToken OpenBracketToken { get; }",
                        "public override SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public CrefBracketedParameterListSyntax AddParameters(params CrefParameterSyntax[] items)",
                        "public CrefBracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)",
                        "public CrefBracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)",
                        "public CrefBracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)",
                        "public CrefBracketedParameterListSyntax WithParameters(SeparatedSyntaxList<CrefParameterSyntax> parameters)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax : BaseCrefParameterListSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public override SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public CrefParameterListSyntax AddParameters(params CrefParameterSyntax[] items)",
                        "public CrefParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)",
                        "public CrefParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public CrefParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public CrefParameterListSyntax WithParameters(SeparatedSyntaxList<CrefParameterSyntax> parameters)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken ColonToken { get; }",
                    "public SeparatedSyntaxList<BaseTypeSyntax> Types { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public BaseListSyntax AddTypes(params BaseTypeSyntax[] items)",
                    "public BaseListSyntax Update(SyntaxToken colonToken, SeparatedSyntaxList<BaseTypeSyntax> types)",
                    "public BaseListSyntax WithColonToken(SyntaxToken colonToken)",
                    "public BaseListSyntax WithTypes(SeparatedSyntaxList<BaseTypeSyntax> types)"
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax : CSharpSyntaxNode",
                  "members": [
                    "public abstract SeparatedSyntaxList<ParameterSyntax> Parameters { get; }"
                  ],
                  "types": [
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax : BaseParameterListSyntax",
                      "members": [
                        "public SyntaxToken CloseBracketToken { get; }",
                        "public SyntaxToken OpenBracketToken { get; }",
                        "public override SeparatedSyntaxList<ParameterSyntax> Parameters { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public BracketedParameterListSyntax AddParameters(params ParameterSyntax[] items)",
                        "public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)",
                        "public BracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)",
                        "public BracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)",
                        "public BracketedParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax : BaseParameterListSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public override SeparatedSyntaxList<ParameterSyntax> Parameters { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ParameterListSyntax AddParameters(params ParameterSyntax[] items)",
                        "public ParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)",
                        "public ParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public ParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public ParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax : CSharpSyntaxNode",
                  "members": [
                    "public abstract TypeSyntax Type { get; }"
                  ],
                  "types": [
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax : BaseTypeSyntax",
                      "members": [
                        "public override TypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public SimpleBaseTypeSyntax Update(TypeSyntax type)",
                        "public SimpleBaseTypeSyntax WithType(TypeSyntax type)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax : CSharpSyntaxNode",
                  "members": [
                    "public BlockSyntax Block { get; }",
                    "public SyntaxToken CatchKeyword { get; }",
                    "public CatchDeclarationSyntax Declaration { get; }",
                    "public CatchFilterClauseSyntax Filter { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public CatchClauseSyntax AddBlockStatements(params StatementSyntax[] items)",
                    "public CatchClauseSyntax Update(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)",
                    "public CatchClauseSyntax WithBlock(BlockSyntax block)",
                    "public CatchClauseSyntax WithCatchKeyword(SyntaxToken catchKeyword)",
                    "public CatchClauseSyntax WithDeclaration(CatchDeclarationSyntax declaration)",
                    "public CatchClauseSyntax WithFilter(CatchFilterClauseSyntax filter)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken CloseParenToken { get; }",
                    "public SyntaxToken Identifier { get; }",
                    "public SyntaxToken OpenParenToken { get; }",
                    "public TypeSyntax Type { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public CatchDeclarationSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)",
                    "public CatchDeclarationSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                    "public CatchDeclarationSyntax WithIdentifier(SyntaxToken identifier)",
                    "public CatchDeclarationSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                    "public CatchDeclarationSyntax WithType(TypeSyntax type)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken CloseParenToken { get; }",
                    "public ExpressionSyntax FilterExpression { get; }",
                    "public SyntaxToken OpenParenToken { get; }",
                    "public SyntaxToken WhenKeyword { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public CatchFilterClauseSyntax Update(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)",
                    "public CatchFilterClauseSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                    "public CatchFilterClauseSyntax WithFilterExpression(ExpressionSyntax filterExpression)",
                    "public CatchFilterClauseSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                    "public CatchFilterClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax : CSharpSyntaxNode, ICompilationUnitSyntax",
                  "members": [
                    "public SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                    "public SyntaxToken EndOfFileToken { get; }",
                    "public SyntaxList<ExternAliasDirectiveSyntax> Externs { get; }",
                    "public SyntaxList<MemberDeclarationSyntax> Members { get; }",
                    "public SyntaxList<UsingDirectiveSyntax> Usings { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public CompilationUnitSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                    "public CompilationUnitSyntax AddExterns(params ExternAliasDirectiveSyntax[] items)",
                    "public CompilationUnitSyntax AddMembers(params MemberDeclarationSyntax[] items)",
                    "public CompilationUnitSyntax AddUsings(params UsingDirectiveSyntax[] items)",
                    "public IList<LoadDirectiveTriviaSyntax> GetLoadDirectives()",
                    "public IList<ReferenceDirectiveTriviaSyntax> GetReferenceDirectives()",
                    "public CompilationUnitSyntax Update(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)",
                    "public CompilationUnitSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                    "public CompilationUnitSyntax WithEndOfFileToken(SyntaxToken endOfFileToken)",
                    "public CompilationUnitSyntax WithExterns(SyntaxList<ExternAliasDirectiveSyntax> externs)",
                    "public CompilationUnitSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)",
                    "public CompilationUnitSyntax WithUsings(SyntaxList<UsingDirectiveSyntax> usings)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax : CSharpSyntaxNode",
                  "members": [
                    "public ArgumentListSyntax ArgumentList { get; }",
                    "public SyntaxToken ColonToken { get; }",
                    "public SyntaxToken ThisOrBaseKeyword { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public ConstructorInitializerSyntax AddArgumentListArguments(params ArgumentSyntax[] items)",
                    "public ConstructorInitializerSyntax Update(SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)",
                    "public ConstructorInitializerSyntax WithArgumentList(ArgumentListSyntax argumentList)",
                    "public ConstructorInitializerSyntax WithColonToken(SyntaxToken colonToken)",
                    "public ConstructorInitializerSyntax WithThisOrBaseKeyword(SyntaxToken thisOrBaseKeyword)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken RefOrOutKeyword { get; }",
                    "public TypeSyntax Type { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public CrefParameterSyntax Update(SyntaxToken refOrOutKeyword, TypeSyntax type)",
                    "public CrefParameterSyntax WithRefOrOutKeyword(SyntaxToken refOrOutKeyword)",
                    "public CrefParameterSyntax WithType(TypeSyntax type)"
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax : CSharpSyntaxNode",
                  "types": [
                    {
                      "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax : CrefSyntax",
                      "types": [
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax : MemberCrefSyntax",
                          "members": [
                            "public SyntaxToken ImplicitOrExplicitKeyword { get; }",
                            "public SyntaxToken OperatorKeyword { get; }",
                            "public CrefParameterListSyntax Parameters { get; }",
                            "public TypeSyntax Type { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public ConversionOperatorMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)",
                            "public ConversionOperatorMemberCrefSyntax Update(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)",
                            "public ConversionOperatorMemberCrefSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword)",
                            "public ConversionOperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)",
                            "public ConversionOperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters)",
                            "public ConversionOperatorMemberCrefSyntax WithType(TypeSyntax type)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax : MemberCrefSyntax",
                          "members": [
                            "public CrefBracketedParameterListSyntax Parameters { get; }",
                            "public SyntaxToken ThisKeyword { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public IndexerMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)",
                            "public IndexerMemberCrefSyntax Update(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)",
                            "public IndexerMemberCrefSyntax WithParameters(CrefBracketedParameterListSyntax parameters)",
                            "public IndexerMemberCrefSyntax WithThisKeyword(SyntaxToken thisKeyword)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax : MemberCrefSyntax",
                          "members": [
                            "public TypeSyntax Name { get; }",
                            "public CrefParameterListSyntax Parameters { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public NameMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)",
                            "public NameMemberCrefSyntax Update(TypeSyntax name, CrefParameterListSyntax parameters)",
                            "public NameMemberCrefSyntax WithName(TypeSyntax name)",
                            "public NameMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax : MemberCrefSyntax",
                          "members": [
                            "public SyntaxToken OperatorKeyword { get; }",
                            "public SyntaxToken OperatorToken { get; }",
                            "public CrefParameterListSyntax Parameters { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public OperatorMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)",
                            "public OperatorMemberCrefSyntax Update(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)",
                            "public OperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)",
                            "public OperatorMemberCrefSyntax WithOperatorToken(SyntaxToken operatorToken)",
                            "public OperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters)"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax : CrefSyntax",
                      "members": [
                        "public TypeSyntax Container { get; }",
                        "public SyntaxToken DotToken { get; }",
                        "public MemberCrefSyntax Member { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public QualifiedCrefSyntax Update(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)",
                        "public QualifiedCrefSyntax WithContainer(TypeSyntax container)",
                        "public QualifiedCrefSyntax WithDotToken(SyntaxToken dotToken)",
                        "public QualifiedCrefSyntax WithMember(MemberCrefSyntax member)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax : CrefSyntax",
                      "members": [
                        "public TypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public TypeCrefSyntax Update(TypeSyntax type)",
                        "public TypeCrefSyntax WithType(TypeSyntax type)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken ElseKeyword { get; }",
                    "public StatementSyntax Statement { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementSyntax statement)",
                    "public ElseClauseSyntax WithElseKeyword(SyntaxToken elseKeyword)",
                    "public ElseClauseSyntax WithStatement(StatementSyntax statement)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken EqualsToken { get; }",
                    "public ExpressionSyntax Value { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, ExpressionSyntax value)",
                    "public EqualsValueClauseSyntax WithEqualsToken(SyntaxToken equalsToken)",
                    "public EqualsValueClauseSyntax WithValue(ExpressionSyntax value)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken DotToken { get; }",
                    "public NameSyntax Name { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public ExplicitInterfaceSpecifierSyntax Update(NameSyntax name, SyntaxToken dotToken)",
                    "public ExplicitInterfaceSpecifierSyntax WithDotToken(SyntaxToken dotToken)",
                    "public ExplicitInterfaceSpecifierSyntax WithName(NameSyntax name)"
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax : CSharpSyntaxNode",
                  "types": [
                    {
                      "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public abstract SyntaxToken AsyncKeyword { get; }",
                        "public abstract CSharpSyntaxNode Body { get; }"
                      ],
                      "types": [
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax : AnonymousFunctionExpressionSyntax",
                          "members": [
                            "public override SyntaxToken AsyncKeyword { get; }",
                            "public BlockSyntax Block { get; }",
                            "public override CSharpSyntaxNode Body { get; }",
                            "public SyntaxToken DelegateKeyword { get; }",
                            "public ParameterListSyntax ParameterList { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public AnonymousMethodExpressionSyntax AddBlockStatements(params StatementSyntax[] items)",
                            "public AnonymousMethodExpressionSyntax AddParameterListParameters(params ParameterSyntax[] items)",
                            "public AnonymousMethodExpressionSyntax Update(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)",
                            "public AnonymousMethodExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword)",
                            "public AnonymousMethodExpressionSyntax WithBlock(BlockSyntax block)",
                            "public AnonymousMethodExpressionSyntax WithBody(CSharpSyntaxNode body)",
                            "public AnonymousMethodExpressionSyntax WithDelegateKeyword(SyntaxToken delegateKeyword)",
                            "public AnonymousMethodExpressionSyntax WithParameterList(ParameterListSyntax parameterList)"
                          ]
                        },
                        {
                          "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax : AnonymousFunctionExpressionSyntax",
                          "members": [
                            "public abstract SyntaxToken ArrowToken { get; }"
                          ],
                          "types": [
                            {
                              "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax : LambdaExpressionSyntax",
                              "members": [
                                "public override SyntaxToken ArrowToken { get; }",
                                "public override SyntaxToken AsyncKeyword { get; }",
                                "public override CSharpSyntaxNode Body { get; }",
                                "public ParameterListSyntax ParameterList { get; }",
                                "public override void Accept(CSharpSyntaxVisitor visitor)",
                                "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                                "public ParenthesizedLambdaExpressionSyntax AddParameterListParameters(params ParameterSyntax[] items)",
                                "public ParenthesizedLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body)",
                                "public ParenthesizedLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken)",
                                "public ParenthesizedLambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword)",
                                "public ParenthesizedLambdaExpressionSyntax WithBody(CSharpSyntaxNode body)",
                                "public ParenthesizedLambdaExpressionSyntax WithParameterList(ParameterListSyntax parameterList)"
                              ]
                            },
                            {
                              "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax : LambdaExpressionSyntax",
                              "members": [
                                "public override SyntaxToken ArrowToken { get; }",
                                "public override SyntaxToken AsyncKeyword { get; }",
                                "public override CSharpSyntaxNode Body { get; }",
                                "public ParameterSyntax Parameter { get; }",
                                "public override void Accept(CSharpSyntaxVisitor visitor)",
                                "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                                "public SimpleLambdaExpressionSyntax AddParameterAttributeLists(params AttributeListSyntax[] items)",
                                "public SimpleLambdaExpressionSyntax AddParameterModifiers(params SyntaxToken[] items)",
                                "public SimpleLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body)",
                                "public SimpleLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken)",
                                "public SimpleLambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword)",
                                "public SimpleLambdaExpressionSyntax WithBody(CSharpSyntaxNode body)",
                                "public SimpleLambdaExpressionSyntax WithParameter(ParameterSyntax parameter)"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken CloseBraceToken { get; }",
                        "public SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> Initializers { get; }",
                        "public SyntaxToken NewKeyword { get; }",
                        "public SyntaxToken OpenBraceToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public AnonymousObjectCreationExpressionSyntax AddInitializers(params AnonymousObjectMemberDeclaratorSyntax[] items)",
                        "public AnonymousObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)",
                        "public AnonymousObjectCreationExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)",
                        "public AnonymousObjectCreationExpressionSyntax WithInitializers(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers)",
                        "public AnonymousObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)",
                        "public AnonymousObjectCreationExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public InitializerExpressionSyntax Initializer { get; }",
                        "public SyntaxToken NewKeyword { get; }",
                        "public ArrayTypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ArrayCreationExpressionSyntax AddTypeRankSpecifiers(params ArrayRankSpecifierSyntax[] items)",
                        "public ArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)",
                        "public ArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)",
                        "public ArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)",
                        "public ArrayCreationExpressionSyntax WithType(ArrayTypeSyntax type)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public ExpressionSyntax Left { get; }",
                        "public SyntaxToken OperatorToken { get; }",
                        "public ExpressionSyntax Right { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public AssignmentExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
                        "public AssignmentExpressionSyntax WithLeft(ExpressionSyntax left)",
                        "public AssignmentExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)",
                        "public AssignmentExpressionSyntax WithRight(ExpressionSyntax right)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken AwaitKeyword { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public AwaitExpressionSyntax Update(SyntaxToken awaitKeyword, ExpressionSyntax expression)",
                        "public AwaitExpressionSyntax WithAwaitKeyword(SyntaxToken awaitKeyword)",
                        "public AwaitExpressionSyntax WithExpression(ExpressionSyntax expression)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public ExpressionSyntax Left { get; }",
                        "public SyntaxToken OperatorToken { get; }",
                        "public ExpressionSyntax Right { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
                        "public BinaryExpressionSyntax WithLeft(ExpressionSyntax left)",
                        "public BinaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)",
                        "public BinaryExpressionSyntax WithRight(ExpressionSyntax right)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public TypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public CastExpressionSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)",
                        "public CastExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public CastExpressionSyntax WithExpression(ExpressionSyntax expression)",
                        "public CastExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public CastExpressionSyntax WithType(TypeSyntax type)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken Keyword { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public CheckedExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)",
                        "public CheckedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public CheckedExpressionSyntax WithExpression(ExpressionSyntax expression)",
                        "public CheckedExpressionSyntax WithKeyword(SyntaxToken keyword)",
                        "public CheckedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken OperatorToken { get; }",
                        "public ExpressionSyntax WhenNotNull { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ConditionalAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)",
                        "public ConditionalAccessExpressionSyntax WithExpression(ExpressionSyntax expression)",
                        "public ConditionalAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)",
                        "public ConditionalAccessExpressionSyntax WithWhenNotNull(ExpressionSyntax whenNotNull)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken ColonToken { get; }",
                        "public ExpressionSyntax Condition { get; }",
                        "public SyntaxToken QuestionToken { get; }",
                        "public ExpressionSyntax WhenFalse { get; }",
                        "public ExpressionSyntax WhenTrue { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ConditionalExpressionSyntax Update(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)",
                        "public ConditionalExpressionSyntax WithColonToken(SyntaxToken colonToken)",
                        "public ConditionalExpressionSyntax WithCondition(ExpressionSyntax condition)",
                        "public ConditionalExpressionSyntax WithQuestionToken(SyntaxToken questionToken)",
                        "public ConditionalExpressionSyntax WithWhenFalse(ExpressionSyntax whenFalse)",
                        "public ConditionalExpressionSyntax WithWhenTrue(ExpressionSyntax whenTrue)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public VariableDesignationSyntax Designation { get; }",
                        "public TypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public DeclarationExpressionSyntax Update(TypeSyntax type, VariableDesignationSyntax designation)",
                        "public DeclarationExpressionSyntax WithDesignation(VariableDesignationSyntax designation)",
                        "public DeclarationExpressionSyntax WithType(TypeSyntax type)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public SyntaxToken Keyword { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public TypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public DefaultExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)",
                        "public DefaultExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public DefaultExpressionSyntax WithKeyword(SyntaxToken keyword)",
                        "public DefaultExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public DefaultExpressionSyntax WithType(TypeSyntax type)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public BracketedArgumentListSyntax ArgumentList { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ElementAccessExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)",
                        "public ElementAccessExpressionSyntax Update(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)",
                        "public ElementAccessExpressionSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)",
                        "public ElementAccessExpressionSyntax WithExpression(ExpressionSyntax expression)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public BracketedArgumentListSyntax ArgumentList { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ElementBindingExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)",
                        "public ElementBindingExpressionSyntax Update(BracketedArgumentListSyntax argumentList)",
                        "public ElementBindingExpressionSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken CloseBracketToken { get; }",
                        "public SyntaxTokenList Commas { get; }",
                        "public InitializerExpressionSyntax Initializer { get; }",
                        "public SyntaxToken NewKeyword { get; }",
                        "public SyntaxToken OpenBracketToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ImplicitArrayCreationExpressionSyntax AddCommas(params SyntaxToken[] items)",
                        "public ImplicitArrayCreationExpressionSyntax AddInitializerExpressions(params ExpressionSyntax[] items)",
                        "public ImplicitArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)",
                        "public ImplicitArrayCreationExpressionSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)",
                        "public ImplicitArrayCreationExpressionSyntax WithCommas(SyntaxTokenList commas)",
                        "public ImplicitArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)",
                        "public ImplicitArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)",
                        "public ImplicitArrayCreationExpressionSyntax WithOpenBracketToken(SyntaxToken openBracketToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax : ExpressionSyntax",
                      "members": [
                        "public BracketedArgumentListSyntax ArgumentList { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ImplicitElementAccessSyntax AddArgumentListArguments(params ArgumentSyntax[] items)",
                        "public ImplicitElementAccessSyntax Update(BracketedArgumentListSyntax argumentList)",
                        "public ImplicitElementAccessSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken CloseBraceToken { get; }",
                        "public SeparatedSyntaxList<ExpressionSyntax> Expressions { get; }",
                        "public SyntaxToken OpenBraceToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public InitializerExpressionSyntax AddExpressions(params ExpressionSyntax[] items)",
                        "public InitializerExpressionSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)",
                        "public InitializerExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)",
                        "public InitializerExpressionSyntax WithExpressions(SeparatedSyntaxList<ExpressionSyntax> expressions)",
                        "public InitializerExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken)"
                      ]
                    },
                    {
                      "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InstanceExpressionSyntax : ExpressionSyntax",
                      "types": [
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax : InstanceExpressionSyntax",
                          "members": [
                            "public SyntaxToken Token { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public BaseExpressionSyntax Update(SyntaxToken token)",
                            "public BaseExpressionSyntax WithToken(SyntaxToken token)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax : InstanceExpressionSyntax",
                          "members": [
                            "public SyntaxToken Token { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public ThisExpressionSyntax Update(SyntaxToken token)",
                            "public ThisExpressionSyntax WithToken(SyntaxToken token)"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxList<InterpolatedStringContentSyntax> Contents { get; }",
                        "public SyntaxToken StringEndToken { get; }",
                        "public SyntaxToken StringStartToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public InterpolatedStringExpressionSyntax AddContents(params InterpolatedStringContentSyntax[] items)",
                        "public InterpolatedStringExpressionSyntax Update(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)",
                        "public InterpolatedStringExpressionSyntax WithContents(SyntaxList<InterpolatedStringContentSyntax> contents)",
                        "public InterpolatedStringExpressionSyntax WithStringEndToken(SyntaxToken stringEndToken)",
                        "public InterpolatedStringExpressionSyntax WithStringStartToken(SyntaxToken stringStartToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public ArgumentListSyntax ArgumentList { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public InvocationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)",
                        "public InvocationExpressionSyntax Update(ExpressionSyntax expression, ArgumentListSyntax argumentList)",
                        "public InvocationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList)",
                        "public InvocationExpressionSyntax WithExpression(ExpressionSyntax expression)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken IsKeyword { get; }",
                        "public PatternSyntax Pattern { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public IsPatternExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)",
                        "public IsPatternExpressionSyntax WithExpression(ExpressionSyntax expression)",
                        "public IsPatternExpressionSyntax WithIsKeyword(SyntaxToken isKeyword)",
                        "public IsPatternExpressionSyntax WithPattern(PatternSyntax pattern)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken Token { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public LiteralExpressionSyntax Update(SyntaxToken token)",
                        "public LiteralExpressionSyntax WithToken(SyntaxToken token)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken Keyword { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public MakeRefExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)",
                        "public MakeRefExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public MakeRefExpressionSyntax WithExpression(ExpressionSyntax expression)",
                        "public MakeRefExpressionSyntax WithKeyword(SyntaxToken keyword)",
                        "public MakeRefExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public ExpressionSyntax Expression { get; }",
                        "public SimpleNameSyntax Name { get; }",
                        "public SyntaxToken OperatorToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public MemberAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)",
                        "public MemberAccessExpressionSyntax WithExpression(ExpressionSyntax expression)",
                        "public MemberAccessExpressionSyntax WithName(SimpleNameSyntax name)",
                        "public MemberAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SimpleNameSyntax Name { get; }",
                        "public SyntaxToken OperatorToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public MemberBindingExpressionSyntax Update(SyntaxToken operatorToken, SimpleNameSyntax name)",
                        "public MemberBindingExpressionSyntax WithName(SimpleNameSyntax name)",
                        "public MemberBindingExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public ArgumentListSyntax ArgumentList { get; }",
                        "public InitializerExpressionSyntax Initializer { get; }",
                        "public SyntaxToken NewKeyword { get; }",
                        "public TypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ObjectCreationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)",
                        "public ObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)",
                        "public ObjectCreationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList)",
                        "public ObjectCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)",
                        "public ObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)",
                        "public ObjectCreationExpressionSyntax WithType(TypeSyntax type)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken OmittedArraySizeExpressionToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public OmittedArraySizeExpressionSyntax Update(SyntaxToken omittedArraySizeExpressionToken)",
                        "public OmittedArraySizeExpressionSyntax WithOmittedArraySizeExpressionToken(SyntaxToken omittedArraySizeExpressionToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)",
                        "public ParenthesizedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public ParenthesizedExpressionSyntax WithExpression(ExpressionSyntax expression)",
                        "public ParenthesizedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public ExpressionSyntax Operand { get; }",
                        "public SyntaxToken OperatorToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public PostfixUnaryExpressionSyntax Update(ExpressionSyntax operand, SyntaxToken operatorToken)",
                        "public PostfixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand)",
                        "public PostfixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public ExpressionSyntax Operand { get; }",
                        "public SyntaxToken OperatorToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public PrefixUnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand)",
                        "public PrefixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand)",
                        "public PrefixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public QueryBodySyntax Body { get; }",
                        "public FromClauseSyntax FromClause { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public QueryExpressionSyntax AddBodyClauses(params QueryClauseSyntax[] items)",
                        "public QueryExpressionSyntax Update(FromClauseSyntax fromClause, QueryBodySyntax body)",
                        "public QueryExpressionSyntax WithBody(QueryBodySyntax body)",
                        "public QueryExpressionSyntax WithFromClause(FromClauseSyntax fromClause)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken RefKeyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public RefExpressionSyntax Update(SyntaxToken refKeyword, ExpressionSyntax expression)",
                        "public RefExpressionSyntax WithExpression(ExpressionSyntax expression)",
                        "public RefExpressionSyntax WithRefKeyword(SyntaxToken refKeyword)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken Keyword { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public RefTypeExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)",
                        "public RefTypeExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public RefTypeExpressionSyntax WithExpression(ExpressionSyntax expression)",
                        "public RefTypeExpressionSyntax WithKeyword(SyntaxToken keyword)",
                        "public RefTypeExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public SyntaxToken Comma { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken Keyword { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public TypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public RefValueExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)",
                        "public RefValueExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public RefValueExpressionSyntax WithComma(SyntaxToken comma)",
                        "public RefValueExpressionSyntax WithExpression(ExpressionSyntax expression)",
                        "public RefValueExpressionSyntax WithKeyword(SyntaxToken keyword)",
                        "public RefValueExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public RefValueExpressionSyntax WithType(TypeSyntax type)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public SyntaxToken Keyword { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public TypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public SizeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)",
                        "public SizeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public SizeOfExpressionSyntax WithKeyword(SyntaxToken keyword)",
                        "public SizeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public SizeOfExpressionSyntax WithType(TypeSyntax type)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken StackAllocKeyword { get; }",
                        "public TypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public StackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, TypeSyntax type)",
                        "public StackAllocArrayCreationExpressionSyntax WithStackAllocKeyword(SyntaxToken stackAllocKeyword)",
                        "public StackAllocArrayCreationExpressionSyntax WithType(TypeSyntax type)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken ThrowKeyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ThrowExpressionSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression)",
                        "public ThrowExpressionSyntax WithExpression(ExpressionSyntax expression)",
                        "public ThrowExpressionSyntax WithThrowKeyword(SyntaxToken throwKeyword)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }",
                        "public SyntaxToken CloseParenToken { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public TupleExpressionSyntax AddArguments(params ArgumentSyntax[] items)",
                        "public TupleExpressionSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)",
                        "public TupleExpressionSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments)",
                        "public TupleExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public TupleExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax : ExpressionSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public SyntaxToken Keyword { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public TypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public TypeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)",
                        "public TypeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public TypeOfExpressionSyntax WithKeyword(SyntaxToken keyword)",
                        "public TypeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public TypeOfExpressionSyntax WithType(TypeSyntax type)"
                      ]
                    },
                    {
                      "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax : ExpressionSyntax",
                      "members": [
                        "public bool IsVar { get; }"
                      ],
                      "types": [
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax : TypeSyntax",
                          "members": [
                            "public TypeSyntax ElementType { get; }",
                            "public SyntaxList<ArrayRankSpecifierSyntax> RankSpecifiers { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public ArrayTypeSyntax AddRankSpecifiers(params ArrayRankSpecifierSyntax[] items)",
                            "public ArrayTypeSyntax Update(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)",
                            "public ArrayTypeSyntax WithElementType(TypeSyntax elementType)",
                            "public ArrayTypeSyntax WithRankSpecifiers(SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)"
                          ]
                        },
                        {
                          "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax : TypeSyntax",
                          "members": [
                            "public int Arity { get; }"
                          ],
                          "types": [
                            {
                              "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax : NameSyntax",
                              "members": [
                                "public IdentifierNameSyntax Alias { get; }",
                                "public SyntaxToken ColonColonToken { get; }",
                                "public SimpleNameSyntax Name { get; }",
                                "public override void Accept(CSharpSyntaxVisitor visitor)",
                                "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                                "public AliasQualifiedNameSyntax Update(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)",
                                "public AliasQualifiedNameSyntax WithAlias(IdentifierNameSyntax alias)",
                                "public AliasQualifiedNameSyntax WithColonColonToken(SyntaxToken colonColonToken)",
                                "public AliasQualifiedNameSyntax WithName(SimpleNameSyntax name)"
                              ]
                            },
                            {
                              "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax : NameSyntax",
                              "members": [
                                "public SyntaxToken DotToken { get; }",
                                "public NameSyntax Left { get; }",
                                "public SimpleNameSyntax Right { get; }",
                                "public override void Accept(CSharpSyntaxVisitor visitor)",
                                "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                                "public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)",
                                "public QualifiedNameSyntax WithDotToken(SyntaxToken dotToken)",
                                "public QualifiedNameSyntax WithLeft(NameSyntax left)",
                                "public QualifiedNameSyntax WithRight(SimpleNameSyntax right)"
                              ]
                            },
                            {
                              "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax : NameSyntax",
                              "members": [
                                "public abstract SyntaxToken Identifier { get; }"
                              ],
                              "types": [
                                {
                                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax : SimpleNameSyntax",
                                  "members": [
                                    "public override SyntaxToken Identifier { get; }",
                                    "public bool IsUnboundGenericName { get; }",
                                    "public TypeArgumentListSyntax TypeArgumentList { get; }",
                                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                                    "public GenericNameSyntax AddTypeArgumentListArguments(params TypeSyntax[] items)",
                                    "public GenericNameSyntax Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)",
                                    "public GenericNameSyntax WithIdentifier(SyntaxToken identifier)",
                                    "public GenericNameSyntax WithTypeArgumentList(TypeArgumentListSyntax typeArgumentList)"
                                  ]
                                },
                                {
                                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax : SimpleNameSyntax",
                                  "members": [
                                    "public override SyntaxToken Identifier { get; }",
                                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                                    "public IdentifierNameSyntax Update(SyntaxToken identifier)",
                                    "public IdentifierNameSyntax WithIdentifier(SyntaxToken identifier)"
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax : TypeSyntax",
                          "members": [
                            "public TypeSyntax ElementType { get; }",
                            "public SyntaxToken QuestionToken { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public NullableTypeSyntax Update(TypeSyntax elementType, SyntaxToken questionToken)",
                            "public NullableTypeSyntax WithElementType(TypeSyntax elementType)",
                            "public NullableTypeSyntax WithQuestionToken(SyntaxToken questionToken)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax : TypeSyntax",
                          "members": [
                            "public SyntaxToken OmittedTypeArgumentToken { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public OmittedTypeArgumentSyntax Update(SyntaxToken omittedTypeArgumentToken)",
                            "public OmittedTypeArgumentSyntax WithOmittedTypeArgumentToken(SyntaxToken omittedTypeArgumentToken)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax : TypeSyntax",
                          "members": [
                            "public SyntaxToken AsteriskToken { get; }",
                            "public TypeSyntax ElementType { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public PointerTypeSyntax Update(TypeSyntax elementType, SyntaxToken asteriskToken)",
                            "public PointerTypeSyntax WithAsteriskToken(SyntaxToken asteriskToken)",
                            "public PointerTypeSyntax WithElementType(TypeSyntax elementType)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax : TypeSyntax",
                          "members": [
                            "public SyntaxToken Keyword { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public PredefinedTypeSyntax Update(SyntaxToken keyword)",
                            "public PredefinedTypeSyntax WithKeyword(SyntaxToken keyword)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax : TypeSyntax",
                          "members": [
                            "public SyntaxToken RefKeyword { get; }",
                            "public TypeSyntax Type { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public RefTypeSyntax Update(SyntaxToken refKeyword, TypeSyntax type)",
                            "public RefTypeSyntax WithRefKeyword(SyntaxToken refKeyword)",
                            "public RefTypeSyntax WithType(TypeSyntax type)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax : TypeSyntax",
                          "members": [
                            "public SyntaxToken CloseParenToken { get; }",
                            "public SeparatedSyntaxList<TupleElementSyntax> Elements { get; }",
                            "public SyntaxToken OpenParenToken { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public TupleTypeSyntax AddElements(params TupleElementSyntax[] items)",
                            "public TupleTypeSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)",
                            "public TupleTypeSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                            "public TupleTypeSyntax WithElements(SeparatedSyntaxList<TupleElementSyntax> elements)",
                            "public TupleTypeSyntax WithOpenParenToken(SyntaxToken openParenToken)"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken AliasKeyword { get; }",
                    "public SyntaxToken ExternKeyword { get; }",
                    "public SyntaxToken Identifier { get; }",
                    "public SyntaxToken SemicolonToken { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public ExternAliasDirectiveSyntax Update(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)",
                    "public ExternAliasDirectiveSyntax WithAliasKeyword(SyntaxToken aliasKeyword)",
                    "public ExternAliasDirectiveSyntax WithExternKeyword(SyntaxToken externKeyword)",
                    "public ExternAliasDirectiveSyntax WithIdentifier(SyntaxToken identifier)",
                    "public ExternAliasDirectiveSyntax WithSemicolonToken(SyntaxToken semicolonToken)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax : CSharpSyntaxNode",
                  "members": [
                    "public BlockSyntax Block { get; }",
                    "public SyntaxToken FinallyKeyword { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public FinallyClauseSyntax AddBlockStatements(params StatementSyntax[] items)",
                    "public FinallyClauseSyntax Update(SyntaxToken finallyKeyword, BlockSyntax block)",
                    "public FinallyClauseSyntax WithBlock(BlockSyntax block)",
                    "public FinallyClauseSyntax WithFinallyKeyword(SyntaxToken finallyKeyword)"
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax : CSharpSyntaxNode",
                  "types": [
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax : InterpolatedStringContentSyntax",
                      "members": [
                        "public SyntaxToken TextToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public InterpolatedStringTextSyntax Update(SyntaxToken textToken)",
                        "public InterpolatedStringTextSyntax WithTextToken(SyntaxToken textToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax : InterpolatedStringContentSyntax",
                      "members": [
                        "public InterpolationAlignmentClauseSyntax AlignmentClause { get; }",
                        "public SyntaxToken CloseBraceToken { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public InterpolationFormatClauseSyntax FormatClause { get; }",
                        "public SyntaxToken OpenBraceToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public InterpolationSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)",
                        "public InterpolationSyntax WithAlignmentClause(InterpolationAlignmentClauseSyntax alignmentClause)",
                        "public InterpolationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)",
                        "public InterpolationSyntax WithExpression(ExpressionSyntax expression)",
                        "public InterpolationSyntax WithFormatClause(InterpolationFormatClauseSyntax formatClause)",
                        "public InterpolationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken CommaToken { get; }",
                    "public ExpressionSyntax Value { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public InterpolationAlignmentClauseSyntax Update(SyntaxToken commaToken, ExpressionSyntax value)",
                    "public InterpolationAlignmentClauseSyntax WithCommaToken(SyntaxToken commaToken)",
                    "public InterpolationAlignmentClauseSyntax WithValue(ExpressionSyntax value)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken ColonToken { get; }",
                    "public SyntaxToken FormatStringToken { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public InterpolationFormatClauseSyntax Update(SyntaxToken colonToken, SyntaxToken formatStringToken)",
                    "public InterpolationFormatClauseSyntax WithColonToken(SyntaxToken colonToken)",
                    "public InterpolationFormatClauseSyntax WithFormatStringToken(SyntaxToken formatStringToken)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken Identifier { get; }",
                    "public SyntaxToken IntoKeyword { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public JoinIntoClauseSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier)",
                    "public JoinIntoClauseSyntax WithIdentifier(SyntaxToken identifier)",
                    "public JoinIntoClauseSyntax WithIntoKeyword(SyntaxToken intoKeyword)"
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax : CSharpSyntaxNode",
                  "types": [
                    {
                      "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax : MemberDeclarationSyntax",
                      "members": [
                        "public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                        "public abstract VariableDeclarationSyntax Declaration { get; }",
                        "public abstract SyntaxTokenList Modifiers { get; }",
                        "public abstract SyntaxToken SemicolonToken { get; }"
                      ],
                      "types": [
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax",
                          "members": [
                            "public override SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                            "public override VariableDeclarationSyntax Declaration { get; }",
                            "public SyntaxToken EventKeyword { get; }",
                            "public override SyntaxTokenList Modifiers { get; }",
                            "public override SyntaxToken SemicolonToken { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public EventFieldDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                            "public EventFieldDeclarationSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)",
                            "public EventFieldDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                            "public EventFieldDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)",
                            "public EventFieldDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                            "public EventFieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration)",
                            "public EventFieldDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword)",
                            "public EventFieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                            "public EventFieldDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax : BaseFieldDeclarationSyntax",
                          "members": [
                            "public override SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                            "public override VariableDeclarationSyntax Declaration { get; }",
                            "public override SyntaxTokenList Modifiers { get; }",
                            "public override SyntaxToken SemicolonToken { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public FieldDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                            "public FieldDeclarationSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)",
                            "public FieldDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                            "public FieldDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)",
                            "public FieldDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                            "public FieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration)",
                            "public FieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                            "public FieldDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax : MemberDeclarationSyntax",
                      "members": [
                        "public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                        "public abstract BlockSyntax Body { get; }",
                        "public abstract ArrowExpressionClauseSyntax ExpressionBody { get; }",
                        "public abstract SyntaxTokenList Modifiers { get; }",
                        "public abstract ParameterListSyntax ParameterList { get; }",
                        "public abstract SyntaxToken SemicolonToken { get; }"
                      ],
                      "types": [
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax",
                          "members": [
                            "public override SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                            "public override BlockSyntax Body { get; }",
                            "public override ArrowExpressionClauseSyntax ExpressionBody { get; }",
                            "public SyntaxToken Identifier { get; }",
                            "public ConstructorInitializerSyntax Initializer { get; }",
                            "public override SyntaxTokenList Modifiers { get; }",
                            "public override ParameterListSyntax ParameterList { get; }",
                            "public override SyntaxToken SemicolonToken { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public ConstructorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                            "public ConstructorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)",
                            "public ConstructorDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                            "public ConstructorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)",
                            "public ConstructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken)",
                            "public ConstructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
                            "public ConstructorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                            "public ConstructorDeclarationSyntax WithBody(BlockSyntax body)",
                            "public ConstructorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)",
                            "public ConstructorDeclarationSyntax WithIdentifier(SyntaxToken identifier)",
                            "public ConstructorDeclarationSyntax WithInitializer(ConstructorInitializerSyntax initializer)",
                            "public ConstructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                            "public ConstructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)",
                            "public ConstructorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax",
                          "members": [
                            "public override SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                            "public override BlockSyntax Body { get; }",
                            "public override ArrowExpressionClauseSyntax ExpressionBody { get; }",
                            "public SyntaxToken ImplicitOrExplicitKeyword { get; }",
                            "public override SyntaxTokenList Modifiers { get; }",
                            "public SyntaxToken OperatorKeyword { get; }",
                            "public override ParameterListSyntax ParameterList { get; }",
                            "public override SyntaxToken SemicolonToken { get; }",
                            "public TypeSyntax Type { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public ConversionOperatorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                            "public ConversionOperatorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)",
                            "public ConversionOperatorDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                            "public ConversionOperatorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)",
                            "public ConversionOperatorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
                            "public ConversionOperatorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                            "public ConversionOperatorDeclarationSyntax WithBody(BlockSyntax body)",
                            "public ConversionOperatorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)",
                            "public ConversionOperatorDeclarationSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword)",
                            "public ConversionOperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                            "public ConversionOperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)",
                            "public ConversionOperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)",
                            "public ConversionOperatorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)",
                            "public ConversionOperatorDeclarationSyntax WithType(TypeSyntax type)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax : BaseMethodDeclarationSyntax",
                          "members": [
                            "public override SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                            "public override BlockSyntax Body { get; }",
                            "public override ArrowExpressionClauseSyntax ExpressionBody { get; }",
                            "public SyntaxToken Identifier { get; }",
                            "public override SyntaxTokenList Modifiers { get; }",
                            "public override ParameterListSyntax ParameterList { get; }",
                            "public override SyntaxToken SemicolonToken { get; }",
                            "public SyntaxToken TildeToken { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public DestructorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                            "public DestructorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)",
                            "public DestructorDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                            "public DestructorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)",
                            "public DestructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)",
                            "public DestructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
                            "public DestructorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                            "public DestructorDeclarationSyntax WithBody(BlockSyntax body)",
                            "public DestructorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)",
                            "public DestructorDeclarationSyntax WithIdentifier(SyntaxToken identifier)",
                            "public DestructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                            "public DestructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)",
                            "public DestructorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)",
                            "public DestructorDeclarationSyntax WithTildeToken(SyntaxToken tildeToken)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax : BaseMethodDeclarationSyntax",
                          "members": [
                            "public int Arity { get; }",
                            "public override SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                            "public override BlockSyntax Body { get; }",
                            "public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }",
                            "public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }",
                            "public override ArrowExpressionClauseSyntax ExpressionBody { get; }",
                            "public SyntaxToken Identifier { get; }",
                            "public override SyntaxTokenList Modifiers { get; }",
                            "public override ParameterListSyntax ParameterList { get; }",
                            "public TypeSyntax ReturnType { get; }",
                            "public override SyntaxToken SemicolonToken { get; }",
                            "public TypeParameterListSyntax TypeParameterList { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public MethodDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                            "public MethodDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)",
                            "public MethodDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)",
                            "public MethodDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                            "public MethodDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)",
                            "public MethodDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)",
                            "public MethodDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
                            "public MethodDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                            "public MethodDeclarationSyntax WithBody(BlockSyntax body)",
                            "public MethodDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)",
                            "public MethodDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)",
                            "public MethodDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)",
                            "public MethodDeclarationSyntax WithIdentifier(SyntaxToken identifier)",
                            "public MethodDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                            "public MethodDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)",
                            "public MethodDeclarationSyntax WithReturnType(TypeSyntax returnType)",
                            "public MethodDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)",
                            "public MethodDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax : BaseMethodDeclarationSyntax",
                          "members": [
                            "public override SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                            "public override BlockSyntax Body { get; }",
                            "public override ArrowExpressionClauseSyntax ExpressionBody { get; }",
                            "public override SyntaxTokenList Modifiers { get; }",
                            "public SyntaxToken OperatorKeyword { get; }",
                            "public SyntaxToken OperatorToken { get; }",
                            "public override ParameterListSyntax ParameterList { get; }",
                            "public TypeSyntax ReturnType { get; }",
                            "public override SyntaxToken SemicolonToken { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public OperatorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                            "public OperatorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)",
                            "public OperatorDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                            "public OperatorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)",
                            "public OperatorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
                            "public OperatorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                            "public OperatorDeclarationSyntax WithBody(BlockSyntax body)",
                            "public OperatorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)",
                            "public OperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                            "public OperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)",
                            "public OperatorDeclarationSyntax WithOperatorToken(SyntaxToken operatorToken)",
                            "public OperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)",
                            "public OperatorDeclarationSyntax WithReturnType(TypeSyntax returnType)",
                            "public OperatorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax : MemberDeclarationSyntax",
                      "members": [
                        "public abstract AccessorListSyntax AccessorList { get; }",
                        "public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                        "public abstract ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }",
                        "public abstract SyntaxTokenList Modifiers { get; }",
                        "public abstract TypeSyntax Type { get; }"
                      ],
                      "types": [
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax : BasePropertyDeclarationSyntax",
                          "members": [
                            "public override AccessorListSyntax AccessorList { get; }",
                            "public override SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                            "public SyntaxToken EventKeyword { get; }",
                            "public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }",
                            "public SyntaxToken Identifier { get; }",
                            "public override SyntaxTokenList Modifiers { get; }",
                            "public override TypeSyntax Type { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public EventDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items)",
                            "public EventDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                            "public EventDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                            "public EventDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)",
                            "public EventDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList)",
                            "public EventDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                            "public EventDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword)",
                            "public EventDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)",
                            "public EventDeclarationSyntax WithIdentifier(SyntaxToken identifier)",
                            "public EventDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                            "public EventDeclarationSyntax WithType(TypeSyntax type)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax : BasePropertyDeclarationSyntax",
                          "members": [
                            "public override AccessorListSyntax AccessorList { get; }",
                            "public override SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                            "public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }",
                            "public ArrowExpressionClauseSyntax ExpressionBody { get; }",
                            "public override SyntaxTokenList Modifiers { get; }",
                            "public BracketedParameterListSyntax ParameterList { get; }",
                            "public SyntaxToken Semicolon { get; }",
                            "public SyntaxToken SemicolonToken { get; }",
                            "public SyntaxToken ThisKeyword { get; }",
                            "public override TypeSyntax Type { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public IndexerDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items)",
                            "public IndexerDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                            "public IndexerDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                            "public IndexerDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)",
                            "public IndexerDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
                            "public IndexerDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList)",
                            "public IndexerDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                            "public IndexerDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)",
                            "public IndexerDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)",
                            "public IndexerDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                            "public IndexerDeclarationSyntax WithParameterList(BracketedParameterListSyntax parameterList)",
                            "public IndexerDeclarationSyntax WithSemicolon(SyntaxToken semicolon)",
                            "public IndexerDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)",
                            "public IndexerDeclarationSyntax WithThisKeyword(SyntaxToken thisKeyword)",
                            "public IndexerDeclarationSyntax WithType(TypeSyntax type)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax : BasePropertyDeclarationSyntax",
                          "members": [
                            "public override AccessorListSyntax AccessorList { get; }",
                            "public override SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                            "public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }",
                            "public ArrowExpressionClauseSyntax ExpressionBody { get; }",
                            "public SyntaxToken Identifier { get; }",
                            "public EqualsValueClauseSyntax Initializer { get; }",
                            "public override SyntaxTokenList Modifiers { get; }",
                            "public SyntaxToken Semicolon { get; }",
                            "public SyntaxToken SemicolonToken { get; }",
                            "public override TypeSyntax Type { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public PropertyDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items)",
                            "public PropertyDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                            "public PropertyDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                            "public PropertyDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)",
                            "public PropertyDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList)",
                            "public PropertyDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                            "public PropertyDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)",
                            "public PropertyDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)",
                            "public PropertyDeclarationSyntax WithIdentifier(SyntaxToken identifier)",
                            "public PropertyDeclarationSyntax WithInitializer(EqualsValueClauseSyntax initializer)",
                            "public PropertyDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                            "public PropertyDeclarationSyntax WithSemicolon(SyntaxToken semicolon)",
                            "public PropertyDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)",
                            "public PropertyDeclarationSyntax WithType(TypeSyntax type)"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax : MemberDeclarationSyntax",
                      "members": [
                        "public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                        "public abstract BaseListSyntax BaseList { get; }",
                        "public abstract SyntaxToken CloseBraceToken { get; }",
                        "public abstract SyntaxToken Identifier { get; }",
                        "public abstract SyntaxTokenList Modifiers { get; }",
                        "public abstract SyntaxToken OpenBraceToken { get; }",
                        "public abstract SyntaxToken SemicolonToken { get; }"
                      ],
                      "types": [
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax : BaseTypeDeclarationSyntax",
                          "members": [
                            "public override SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                            "public override BaseListSyntax BaseList { get; }",
                            "public override SyntaxToken CloseBraceToken { get; }",
                            "public SyntaxToken EnumKeyword { get; }",
                            "public override SyntaxToken Identifier { get; }",
                            "public SeparatedSyntaxList<EnumMemberDeclarationSyntax> Members { get; }",
                            "public override SyntaxTokenList Modifiers { get; }",
                            "public override SyntaxToken OpenBraceToken { get; }",
                            "public override SyntaxToken SemicolonToken { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public EnumDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                            "public EnumDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items)",
                            "public EnumDeclarationSyntax AddMembers(params EnumMemberDeclarationSyntax[] items)",
                            "public EnumDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                            "public EnumDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)",
                            "public EnumDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                            "public EnumDeclarationSyntax WithBaseList(BaseListSyntax baseList)",
                            "public EnumDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)",
                            "public EnumDeclarationSyntax WithEnumKeyword(SyntaxToken enumKeyword)",
                            "public EnumDeclarationSyntax WithIdentifier(SyntaxToken identifier)",
                            "public EnumDeclarationSyntax WithMembers(SeparatedSyntaxList<EnumMemberDeclarationSyntax> members)",
                            "public EnumDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                            "public EnumDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)",
                            "public EnumDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)"
                          ]
                        },
                        {
                          "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax : BaseTypeDeclarationSyntax",
                          "members": [
                            "public int Arity { get; }",
                            "public abstract SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }",
                            "public abstract SyntaxToken Keyword { get; }",
                            "public abstract SyntaxList<MemberDeclarationSyntax> Members { get; }",
                            "public abstract TypeParameterListSyntax TypeParameterList { get; }"
                          ],
                          "types": [
                            {
                              "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax : TypeDeclarationSyntax",
                              "members": [
                                "public override SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                                "public override BaseListSyntax BaseList { get; }",
                                "public override SyntaxToken CloseBraceToken { get; }",
                                "public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }",
                                "public override SyntaxToken Identifier { get; }",
                                "public override SyntaxToken Keyword { get; }",
                                "public override SyntaxList<MemberDeclarationSyntax> Members { get; }",
                                "public override SyntaxTokenList Modifiers { get; }",
                                "public override SyntaxToken OpenBraceToken { get; }",
                                "public override SyntaxToken SemicolonToken { get; }",
                                "public override TypeParameterListSyntax TypeParameterList { get; }",
                                "public override void Accept(CSharpSyntaxVisitor visitor)",
                                "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                                "public ClassDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                                "public ClassDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items)",
                                "public ClassDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)",
                                "public ClassDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)",
                                "public ClassDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                                "public ClassDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)",
                                "public ClassDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)",
                                "public ClassDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                                "public ClassDeclarationSyntax WithBaseList(BaseListSyntax baseList)",
                                "public ClassDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)",
                                "public ClassDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)",
                                "public ClassDeclarationSyntax WithIdentifier(SyntaxToken identifier)",
                                "public ClassDeclarationSyntax WithKeyword(SyntaxToken keyword)",
                                "public ClassDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)",
                                "public ClassDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                                "public ClassDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)",
                                "public ClassDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)",
                                "public ClassDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)"
                              ]
                            },
                            {
                              "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax : TypeDeclarationSyntax",
                              "members": [
                                "public override SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                                "public override BaseListSyntax BaseList { get; }",
                                "public override SyntaxToken CloseBraceToken { get; }",
                                "public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }",
                                "public override SyntaxToken Identifier { get; }",
                                "public override SyntaxToken Keyword { get; }",
                                "public override SyntaxList<MemberDeclarationSyntax> Members { get; }",
                                "public override SyntaxTokenList Modifiers { get; }",
                                "public override SyntaxToken OpenBraceToken { get; }",
                                "public override SyntaxToken SemicolonToken { get; }",
                                "public override TypeParameterListSyntax TypeParameterList { get; }",
                                "public override void Accept(CSharpSyntaxVisitor visitor)",
                                "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                                "public InterfaceDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                                "public InterfaceDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items)",
                                "public InterfaceDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)",
                                "public InterfaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)",
                                "public InterfaceDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                                "public InterfaceDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)",
                                "public InterfaceDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)",
                                "public InterfaceDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                                "public InterfaceDeclarationSyntax WithBaseList(BaseListSyntax baseList)",
                                "public InterfaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)",
                                "public InterfaceDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)",
                                "public InterfaceDeclarationSyntax WithIdentifier(SyntaxToken identifier)",
                                "public InterfaceDeclarationSyntax WithKeyword(SyntaxToken keyword)",
                                "public InterfaceDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)",
                                "public InterfaceDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                                "public InterfaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)",
                                "public InterfaceDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)",
                                "public InterfaceDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)"
                              ]
                            },
                            {
                              "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax : TypeDeclarationSyntax",
                              "members": [
                                "public override SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                                "public override BaseListSyntax BaseList { get; }",
                                "public override SyntaxToken CloseBraceToken { get; }",
                                "public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }",
                                "public override SyntaxToken Identifier { get; }",
                                "public override SyntaxToken Keyword { get; }",
                                "public override SyntaxList<MemberDeclarationSyntax> Members { get; }",
                                "public override SyntaxTokenList Modifiers { get; }",
                                "public override SyntaxToken OpenBraceToken { get; }",
                                "public override SyntaxToken SemicolonToken { get; }",
                                "public override TypeParameterListSyntax TypeParameterList { get; }",
                                "public override void Accept(CSharpSyntaxVisitor visitor)",
                                "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                                "public StructDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                                "public StructDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items)",
                                "public StructDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)",
                                "public StructDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)",
                                "public StructDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                                "public StructDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)",
                                "public StructDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)",
                                "public StructDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                                "public StructDeclarationSyntax WithBaseList(BaseListSyntax baseList)",
                                "public StructDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)",
                                "public StructDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)",
                                "public StructDeclarationSyntax WithIdentifier(SyntaxToken identifier)",
                                "public StructDeclarationSyntax WithKeyword(SyntaxToken keyword)",
                                "public StructDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)",
                                "public StructDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                                "public StructDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)",
                                "public StructDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)",
                                "public StructDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax : MemberDeclarationSyntax",
                      "members": [
                        "public int Arity { get; }",
                        "public SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                        "public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }",
                        "public SyntaxToken DelegateKeyword { get; }",
                        "public SyntaxToken Identifier { get; }",
                        "public SyntaxTokenList Modifiers { get; }",
                        "public ParameterListSyntax ParameterList { get; }",
                        "public TypeSyntax ReturnType { get; }",
                        "public SyntaxToken SemicolonToken { get; }",
                        "public TypeParameterListSyntax TypeParameterList { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public DelegateDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                        "public DelegateDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)",
                        "public DelegateDeclarationSyntax AddModifiers(params SyntaxToken[] items)",
                        "public DelegateDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)",
                        "public DelegateDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)",
                        "public DelegateDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)",
                        "public DelegateDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                        "public DelegateDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)",
                        "public DelegateDeclarationSyntax WithDelegateKeyword(SyntaxToken delegateKeyword)",
                        "public DelegateDeclarationSyntax WithIdentifier(SyntaxToken identifier)",
                        "public DelegateDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)",
                        "public DelegateDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)",
                        "public DelegateDeclarationSyntax WithReturnType(TypeSyntax returnType)",
                        "public DelegateDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)",
                        "public DelegateDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax : MemberDeclarationSyntax",
                      "members": [
                        "public SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                        "public EqualsValueClauseSyntax EqualsValue { get; }",
                        "public SyntaxToken Identifier { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public EnumMemberDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                        "public EnumMemberDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)",
                        "public EnumMemberDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                        "public EnumMemberDeclarationSyntax WithEqualsValue(EqualsValueClauseSyntax equalsValue)",
                        "public EnumMemberDeclarationSyntax WithIdentifier(SyntaxToken identifier)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax : MemberDeclarationSyntax",
                      "members": [
                        "public StatementSyntax Statement { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public GlobalStatementSyntax Update(StatementSyntax statement)",
                        "public GlobalStatementSyntax WithStatement(StatementSyntax statement)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax : MemberDeclarationSyntax",
                      "members": [
                        "public SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                        "public SyntaxTokenList Modifiers { get; }",
                        "public TypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public IncompleteMemberSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                        "public IncompleteMemberSyntax AddModifiers(params SyntaxToken[] items)",
                        "public IncompleteMemberSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type)",
                        "public IncompleteMemberSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                        "public IncompleteMemberSyntax WithModifiers(SyntaxTokenList modifiers)",
                        "public IncompleteMemberSyntax WithType(TypeSyntax type)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax : MemberDeclarationSyntax",
                      "members": [
                        "public SyntaxToken CloseBraceToken { get; }",
                        "public SyntaxList<ExternAliasDirectiveSyntax> Externs { get; }",
                        "public SyntaxList<MemberDeclarationSyntax> Members { get; }",
                        "public NameSyntax Name { get; }",
                        "public SyntaxToken NamespaceKeyword { get; }",
                        "public SyntaxToken OpenBraceToken { get; }",
                        "public SyntaxToken SemicolonToken { get; }",
                        "public SyntaxList<UsingDirectiveSyntax> Usings { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public NamespaceDeclarationSyntax AddExterns(params ExternAliasDirectiveSyntax[] items)",
                        "public NamespaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)",
                        "public NamespaceDeclarationSyntax AddUsings(params UsingDirectiveSyntax[] items)",
                        "public NamespaceDeclarationSyntax Update(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)",
                        "public NamespaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)",
                        "public NamespaceDeclarationSyntax WithExterns(SyntaxList<ExternAliasDirectiveSyntax> externs)",
                        "public NamespaceDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)",
                        "public NamespaceDeclarationSyntax WithName(NameSyntax name)",
                        "public NamespaceDeclarationSyntax WithNamespaceKeyword(SyntaxToken namespaceKeyword)",
                        "public NamespaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)",
                        "public NamespaceDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)",
                        "public NamespaceDeclarationSyntax WithUsings(SyntaxList<UsingDirectiveSyntax> usings)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken ColonToken { get; }",
                    "public IdentifierNameSyntax Name { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public NameColonSyntax Update(IdentifierNameSyntax name, SyntaxToken colonToken)",
                    "public NameColonSyntax WithColonToken(SyntaxToken colonToken)",
                    "public NameColonSyntax WithName(IdentifierNameSyntax name)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken EqualsToken { get; }",
                    "public IdentifierNameSyntax Name { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public NameEqualsSyntax Update(IdentifierNameSyntax name, SyntaxToken equalsToken)",
                    "public NameEqualsSyntax WithEqualsToken(SyntaxToken equalsToken)",
                    "public NameEqualsSyntax WithName(IdentifierNameSyntax name)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken AscendingOrDescendingKeyword { get; }",
                    "public ExpressionSyntax Expression { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public OrderingSyntax Update(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)",
                    "public OrderingSyntax WithAscendingOrDescendingKeyword(SyntaxToken ascendingOrDescendingKeyword)",
                    "public OrderingSyntax WithExpression(ExpressionSyntax expression)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                    "public EqualsValueClauseSyntax Default { get; }",
                    "public SyntaxToken Identifier { get; }",
                    "public SyntaxTokenList Modifiers { get; }",
                    "public TypeSyntax Type { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public ParameterSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                    "public ParameterSyntax AddModifiers(params SyntaxToken[] items)",
                    "public ParameterSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)",
                    "public ParameterSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                    "public ParameterSyntax WithDefault(EqualsValueClauseSyntax @default)",
                    "public ParameterSyntax WithIdentifier(SyntaxToken identifier)",
                    "public ParameterSyntax WithModifiers(SyntaxTokenList modifiers)",
                    "public ParameterSyntax WithType(TypeSyntax type)"
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax : CSharpSyntaxNode",
                  "types": [
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax : PatternSyntax",
                      "members": [
                        "public ExpressionSyntax Expression { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ConstantPatternSyntax Update(ExpressionSyntax expression)",
                        "public ConstantPatternSyntax WithExpression(ExpressionSyntax expression)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax : PatternSyntax",
                      "members": [
                        "public VariableDesignationSyntax Designation { get; }",
                        "public TypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public DeclarationPatternSyntax Update(TypeSyntax type, VariableDesignationSyntax designation)",
                        "public DeclarationPatternSyntax WithDesignation(VariableDesignationSyntax designation)",
                        "public DeclarationPatternSyntax WithType(TypeSyntax type)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxList<QueryClauseSyntax> Clauses { get; }",
                    "public QueryContinuationSyntax Continuation { get; }",
                    "public SelectOrGroupClauseSyntax SelectOrGroup { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public QueryBodySyntax AddClauses(params QueryClauseSyntax[] items)",
                    "public QueryBodySyntax Update(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)",
                    "public QueryBodySyntax WithClauses(SyntaxList<QueryClauseSyntax> clauses)",
                    "public QueryBodySyntax WithContinuation(QueryContinuationSyntax continuation)",
                    "public QueryBodySyntax WithSelectOrGroup(SelectOrGroupClauseSyntax selectOrGroup)"
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax : CSharpSyntaxNode",
                  "types": [
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax : QueryClauseSyntax",
                      "members": [
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken FromKeyword { get; }",
                        "public SyntaxToken Identifier { get; }",
                        "public SyntaxToken InKeyword { get; }",
                        "public TypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public FromClauseSyntax Update(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)",
                        "public FromClauseSyntax WithExpression(ExpressionSyntax expression)",
                        "public FromClauseSyntax WithFromKeyword(SyntaxToken fromKeyword)",
                        "public FromClauseSyntax WithIdentifier(SyntaxToken identifier)",
                        "public FromClauseSyntax WithInKeyword(SyntaxToken inKeyword)",
                        "public FromClauseSyntax WithType(TypeSyntax type)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax : QueryClauseSyntax",
                      "members": [
                        "public SyntaxToken EqualsKeyword { get; }",
                        "public SyntaxToken Identifier { get; }",
                        "public ExpressionSyntax InExpression { get; }",
                        "public SyntaxToken InKeyword { get; }",
                        "public JoinIntoClauseSyntax Into { get; }",
                        "public SyntaxToken JoinKeyword { get; }",
                        "public ExpressionSyntax LeftExpression { get; }",
                        "public SyntaxToken OnKeyword { get; }",
                        "public ExpressionSyntax RightExpression { get; }",
                        "public TypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public JoinClauseSyntax Update(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)",
                        "public JoinClauseSyntax WithEqualsKeyword(SyntaxToken equalsKeyword)",
                        "public JoinClauseSyntax WithIdentifier(SyntaxToken identifier)",
                        "public JoinClauseSyntax WithInExpression(ExpressionSyntax inExpression)",
                        "public JoinClauseSyntax WithInKeyword(SyntaxToken inKeyword)",
                        "public JoinClauseSyntax WithInto(JoinIntoClauseSyntax into)",
                        "public JoinClauseSyntax WithJoinKeyword(SyntaxToken joinKeyword)",
                        "public JoinClauseSyntax WithLeftExpression(ExpressionSyntax leftExpression)",
                        "public JoinClauseSyntax WithOnKeyword(SyntaxToken onKeyword)",
                        "public JoinClauseSyntax WithRightExpression(ExpressionSyntax rightExpression)",
                        "public JoinClauseSyntax WithType(TypeSyntax type)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax : QueryClauseSyntax",
                      "members": [
                        "public SyntaxToken EqualsToken { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken Identifier { get; }",
                        "public SyntaxToken LetKeyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public LetClauseSyntax Update(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)",
                        "public LetClauseSyntax WithEqualsToken(SyntaxToken equalsToken)",
                        "public LetClauseSyntax WithExpression(ExpressionSyntax expression)",
                        "public LetClauseSyntax WithIdentifier(SyntaxToken identifier)",
                        "public LetClauseSyntax WithLetKeyword(SyntaxToken letKeyword)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax : QueryClauseSyntax",
                      "members": [
                        "public SyntaxToken OrderByKeyword { get; }",
                        "public SeparatedSyntaxList<OrderingSyntax> Orderings { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public OrderByClauseSyntax AddOrderings(params OrderingSyntax[] items)",
                        "public OrderByClauseSyntax Update(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings)",
                        "public OrderByClauseSyntax WithOrderByKeyword(SyntaxToken orderByKeyword)",
                        "public OrderByClauseSyntax WithOrderings(SeparatedSyntaxList<OrderingSyntax> orderings)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax : QueryClauseSyntax",
                      "members": [
                        "public ExpressionSyntax Condition { get; }",
                        "public SyntaxToken WhereKeyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public WhereClauseSyntax Update(SyntaxToken whereKeyword, ExpressionSyntax condition)",
                        "public WhereClauseSyntax WithCondition(ExpressionSyntax condition)",
                        "public WhereClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax : CSharpSyntaxNode",
                  "members": [
                    "public QueryBodySyntax Body { get; }",
                    "public SyntaxToken Identifier { get; }",
                    "public SyntaxToken IntoKeyword { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public QueryContinuationSyntax AddBodyClauses(params QueryClauseSyntax[] items)",
                    "public QueryContinuationSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)",
                    "public QueryContinuationSyntax WithBody(QueryBodySyntax body)",
                    "public QueryContinuationSyntax WithIdentifier(SyntaxToken identifier)",
                    "public QueryContinuationSyntax WithIntoKeyword(SyntaxToken intoKeyword)"
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax : CSharpSyntaxNode",
                  "types": [
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax : SelectOrGroupClauseSyntax",
                      "members": [
                        "public ExpressionSyntax ByExpression { get; }",
                        "public SyntaxToken ByKeyword { get; }",
                        "public ExpressionSyntax GroupExpression { get; }",
                        "public SyntaxToken GroupKeyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public GroupClauseSyntax Update(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)",
                        "public GroupClauseSyntax WithByExpression(ExpressionSyntax byExpression)",
                        "public GroupClauseSyntax WithByKeyword(SyntaxToken byKeyword)",
                        "public GroupClauseSyntax WithGroupExpression(ExpressionSyntax groupExpression)",
                        "public GroupClauseSyntax WithGroupKeyword(SyntaxToken groupKeyword)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax : SelectOrGroupClauseSyntax",
                      "members": [
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken SelectKeyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public SelectClauseSyntax Update(SyntaxToken selectKeyword, ExpressionSyntax expression)",
                        "public SelectClauseSyntax WithExpression(ExpressionSyntax expression)",
                        "public SelectClauseSyntax WithSelectKeyword(SyntaxToken selectKeyword)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax : CSharpSyntaxNode",
                  "types": [
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax : StatementSyntax",
                      "members": [
                        "public SyntaxToken CloseBraceToken { get; }",
                        "public SyntaxToken OpenBraceToken { get; }",
                        "public SyntaxList<StatementSyntax> Statements { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public BlockSyntax AddStatements(params StatementSyntax[] items)",
                        "public BlockSyntax Update(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)",
                        "public BlockSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)",
                        "public BlockSyntax WithOpenBraceToken(SyntaxToken openBraceToken)",
                        "public BlockSyntax WithStatements(SyntaxList<StatementSyntax> statements)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax : StatementSyntax",
                      "members": [
                        "public SyntaxToken BreakKeyword { get; }",
                        "public SyntaxToken SemicolonToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public BreakStatementSyntax Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken)",
                        "public BreakStatementSyntax WithBreakKeyword(SyntaxToken breakKeyword)",
                        "public BreakStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax : StatementSyntax",
                      "members": [
                        "public BlockSyntax Block { get; }",
                        "public SyntaxToken Keyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public CheckedStatementSyntax AddBlockStatements(params StatementSyntax[] items)",
                        "public CheckedStatementSyntax Update(SyntaxToken keyword, BlockSyntax block)",
                        "public CheckedStatementSyntax WithBlock(BlockSyntax block)",
                        "public CheckedStatementSyntax WithKeyword(SyntaxToken keyword)"
                      ]
                    },
                    {
                      "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax : StatementSyntax",
                      "members": [
                        "public abstract SyntaxToken CloseParenToken { get; }",
                        "public abstract ExpressionSyntax Expression { get; }",
                        "public abstract SyntaxToken ForEachKeyword { get; }",
                        "public abstract SyntaxToken InKeyword { get; }",
                        "public abstract SyntaxToken OpenParenToken { get; }",
                        "public abstract StatementSyntax Statement { get; }"
                      ],
                      "types": [
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax : CommonForEachStatementSyntax",
                          "members": [
                            "public override SyntaxToken CloseParenToken { get; }",
                            "public override ExpressionSyntax Expression { get; }",
                            "public override SyntaxToken ForEachKeyword { get; }",
                            "public SyntaxToken Identifier { get; }",
                            "public override SyntaxToken InKeyword { get; }",
                            "public override SyntaxToken OpenParenToken { get; }",
                            "public override StatementSyntax Statement { get; }",
                            "public TypeSyntax Type { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public ForEachStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)",
                            "public ForEachStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                            "public ForEachStatementSyntax WithExpression(ExpressionSyntax expression)",
                            "public ForEachStatementSyntax WithForEachKeyword(SyntaxToken forEachKeyword)",
                            "public ForEachStatementSyntax WithIdentifier(SyntaxToken identifier)",
                            "public ForEachStatementSyntax WithInKeyword(SyntaxToken inKeyword)",
                            "public ForEachStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                            "public ForEachStatementSyntax WithStatement(StatementSyntax statement)",
                            "public ForEachStatementSyntax WithType(TypeSyntax type)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax : CommonForEachStatementSyntax",
                          "members": [
                            "public override SyntaxToken CloseParenToken { get; }",
                            "public override ExpressionSyntax Expression { get; }",
                            "public override SyntaxToken ForEachKeyword { get; }",
                            "public override SyntaxToken InKeyword { get; }",
                            "public override SyntaxToken OpenParenToken { get; }",
                            "public override StatementSyntax Statement { get; }",
                            "public ExpressionSyntax Variable { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public ForEachVariableStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)",
                            "public ForEachVariableStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                            "public ForEachVariableStatementSyntax WithExpression(ExpressionSyntax expression)",
                            "public ForEachVariableStatementSyntax WithForEachKeyword(SyntaxToken forEachKeyword)",
                            "public ForEachVariableStatementSyntax WithInKeyword(SyntaxToken inKeyword)",
                            "public ForEachVariableStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                            "public ForEachVariableStatementSyntax WithStatement(StatementSyntax statement)",
                            "public ForEachVariableStatementSyntax WithVariable(ExpressionSyntax variable)"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax : StatementSyntax",
                      "members": [
                        "public SyntaxToken ContinueKeyword { get; }",
                        "public SyntaxToken SemicolonToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ContinueStatementSyntax Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken)",
                        "public ContinueStatementSyntax WithContinueKeyword(SyntaxToken continueKeyword)",
                        "public ContinueStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax : StatementSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public ExpressionSyntax Condition { get; }",
                        "public SyntaxToken DoKeyword { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public SyntaxToken SemicolonToken { get; }",
                        "public StatementSyntax Statement { get; }",
                        "public SyntaxToken WhileKeyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public DoStatementSyntax Update(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)",
                        "public DoStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public DoStatementSyntax WithCondition(ExpressionSyntax condition)",
                        "public DoStatementSyntax WithDoKeyword(SyntaxToken doKeyword)",
                        "public DoStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public DoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)",
                        "public DoStatementSyntax WithStatement(StatementSyntax statement)",
                        "public DoStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax : StatementSyntax",
                      "members": [
                        "public SyntaxToken SemicolonToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public EmptyStatementSyntax Update(SyntaxToken semicolonToken)",
                        "public EmptyStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax : StatementSyntax",
                      "members": [
                        "public bool AllowsAnyExpression { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken SemicolonToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ExpressionStatementSyntax Update(ExpressionSyntax expression, SyntaxToken semicolonToken)",
                        "public ExpressionStatementSyntax WithExpression(ExpressionSyntax expression)",
                        "public ExpressionStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax : StatementSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public VariableDeclarationSyntax Declaration { get; }",
                        "public SyntaxToken FixedKeyword { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public StatementSyntax Statement { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public FixedStatementSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)",
                        "public FixedStatementSyntax Update(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)",
                        "public FixedStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public FixedStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)",
                        "public FixedStatementSyntax WithFixedKeyword(SyntaxToken fixedKeyword)",
                        "public FixedStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public FixedStatementSyntax WithStatement(StatementSyntax statement)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax : StatementSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public ExpressionSyntax Condition { get; }",
                        "public VariableDeclarationSyntax Declaration { get; }",
                        "public SyntaxToken FirstSemicolonToken { get; }",
                        "public SyntaxToken ForKeyword { get; }",
                        "public SeparatedSyntaxList<ExpressionSyntax> Incrementors { get; }",
                        "public SeparatedSyntaxList<ExpressionSyntax> Initializers { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public SyntaxToken SecondSemicolonToken { get; }",
                        "public StatementSyntax Statement { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ForStatementSyntax AddIncrementors(params ExpressionSyntax[] items)",
                        "public ForStatementSyntax AddInitializers(params ExpressionSyntax[] items)",
                        "public ForStatementSyntax Update(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)",
                        "public ForStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public ForStatementSyntax WithCondition(ExpressionSyntax condition)",
                        "public ForStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)",
                        "public ForStatementSyntax WithFirstSemicolonToken(SyntaxToken firstSemicolonToken)",
                        "public ForStatementSyntax WithForKeyword(SyntaxToken forKeyword)",
                        "public ForStatementSyntax WithIncrementors(SeparatedSyntaxList<ExpressionSyntax> incrementors)",
                        "public ForStatementSyntax WithInitializers(SeparatedSyntaxList<ExpressionSyntax> initializers)",
                        "public ForStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public ForStatementSyntax WithSecondSemicolonToken(SyntaxToken secondSemicolonToken)",
                        "public ForStatementSyntax WithStatement(StatementSyntax statement)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax : StatementSyntax",
                      "members": [
                        "public SyntaxToken CaseOrDefaultKeyword { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken GotoKeyword { get; }",
                        "public SyntaxToken SemicolonToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public GotoStatementSyntax Update(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)",
                        "public GotoStatementSyntax WithCaseOrDefaultKeyword(SyntaxToken caseOrDefaultKeyword)",
                        "public GotoStatementSyntax WithExpression(ExpressionSyntax expression)",
                        "public GotoStatementSyntax WithGotoKeyword(SyntaxToken gotoKeyword)",
                        "public GotoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax : StatementSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public ExpressionSyntax Condition { get; }",
                        "public ElseClauseSyntax Else { get; }",
                        "public SyntaxToken IfKeyword { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public StatementSyntax Statement { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public IfStatementSyntax Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)",
                        "public IfStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public IfStatementSyntax WithCondition(ExpressionSyntax condition)",
                        "public IfStatementSyntax WithElse(ElseClauseSyntax @else)",
                        "public IfStatementSyntax WithIfKeyword(SyntaxToken ifKeyword)",
                        "public IfStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public IfStatementSyntax WithStatement(StatementSyntax statement)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax : StatementSyntax",
                      "members": [
                        "public SyntaxToken ColonToken { get; }",
                        "public SyntaxToken Identifier { get; }",
                        "public StatementSyntax Statement { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public LabeledStatementSyntax Update(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)",
                        "public LabeledStatementSyntax WithColonToken(SyntaxToken colonToken)",
                        "public LabeledStatementSyntax WithIdentifier(SyntaxToken identifier)",
                        "public LabeledStatementSyntax WithStatement(StatementSyntax statement)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax : StatementSyntax",
                      "members": [
                        "public VariableDeclarationSyntax Declaration { get; }",
                        "public bool IsConst { get; }",
                        "public SyntaxTokenList Modifiers { get; }",
                        "public SyntaxToken SemicolonToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public LocalDeclarationStatementSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)",
                        "public LocalDeclarationStatementSyntax AddModifiers(params SyntaxToken[] items)",
                        "public LocalDeclarationStatementSyntax Update(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)",
                        "public LocalDeclarationStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)",
                        "public LocalDeclarationStatementSyntax WithModifiers(SyntaxTokenList modifiers)",
                        "public LocalDeclarationStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax : StatementSyntax",
                      "members": [
                        "public BlockSyntax Body { get; }",
                        "public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }",
                        "public ArrowExpressionClauseSyntax ExpressionBody { get; }",
                        "public SyntaxToken Identifier { get; }",
                        "public SyntaxTokenList Modifiers { get; }",
                        "public ParameterListSyntax ParameterList { get; }",
                        "public TypeSyntax ReturnType { get; }",
                        "public SyntaxToken SemicolonToken { get; }",
                        "public TypeParameterListSyntax TypeParameterList { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public LocalFunctionStatementSyntax AddBodyStatements(params StatementSyntax[] items)",
                        "public LocalFunctionStatementSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)",
                        "public LocalFunctionStatementSyntax AddModifiers(params SyntaxToken[] items)",
                        "public LocalFunctionStatementSyntax AddParameterListParameters(params ParameterSyntax[] items)",
                        "public LocalFunctionStatementSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)",
                        "public LocalFunctionStatementSyntax Update(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
                        "public LocalFunctionStatementSyntax WithBody(BlockSyntax body)",
                        "public LocalFunctionStatementSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)",
                        "public LocalFunctionStatementSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)",
                        "public LocalFunctionStatementSyntax WithIdentifier(SyntaxToken identifier)",
                        "public LocalFunctionStatementSyntax WithModifiers(SyntaxTokenList modifiers)",
                        "public LocalFunctionStatementSyntax WithParameterList(ParameterListSyntax parameterList)",
                        "public LocalFunctionStatementSyntax WithReturnType(TypeSyntax returnType)",
                        "public LocalFunctionStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)",
                        "public LocalFunctionStatementSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax : StatementSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken LockKeyword { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public StatementSyntax Statement { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public LockStatementSyntax Update(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)",
                        "public LockStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public LockStatementSyntax WithExpression(ExpressionSyntax expression)",
                        "public LockStatementSyntax WithLockKeyword(SyntaxToken lockKeyword)",
                        "public LockStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public LockStatementSyntax WithStatement(StatementSyntax statement)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax : StatementSyntax",
                      "members": [
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken ReturnKeyword { get; }",
                        "public SyntaxToken SemicolonToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ReturnStatementSyntax Update(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)",
                        "public ReturnStatementSyntax WithExpression(ExpressionSyntax expression)",
                        "public ReturnStatementSyntax WithReturnKeyword(SyntaxToken returnKeyword)",
                        "public ReturnStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax : StatementSyntax",
                      "members": [
                        "public SyntaxToken CloseBraceToken { get; }",
                        "public SyntaxToken CloseParenToken { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken OpenBraceToken { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public SyntaxList<SwitchSectionSyntax> Sections { get; }",
                        "public SyntaxToken SwitchKeyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public SwitchStatementSyntax AddSections(params SwitchSectionSyntax[] items)",
                        "public SwitchStatementSyntax Update(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)",
                        "public SwitchStatementSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)",
                        "public SwitchStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public SwitchStatementSyntax WithExpression(ExpressionSyntax expression)",
                        "public SwitchStatementSyntax WithOpenBraceToken(SyntaxToken openBraceToken)",
                        "public SwitchStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public SwitchStatementSyntax WithSections(SyntaxList<SwitchSectionSyntax> sections)",
                        "public SwitchStatementSyntax WithSwitchKeyword(SyntaxToken switchKeyword)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax : StatementSyntax",
                      "members": [
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken SemicolonToken { get; }",
                        "public SyntaxToken ThrowKeyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ThrowStatementSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)",
                        "public ThrowStatementSyntax WithExpression(ExpressionSyntax expression)",
                        "public ThrowStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)",
                        "public ThrowStatementSyntax WithThrowKeyword(SyntaxToken throwKeyword)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax : StatementSyntax",
                      "members": [
                        "public BlockSyntax Block { get; }",
                        "public SyntaxList<CatchClauseSyntax> Catches { get; }",
                        "public FinallyClauseSyntax Finally { get; }",
                        "public SyntaxToken TryKeyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public TryStatementSyntax AddBlockStatements(params StatementSyntax[] items)",
                        "public TryStatementSyntax AddCatches(params CatchClauseSyntax[] items)",
                        "public TryStatementSyntax Update(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)",
                        "public TryStatementSyntax WithBlock(BlockSyntax block)",
                        "public TryStatementSyntax WithCatches(SyntaxList<CatchClauseSyntax> catches)",
                        "public TryStatementSyntax WithFinally(FinallyClauseSyntax @finally)",
                        "public TryStatementSyntax WithTryKeyword(SyntaxToken tryKeyword)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax : StatementSyntax",
                      "members": [
                        "public BlockSyntax Block { get; }",
                        "public SyntaxToken UnsafeKeyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public UnsafeStatementSyntax AddBlockStatements(params StatementSyntax[] items)",
                        "public UnsafeStatementSyntax Update(SyntaxToken unsafeKeyword, BlockSyntax block)",
                        "public UnsafeStatementSyntax WithBlock(BlockSyntax block)",
                        "public UnsafeStatementSyntax WithUnsafeKeyword(SyntaxToken unsafeKeyword)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax : StatementSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public VariableDeclarationSyntax Declaration { get; }",
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public StatementSyntax Statement { get; }",
                        "public SyntaxToken UsingKeyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public UsingStatementSyntax Update(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)",
                        "public UsingStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public UsingStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)",
                        "public UsingStatementSyntax WithExpression(ExpressionSyntax expression)",
                        "public UsingStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public UsingStatementSyntax WithStatement(StatementSyntax statement)",
                        "public UsingStatementSyntax WithUsingKeyword(SyntaxToken usingKeyword)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax : StatementSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public ExpressionSyntax Condition { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public StatementSyntax Statement { get; }",
                        "public SyntaxToken WhileKeyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public WhileStatementSyntax Update(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)",
                        "public WhileStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public WhileStatementSyntax WithCondition(ExpressionSyntax condition)",
                        "public WhileStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public WhileStatementSyntax WithStatement(StatementSyntax statement)",
                        "public WhileStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax : StatementSyntax",
                      "members": [
                        "public ExpressionSyntax Expression { get; }",
                        "public SyntaxToken ReturnOrBreakKeyword { get; }",
                        "public SyntaxToken SemicolonToken { get; }",
                        "public SyntaxToken YieldKeyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public YieldStatementSyntax Update(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)",
                        "public YieldStatementSyntax WithExpression(ExpressionSyntax expression)",
                        "public YieldStatementSyntax WithReturnOrBreakKeyword(SyntaxToken returnOrBreakKeyword)",
                        "public YieldStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)",
                        "public YieldStatementSyntax WithYieldKeyword(SyntaxToken yieldKeyword)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax : CSharpSyntaxNode, IStructuredTriviaSyntax",
                  "members": [
                    "public override SyntaxTrivia ParentTrivia { get; }"
                  ],
                  "types": [
                    {
                      "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax : StructuredTriviaSyntax",
                      "members": [
                        "public SyntaxToken DirectiveNameToken { get; }",
                        "public abstract SyntaxToken EndOfDirectiveToken { get; }",
                        "public abstract SyntaxToken HashToken { get; }",
                        "public abstract bool IsActive { get; }",
                        "public DirectiveTriviaSyntax GetNextDirective(Func<DirectiveTriviaSyntax, bool> predicate = null)",
                        "public DirectiveTriviaSyntax GetPreviousDirective(Func<DirectiveTriviaSyntax, bool> predicate = null)",
                        "public List<DirectiveTriviaSyntax> GetRelatedDirectives()"
                      ],
                      "types": [
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax : DirectiveTriviaSyntax",
                          "members": [
                            "public override SyntaxToken EndOfDirectiveToken { get; }",
                            "public override SyntaxToken HashToken { get; }",
                            "public SyntaxToken Identifier { get; }",
                            "public override bool IsActive { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public BadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)",
                            "public BadDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                            "public BadDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                            "public BadDirectiveTriviaSyntax WithIdentifier(SyntaxToken identifier)",
                            "public BadDirectiveTriviaSyntax WithIsActive(bool isActive)"
                          ]
                        },
                        {
                          "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BranchingDirectiveTriviaSyntax : DirectiveTriviaSyntax",
                          "members": [
                            "public abstract bool BranchTaken { get; }"
                          ],
                          "types": [
                            {
                              "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax",
                              "members": [
                                "public abstract ExpressionSyntax Condition { get; }",
                                "public abstract bool ConditionValue { get; }"
                              ],
                              "types": [
                                {
                                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax",
                                  "members": [
                                    "public override bool BranchTaken { get; }",
                                    "public override ExpressionSyntax Condition { get; }",
                                    "public override bool ConditionValue { get; }",
                                    "public SyntaxToken ElifKeyword { get; }",
                                    "public override SyntaxToken EndOfDirectiveToken { get; }",
                                    "public override SyntaxToken HashToken { get; }",
                                    "public override bool IsActive { get; }",
                                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                                    "public ElifDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)",
                                    "public ElifDirectiveTriviaSyntax WithBranchTaken(bool branchTaken)",
                                    "public ElifDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition)",
                                    "public ElifDirectiveTriviaSyntax WithConditionValue(bool conditionValue)",
                                    "public ElifDirectiveTriviaSyntax WithElifKeyword(SyntaxToken elifKeyword)",
                                    "public ElifDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                                    "public ElifDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                                    "public ElifDirectiveTriviaSyntax WithIsActive(bool isActive)"
                                  ]
                                },
                                {
                                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax",
                                  "members": [
                                    "public override bool BranchTaken { get; }",
                                    "public override ExpressionSyntax Condition { get; }",
                                    "public override bool ConditionValue { get; }",
                                    "public override SyntaxToken EndOfDirectiveToken { get; }",
                                    "public override SyntaxToken HashToken { get; }",
                                    "public SyntaxToken IfKeyword { get; }",
                                    "public override bool IsActive { get; }",
                                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                                    "public IfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)",
                                    "public IfDirectiveTriviaSyntax WithBranchTaken(bool branchTaken)",
                                    "public IfDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition)",
                                    "public IfDirectiveTriviaSyntax WithConditionValue(bool conditionValue)",
                                    "public IfDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                                    "public IfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                                    "public IfDirectiveTriviaSyntax WithIfKeyword(SyntaxToken ifKeyword)",
                                    "public IfDirectiveTriviaSyntax WithIsActive(bool isActive)"
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax",
                              "members": [
                                "public override bool BranchTaken { get; }",
                                "public SyntaxToken ElseKeyword { get; }",
                                "public override SyntaxToken EndOfDirectiveToken { get; }",
                                "public override SyntaxToken HashToken { get; }",
                                "public override bool IsActive { get; }",
                                "public override void Accept(CSharpSyntaxVisitor visitor)",
                                "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                                "public ElseDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)",
                                "public ElseDirectiveTriviaSyntax WithBranchTaken(bool branchTaken)",
                                "public ElseDirectiveTriviaSyntax WithElseKeyword(SyntaxToken elseKeyword)",
                                "public ElseDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                                "public ElseDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                                "public ElseDirectiveTriviaSyntax WithIsActive(bool isActive)"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax : DirectiveTriviaSyntax",
                          "members": [
                            "public SyntaxToken DefineKeyword { get; }",
                            "public override SyntaxToken EndOfDirectiveToken { get; }",
                            "public override SyntaxToken HashToken { get; }",
                            "public override bool IsActive { get; }",
                            "public SyntaxToken Name { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public DefineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)",
                            "public DefineDirectiveTriviaSyntax WithDefineKeyword(SyntaxToken defineKeyword)",
                            "public DefineDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                            "public DefineDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                            "public DefineDirectiveTriviaSyntax WithIsActive(bool isActive)",
                            "public DefineDirectiveTriviaSyntax WithName(SyntaxToken name)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax",
                          "members": [
                            "public SyntaxToken EndIfKeyword { get; }",
                            "public override SyntaxToken EndOfDirectiveToken { get; }",
                            "public override SyntaxToken HashToken { get; }",
                            "public override bool IsActive { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public EndIfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)",
                            "public EndIfDirectiveTriviaSyntax WithEndIfKeyword(SyntaxToken endIfKeyword)",
                            "public EndIfDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                            "public EndIfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                            "public EndIfDirectiveTriviaSyntax WithIsActive(bool isActive)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax",
                          "members": [
                            "public override SyntaxToken EndOfDirectiveToken { get; }",
                            "public SyntaxToken EndRegionKeyword { get; }",
                            "public override SyntaxToken HashToken { get; }",
                            "public override bool IsActive { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public EndRegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)",
                            "public EndRegionDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                            "public EndRegionDirectiveTriviaSyntax WithEndRegionKeyword(SyntaxToken endRegionKeyword)",
                            "public EndRegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                            "public EndRegionDirectiveTriviaSyntax WithIsActive(bool isActive)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax : DirectiveTriviaSyntax",
                          "members": [
                            "public override SyntaxToken EndOfDirectiveToken { get; }",
                            "public SyntaxToken ErrorKeyword { get; }",
                            "public override SyntaxToken HashToken { get; }",
                            "public override bool IsActive { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public ErrorDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)",
                            "public ErrorDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                            "public ErrorDirectiveTriviaSyntax WithErrorKeyword(SyntaxToken errorKeyword)",
                            "public ErrorDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                            "public ErrorDirectiveTriviaSyntax WithIsActive(bool isActive)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax : DirectiveTriviaSyntax",
                          "members": [
                            "public override SyntaxToken EndOfDirectiveToken { get; }",
                            "public SyntaxToken File { get; }",
                            "public override SyntaxToken HashToken { get; }",
                            "public override bool IsActive { get; }",
                            "public SyntaxToken Line { get; }",
                            "public SyntaxToken LineKeyword { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public LineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)",
                            "public LineDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                            "public LineDirectiveTriviaSyntax WithFile(SyntaxToken file)",
                            "public LineDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                            "public LineDirectiveTriviaSyntax WithIsActive(bool isActive)",
                            "public LineDirectiveTriviaSyntax WithLine(SyntaxToken line)",
                            "public LineDirectiveTriviaSyntax WithLineKeyword(SyntaxToken lineKeyword)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax : DirectiveTriviaSyntax",
                          "members": [
                            "public override SyntaxToken EndOfDirectiveToken { get; }",
                            "public SyntaxToken File { get; }",
                            "public override SyntaxToken HashToken { get; }",
                            "public override bool IsActive { get; }",
                            "public SyntaxToken LoadKeyword { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public LoadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)",
                            "public LoadDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                            "public LoadDirectiveTriviaSyntax WithFile(SyntaxToken file)",
                            "public LoadDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                            "public LoadDirectiveTriviaSyntax WithIsActive(bool isActive)",
                            "public LoadDirectiveTriviaSyntax WithLoadKeyword(SyntaxToken loadKeyword)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax",
                          "members": [
                            "public SyntaxToken Bytes { get; }",
                            "public SyntaxToken ChecksumKeyword { get; }",
                            "public override SyntaxToken EndOfDirectiveToken { get; }",
                            "public SyntaxToken File { get; }",
                            "public SyntaxToken Guid { get; }",
                            "public override SyntaxToken HashToken { get; }",
                            "public override bool IsActive { get; }",
                            "public SyntaxToken PragmaKeyword { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public PragmaChecksumDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)",
                            "public PragmaChecksumDirectiveTriviaSyntax WithBytes(SyntaxToken bytes)",
                            "public PragmaChecksumDirectiveTriviaSyntax WithChecksumKeyword(SyntaxToken checksumKeyword)",
                            "public PragmaChecksumDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                            "public PragmaChecksumDirectiveTriviaSyntax WithFile(SyntaxToken file)",
                            "public PragmaChecksumDirectiveTriviaSyntax WithGuid(SyntaxToken guid)",
                            "public PragmaChecksumDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                            "public PragmaChecksumDirectiveTriviaSyntax WithIsActive(bool isActive)",
                            "public PragmaChecksumDirectiveTriviaSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax",
                          "members": [
                            "public SyntaxToken DisableOrRestoreKeyword { get; }",
                            "public override SyntaxToken EndOfDirectiveToken { get; }",
                            "public SeparatedSyntaxList<ExpressionSyntax> ErrorCodes { get; }",
                            "public override SyntaxToken HashToken { get; }",
                            "public override bool IsActive { get; }",
                            "public SyntaxToken PragmaKeyword { get; }",
                            "public SyntaxToken WarningKeyword { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public PragmaWarningDirectiveTriviaSyntax AddErrorCodes(params ExpressionSyntax[] items)",
                            "public PragmaWarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)",
                            "public PragmaWarningDirectiveTriviaSyntax WithDisableOrRestoreKeyword(SyntaxToken disableOrRestoreKeyword)",
                            "public PragmaWarningDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                            "public PragmaWarningDirectiveTriviaSyntax WithErrorCodes(SeparatedSyntaxList<ExpressionSyntax> errorCodes)",
                            "public PragmaWarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                            "public PragmaWarningDirectiveTriviaSyntax WithIsActive(bool isActive)",
                            "public PragmaWarningDirectiveTriviaSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword)",
                            "public PragmaWarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax",
                          "members": [
                            "public override SyntaxToken EndOfDirectiveToken { get; }",
                            "public SyntaxToken File { get; }",
                            "public override SyntaxToken HashToken { get; }",
                            "public override bool IsActive { get; }",
                            "public SyntaxToken ReferenceKeyword { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public ReferenceDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)",
                            "public ReferenceDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                            "public ReferenceDirectiveTriviaSyntax WithFile(SyntaxToken file)",
                            "public ReferenceDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                            "public ReferenceDirectiveTriviaSyntax WithIsActive(bool isActive)",
                            "public ReferenceDirectiveTriviaSyntax WithReferenceKeyword(SyntaxToken referenceKeyword)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax",
                          "members": [
                            "public override SyntaxToken EndOfDirectiveToken { get; }",
                            "public override SyntaxToken HashToken { get; }",
                            "public override bool IsActive { get; }",
                            "public SyntaxToken RegionKeyword { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public RegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)",
                            "public RegionDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                            "public RegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                            "public RegionDirectiveTriviaSyntax WithIsActive(bool isActive)",
                            "public RegionDirectiveTriviaSyntax WithRegionKeyword(SyntaxToken regionKeyword)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax : DirectiveTriviaSyntax",
                          "members": [
                            "public override SyntaxToken EndOfDirectiveToken { get; }",
                            "public SyntaxToken ExclamationToken { get; }",
                            "public override SyntaxToken HashToken { get; }",
                            "public override bool IsActive { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public ShebangDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)",
                            "public ShebangDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                            "public ShebangDirectiveTriviaSyntax WithExclamationToken(SyntaxToken exclamationToken)",
                            "public ShebangDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                            "public ShebangDirectiveTriviaSyntax WithIsActive(bool isActive)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax : DirectiveTriviaSyntax",
                          "members": [
                            "public override SyntaxToken EndOfDirectiveToken { get; }",
                            "public override SyntaxToken HashToken { get; }",
                            "public override bool IsActive { get; }",
                            "public SyntaxToken Name { get; }",
                            "public SyntaxToken UndefKeyword { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public UndefDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)",
                            "public UndefDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                            "public UndefDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                            "public UndefDirectiveTriviaSyntax WithIsActive(bool isActive)",
                            "public UndefDirectiveTriviaSyntax WithName(SyntaxToken name)",
                            "public UndefDirectiveTriviaSyntax WithUndefKeyword(SyntaxToken undefKeyword)"
                          ]
                        },
                        {
                          "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax : DirectiveTriviaSyntax",
                          "members": [
                            "public override SyntaxToken EndOfDirectiveToken { get; }",
                            "public override SyntaxToken HashToken { get; }",
                            "public override bool IsActive { get; }",
                            "public SyntaxToken WarningKeyword { get; }",
                            "public override void Accept(CSharpSyntaxVisitor visitor)",
                            "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                            "public WarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)",
                            "public WarningDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)",
                            "public WarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)",
                            "public WarningDirectiveTriviaSyntax WithIsActive(bool isActive)",
                            "public WarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword)"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax : StructuredTriviaSyntax",
                      "members": [
                        "public SyntaxList<XmlNodeSyntax> Content { get; }",
                        "public SyntaxToken EndOfComment { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public DocumentationCommentTriviaSyntax AddContent(params XmlNodeSyntax[] items)",
                        "public DocumentationCommentTriviaSyntax Update(SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)",
                        "public DocumentationCommentTriviaSyntax WithContent(SyntaxList<XmlNodeSyntax> content)",
                        "public DocumentationCommentTriviaSyntax WithEndOfComment(SyntaxToken endOfComment)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax : StructuredTriviaSyntax, ISkippedTokensTriviaSyntax",
                      "members": [
                        "public SyntaxTokenList Tokens { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public SkippedTokensTriviaSyntax AddTokens(params SyntaxToken[] items)",
                        "public SkippedTokensTriviaSyntax Update(SyntaxTokenList tokens)",
                        "public SkippedTokensTriviaSyntax WithTokens(SyntaxTokenList tokens)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax : CSharpSyntaxNode",
                  "members": [
                    "public abstract SyntaxToken ColonToken { get; }",
                    "public abstract SyntaxToken Keyword { get; }"
                  ],
                  "types": [
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax : SwitchLabelSyntax",
                      "members": [
                        "public override SyntaxToken ColonToken { get; }",
                        "public override SyntaxToken Keyword { get; }",
                        "public PatternSyntax Pattern { get; }",
                        "public WhenClauseSyntax WhenClause { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public CasePatternSwitchLabelSyntax Update(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)",
                        "public CasePatternSwitchLabelSyntax WithColonToken(SyntaxToken colonToken)",
                        "public CasePatternSwitchLabelSyntax WithKeyword(SyntaxToken keyword)",
                        "public CasePatternSwitchLabelSyntax WithPattern(PatternSyntax pattern)",
                        "public CasePatternSwitchLabelSyntax WithWhenClause(WhenClauseSyntax whenClause)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax : SwitchLabelSyntax",
                      "members": [
                        "public override SyntaxToken ColonToken { get; }",
                        "public override SyntaxToken Keyword { get; }",
                        "public ExpressionSyntax Value { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public CaseSwitchLabelSyntax Update(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)",
                        "public CaseSwitchLabelSyntax WithColonToken(SyntaxToken colonToken)",
                        "public CaseSwitchLabelSyntax WithKeyword(SyntaxToken keyword)",
                        "public CaseSwitchLabelSyntax WithValue(ExpressionSyntax value)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax : SwitchLabelSyntax",
                      "members": [
                        "public override SyntaxToken ColonToken { get; }",
                        "public override SyntaxToken Keyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public DefaultSwitchLabelSyntax Update(SyntaxToken keyword, SyntaxToken colonToken)",
                        "public DefaultSwitchLabelSyntax WithColonToken(SyntaxToken colonToken)",
                        "public DefaultSwitchLabelSyntax WithKeyword(SyntaxToken keyword)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxList<SwitchLabelSyntax> Labels { get; }",
                    "public SyntaxList<StatementSyntax> Statements { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public SwitchSectionSyntax AddLabels(params SwitchLabelSyntax[] items)",
                    "public SwitchSectionSyntax AddStatements(params StatementSyntax[] items)",
                    "public SwitchSectionSyntax Update(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements)",
                    "public SwitchSectionSyntax WithLabels(SyntaxList<SwitchLabelSyntax> labels)",
                    "public SwitchSectionSyntax WithStatements(SyntaxList<StatementSyntax> statements)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken Identifier { get; }",
                    "public TypeSyntax Type { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public TupleElementSyntax Update(TypeSyntax type, SyntaxToken identifier)",
                    "public TupleElementSyntax WithIdentifier(SyntaxToken identifier)",
                    "public TupleElementSyntax WithType(TypeSyntax type)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SeparatedSyntaxList<TypeSyntax> Arguments { get; }",
                    "public SyntaxToken GreaterThanToken { get; }",
                    "public SyntaxToken LessThanToken { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public TypeArgumentListSyntax AddArguments(params TypeSyntax[] items)",
                    "public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)",
                    "public TypeArgumentListSyntax WithArguments(SeparatedSyntaxList<TypeSyntax> arguments)",
                    "public TypeArgumentListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)",
                    "public TypeArgumentListSyntax WithLessThanToken(SyntaxToken lessThanToken)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken ColonToken { get; }",
                    "public SeparatedSyntaxList<TypeParameterConstraintSyntax> Constraints { get; }",
                    "public IdentifierNameSyntax Name { get; }",
                    "public SyntaxToken WhereKeyword { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public TypeParameterConstraintClauseSyntax AddConstraints(params TypeParameterConstraintSyntax[] items)",
                    "public TypeParameterConstraintClauseSyntax Update(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)",
                    "public TypeParameterConstraintClauseSyntax WithColonToken(SyntaxToken colonToken)",
                    "public TypeParameterConstraintClauseSyntax WithConstraints(SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)",
                    "public TypeParameterConstraintClauseSyntax WithName(IdentifierNameSyntax name)",
                    "public TypeParameterConstraintClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword)"
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax : CSharpSyntaxNode",
                  "types": [
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax",
                      "members": [
                        "public SyntaxToken ClassOrStructKeyword { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ClassOrStructConstraintSyntax Update(SyntaxToken classOrStructKeyword)",
                        "public ClassOrStructConstraintSyntax WithClassOrStructKeyword(SyntaxToken classOrStructKeyword)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax : TypeParameterConstraintSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public SyntaxToken NewKeyword { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ConstructorConstraintSyntax Update(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)",
                        "public ConstructorConstraintSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public ConstructorConstraintSyntax WithNewKeyword(SyntaxToken newKeyword)",
                        "public ConstructorConstraintSyntax WithOpenParenToken(SyntaxToken openParenToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax : TypeParameterConstraintSyntax",
                      "members": [
                        "public TypeSyntax Type { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public TypeConstraintSyntax Update(TypeSyntax type)",
                        "public TypeConstraintSyntax WithType(TypeSyntax type)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken GreaterThanToken { get; }",
                    "public SyntaxToken LessThanToken { get; }",
                    "public SeparatedSyntaxList<TypeParameterSyntax> Parameters { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public TypeParameterListSyntax AddParameters(params TypeParameterSyntax[] items)",
                    "public TypeParameterListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)",
                    "public TypeParameterListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)",
                    "public TypeParameterListSyntax WithLessThanToken(SyntaxToken lessThanToken)",
                    "public TypeParameterListSyntax WithParameters(SeparatedSyntaxList<TypeParameterSyntax> parameters)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxList<AttributeListSyntax> AttributeLists { get; }",
                    "public SyntaxToken Identifier { get; }",
                    "public SyntaxToken VarianceKeyword { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public TypeParameterSyntax AddAttributeLists(params AttributeListSyntax[] items)",
                    "public TypeParameterSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)",
                    "public TypeParameterSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)",
                    "public TypeParameterSyntax WithIdentifier(SyntaxToken identifier)",
                    "public TypeParameterSyntax WithVarianceKeyword(SyntaxToken varianceKeyword)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax : CSharpSyntaxNode",
                  "members": [
                    "public NameEqualsSyntax Alias { get; }",
                    "public NameSyntax Name { get; }",
                    "public SyntaxToken SemicolonToken { get; }",
                    "public SyntaxToken StaticKeyword { get; }",
                    "public SyntaxToken UsingKeyword { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public UsingDirectiveSyntax Update(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)",
                    "public UsingDirectiveSyntax WithAlias(NameEqualsSyntax alias)",
                    "public UsingDirectiveSyntax WithName(NameSyntax name)",
                    "public UsingDirectiveSyntax WithSemicolonToken(SyntaxToken semicolonToken)",
                    "public UsingDirectiveSyntax WithStaticKeyword(SyntaxToken staticKeyword)",
                    "public UsingDirectiveSyntax WithUsingKeyword(SyntaxToken usingKeyword)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax : CSharpSyntaxNode",
                  "members": [
                    "public TypeSyntax Type { get; }",
                    "public SeparatedSyntaxList<VariableDeclaratorSyntax> Variables { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public VariableDeclarationSyntax AddVariables(params VariableDeclaratorSyntax[] items)",
                    "public VariableDeclarationSyntax Update(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables)",
                    "public VariableDeclarationSyntax WithType(TypeSyntax type)",
                    "public VariableDeclarationSyntax WithVariables(SeparatedSyntaxList<VariableDeclaratorSyntax> variables)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax : CSharpSyntaxNode",
                  "members": [
                    "public BracketedArgumentListSyntax ArgumentList { get; }",
                    "public SyntaxToken Identifier { get; }",
                    "public EqualsValueClauseSyntax Initializer { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public VariableDeclaratorSyntax AddArgumentListArguments(params ArgumentSyntax[] items)",
                    "public VariableDeclaratorSyntax Update(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)",
                    "public VariableDeclaratorSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)",
                    "public VariableDeclaratorSyntax WithIdentifier(SyntaxToken identifier)",
                    "public VariableDeclaratorSyntax WithInitializer(EqualsValueClauseSyntax initializer)"
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax : CSharpSyntaxNode",
                  "types": [
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax : VariableDesignationSyntax",
                      "members": [
                        "public SyntaxToken UnderscoreToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public DiscardDesignationSyntax Update(SyntaxToken underscoreToken)",
                        "public DiscardDesignationSyntax WithUnderscoreToken(SyntaxToken underscoreToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax : VariableDesignationSyntax",
                      "members": [
                        "public SyntaxToken CloseParenToken { get; }",
                        "public SyntaxToken OpenParenToken { get; }",
                        "public SeparatedSyntaxList<VariableDesignationSyntax> Variables { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public ParenthesizedVariableDesignationSyntax AddVariables(params VariableDesignationSyntax[] items)",
                        "public ParenthesizedVariableDesignationSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken)",
                        "public ParenthesizedVariableDesignationSyntax WithCloseParenToken(SyntaxToken closeParenToken)",
                        "public ParenthesizedVariableDesignationSyntax WithOpenParenToken(SyntaxToken openParenToken)",
                        "public ParenthesizedVariableDesignationSyntax WithVariables(SeparatedSyntaxList<VariableDesignationSyntax> variables)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax : VariableDesignationSyntax",
                      "members": [
                        "public SyntaxToken Identifier { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public SingleVariableDesignationSyntax Update(SyntaxToken identifier)",
                        "public SingleVariableDesignationSyntax WithIdentifier(SyntaxToken identifier)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax : CSharpSyntaxNode",
                  "members": [
                    "public ExpressionSyntax Condition { get; }",
                    "public SyntaxToken WhenKeyword { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public WhenClauseSyntax Update(SyntaxToken whenKeyword, ExpressionSyntax condition)",
                    "public WhenClauseSyntax WithCondition(ExpressionSyntax condition)",
                    "public WhenClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword)"
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax : CSharpSyntaxNode",
                  "members": [
                    "public abstract SyntaxToken EndQuoteToken { get; }",
                    "public abstract SyntaxToken EqualsToken { get; }",
                    "public abstract XmlNameSyntax Name { get; }",
                    "public abstract SyntaxToken StartQuoteToken { get; }"
                  ],
                  "types": [
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax : XmlAttributeSyntax",
                      "members": [
                        "public CrefSyntax Cref { get; }",
                        "public override SyntaxToken EndQuoteToken { get; }",
                        "public override SyntaxToken EqualsToken { get; }",
                        "public override XmlNameSyntax Name { get; }",
                        "public override SyntaxToken StartQuoteToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public XmlCrefAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)",
                        "public XmlCrefAttributeSyntax WithCref(CrefSyntax cref)",
                        "public XmlCrefAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken)",
                        "public XmlCrefAttributeSyntax WithEqualsToken(SyntaxToken equalsToken)",
                        "public XmlCrefAttributeSyntax WithName(XmlNameSyntax name)",
                        "public XmlCrefAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax : XmlAttributeSyntax",
                      "members": [
                        "public override SyntaxToken EndQuoteToken { get; }",
                        "public override SyntaxToken EqualsToken { get; }",
                        "public IdentifierNameSyntax Identifier { get; }",
                        "public override XmlNameSyntax Name { get; }",
                        "public override SyntaxToken StartQuoteToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)",
                        "public XmlNameAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken)",
                        "public XmlNameAttributeSyntax WithEqualsToken(SyntaxToken equalsToken)",
                        "public XmlNameAttributeSyntax WithIdentifier(IdentifierNameSyntax identifier)",
                        "public XmlNameAttributeSyntax WithName(XmlNameSyntax name)",
                        "public XmlNameAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax : XmlAttributeSyntax",
                      "members": [
                        "public override SyntaxToken EndQuoteToken { get; }",
                        "public override SyntaxToken EqualsToken { get; }",
                        "public override XmlNameSyntax Name { get; }",
                        "public override SyntaxToken StartQuoteToken { get; }",
                        "public SyntaxTokenList TextTokens { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public XmlTextAttributeSyntax AddTextTokens(params SyntaxToken[] items)",
                        "public XmlTextAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)",
                        "public XmlTextAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken)",
                        "public XmlTextAttributeSyntax WithEqualsToken(SyntaxToken equalsToken)",
                        "public XmlTextAttributeSyntax WithName(XmlNameSyntax name)",
                        "public XmlTextAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken)",
                        "public XmlTextAttributeSyntax WithTextTokens(SyntaxTokenList textTokens)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken GreaterThanToken { get; }",
                    "public SyntaxToken LessThanSlashToken { get; }",
                    "public XmlNameSyntax Name { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)",
                    "public XmlElementEndTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)",
                    "public XmlElementEndTagSyntax WithLessThanSlashToken(SyntaxToken lessThanSlashToken)",
                    "public XmlElementEndTagSyntax WithName(XmlNameSyntax name)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxList<XmlAttributeSyntax> Attributes { get; }",
                    "public SyntaxToken GreaterThanToken { get; }",
                    "public SyntaxToken LessThanToken { get; }",
                    "public XmlNameSyntax Name { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public XmlElementStartTagSyntax AddAttributes(params XmlAttributeSyntax[] items)",
                    "public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)",
                    "public XmlElementStartTagSyntax WithAttributes(SyntaxList<XmlAttributeSyntax> attributes)",
                    "public XmlElementStartTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)",
                    "public XmlElementStartTagSyntax WithLessThanToken(SyntaxToken lessThanToken)",
                    "public XmlElementStartTagSyntax WithName(XmlNameSyntax name)"
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken LocalName { get; }",
                    "public XmlPrefixSyntax Prefix { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName)",
                    "public XmlNameSyntax WithLocalName(SyntaxToken localName)",
                    "public XmlNameSyntax WithPrefix(XmlPrefixSyntax prefix)"
                  ]
                },
                {
                  "type": "public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax : CSharpSyntaxNode",
                  "types": [
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax : XmlNodeSyntax",
                      "members": [
                        "public SyntaxToken EndCDataToken { get; }",
                        "public SyntaxToken StartCDataToken { get; }",
                        "public SyntaxTokenList TextTokens { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public XmlCDataSectionSyntax AddTextTokens(params SyntaxToken[] items)",
                        "public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken)",
                        "public XmlCDataSectionSyntax WithEndCDataToken(SyntaxToken endCDataToken)",
                        "public XmlCDataSectionSyntax WithStartCDataToken(SyntaxToken startCDataToken)",
                        "public XmlCDataSectionSyntax WithTextTokens(SyntaxTokenList textTokens)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax : XmlNodeSyntax",
                      "members": [
                        "public SyntaxToken LessThanExclamationMinusMinusToken { get; }",
                        "public SyntaxToken MinusMinusGreaterThanToken { get; }",
                        "public SyntaxTokenList TextTokens { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public XmlCommentSyntax AddTextTokens(params SyntaxToken[] items)",
                        "public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken)",
                        "public XmlCommentSyntax WithLessThanExclamationMinusMinusToken(SyntaxToken lessThanExclamationMinusMinusToken)",
                        "public XmlCommentSyntax WithMinusMinusGreaterThanToken(SyntaxToken minusMinusGreaterThanToken)",
                        "public XmlCommentSyntax WithTextTokens(SyntaxTokenList textTokens)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax : XmlNodeSyntax",
                      "members": [
                        "public SyntaxList<XmlNodeSyntax> Content { get; }",
                        "public XmlElementEndTagSyntax EndTag { get; }",
                        "public XmlElementStartTagSyntax StartTag { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public XmlElementSyntax AddContent(params XmlNodeSyntax[] items)",
                        "public XmlElementSyntax AddStartTagAttributes(params XmlAttributeSyntax[] items)",
                        "public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)",
                        "public XmlElementSyntax WithContent(SyntaxList<XmlNodeSyntax> content)",
                        "public XmlElementSyntax WithEndTag(XmlElementEndTagSyntax endTag)",
                        "public XmlElementSyntax WithStartTag(XmlElementStartTagSyntax startTag)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax : XmlNodeSyntax",
                      "members": [
                        "public SyntaxList<XmlAttributeSyntax> Attributes { get; }",
                        "public SyntaxToken LessThanToken { get; }",
                        "public XmlNameSyntax Name { get; }",
                        "public SyntaxToken SlashGreaterThanToken { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public XmlEmptyElementSyntax AddAttributes(params XmlAttributeSyntax[] items)",
                        "public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)",
                        "public XmlEmptyElementSyntax WithAttributes(SyntaxList<XmlAttributeSyntax> attributes)",
                        "public XmlEmptyElementSyntax WithLessThanToken(SyntaxToken lessThanToken)",
                        "public XmlEmptyElementSyntax WithName(XmlNameSyntax name)",
                        "public XmlEmptyElementSyntax WithSlashGreaterThanToken(SyntaxToken slashGreaterThanToken)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax : XmlNodeSyntax",
                      "members": [
                        "public SyntaxToken EndProcessingInstructionToken { get; }",
                        "public XmlNameSyntax Name { get; }",
                        "public SyntaxToken StartProcessingInstructionToken { get; }",
                        "public SyntaxTokenList TextTokens { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public XmlProcessingInstructionSyntax AddTextTokens(params SyntaxToken[] items)",
                        "public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken)",
                        "public XmlProcessingInstructionSyntax WithEndProcessingInstructionToken(SyntaxToken endProcessingInstructionToken)",
                        "public XmlProcessingInstructionSyntax WithName(XmlNameSyntax name)",
                        "public XmlProcessingInstructionSyntax WithStartProcessingInstructionToken(SyntaxToken startProcessingInstructionToken)",
                        "public XmlProcessingInstructionSyntax WithTextTokens(SyntaxTokenList textTokens)"
                      ]
                    },
                    {
                      "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax : XmlNodeSyntax",
                      "members": [
                        "public SyntaxTokenList TextTokens { get; }",
                        "public override void Accept(CSharpSyntaxVisitor visitor)",
                        "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                        "public XmlTextSyntax AddTextTokens(params SyntaxToken[] items)",
                        "public XmlTextSyntax Update(SyntaxTokenList textTokens)",
                        "public XmlTextSyntax WithTextTokens(SyntaxTokenList textTokens)"
                      ]
                    }
                  ]
                },
                {
                  "type": "public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax : CSharpSyntaxNode",
                  "members": [
                    "public SyntaxToken ColonToken { get; }",
                    "public SyntaxToken Prefix { get; }",
                    "public override void Accept(CSharpSyntaxVisitor visitor)",
                    "public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)",
                    "public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken)",
                    "public XmlPrefixSyntax WithColonToken(SyntaxToken colonToken)",
                    "public XmlPrefixSyntax WithPrefix(SyntaxToken prefix)"
                  ]
                }
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.SyntaxReference",
          "members": [
            "protected SyntaxReference()",
            "public abstract TextSpan Span { get; }",
            "public abstract SyntaxTree SyntaxTree { get; }",
            "public abstract SyntaxNode GetSyntax(CancellationToken cancellationToken = default)",
            "public virtual Task<SyntaxNode> GetSyntaxAsync(CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.SyntaxTree",
          "members": [
            "protected SyntaxTree()",
            "public abstract Encoding Encoding { get; }",
            "public abstract string FilePath { get; }",
            "public abstract bool HasCompilationUnitRoot { get; }",
            "public abstract int Length { get; }",
            "public ParseOptions Options { get; }",
            "protected abstract ParseOptions OptionsCore { get; }",
            "public abstract IList<TextSpan> GetChangedSpans(SyntaxTree syntaxTree)",
            "public abstract IList<TextChange> GetChanges(SyntaxTree oldTree)",
            "public abstract IEnumerable<Diagnostic> GetDiagnostics(CancellationToken cancellationToken = default)",
            "public abstract IEnumerable<Diagnostic> GetDiagnostics(SyntaxNode node)",
            "public abstract IEnumerable<Diagnostic> GetDiagnostics(SyntaxNodeOrToken nodeOrToken)",
            "public abstract IEnumerable<Diagnostic> GetDiagnostics(SyntaxToken token)",
            "public abstract IEnumerable<Diagnostic> GetDiagnostics(SyntaxTrivia trivia)",
            "public abstract FileLinePositionSpan GetLineSpan(TextSpan span, CancellationToken cancellationToken = default)",
            "public virtual LineVisibility GetLineVisibility(int position, CancellationToken cancellationToken = default)",
            "public abstract Location GetLocation(TextSpan span)",
            "public abstract FileLinePositionSpan GetMappedLineSpan(TextSpan span, CancellationToken cancellationToken = default)",
            "public abstract SyntaxReference GetReference(SyntaxNode node)",
            "public SyntaxNode GetRoot(CancellationToken cancellationToken = default)",
            "public Task<SyntaxNode> GetRootAsync(CancellationToken cancellationToken = default)",
            "protected abstract Task<SyntaxNode> GetRootAsyncCore(CancellationToken cancellationToken)",
            "protected abstract SyntaxNode GetRootCore(CancellationToken cancellationToken)",
            "public abstract SourceText GetText(CancellationToken cancellationToken = default)",
            "public virtual Task<SourceText> GetTextAsync(CancellationToken cancellationToken = default)",
            "public abstract bool HasHiddenRegions()",
            "public abstract bool IsEquivalentTo(SyntaxTree tree, bool topLevel = false)",
            "public override string ToString()",
            "public bool TryGetRoot(out SyntaxNode root)",
            "protected abstract bool TryGetRootCore(out SyntaxNode root)",
            "public abstract bool TryGetText(out SourceText text)",
            "public abstract SyntaxTree WithChangedText(SourceText newText)",
            "public abstract SyntaxTree WithFilePath(string path)",
            "public abstract SyntaxTree WithRootAndOptions(SyntaxNode root, ParseOptions options)"
          ],
          "types": [
            {
              "type": "public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree : SyntaxTree",
              "members": [
                "protected CSharpSyntaxTree()",
                "public abstract CSharpParseOptions Options { get; }",
                "protected override ParseOptions OptionsCore { get; }",
                "protected T CloneNodeAsRoot<T>(T node) where T : CSharpSyntaxNode",
                "public static SyntaxTree Create(CSharpSyntaxNode root, CSharpParseOptions options = null, string path = \"\", Encoding encoding = null)",
                "public override IList<TextSpan> GetChangedSpans(SyntaxTree oldTree)",
                "public override IList<TextChange> GetChanges(SyntaxTree oldTree)",
                "public CompilationUnitSyntax GetCompilationUnitRoot(CancellationToken cancellationToken = default)",
                "public override IEnumerable<Diagnostic> GetDiagnostics(CancellationToken cancellationToken = default)",
                "public override IEnumerable<Diagnostic> GetDiagnostics(SyntaxNode node)",
                "public override IEnumerable<Diagnostic> GetDiagnostics(SyntaxNodeOrToken nodeOrToken)",
                "public override IEnumerable<Diagnostic> GetDiagnostics(SyntaxToken token)",
                "public override IEnumerable<Diagnostic> GetDiagnostics(SyntaxTrivia trivia)",
                "public override FileLinePositionSpan GetLineSpan(TextSpan span, CancellationToken cancellationToken = default)",
                "public override LineVisibility GetLineVisibility(int position, CancellationToken cancellationToken = default)",
                "public override Location GetLocation(TextSpan span)",
                "public override FileLinePositionSpan GetMappedLineSpan(TextSpan span, CancellationToken cancellationToken = default)",
                "public abstract CSharpSyntaxNode GetRoot(CancellationToken cancellationToken = default)",
                "public virtual Task<CSharpSyntaxNode> GetRootAsync(CancellationToken cancellationToken = default)",
                "protected override Task<SyntaxNode> GetRootAsyncCore(CancellationToken cancellationToken)",
                "protected override SyntaxNode GetRootCore(CancellationToken cancellationToken)",
                "public override bool HasHiddenRegions()",
                "public override bool IsEquivalentTo(SyntaxTree tree, bool topLevel = false)",
                "public static SyntaxTree ParseText(SourceText text, CSharpParseOptions options = null, string path = \"\", CancellationToken cancellationToken = default)",
                "public static SyntaxTree ParseText(string text, CSharpParseOptions options = null, string path = \"\", Encoding encoding = null, CancellationToken cancellationToken = default)",
                "public abstract bool TryGetRoot(out CSharpSyntaxNode root)",
                "protected override bool TryGetRootCore(out SyntaxNode root)",
                "public override SyntaxTree WithChangedText(SourceText newText)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.SyntaxWalker",
          "members": [
            "protected SyntaxWalker(SyntaxWalkerDepth depth = Node)",
            "protected SyntaxWalkerDepth Depth { get; }",
            "public virtual void Visit(SyntaxNode node)",
            "protected virtual void VisitToken(SyntaxToken token)",
            "protected virtual void VisitTrivia(SyntaxTrivia trivia)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.TextAndVersion",
          "members": [
            "public string FilePath { get; }",
            "public SourceText Text { get; }",
            "public VersionStamp Version { get; }",
            "public static TextAndVersion Create(SourceText text, VersionStamp version, string filePath = null)"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.TextDocument",
          "members": [
            "protected TextDocument()",
            "public string FilePath { get; }",
            "public IReadOnlyList<string> Folders { get; }",
            "public DocumentId Id { get; }",
            "public string Name { get; }",
            "public Project Project { get; protected set; }",
            "public Task<SourceText> GetTextAsync(CancellationToken cancellationToken = default)",
            "public Task<VersionStamp> GetTextVersionAsync(CancellationToken cancellationToken = default)",
            "public bool TryGetText(out SourceText text)",
            "public bool TryGetTextVersion(out VersionStamp version)"
          ],
          "types": [
            {
              "type": "public class Microsoft.CodeAnalysis.Document : TextDocument",
              "members": [
                "public SourceCodeKind SourceCodeKind { get; }",
                "public bool SupportsSemanticModel { get; }",
                "public bool SupportsSyntaxTree { get; }",
                "public ImmutableArray<DocumentId> GetLinkedDocumentIds()",
                "public Task<DocumentOptionSet> GetOptionsAsync(CancellationToken cancellationToken = default)",
                "public Task<SemanticModel> GetSemanticModelAsync(CancellationToken cancellationToken = default)",
                "public Task<SyntaxNode> GetSyntaxRootAsync(CancellationToken cancellationToken = default)",
                "public Task<SyntaxTree> GetSyntaxTreeAsync(CancellationToken cancellationToken = default)",
                "public Task<VersionStamp> GetSyntaxVersionAsync(CancellationToken cancellationToken = default)",
                "public Task<IEnumerable<TextChange>> GetTextChangesAsync(Document oldDocument, CancellationToken cancellationToken = default)",
                "public bool TryGetSemanticModel(out SemanticModel semanticModel)",
                "public bool TryGetSyntaxRoot(out SyntaxNode root)",
                "public bool TryGetSyntaxTree(out SyntaxTree syntaxTree)",
                "public bool TryGetSyntaxVersion(out VersionStamp version)",
                "public Document WithFilePath(string filePath)",
                "public Document WithFolders(IEnumerable<string> folders)",
                "public Document WithName(string name)",
                "public Document WithSourceCodeKind(SourceCodeKind kind)",
                "public Document WithSyntaxRoot(SyntaxNode root)",
                "public Document WithText(SourceText text)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.TextLoader",
          "members": [
            "protected TextLoader()",
            "public static TextLoader From(TextAndVersion textAndVersion)",
            "public static TextLoader From(SourceTextContainer container, VersionStamp version, string filePath = null)",
            "public abstract Task<TextAndVersion> LoadTextAndVersionAsync(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Workspace : IDisposable",
          "members": [
            "protected Workspace(HostServices host, string workspaceKind)",
            "public event EventHandler<DocumentActiveContextChangedEventArgs> DocumentActiveContextChanged",
            "public event EventHandler<DocumentEventArgs> DocumentClosed",
            "public event EventHandler<DocumentEventArgs> DocumentOpened",
            "public event EventHandler<WorkspaceChangeEventArgs> WorkspaceChanged",
            "public event EventHandler<WorkspaceDiagnosticEventArgs> WorkspaceFailed",
            "public virtual bool CanOpenDocuments { get; }",
            "public Solution CurrentSolution { get; }",
            "public string Kind { get; }",
            "public OptionSet Options { get; set; }",
            "protected internal virtual bool PartialSemanticsEnabled { get; }",
            "public HostWorkspaceServices Services { get; }",
            "protected virtual Project AdjustReloadedProject(Project oldProject, Project reloadedProject)",
            "protected virtual Solution AdjustReloadedSolution(Solution oldSolution, Solution reloadedSolution)",
            "protected virtual void ApplyAdditionalDocumentAdded(DocumentInfo info, SourceText text)",
            "protected virtual void ApplyAdditionalDocumentRemoved(DocumentId documentId)",
            "protected virtual void ApplyAdditionalDocumentTextChanged(DocumentId id, SourceText text)",
            "protected virtual void ApplyAnalyzerReferenceAdded(ProjectId projectId, AnalyzerReference analyzerReference)",
            "protected virtual void ApplyAnalyzerReferenceRemoved(ProjectId projectId, AnalyzerReference analyzerReference)",
            "protected virtual void ApplyCompilationOptionsChanged(ProjectId projectId, CompilationOptions options)",
            "protected virtual void ApplyDocumentAdded(DocumentInfo info, SourceText text)",
            "protected virtual void ApplyDocumentInfoChanged(DocumentId id, DocumentInfo info)",
            "protected virtual void ApplyDocumentRemoved(DocumentId documentId)",
            "protected virtual void ApplyDocumentTextChanged(DocumentId id, SourceText text)",
            "protected virtual void ApplyMetadataReferenceAdded(ProjectId projectId, MetadataReference metadataReference)",
            "protected virtual void ApplyMetadataReferenceRemoved(ProjectId projectId, MetadataReference metadataReference)",
            "protected virtual void ApplyParseOptionsChanged(ProjectId projectId, ParseOptions options)",
            "protected virtual void ApplyProjectAdded(ProjectInfo project)",
            "protected virtual void ApplyProjectChanges(ProjectChanges projectChanges)",
            "protected virtual void ApplyProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference)",
            "protected virtual void ApplyProjectReferenceRemoved(ProjectId projectId, ProjectReference projectReference)",
            "protected virtual void ApplyProjectRemoved(ProjectId projectId)",
            "public virtual bool CanApplyChange(ApplyChangesKind feature)",
            "protected virtual bool CanApplyParseOptionChange(ParseOptions oldOptions, ParseOptions newOptions, Project project)",
            "protected void CheckAdditionalDocumentIsInCurrentSolution(DocumentId documentId)",
            "protected void CheckAdditionalDocumentIsNotInCurrentSolution(DocumentId documentId)",
            "protected void CheckCanOpenDocuments()",
            "protected virtual void CheckDocumentCanBeRemoved(DocumentId documentId)",
            "protected void CheckDocumentIsClosed(DocumentId documentId)",
            "protected void CheckDocumentIsInCurrentSolution(DocumentId documentId)",
            "protected void CheckDocumentIsNotInCurrentSolution(DocumentId documentId)",
            "protected void CheckDocumentIsOpen(DocumentId documentId)",
            "protected virtual void CheckProjectCanBeRemoved(ProjectId projectId)",
            "protected void CheckProjectDoesNotContainOpenDocuments(ProjectId projectId)",
            "protected void CheckProjectDoesNotHaveAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference)",
            "protected void CheckProjectDoesNotHaveMetadataReference(ProjectId projectId, MetadataReference metadataReference)",
            "protected void CheckProjectDoesNotHaveProjectReference(ProjectId fromProjectId, ProjectReference projectReference)",
            "protected void CheckProjectDoesNotHaveTransitiveProjectReference(ProjectId fromProjectId, ProjectId toProjectId)",
            "protected void CheckProjectHasAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference)",
            "protected void CheckProjectHasMetadataReference(ProjectId projectId, MetadataReference metadataReference)",
            "protected void CheckProjectHasProjectReference(ProjectId fromProjectId, ProjectReference projectReference)",
            "protected void CheckProjectIsInCurrentSolution(ProjectId projectId)",
            "protected void CheckProjectIsNotInCurrentSolution(ProjectId projectId)",
            "protected void CheckSolutionIsEmpty()",
            "protected virtual void ClearDocumentData(DocumentId documentId)",
            "protected void ClearOpenDocument(DocumentId documentId, bool isSolutionClosing = false)",
            "protected virtual void ClearProjectData(ProjectId projectId)",
            "protected void ClearSolution()",
            "protected virtual void ClearSolutionData()",
            "public virtual void CloseAdditionalDocument(DocumentId documentId)",
            "public virtual void CloseDocument(DocumentId documentId)",
            "protected internal Solution CreateSolution(SolutionId id)",
            "protected internal Solution CreateSolution(SolutionInfo solutionInfo)",
            "public void Dispose()",
            "protected virtual void Dispose(bool finalize)",
            "protected virtual string GetAdditionalDocumentName(DocumentId documentId)",
            "public virtual DocumentId GetDocumentIdInCurrentContext(SourceTextContainer container)",
            "protected virtual string GetDocumentName(DocumentId documentId)",
            "public virtual IEnumerable<DocumentId> GetOpenDocumentIds(ProjectId projectId = null)",
            "protected virtual string GetProjectName(ProjectId projectId)",
            "public virtual IEnumerable<DocumentId> GetRelatedDocumentIds(SourceTextContainer container)",
            "public static WorkspaceRegistration GetWorkspaceRegistration(SourceTextContainer textContainer)",
            "public virtual bool IsDocumentOpen(DocumentId documentId)",
            "protected internal void OnAdditionalDocumentAdded(DocumentInfo documentInfo)",
            "protected internal void OnAdditionalDocumentClosed(DocumentId documentId, TextLoader reloader)",
            "protected internal void OnAdditionalDocumentOpened(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext = true)",
            "protected internal void OnAdditionalDocumentRemoved(DocumentId documentId)",
            "protected internal void OnAdditionalDocumentTextChanged(DocumentId documentId, SourceText newText, PreservationMode mode)",
            "protected internal void OnAdditionalDocumentTextLoaderChanged(DocumentId documentId, TextLoader loader)",
            "protected internal void OnAnalyzerReferenceAdded(ProjectId projectId, AnalyzerReference analyzerReference)",
            "protected internal void OnAnalyzerReferenceRemoved(ProjectId projectId, AnalyzerReference analyzerReference)",
            "protected internal void OnAssemblyNameChanged(ProjectId projectId, string assemblyName)",
            "protected internal void OnCompilationOptionsChanged(ProjectId projectId, CompilationOptions options)",
            "protected internal void OnDocumentAdded(DocumentInfo documentInfo)",
            "protected internal void OnDocumentClosed(DocumentId documentId, TextLoader reloader, bool updateActiveContext = false)",
            "protected virtual void OnDocumentClosing(DocumentId documentId)",
            "protected void OnDocumentContextUpdated(DocumentId documentId)",
            "protected internal void OnDocumentInfoChanged(DocumentId documentId, DocumentInfo newInfo)",
            "protected internal void OnDocumentOpened(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext = true)",
            "protected internal void OnDocumentReloaded(DocumentInfo newDocumentInfo)",
            "protected internal void OnDocumentRemoved(DocumentId documentId)",
            "protected internal void OnDocumentSourceCodeKindChanged(DocumentId documentId, SourceCodeKind sourceCodeKind)",
            "protected virtual void OnDocumentTextChanged(Document document)",
            "protected internal void OnDocumentTextChanged(DocumentId documentId, SourceText newText, PreservationMode mode)",
            "protected internal void OnDocumentTextLoaderChanged(DocumentId documentId, TextLoader loader)",
            "protected internal void OnMetadataReferenceAdded(ProjectId projectId, MetadataReference metadataReference)",
            "protected internal void OnMetadataReferenceRemoved(ProjectId projectId, MetadataReference metadataReference)",
            "protected internal void OnOutputFilePathChanged(ProjectId projectId, string outputFilePath)",
            "protected internal void OnParseOptionsChanged(ProjectId projectId, ParseOptions options)",
            "protected internal void OnProjectAdded(ProjectInfo projectInfo)",
            "protected internal void OnProjectNameChanged(ProjectId projectId, string name, string filePath)",
            "protected internal void OnProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference)",
            "protected internal void OnProjectReferenceRemoved(ProjectId projectId, ProjectReference projectReference)",
            "protected internal virtual void OnProjectReloaded(ProjectInfo reloadedProjectInfo)",
            "protected internal virtual void OnProjectRemoved(ProjectId projectId)",
            "protected internal void OnSolutionAdded(SolutionInfo solutionInfo)",
            "protected internal void OnSolutionReloaded(SolutionInfo reloadedSolutionInfo)",
            "protected internal void OnSolutionRemoved()",
            "protected internal virtual void OnWorkspaceFailed(WorkspaceDiagnostic diagnostic)",
            "public virtual void OpenAdditionalDocument(DocumentId documentId, bool activate = true)",
            "public virtual void OpenDocument(DocumentId documentId, bool activate = true)",
            "protected Task RaiseDocumentActiveContextChangedEventAsync(Document document)",
            "protected Task RaiseDocumentActiveContextChangedEventAsync(SourceTextContainer sourceTextContainer, DocumentId oldActiveContextDocumentId, DocumentId newActiveContextDocumentId)",
            "protected Task RaiseDocumentClosedEventAsync(Document document)",
            "protected Task RaiseDocumentOpenedEventAsync(Document document)",
            "protected Task RaiseWorkspaceChangedEventAsync(WorkspaceChangeKind kind, Solution oldSolution, Solution newSolution, ProjectId projectId = null, DocumentId documentId = null)",
            "protected void RegisterText(SourceTextContainer textContainer)",
            "protected internal Task ScheduleTask(Action action, string taskName = \"Workspace.Task\")",
            "protected internal Task<T> ScheduleTask<T>(Func<T> func, string taskName = \"Workspace.Task\")",
            "protected Solution SetCurrentSolution(Solution solution)",
            "public virtual bool TryApplyChanges(Solution newSolution)",
            "public static bool TryGetWorkspace(SourceTextContainer textContainer, out Workspace workspace)",
            "protected void UnregisterText(SourceTextContainer textContainer)",
            "protected void UpdateReferencesAfterAdd()"
          ],
          "types": [
            {
              "type": "public sealed class Microsoft.CodeAnalysis.AdhocWorkspace : Workspace",
              "members": [
                "public AdhocWorkspace()",
                "public AdhocWorkspace(HostServices host, string workspaceKind = \"Custom\")",
                "public override bool CanOpenDocuments { get; }",
                "public Document AddDocument(DocumentInfo documentInfo)",
                "public Document AddDocument(ProjectId projectId, string name, SourceText text)",
                "public Project AddProject(ProjectInfo projectInfo)",
                "public Project AddProject(string name, string language)",
                "public void AddProjects(IEnumerable<ProjectInfo> projectInfos)",
                "public Solution AddSolution(SolutionInfo solutionInfo)",
                "public override bool CanApplyChange(ApplyChangesKind feature)",
                "public void ClearSolution()",
                "public override void CloseAdditionalDocument(DocumentId documentId)",
                "public override void CloseDocument(DocumentId documentId)",
                "public override void OpenAdditionalDocument(DocumentId documentId, bool activate = true)",
                "public override void OpenDocument(DocumentId documentId, bool activate = true)"
              ]
            }
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.WorkspaceDiagnostic",
          "members": [
            "public WorkspaceDiagnostic(WorkspaceDiagnosticKind kind, string message)",
            "public WorkspaceDiagnosticKind Kind { get; }",
            "public string Message { get; }",
            "public override string ToString()"
          ],
          "types": [
            {
              "type": "public class Microsoft.CodeAnalysis.DocumentDiagnostic : WorkspaceDiagnostic",
              "members": [
                "public DocumentDiagnostic(WorkspaceDiagnosticKind kind, string message, DocumentId documentId)",
                "public DocumentId DocumentId { get; }"
              ]
            },
            {
              "type": "public class Microsoft.CodeAnalysis.ProjectDiagnostic : WorkspaceDiagnostic",
              "members": [
                "public ProjectDiagnostic(WorkspaceDiagnosticKind kind, string message, ProjectId projectId)",
                "public ProjectId ProjectId { get; }"
              ]
            }
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.WorkspaceRegistration",
          "members": [
            "public event EventHandler WorkspaceChanged",
            "public Workspace Workspace { get; }"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.XmlReferenceResolver",
          "members": [
            "protected XmlReferenceResolver()",
            "public override abstract bool Equals(object other)",
            "public override abstract int GetHashCode()",
            "public abstract Stream OpenRead(string resolvedPath)",
            "public abstract string ResolveReference(string path, string baseFilePath)"
          ],
          "types": [
            {
              "type": "public class Microsoft.CodeAnalysis.XmlFileResolver : XmlReferenceResolver",
              "members": [
                "public XmlFileResolver(string baseDirectory)",
                "public string BaseDirectory { get; }",
                "public static XmlFileResolver Default { get; }",
                "public override bool Equals(object obj)",
                "protected virtual bool FileExists(string resolvedPath)",
                "public override int GetHashCode()",
                "public override Stream OpenRead(string resolvedPath)",
                "public override string ResolveReference(string path, string baseFilePath)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor",
          "members": [
            "protected CSharpSyntaxVisitor()",
            "public virtual void DefaultVisit(SyntaxNode node)",
            "public virtual void Visit(SyntaxNode node)",
            "public virtual void VisitAccessorDeclaration(AccessorDeclarationSyntax node)",
            "public virtual void VisitAccessorList(AccessorListSyntax node)",
            "public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node)",
            "public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)",
            "public virtual void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)",
            "public virtual void VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)",
            "public virtual void VisitArgument(ArgumentSyntax node)",
            "public virtual void VisitArgumentList(ArgumentListSyntax node)",
            "public virtual void VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)",
            "public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)",
            "public virtual void VisitArrayType(ArrayTypeSyntax node)",
            "public virtual void VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)",
            "public virtual void VisitAssignmentExpression(AssignmentExpressionSyntax node)",
            "public virtual void VisitAttribute(AttributeSyntax node)",
            "public virtual void VisitAttributeArgument(AttributeArgumentSyntax node)",
            "public virtual void VisitAttributeArgumentList(AttributeArgumentListSyntax node)",
            "public virtual void VisitAttributeList(AttributeListSyntax node)",
            "public virtual void VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)",
            "public virtual void VisitAwaitExpression(AwaitExpressionSyntax node)",
            "public virtual void VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)",
            "public virtual void VisitBaseExpression(BaseExpressionSyntax node)",
            "public virtual void VisitBaseList(BaseListSyntax node)",
            "public virtual void VisitBinaryExpression(BinaryExpressionSyntax node)",
            "public virtual void VisitBlock(BlockSyntax node)",
            "public virtual void VisitBracketedArgumentList(BracketedArgumentListSyntax node)",
            "public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node)",
            "public virtual void VisitBreakStatement(BreakStatementSyntax node)",
            "public virtual void VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)",
            "public virtual void VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)",
            "public virtual void VisitCastExpression(CastExpressionSyntax node)",
            "public virtual void VisitCatchClause(CatchClauseSyntax node)",
            "public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node)",
            "public virtual void VisitCatchFilterClause(CatchFilterClauseSyntax node)",
            "public virtual void VisitCheckedExpression(CheckedExpressionSyntax node)",
            "public virtual void VisitCheckedStatement(CheckedStatementSyntax node)",
            "public virtual void VisitClassDeclaration(ClassDeclarationSyntax node)",
            "public virtual void VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)",
            "public virtual void VisitCompilationUnit(CompilationUnitSyntax node)",
            "public virtual void VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)",
            "public virtual void VisitConditionalExpression(ConditionalExpressionSyntax node)",
            "public virtual void VisitConstantPattern(ConstantPatternSyntax node)",
            "public virtual void VisitConstructorConstraint(ConstructorConstraintSyntax node)",
            "public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node)",
            "public virtual void VisitConstructorInitializer(ConstructorInitializerSyntax node)",
            "public virtual void VisitContinueStatement(ContinueStatementSyntax node)",
            "public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)",
            "public virtual void VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)",
            "public virtual void VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)",
            "public virtual void VisitCrefParameter(CrefParameterSyntax node)",
            "public virtual void VisitCrefParameterList(CrefParameterListSyntax node)",
            "public virtual void VisitDeclarationExpression(DeclarationExpressionSyntax node)",
            "public virtual void VisitDeclarationPattern(DeclarationPatternSyntax node)",
            "public virtual void VisitDefaultExpression(DefaultExpressionSyntax node)",
            "public virtual void VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)",
            "public virtual void VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)",
            "public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node)",
            "public virtual void VisitDestructorDeclaration(DestructorDeclarationSyntax node)",
            "public virtual void VisitDiscardDesignation(DiscardDesignationSyntax node)",
            "public virtual void VisitDoStatement(DoStatementSyntax node)",
            "public virtual void VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)",
            "public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node)",
            "public virtual void VisitElementBindingExpression(ElementBindingExpressionSyntax node)",
            "public virtual void VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)",
            "public virtual void VisitElseClause(ElseClauseSyntax node)",
            "public virtual void VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)",
            "public virtual void VisitEmptyStatement(EmptyStatementSyntax node)",
            "public virtual void VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)",
            "public virtual void VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)",
            "public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node)",
            "public virtual void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)",
            "public virtual void VisitEqualsValueClause(EqualsValueClauseSyntax node)",
            "public virtual void VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)",
            "public virtual void VisitEventDeclaration(EventDeclarationSyntax node)",
            "public virtual void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)",
            "public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)",
            "public virtual void VisitExpressionStatement(ExpressionStatementSyntax node)",
            "public virtual void VisitExternAliasDirective(ExternAliasDirectiveSyntax node)",
            "public virtual void VisitFieldDeclaration(FieldDeclarationSyntax node)",
            "public virtual void VisitFinallyClause(FinallyClauseSyntax node)",
            "public virtual void VisitFixedStatement(FixedStatementSyntax node)",
            "public virtual void VisitForEachStatement(ForEachStatementSyntax node)",
            "public virtual void VisitForEachVariableStatement(ForEachVariableStatementSyntax node)",
            "public virtual void VisitForStatement(ForStatementSyntax node)",
            "public virtual void VisitFromClause(FromClauseSyntax node)",
            "public virtual void VisitGenericName(GenericNameSyntax node)",
            "public virtual void VisitGlobalStatement(GlobalStatementSyntax node)",
            "public virtual void VisitGotoStatement(GotoStatementSyntax node)",
            "public virtual void VisitGroupClause(GroupClauseSyntax node)",
            "public virtual void VisitIdentifierName(IdentifierNameSyntax node)",
            "public virtual void VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)",
            "public virtual void VisitIfStatement(IfStatementSyntax node)",
            "public virtual void VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)",
            "public virtual void VisitImplicitElementAccess(ImplicitElementAccessSyntax node)",
            "public virtual void VisitIncompleteMember(IncompleteMemberSyntax node)",
            "public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node)",
            "public virtual void VisitIndexerMemberCref(IndexerMemberCrefSyntax node)",
            "public virtual void VisitInitializerExpression(InitializerExpressionSyntax node)",
            "public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)",
            "public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)",
            "public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node)",
            "public virtual void VisitInterpolation(InterpolationSyntax node)",
            "public virtual void VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)",
            "public virtual void VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)",
            "public virtual void VisitInvocationExpression(InvocationExpressionSyntax node)",
            "public virtual void VisitIsPatternExpression(IsPatternExpressionSyntax node)",
            "public virtual void VisitJoinClause(JoinClauseSyntax node)",
            "public virtual void VisitJoinIntoClause(JoinIntoClauseSyntax node)",
            "public virtual void VisitLabeledStatement(LabeledStatementSyntax node)",
            "public virtual void VisitLetClause(LetClauseSyntax node)",
            "public virtual void VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)",
            "public virtual void VisitLiteralExpression(LiteralExpressionSyntax node)",
            "public virtual void VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)",
            "public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)",
            "public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)",
            "public virtual void VisitLockStatement(LockStatementSyntax node)",
            "public virtual void VisitMakeRefExpression(MakeRefExpressionSyntax node)",
            "public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node)",
            "public virtual void VisitMemberBindingExpression(MemberBindingExpressionSyntax node)",
            "public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node)",
            "public virtual void VisitNameColon(NameColonSyntax node)",
            "public virtual void VisitNameEquals(NameEqualsSyntax node)",
            "public virtual void VisitNameMemberCref(NameMemberCrefSyntax node)",
            "public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)",
            "public virtual void VisitNullableType(NullableTypeSyntax node)",
            "public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)",
            "public virtual void VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)",
            "public virtual void VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)",
            "public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node)",
            "public virtual void VisitOperatorMemberCref(OperatorMemberCrefSyntax node)",
            "public virtual void VisitOrderByClause(OrderByClauseSyntax node)",
            "public virtual void VisitOrdering(OrderingSyntax node)",
            "public virtual void VisitParameter(ParameterSyntax node)",
            "public virtual void VisitParameterList(ParameterListSyntax node)",
            "public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)",
            "public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)",
            "public virtual void VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)",
            "public virtual void VisitPointerType(PointerTypeSyntax node)",
            "public virtual void VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)",
            "public virtual void VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)",
            "public virtual void VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)",
            "public virtual void VisitPredefinedType(PredefinedTypeSyntax node)",
            "public virtual void VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)",
            "public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node)",
            "public virtual void VisitQualifiedCref(QualifiedCrefSyntax node)",
            "public virtual void VisitQualifiedName(QualifiedNameSyntax node)",
            "public virtual void VisitQueryBody(QueryBodySyntax node)",
            "public virtual void VisitQueryContinuation(QueryContinuationSyntax node)",
            "public virtual void VisitQueryExpression(QueryExpressionSyntax node)",
            "public virtual void VisitRefExpression(RefExpressionSyntax node)",
            "public virtual void VisitRefType(RefTypeSyntax node)",
            "public virtual void VisitRefTypeExpression(RefTypeExpressionSyntax node)",
            "public virtual void VisitRefValueExpression(RefValueExpressionSyntax node)",
            "public virtual void VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)",
            "public virtual void VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)",
            "public virtual void VisitReturnStatement(ReturnStatementSyntax node)",
            "public virtual void VisitSelectClause(SelectClauseSyntax node)",
            "public virtual void VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)",
            "public virtual void VisitSimpleBaseType(SimpleBaseTypeSyntax node)",
            "public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)",
            "public virtual void VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)",
            "public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node)",
            "public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)",
            "public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)",
            "public virtual void VisitStructDeclaration(StructDeclarationSyntax node)",
            "public virtual void VisitSwitchSection(SwitchSectionSyntax node)",
            "public virtual void VisitSwitchStatement(SwitchStatementSyntax node)",
            "public virtual void VisitThisExpression(ThisExpressionSyntax node)",
            "public virtual void VisitThrowExpression(ThrowExpressionSyntax node)",
            "public virtual void VisitThrowStatement(ThrowStatementSyntax node)",
            "public virtual void VisitTryStatement(TryStatementSyntax node)",
            "public virtual void VisitTupleElement(TupleElementSyntax node)",
            "public virtual void VisitTupleExpression(TupleExpressionSyntax node)",
            "public virtual void VisitTupleType(TupleTypeSyntax node)",
            "public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node)",
            "public virtual void VisitTypeConstraint(TypeConstraintSyntax node)",
            "public virtual void VisitTypeCref(TypeCrefSyntax node)",
            "public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node)",
            "public virtual void VisitTypeParameter(TypeParameterSyntax node)",
            "public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)",
            "public virtual void VisitTypeParameterList(TypeParameterListSyntax node)",
            "public virtual void VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)",
            "public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node)",
            "public virtual void VisitUsingDirective(UsingDirectiveSyntax node)",
            "public virtual void VisitUsingStatement(UsingStatementSyntax node)",
            "public virtual void VisitVariableDeclaration(VariableDeclarationSyntax node)",
            "public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node)",
            "public virtual void VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)",
            "public virtual void VisitWhenClause(WhenClauseSyntax node)",
            "public virtual void VisitWhereClause(WhereClauseSyntax node)",
            "public virtual void VisitWhileStatement(WhileStatementSyntax node)",
            "public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node)",
            "public virtual void VisitXmlComment(XmlCommentSyntax node)",
            "public virtual void VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)",
            "public virtual void VisitXmlElement(XmlElementSyntax node)",
            "public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node)",
            "public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node)",
            "public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node)",
            "public virtual void VisitXmlName(XmlNameSyntax node)",
            "public virtual void VisitXmlNameAttribute(XmlNameAttributeSyntax node)",
            "public virtual void VisitXmlPrefix(XmlPrefixSyntax node)",
            "public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)",
            "public virtual void VisitXmlText(XmlTextSyntax node)",
            "public virtual void VisitXmlTextAttribute(XmlTextAttributeSyntax node)",
            "public virtual void VisitYieldStatement(YieldStatementSyntax node)"
          ],
          "types": [
            {
              "type": "public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker : CSharpSyntaxVisitor",
              "members": [
                "protected CSharpSyntaxWalker(SyntaxWalkerDepth depth = Node)",
                "protected SyntaxWalkerDepth Depth { get; }",
                "public override void DefaultVisit(SyntaxNode node)",
                "public override void Visit(SyntaxNode node)",
                "public virtual void VisitLeadingTrivia(SyntaxToken token)",
                "public virtual void VisitToken(SyntaxToken token)",
                "public virtual void VisitTrailingTrivia(SyntaxToken token)",
                "public virtual void VisitTrivia(SyntaxTrivia trivia)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult>",
          "members": [
            "protected CSharpSyntaxVisitor()",
            "public virtual TResult DefaultVisit(SyntaxNode node)",
            "public virtual TResult Visit(SyntaxNode node)",
            "public virtual TResult VisitAccessorDeclaration(AccessorDeclarationSyntax node)",
            "public virtual TResult VisitAccessorList(AccessorListSyntax node)",
            "public virtual TResult VisitAliasQualifiedName(AliasQualifiedNameSyntax node)",
            "public virtual TResult VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)",
            "public virtual TResult VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)",
            "public virtual TResult VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)",
            "public virtual TResult VisitArgument(ArgumentSyntax node)",
            "public virtual TResult VisitArgumentList(ArgumentListSyntax node)",
            "public virtual TResult VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)",
            "public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)",
            "public virtual TResult VisitArrayType(ArrayTypeSyntax node)",
            "public virtual TResult VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)",
            "public virtual TResult VisitAssignmentExpression(AssignmentExpressionSyntax node)",
            "public virtual TResult VisitAttribute(AttributeSyntax node)",
            "public virtual TResult VisitAttributeArgument(AttributeArgumentSyntax node)",
            "public virtual TResult VisitAttributeArgumentList(AttributeArgumentListSyntax node)",
            "public virtual TResult VisitAttributeList(AttributeListSyntax node)",
            "public virtual TResult VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)",
            "public virtual TResult VisitAwaitExpression(AwaitExpressionSyntax node)",
            "public virtual TResult VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)",
            "public virtual TResult VisitBaseExpression(BaseExpressionSyntax node)",
            "public virtual TResult VisitBaseList(BaseListSyntax node)",
            "public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node)",
            "public virtual TResult VisitBlock(BlockSyntax node)",
            "public virtual TResult VisitBracketedArgumentList(BracketedArgumentListSyntax node)",
            "public virtual TResult VisitBracketedParameterList(BracketedParameterListSyntax node)",
            "public virtual TResult VisitBreakStatement(BreakStatementSyntax node)",
            "public virtual TResult VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)",
            "public virtual TResult VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)",
            "public virtual TResult VisitCastExpression(CastExpressionSyntax node)",
            "public virtual TResult VisitCatchClause(CatchClauseSyntax node)",
            "public virtual TResult VisitCatchDeclaration(CatchDeclarationSyntax node)",
            "public virtual TResult VisitCatchFilterClause(CatchFilterClauseSyntax node)",
            "public virtual TResult VisitCheckedExpression(CheckedExpressionSyntax node)",
            "public virtual TResult VisitCheckedStatement(CheckedStatementSyntax node)",
            "public virtual TResult VisitClassDeclaration(ClassDeclarationSyntax node)",
            "public virtual TResult VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)",
            "public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node)",
            "public virtual TResult VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)",
            "public virtual TResult VisitConditionalExpression(ConditionalExpressionSyntax node)",
            "public virtual TResult VisitConstantPattern(ConstantPatternSyntax node)",
            "public virtual TResult VisitConstructorConstraint(ConstructorConstraintSyntax node)",
            "public virtual TResult VisitConstructorDeclaration(ConstructorDeclarationSyntax node)",
            "public virtual TResult VisitConstructorInitializer(ConstructorInitializerSyntax node)",
            "public virtual TResult VisitContinueStatement(ContinueStatementSyntax node)",
            "public virtual TResult VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)",
            "public virtual TResult VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)",
            "public virtual TResult VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)",
            "public virtual TResult VisitCrefParameter(CrefParameterSyntax node)",
            "public virtual TResult VisitCrefParameterList(CrefParameterListSyntax node)",
            "public virtual TResult VisitDeclarationExpression(DeclarationExpressionSyntax node)",
            "public virtual TResult VisitDeclarationPattern(DeclarationPatternSyntax node)",
            "public virtual TResult VisitDefaultExpression(DefaultExpressionSyntax node)",
            "public virtual TResult VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)",
            "public virtual TResult VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)",
            "public virtual TResult VisitDelegateDeclaration(DelegateDeclarationSyntax node)",
            "public virtual TResult VisitDestructorDeclaration(DestructorDeclarationSyntax node)",
            "public virtual TResult VisitDiscardDesignation(DiscardDesignationSyntax node)",
            "public virtual TResult VisitDoStatement(DoStatementSyntax node)",
            "public virtual TResult VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)",
            "public virtual TResult VisitElementAccessExpression(ElementAccessExpressionSyntax node)",
            "public virtual TResult VisitElementBindingExpression(ElementBindingExpressionSyntax node)",
            "public virtual TResult VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)",
            "public virtual TResult VisitElseClause(ElseClauseSyntax node)",
            "public virtual TResult VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)",
            "public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node)",
            "public virtual TResult VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)",
            "public virtual TResult VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)",
            "public virtual TResult VisitEnumDeclaration(EnumDeclarationSyntax node)",
            "public virtual TResult VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)",
            "public virtual TResult VisitEqualsValueClause(EqualsValueClauseSyntax node)",
            "public virtual TResult VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)",
            "public virtual TResult VisitEventDeclaration(EventDeclarationSyntax node)",
            "public virtual TResult VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)",
            "public virtual TResult VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)",
            "public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node)",
            "public virtual TResult VisitExternAliasDirective(ExternAliasDirectiveSyntax node)",
            "public virtual TResult VisitFieldDeclaration(FieldDeclarationSyntax node)",
            "public virtual TResult VisitFinallyClause(FinallyClauseSyntax node)",
            "public virtual TResult VisitFixedStatement(FixedStatementSyntax node)",
            "public virtual TResult VisitForEachStatement(ForEachStatementSyntax node)",
            "public virtual TResult VisitForEachVariableStatement(ForEachVariableStatementSyntax node)",
            "public virtual TResult VisitForStatement(ForStatementSyntax node)",
            "public virtual TResult VisitFromClause(FromClauseSyntax node)",
            "public virtual TResult VisitGenericName(GenericNameSyntax node)",
            "public virtual TResult VisitGlobalStatement(GlobalStatementSyntax node)",
            "public virtual TResult VisitGotoStatement(GotoStatementSyntax node)",
            "public virtual TResult VisitGroupClause(GroupClauseSyntax node)",
            "public virtual TResult VisitIdentifierName(IdentifierNameSyntax node)",
            "public virtual TResult VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)",
            "public virtual TResult VisitIfStatement(IfStatementSyntax node)",
            "public virtual TResult VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)",
            "public virtual TResult VisitImplicitElementAccess(ImplicitElementAccessSyntax node)",
            "public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node)",
            "public virtual TResult VisitIndexerDeclaration(IndexerDeclarationSyntax node)",
            "public virtual TResult VisitIndexerMemberCref(IndexerMemberCrefSyntax node)",
            "public virtual TResult VisitInitializerExpression(InitializerExpressionSyntax node)",
            "public virtual TResult VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)",
            "public virtual TResult VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)",
            "public virtual TResult VisitInterpolatedStringText(InterpolatedStringTextSyntax node)",
            "public virtual TResult VisitInterpolation(InterpolationSyntax node)",
            "public virtual TResult VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)",
            "public virtual TResult VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)",
            "public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node)",
            "public virtual TResult VisitIsPatternExpression(IsPatternExpressionSyntax node)",
            "public virtual TResult VisitJoinClause(JoinClauseSyntax node)",
            "public virtual TResult VisitJoinIntoClause(JoinIntoClauseSyntax node)",
            "public virtual TResult VisitLabeledStatement(LabeledStatementSyntax node)",
            "public virtual TResult VisitLetClause(LetClauseSyntax node)",
            "public virtual TResult VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)",
            "public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node)",
            "public virtual TResult VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)",
            "public virtual TResult VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)",
            "public virtual TResult VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)",
            "public virtual TResult VisitLockStatement(LockStatementSyntax node)",
            "public virtual TResult VisitMakeRefExpression(MakeRefExpressionSyntax node)",
            "public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node)",
            "public virtual TResult VisitMemberBindingExpression(MemberBindingExpressionSyntax node)",
            "public virtual TResult VisitMethodDeclaration(MethodDeclarationSyntax node)",
            "public virtual TResult VisitNameColon(NameColonSyntax node)",
            "public virtual TResult VisitNameEquals(NameEqualsSyntax node)",
            "public virtual TResult VisitNameMemberCref(NameMemberCrefSyntax node)",
            "public virtual TResult VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)",
            "public virtual TResult VisitNullableType(NullableTypeSyntax node)",
            "public virtual TResult VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)",
            "public virtual TResult VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)",
            "public virtual TResult VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)",
            "public virtual TResult VisitOperatorDeclaration(OperatorDeclarationSyntax node)",
            "public virtual TResult VisitOperatorMemberCref(OperatorMemberCrefSyntax node)",
            "public virtual TResult VisitOrderByClause(OrderByClauseSyntax node)",
            "public virtual TResult VisitOrdering(OrderingSyntax node)",
            "public virtual TResult VisitParameter(ParameterSyntax node)",
            "public virtual TResult VisitParameterList(ParameterListSyntax node)",
            "public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)",
            "public virtual TResult VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)",
            "public virtual TResult VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)",
            "public virtual TResult VisitPointerType(PointerTypeSyntax node)",
            "public virtual TResult VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)",
            "public virtual TResult VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)",
            "public virtual TResult VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)",
            "public virtual TResult VisitPredefinedType(PredefinedTypeSyntax node)",
            "public virtual TResult VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)",
            "public virtual TResult VisitPropertyDeclaration(PropertyDeclarationSyntax node)",
            "public virtual TResult VisitQualifiedCref(QualifiedCrefSyntax node)",
            "public virtual TResult VisitQualifiedName(QualifiedNameSyntax node)",
            "public virtual TResult VisitQueryBody(QueryBodySyntax node)",
            "public virtual TResult VisitQueryContinuation(QueryContinuationSyntax node)",
            "public virtual TResult VisitQueryExpression(QueryExpressionSyntax node)",
            "public virtual TResult VisitRefExpression(RefExpressionSyntax node)",
            "public virtual TResult VisitRefType(RefTypeSyntax node)",
            "public virtual TResult VisitRefTypeExpression(RefTypeExpressionSyntax node)",
            "public virtual TResult VisitRefValueExpression(RefValueExpressionSyntax node)",
            "public virtual TResult VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)",
            "public virtual TResult VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)",
            "public virtual TResult VisitReturnStatement(ReturnStatementSyntax node)",
            "public virtual TResult VisitSelectClause(SelectClauseSyntax node)",
            "public virtual TResult VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)",
            "public virtual TResult VisitSimpleBaseType(SimpleBaseTypeSyntax node)",
            "public virtual TResult VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)",
            "public virtual TResult VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)",
            "public virtual TResult VisitSizeOfExpression(SizeOfExpressionSyntax node)",
            "public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)",
            "public virtual TResult VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)",
            "public virtual TResult VisitStructDeclaration(StructDeclarationSyntax node)",
            "public virtual TResult VisitSwitchSection(SwitchSectionSyntax node)",
            "public virtual TResult VisitSwitchStatement(SwitchStatementSyntax node)",
            "public virtual TResult VisitThisExpression(ThisExpressionSyntax node)",
            "public virtual TResult VisitThrowExpression(ThrowExpressionSyntax node)",
            "public virtual TResult VisitThrowStatement(ThrowStatementSyntax node)",
            "public virtual TResult VisitTryStatement(TryStatementSyntax node)",
            "public virtual TResult VisitTupleElement(TupleElementSyntax node)",
            "public virtual TResult VisitTupleExpression(TupleExpressionSyntax node)",
            "public virtual TResult VisitTupleType(TupleTypeSyntax node)",
            "public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node)",
            "public virtual TResult VisitTypeConstraint(TypeConstraintSyntax node)",
            "public virtual TResult VisitTypeCref(TypeCrefSyntax node)",
            "public virtual TResult VisitTypeOfExpression(TypeOfExpressionSyntax node)",
            "public virtual TResult VisitTypeParameter(TypeParameterSyntax node)",
            "public virtual TResult VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)",
            "public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node)",
            "public virtual TResult VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)",
            "public virtual TResult VisitUnsafeStatement(UnsafeStatementSyntax node)",
            "public virtual TResult VisitUsingDirective(UsingDirectiveSyntax node)",
            "public virtual TResult VisitUsingStatement(UsingStatementSyntax node)",
            "public virtual TResult VisitVariableDeclaration(VariableDeclarationSyntax node)",
            "public virtual TResult VisitVariableDeclarator(VariableDeclaratorSyntax node)",
            "public virtual TResult VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)",
            "public virtual TResult VisitWhenClause(WhenClauseSyntax node)",
            "public virtual TResult VisitWhereClause(WhereClauseSyntax node)",
            "public virtual TResult VisitWhileStatement(WhileStatementSyntax node)",
            "public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node)",
            "public virtual TResult VisitXmlComment(XmlCommentSyntax node)",
            "public virtual TResult VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)",
            "public virtual TResult VisitXmlElement(XmlElementSyntax node)",
            "public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node)",
            "public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node)",
            "public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node)",
            "public virtual TResult VisitXmlName(XmlNameSyntax node)",
            "public virtual TResult VisitXmlNameAttribute(XmlNameAttributeSyntax node)",
            "public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node)",
            "public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)",
            "public virtual TResult VisitXmlText(XmlTextSyntax node)",
            "public virtual TResult VisitXmlTextAttribute(XmlTextAttributeSyntax node)",
            "public virtual TResult VisitYieldStatement(YieldStatementSyntax node)"
          ],
          "types": [
            {
              "type": "public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter : CSharpSyntaxVisitor<SyntaxNode>",
              "members": [
                "public CSharpSyntaxRewriter(bool visitIntoStructuredTrivia = false)",
                "public virtual bool VisitIntoStructuredTrivia { get; }",
                "public override SyntaxNode Visit(SyntaxNode node)",
                "public override SyntaxNode VisitAccessorDeclaration(AccessorDeclarationSyntax node)",
                "public override SyntaxNode VisitAccessorList(AccessorListSyntax node)",
                "public override SyntaxNode VisitAliasQualifiedName(AliasQualifiedNameSyntax node)",
                "public override SyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)",
                "public override SyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)",
                "public override SyntaxNode VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)",
                "public override SyntaxNode VisitArgument(ArgumentSyntax node)",
                "public override SyntaxNode VisitArgumentList(ArgumentListSyntax node)",
                "public override SyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)",
                "public override SyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)",
                "public override SyntaxNode VisitArrayType(ArrayTypeSyntax node)",
                "public override SyntaxNode VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)",
                "public override SyntaxNode VisitAssignmentExpression(AssignmentExpressionSyntax node)",
                "public override SyntaxNode VisitAttribute(AttributeSyntax node)",
                "public override SyntaxNode VisitAttributeArgument(AttributeArgumentSyntax node)",
                "public override SyntaxNode VisitAttributeArgumentList(AttributeArgumentListSyntax node)",
                "public override SyntaxNode VisitAttributeList(AttributeListSyntax node)",
                "public override SyntaxNode VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)",
                "public override SyntaxNode VisitAwaitExpression(AwaitExpressionSyntax node)",
                "public override SyntaxNode VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitBaseExpression(BaseExpressionSyntax node)",
                "public override SyntaxNode VisitBaseList(BaseListSyntax node)",
                "public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)",
                "public override SyntaxNode VisitBlock(BlockSyntax node)",
                "public override SyntaxNode VisitBracketedArgumentList(BracketedArgumentListSyntax node)",
                "public override SyntaxNode VisitBracketedParameterList(BracketedParameterListSyntax node)",
                "public override SyntaxNode VisitBreakStatement(BreakStatementSyntax node)",
                "public override SyntaxNode VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)",
                "public override SyntaxNode VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)",
                "public override SyntaxNode VisitCastExpression(CastExpressionSyntax node)",
                "public override SyntaxNode VisitCatchClause(CatchClauseSyntax node)",
                "public override SyntaxNode VisitCatchDeclaration(CatchDeclarationSyntax node)",
                "public override SyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node)",
                "public override SyntaxNode VisitCheckedExpression(CheckedExpressionSyntax node)",
                "public override SyntaxNode VisitCheckedStatement(CheckedStatementSyntax node)",
                "public override SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)",
                "public override SyntaxNode VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)",
                "public override SyntaxNode VisitCompilationUnit(CompilationUnitSyntax node)",
                "public override SyntaxNode VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)",
                "public override SyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node)",
                "public override SyntaxNode VisitConstantPattern(ConstantPatternSyntax node)",
                "public override SyntaxNode VisitConstructorConstraint(ConstructorConstraintSyntax node)",
                "public override SyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node)",
                "public override SyntaxNode VisitConstructorInitializer(ConstructorInitializerSyntax node)",
                "public override SyntaxNode VisitContinueStatement(ContinueStatementSyntax node)",
                "public override SyntaxNode VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)",
                "public override SyntaxNode VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)",
                "public override SyntaxNode VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)",
                "public override SyntaxNode VisitCrefParameter(CrefParameterSyntax node)",
                "public override SyntaxNode VisitCrefParameterList(CrefParameterListSyntax node)",
                "public override SyntaxNode VisitDeclarationExpression(DeclarationExpressionSyntax node)",
                "public override SyntaxNode VisitDeclarationPattern(DeclarationPatternSyntax node)",
                "public override SyntaxNode VisitDefaultExpression(DefaultExpressionSyntax node)",
                "public override SyntaxNode VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)",
                "public override SyntaxNode VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitDelegateDeclaration(DelegateDeclarationSyntax node)",
                "public override SyntaxNode VisitDestructorDeclaration(DestructorDeclarationSyntax node)",
                "public override SyntaxNode VisitDiscardDesignation(DiscardDesignationSyntax node)",
                "public override SyntaxNode VisitDoStatement(DoStatementSyntax node)",
                "public override SyntaxNode VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)",
                "public override SyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node)",
                "public override SyntaxNode VisitElementBindingExpression(ElementBindingExpressionSyntax node)",
                "public override SyntaxNode VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitElseClause(ElseClauseSyntax node)",
                "public override SyntaxNode VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitEmptyStatement(EmptyStatementSyntax node)",
                "public override SyntaxNode VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node)",
                "public override SyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)",
                "public override SyntaxNode VisitEqualsValueClause(EqualsValueClauseSyntax node)",
                "public override SyntaxNode VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitEventDeclaration(EventDeclarationSyntax node)",
                "public override SyntaxNode VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)",
                "public override SyntaxNode VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)",
                "public override SyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node)",
                "public override SyntaxNode VisitExternAliasDirective(ExternAliasDirectiveSyntax node)",
                "public override SyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node)",
                "public override SyntaxNode VisitFinallyClause(FinallyClauseSyntax node)",
                "public override SyntaxNode VisitFixedStatement(FixedStatementSyntax node)",
                "public override SyntaxNode VisitForEachStatement(ForEachStatementSyntax node)",
                "public override SyntaxNode VisitForEachVariableStatement(ForEachVariableStatementSyntax node)",
                "public override SyntaxNode VisitForStatement(ForStatementSyntax node)",
                "public override SyntaxNode VisitFromClause(FromClauseSyntax node)",
                "public override SyntaxNode VisitGenericName(GenericNameSyntax node)",
                "public override SyntaxNode VisitGlobalStatement(GlobalStatementSyntax node)",
                "public override SyntaxNode VisitGotoStatement(GotoStatementSyntax node)",
                "public override SyntaxNode VisitGroupClause(GroupClauseSyntax node)",
                "public override SyntaxNode VisitIdentifierName(IdentifierNameSyntax node)",
                "public override SyntaxNode VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitIfStatement(IfStatementSyntax node)",
                "public override SyntaxNode VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)",
                "public override SyntaxNode VisitImplicitElementAccess(ImplicitElementAccessSyntax node)",
                "public override SyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node)",
                "public override SyntaxNode VisitIndexerDeclaration(IndexerDeclarationSyntax node)",
                "public override SyntaxNode VisitIndexerMemberCref(IndexerMemberCrefSyntax node)",
                "public override SyntaxNode VisitInitializerExpression(InitializerExpressionSyntax node)",
                "public override SyntaxNode VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)",
                "public override SyntaxNode VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)",
                "public override SyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node)",
                "public override SyntaxNode VisitInterpolation(InterpolationSyntax node)",
                "public override SyntaxNode VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)",
                "public override SyntaxNode VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)",
                "public override SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)",
                "public override SyntaxNode VisitIsPatternExpression(IsPatternExpressionSyntax node)",
                "public override SyntaxNode VisitJoinClause(JoinClauseSyntax node)",
                "public override SyntaxNode VisitJoinIntoClause(JoinIntoClauseSyntax node)",
                "public override SyntaxNode VisitLabeledStatement(LabeledStatementSyntax node)",
                "public override SyntaxNode VisitLetClause(LetClauseSyntax node)",
                "public override SyntaxNode VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)",
                "public virtual SyntaxTokenList VisitList(SyntaxTokenList list)",
                "public virtual SyntaxTriviaList VisitList(SyntaxTriviaList list)",
                "public virtual SyntaxList<TNode> VisitList<TNode>(SyntaxList<TNode> list) where TNode : SyntaxNode",
                "public virtual SeparatedSyntaxList<TNode> VisitList<TNode>(SeparatedSyntaxList<TNode> list) where TNode : SyntaxNode",
                "public virtual SyntaxTrivia VisitListElement(SyntaxTrivia element)",
                "public virtual TNode VisitListElement<TNode>(TNode node) where TNode : SyntaxNode",
                "public virtual SyntaxToken VisitListSeparator(SyntaxToken separator)",
                "public override SyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node)",
                "public override SyntaxNode VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)",
                "public override SyntaxNode VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)",
                "public override SyntaxNode VisitLockStatement(LockStatementSyntax node)",
                "public override SyntaxNode VisitMakeRefExpression(MakeRefExpressionSyntax node)",
                "public override SyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node)",
                "public override SyntaxNode VisitMemberBindingExpression(MemberBindingExpressionSyntax node)",
                "public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)",
                "public override SyntaxNode VisitNameColon(NameColonSyntax node)",
                "public override SyntaxNode VisitNameEquals(NameEqualsSyntax node)",
                "public override SyntaxNode VisitNameMemberCref(NameMemberCrefSyntax node)",
                "public override SyntaxNode VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)",
                "public override SyntaxNode VisitNullableType(NullableTypeSyntax node)",
                "public override SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)",
                "public override SyntaxNode VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)",
                "public override SyntaxNode VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)",
                "public override SyntaxNode VisitOperatorDeclaration(OperatorDeclarationSyntax node)",
                "public override SyntaxNode VisitOperatorMemberCref(OperatorMemberCrefSyntax node)",
                "public override SyntaxNode VisitOrderByClause(OrderByClauseSyntax node)",
                "public override SyntaxNode VisitOrdering(OrderingSyntax node)",
                "public override SyntaxNode VisitParameter(ParameterSyntax node)",
                "public override SyntaxNode VisitParameterList(ParameterListSyntax node)",
                "public override SyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)",
                "public override SyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)",
                "public override SyntaxNode VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)",
                "public override SyntaxNode VisitPointerType(PointerTypeSyntax node)",
                "public override SyntaxNode VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)",
                "public override SyntaxNode VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitPredefinedType(PredefinedTypeSyntax node)",
                "public override SyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)",
                "public override SyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)",
                "public override SyntaxNode VisitQualifiedCref(QualifiedCrefSyntax node)",
                "public override SyntaxNode VisitQualifiedName(QualifiedNameSyntax node)",
                "public override SyntaxNode VisitQueryBody(QueryBodySyntax node)",
                "public override SyntaxNode VisitQueryContinuation(QueryContinuationSyntax node)",
                "public override SyntaxNode VisitQueryExpression(QueryExpressionSyntax node)",
                "public override SyntaxNode VisitRefExpression(RefExpressionSyntax node)",
                "public override SyntaxNode VisitRefType(RefTypeSyntax node)",
                "public override SyntaxNode VisitRefTypeExpression(RefTypeExpressionSyntax node)",
                "public override SyntaxNode VisitRefValueExpression(RefValueExpressionSyntax node)",
                "public override SyntaxNode VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitReturnStatement(ReturnStatementSyntax node)",
                "public override SyntaxNode VisitSelectClause(SelectClauseSyntax node)",
                "public override SyntaxNode VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitSimpleBaseType(SimpleBaseTypeSyntax node)",
                "public override SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)",
                "public override SyntaxNode VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)",
                "public override SyntaxNode VisitSizeOfExpression(SizeOfExpressionSyntax node)",
                "public override SyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)",
                "public override SyntaxNode VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)",
                "public override SyntaxNode VisitStructDeclaration(StructDeclarationSyntax node)",
                "public override SyntaxNode VisitSwitchSection(SwitchSectionSyntax node)",
                "public override SyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)",
                "public override SyntaxNode VisitThisExpression(ThisExpressionSyntax node)",
                "public override SyntaxNode VisitThrowExpression(ThrowExpressionSyntax node)",
                "public override SyntaxNode VisitThrowStatement(ThrowStatementSyntax node)",
                "public virtual SyntaxToken VisitToken(SyntaxToken token)",
                "public virtual SyntaxTrivia VisitTrivia(SyntaxTrivia trivia)",
                "public override SyntaxNode VisitTryStatement(TryStatementSyntax node)",
                "public override SyntaxNode VisitTupleElement(TupleElementSyntax node)",
                "public override SyntaxNode VisitTupleExpression(TupleExpressionSyntax node)",
                "public override SyntaxNode VisitTupleType(TupleTypeSyntax node)",
                "public override SyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node)",
                "public override SyntaxNode VisitTypeConstraint(TypeConstraintSyntax node)",
                "public override SyntaxNode VisitTypeCref(TypeCrefSyntax node)",
                "public override SyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node)",
                "public override SyntaxNode VisitTypeParameter(TypeParameterSyntax node)",
                "public override SyntaxNode VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)",
                "public override SyntaxNode VisitTypeParameterList(TypeParameterListSyntax node)",
                "public override SyntaxNode VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitUnsafeStatement(UnsafeStatementSyntax node)",
                "public override SyntaxNode VisitUsingDirective(UsingDirectiveSyntax node)",
                "public override SyntaxNode VisitUsingStatement(UsingStatementSyntax node)",
                "public override SyntaxNode VisitVariableDeclaration(VariableDeclarationSyntax node)",
                "public override SyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node)",
                "public override SyntaxNode VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)",
                "public override SyntaxNode VisitWhenClause(WhenClauseSyntax node)",
                "public override SyntaxNode VisitWhereClause(WhereClauseSyntax node)",
                "public override SyntaxNode VisitWhileStatement(WhileStatementSyntax node)",
                "public override SyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node)",
                "public override SyntaxNode VisitXmlComment(XmlCommentSyntax node)",
                "public override SyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)",
                "public override SyntaxNode VisitXmlElement(XmlElementSyntax node)",
                "public override SyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node)",
                "public override SyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node)",
                "public override SyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node)",
                "public override SyntaxNode VisitXmlName(XmlNameSyntax node)",
                "public override SyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node)",
                "public override SyntaxNode VisitXmlPrefix(XmlPrefixSyntax node)",
                "public override SyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)",
                "public override SyntaxNode VisitXmlText(XmlTextSyntax node)",
                "public override SyntaxNode VisitXmlTextAttribute(XmlTextAttributeSyntax node)",
                "public override SyntaxNode VisitYieldStatement(YieldStatementSyntax node)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.CodeActions.CodeAction",
          "members": [
            "protected CodeAction()",
            "public virtual string EquivalenceKey { get; }",
            "public virtual ImmutableArray<string> Tags { get; }",
            "public abstract string Title { get; }",
            "protected virtual Task<IEnumerable<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken)",
            "protected virtual Task<IEnumerable<CodeActionOperation>> ComputePreviewOperationsAsync(CancellationToken cancellationToken)",
            "public static CodeAction Create(string title, Func<CancellationToken, Task<Document>> createChangedDocument, string equivalenceKey = null)",
            "public static CodeAction Create(string title, Func<CancellationToken, Task<Solution>> createChangedSolution, string equivalenceKey = null)",
            "protected virtual Task<Document> GetChangedDocumentAsync(CancellationToken cancellationToken)",
            "protected virtual Task<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken)",
            "public Task<ImmutableArray<CodeActionOperation>> GetOperationsAsync(CancellationToken cancellationToken)",
            "public Task<ImmutableArray<CodeActionOperation>> GetPreviewOperationsAsync(CancellationToken cancellationToken)",
            "protected Task<ImmutableArray<CodeActionOperation>> PostProcessAsync(IEnumerable<CodeActionOperation> operations, CancellationToken cancellationToken)",
            "protected Task<Solution> PostProcessChangesAsync(Solution changedSolution, CancellationToken cancellationToken)",
            "protected virtual Task<Document> PostProcessChangesAsync(Document document, CancellationToken cancellationToken)"
          ],
          "types": [
            {
              "type": "public abstract class Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions : CodeAction",
              "members": [
                "protected CodeActionWithOptions()",
                "protected override Task<IEnumerable<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken)",
                "protected abstract Task<IEnumerable<CodeActionOperation>> ComputeOperationsAsync(object options, CancellationToken cancellationToken)",
                "public Task<IEnumerable<CodeActionOperation>> GetOperationsAsync(object options, CancellationToken cancellationToken)",
                "public abstract object GetOptions(CancellationToken cancellationToken)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.CodeActions.CodeActionOperation",
          "members": [
            "protected CodeActionOperation()",
            "public virtual string Title { get; }",
            "public virtual void Apply(Workspace workspace, CancellationToken cancellationToken)"
          ],
          "types": [
            {
              "type": "public sealed class Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation : CodeActionOperation",
              "members": [
                "public ApplyChangesOperation(Solution changedSolution)",
                "public Solution ChangedSolution { get; }",
                "public override void Apply(Workspace workspace, CancellationToken cancellationToken)"
              ]
            },
            {
              "type": "public sealed class Microsoft.CodeAnalysis.CodeActions.OpenDocumentOperation : CodeActionOperation",
              "members": [
                "public OpenDocumentOperation(DocumentId documentId, bool activateIfAlreadyOpen = false)",
                "public DocumentId DocumentId { get; }",
                "public override void Apply(Workspace workspace, CancellationToken cancellationToken)"
              ]
            },
            {
              "type": "public abstract class Microsoft.CodeAnalysis.CodeActions.PreviewOperation : CodeActionOperation",
              "members": [
                "protected PreviewOperation()",
                "public abstract Task<object> GetPreviewAsync(CancellationToken cancellationToken)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider",
          "members": [
            "protected CodeFixProvider()",
            "public abstract ImmutableArray<string> FixableDiagnosticIds { get; }",
            "public virtual FixAllProvider GetFixAllProvider()",
            "public abstract Task RegisterCodeFixesAsync(CodeFixContext context)"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.CodeFixes.FixAllContext",
          "members": [
            "public FixAllContext(Document document, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable<string> diagnosticIds, FixAllContext.DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken)",
            "public FixAllContext(Project project, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable<string> diagnosticIds, FixAllContext.DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken)",
            "public CancellationToken CancellationToken { get; }",
            "public string CodeActionEquivalenceKey { get; }",
            "public CodeFixProvider CodeFixProvider { get; }",
            "public ImmutableHashSet<string> DiagnosticIds { get; }",
            "public Document Document { get; }",
            "public Project Project { get; }",
            "public FixAllScope Scope { get; }",
            "public Solution Solution { get; }",
            "public Task<ImmutableArray<Diagnostic>> GetAllDiagnosticsAsync(Project project)",
            "public Task<ImmutableArray<Diagnostic>> GetDocumentDiagnosticsAsync(Document document)",
            "public Task<ImmutableArray<Diagnostic>> GetProjectDiagnosticsAsync(Project project)",
            "public FixAllContext WithCancellationToken(CancellationToken cancellationToken)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider",
          "members": [
            "protected DiagnosticProvider()",
            "public abstract Task<IEnumerable<Diagnostic>> GetAllDiagnosticsAsync(Project project, CancellationToken cancellationToken)",
            "public abstract Task<IEnumerable<Diagnostic>> GetDocumentDiagnosticsAsync(Document document, CancellationToken cancellationToken)",
            "public abstract Task<IEnumerable<Diagnostic>> GetProjectDiagnosticsAsync(Project project, CancellationToken cancellationToken)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.CodeFixes.FixAllProvider",
          "members": [
            "protected FixAllProvider()",
            "public abstract Task<CodeAction> GetFixAsync(FixAllContext fixAllContext)",
            "public virtual IEnumerable<string> GetSupportedFixAllDiagnosticIds(CodeFixProvider originalCodeFixProvider)",
            "public virtual IEnumerable<FixAllScope> GetSupportedFixAllScopes()"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider",
          "members": [
            "protected CodeRefactoringProvider()",
            "public abstract Task ComputeRefactoringsAsync(CodeRefactoringContext context)"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption<T> : IEquatable<CodeStyleOption<T>>, ICodeStyleOption",
          "members": [
            "public CodeStyleOption(T value, NotificationOption notification)",
            "public static CodeStyleOption<T> Default { get; }",
            "public NotificationOption Notification { get; set; }",
            "public T Value { get; set; }",
            "public override bool Equals(object obj)",
            "public bool Equals(CodeStyleOption<T> other)",
            "public static CodeStyleOption<T> FromXElement(XElement element)",
            "public override int GetHashCode()",
            "public XElement ToXElement()"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions",
          "members": [
            "public static readonly PerLanguageOption<CodeStyleOption<bool>> PreferIntrinsicPredefinedTypeKeywordInDeclaration",
            "public static readonly PerLanguageOption<CodeStyleOption<bool>> PreferIntrinsicPredefinedTypeKeywordInMemberAccess",
            "public static readonly PerLanguageOption<CodeStyleOption<bool>> QualifyEventAccess",
            "public static readonly PerLanguageOption<CodeStyleOption<bool>> QualifyFieldAccess",
            "public static readonly PerLanguageOption<CodeStyleOption<bool>> QualifyMethodAccess",
            "public static readonly PerLanguageOption<CodeStyleOption<bool>> QualifyPropertyAccess",
            "public CodeStyleOptions()"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.CodeStyle.NotificationOption",
          "members": [
            "public static readonly NotificationOption Error",
            "public static readonly NotificationOption None",
            "public static readonly NotificationOption Suggestion",
            "public static readonly NotificationOption Warning",
            "public string Name { get; set; }",
            "public DiagnosticSeverity Value { get; set; }",
            "public override string ToString()"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Diagnostics.AnalysisContext",
          "members": [
            "protected AnalysisContext()",
            "public virtual void ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags analysisMode)",
            "public virtual void EnableConcurrentExecution()",
            "public abstract void RegisterCodeBlockAction(Action<CodeBlockAnalysisContext> action)",
            "public abstract void RegisterCodeBlockStartAction<TLanguageKindEnum>(Action<CodeBlockStartAnalysisContext<TLanguageKindEnum>> action) where TLanguageKindEnum : struct",
            "public abstract void RegisterCompilationAction(Action<CompilationAnalysisContext> action)",
            "public abstract void RegisterCompilationStartAction(Action<CompilationStartAnalysisContext> action)",
            "public void RegisterOperationAction(Action<OperationAnalysisContext> action, params OperationKind[] operationKinds)",
            "public virtual void RegisterOperationAction(Action<OperationAnalysisContext> action, ImmutableArray<OperationKind> operationKinds)",
            "public virtual void RegisterOperationBlockAction(Action<OperationBlockAnalysisContext> action)",
            "public virtual void RegisterOperationBlockStartAction(Action<OperationBlockStartAnalysisContext> action)",
            "public abstract void RegisterSemanticModelAction(Action<SemanticModelAnalysisContext> action)",
            "public void RegisterSymbolAction(Action<SymbolAnalysisContext> action, params SymbolKind[] symbolKinds)",
            "public abstract void RegisterSymbolAction(Action<SymbolAnalysisContext> action, ImmutableArray<SymbolKind> symbolKinds)",
            "public void RegisterSyntaxNodeAction<TLanguageKindEnum>(Action<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds) where TLanguageKindEnum : struct",
            "public abstract void RegisterSyntaxNodeAction<TLanguageKindEnum>(Action<SyntaxNodeAnalysisContext> action, ImmutableArray<TLanguageKindEnum> syntaxKinds) where TLanguageKindEnum : struct",
            "public abstract void RegisterSyntaxTreeAction(Action<SyntaxTreeAnalysisContext> action)",
            "public bool TryGetValue<TValue>(SourceText text, SourceTextValueProvider<TValue> valueProvider, out TValue value)"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.Diagnostics.AnalysisResult",
          "members": [
            "public ImmutableDictionary<DiagnosticAnalyzer, AnalyzerTelemetryInfo> AnalyzerTelemetryInfo { get; }",
            "public ImmutableArray<DiagnosticAnalyzer> Analyzers { get; }",
            "public ImmutableDictionary<DiagnosticAnalyzer, ImmutableArray<Diagnostic>> CompilationDiagnostics { get; }",
            "public ImmutableDictionary<SyntaxTree, ImmutableDictionary<DiagnosticAnalyzer, ImmutableArray<Diagnostic>>> SemanticDiagnostics { get; }",
            "public ImmutableDictionary<SyntaxTree, ImmutableDictionary<DiagnosticAnalyzer, ImmutableArray<Diagnostic>>> SyntaxDiagnostics { get; }",
            "public ImmutableArray<Diagnostic> GetAllDiagnostics()",
            "public ImmutableArray<Diagnostic> GetAllDiagnostics(DiagnosticAnalyzer analyzer)"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions",
          "members": [
            "public AnalyzerOptions(ImmutableArray<AdditionalText> additionalFiles)",
            "public ImmutableArray<AdditionalText> AdditionalFiles { get; }",
            "public override bool Equals(object obj)",
            "public override int GetHashCode()",
            "public AnalyzerOptions WithAdditionalFiles(ImmutableArray<AdditionalText> additionalFiles)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference",
          "members": [
            "protected AnalyzerReference()",
            "public virtual string Display { get; }",
            "public abstract string FullPath { get; }",
            "public abstract object Id { get; }",
            "public abstract ImmutableArray<DiagnosticAnalyzer> GetAnalyzers(string language)",
            "public abstract ImmutableArray<DiagnosticAnalyzer> GetAnalyzersForAllLanguages()"
          ],
          "types": [
            {
              "type": "public sealed class Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference : AnalyzerReference, IEquatable<AnalyzerReference>",
              "members": [
                "public AnalyzerFileReference(string fullPath, IAnalyzerAssemblyLoader assemblyLoader)",
                "public event EventHandler<AnalyzerLoadFailureEventArgs> AnalyzerLoadFailed",
                "public override string Display { get; }",
                "public override string FullPath { get; }",
                "public override object Id { get; }",
                "public override bool Equals(object obj)",
                "public bool Equals(AnalyzerReference other)",
                "public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzers(string language)",
                "public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzersForAllLanguages()",
                "public Assembly GetAssembly()",
                "public override int GetHashCode()"
              ]
            },
            {
              "type": "public sealed class Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference : AnalyzerReference",
              "members": [
                "public AnalyzerImageReference(ImmutableArray<DiagnosticAnalyzer> analyzers, string fullPath = null, string display = null)",
                "public override string Display { get; }",
                "public override string FullPath { get; }",
                "public override object Id { get; }",
                "public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzers(string language)",
                "public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzersForAllLanguages()"
              ]
            },
            {
              "type": "public sealed class Microsoft.CodeAnalysis.Diagnostics.UnresolvedAnalyzerReference : AnalyzerReference",
              "members": [
                "public UnresolvedAnalyzerReference(string unresolvedPath)",
                "public override string Display { get; }",
                "public override string FullPath { get; }",
                "public override object Id { get; }",
                "public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzers(string language)",
                "public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzersForAllLanguages()"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext<TLanguageKindEnum> where TLanguageKindEnum : struct",
          "members": [
            "protected CodeBlockStartAnalysisContext(SyntaxNode codeBlock, ISymbol owningSymbol, SemanticModel semanticModel, AnalyzerOptions options, CancellationToken cancellationToken)",
            "public CancellationToken CancellationToken { get; }",
            "public SyntaxNode CodeBlock { get; }",
            "public AnalyzerOptions Options { get; }",
            "public ISymbol OwningSymbol { get; }",
            "public SemanticModel SemanticModel { get; }",
            "public abstract void RegisterCodeBlockEndAction(Action<CodeBlockAnalysisContext> action)",
            "public void RegisterSyntaxNodeAction(Action<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds)",
            "public abstract void RegisterSyntaxNodeAction(Action<SyntaxNodeAnalysisContext> action, ImmutableArray<TLanguageKindEnum> syntaxKinds)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext",
          "members": [
            "protected CompilationStartAnalysisContext(Compilation compilation, AnalyzerOptions options, CancellationToken cancellationToken)",
            "public CancellationToken CancellationToken { get; }",
            "public Compilation Compilation { get; }",
            "public AnalyzerOptions Options { get; }",
            "public abstract void RegisterCodeBlockAction(Action<CodeBlockAnalysisContext> action)",
            "public abstract void RegisterCodeBlockStartAction<TLanguageKindEnum>(Action<CodeBlockStartAnalysisContext<TLanguageKindEnum>> action) where TLanguageKindEnum : struct",
            "public abstract void RegisterCompilationEndAction(Action<CompilationAnalysisContext> action)",
            "public void RegisterOperationAction(Action<OperationAnalysisContext> action, params OperationKind[] operationKinds)",
            "public virtual void RegisterOperationAction(Action<OperationAnalysisContext> action, ImmutableArray<OperationKind> operationKinds)",
            "public virtual void RegisterOperationBlockAction(Action<OperationBlockAnalysisContext> action)",
            "public virtual void RegisterOperationBlockStartAction(Action<OperationBlockStartAnalysisContext> action)",
            "public abstract void RegisterSemanticModelAction(Action<SemanticModelAnalysisContext> action)",
            "public void RegisterSymbolAction(Action<SymbolAnalysisContext> action, params SymbolKind[] symbolKinds)",
            "public abstract void RegisterSymbolAction(Action<SymbolAnalysisContext> action, ImmutableArray<SymbolKind> symbolKinds)",
            "public void RegisterSyntaxNodeAction<TLanguageKindEnum>(Action<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds) where TLanguageKindEnum : struct",
            "public abstract void RegisterSyntaxNodeAction<TLanguageKindEnum>(Action<SyntaxNodeAnalysisContext> action, ImmutableArray<TLanguageKindEnum> syntaxKinds) where TLanguageKindEnum : struct",
            "public abstract void RegisterSyntaxTreeAction(Action<SyntaxTreeAnalysisContext> action)",
            "public bool TryGetValue<TValue>(SourceText text, SourceTextValueProvider<TValue> valueProvider, out TValue value)",
            "public bool TryGetValue<TValue>(SyntaxTree tree, SyntaxTreeValueProvider<TValue> valueProvider, out TValue value)"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers",
          "members": [
            "public CompilationWithAnalyzers(Compilation compilation, ImmutableArray<DiagnosticAnalyzer> analyzers, CompilationWithAnalyzersOptions analysisOptions)",
            "public CompilationWithAnalyzers(Compilation compilation, ImmutableArray<DiagnosticAnalyzer> analyzers, AnalyzerOptions options, CancellationToken cancellationToken)",
            "public CompilationWithAnalyzersOptions AnalysisOptions { get; }",
            "public ImmutableArray<DiagnosticAnalyzer> Analyzers { get; }",
            "public CancellationToken CancellationToken { get; }",
            "public Compilation Compilation { get; }",
            "public static void ClearAnalyzerState(ImmutableArray<DiagnosticAnalyzer> analyzers)",
            "public Task<ImmutableArray<Diagnostic>> GetAllDiagnosticsAsync()",
            "public Task<ImmutableArray<Diagnostic>> GetAllDiagnosticsAsync(CancellationToken cancellationToken)",
            "public Task<AnalysisResult> GetAnalysisResultAsync(CancellationToken cancellationToken)",
            "public Task<AnalysisResult> GetAnalysisResultAsync(ImmutableArray<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken)",
            "public Task<ImmutableArray<Diagnostic>> GetAnalyzerCompilationDiagnosticsAsync(CancellationToken cancellationToken)",
            "public Task<ImmutableArray<Diagnostic>> GetAnalyzerCompilationDiagnosticsAsync(ImmutableArray<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken)",
            "public Task<ImmutableArray<Diagnostic>> GetAnalyzerDiagnosticsAsync()",
            "public Task<ImmutableArray<Diagnostic>> GetAnalyzerDiagnosticsAsync(CancellationToken cancellationToken)",
            "public Task<ImmutableArray<Diagnostic>> GetAnalyzerDiagnosticsAsync(ImmutableArray<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken)",
            "public Task<ImmutableArray<Diagnostic>> GetAnalyzerSemanticDiagnosticsAsync(SemanticModel model, TextSpan? filterSpan, CancellationToken cancellationToken)",
            "public Task<ImmutableArray<Diagnostic>> GetAnalyzerSemanticDiagnosticsAsync(SemanticModel model, TextSpan? filterSpan, ImmutableArray<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken)",
            "public Task<ImmutableArray<Diagnostic>> GetAnalyzerSyntaxDiagnosticsAsync(SyntaxTree tree, CancellationToken cancellationToken)",
            "public Task<ImmutableArray<Diagnostic>> GetAnalyzerSyntaxDiagnosticsAsync(SyntaxTree tree, ImmutableArray<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken)",
            "public Task<AnalyzerTelemetryInfo> GetAnalyzerTelemetryInfoAsync(DiagnosticAnalyzer analyzer, CancellationToken cancellationToken)",
            "public static IEnumerable<Diagnostic> GetEffectiveDiagnostics(IEnumerable<Diagnostic> diagnostics, Compilation compilation)",
            "public static IEnumerable<Diagnostic> GetEffectiveDiagnostics(ImmutableArray<Diagnostic> diagnostics, Compilation compilation)",
            "public static bool IsDiagnosticAnalyzerSuppressed(DiagnosticAnalyzer analyzer, CompilationOptions options, Action<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException = null)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions",
          "members": [
            "public CompilationWithAnalyzersOptions(AnalyzerOptions options, Action<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime)",
            "public CompilationWithAnalyzersOptions(AnalyzerOptions options, Action<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime, bool reportSuppressedDiagnostics)",
            "public CompilationWithAnalyzersOptions(AnalyzerOptions options, Action<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime, bool reportSuppressedDiagnostics, Func<Exception, bool> analyzerExceptionFilter)",
            "public Func<Exception, bool> AnalyzerExceptionFilter { get; }",
            "public bool ConcurrentAnalysis { get; }",
            "public bool LogAnalyzerExecutionTime { get; }",
            "public Action<Exception, DiagnosticAnalyzer, Diagnostic> OnAnalyzerException { get; }",
            "public AnalyzerOptions Options { get; }",
            "public bool ReportSuppressedDiagnostics { get; }"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer",
          "members": [
            "protected DiagnosticAnalyzer()",
            "public abstract ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; }",
            "public override sealed bool Equals(object obj)",
            "public override sealed int GetHashCode()",
            "public abstract void Initialize(AnalysisContext context)",
            "public override sealed string ToString()"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext",
          "members": [
            "protected OperationBlockStartAnalysisContext(ImmutableArray<IOperation> operationBlocks, ISymbol owningSymbol, Compilation compilation, AnalyzerOptions options, CancellationToken cancellationToken)",
            "public CancellationToken CancellationToken { get; }",
            "public Compilation Compilation { get; }",
            "public ImmutableArray<IOperation> OperationBlocks { get; }",
            "public AnalyzerOptions Options { get; }",
            "public ISymbol OwningSymbol { get; }",
            "public void RegisterOperationAction(Action<OperationAnalysisContext> action, params OperationKind[] operationKinds)",
            "public abstract void RegisterOperationAction(Action<OperationAnalysisContext> action, ImmutableArray<OperationKind> operationKinds)",
            "public abstract void RegisterOperationBlockEndAction(Action<OperationBlockAnalysisContext> action)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.Diagnostics.SourceTextValueProvider<TValue>",
          "members": [
            "public SourceTextValueProvider(Func<SourceText, TValue> computeValue, IEqualityComparer<SourceText> sourceTextComparer = null)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.Diagnostics.SuppressionInfo",
          "members": [
            "public AttributeData Attribute { get; }",
            "public string Id { get; }"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeValueProvider<TValue>",
          "members": [
            "public SyntaxTreeValueProvider(Func<SyntaxTree, TValue> computeValue, IEqualityComparer<SyntaxTree> syntaxTreeComparer = null)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo",
          "members": [
            "public AnalyzerTelemetryInfo()",
            "public int CodeBlockActionsCount { get; set; }",
            "public int CodeBlockEndActionsCount { get; set; }",
            "public int CodeBlockStartActionsCount { get; set; }",
            "public int CompilationActionsCount { get; set; }",
            "public int CompilationEndActionsCount { get; set; }",
            "public int CompilationStartActionsCount { get; set; }",
            "public TimeSpan ExecutionTime { get; set; }",
            "public int OperationActionsCount { get; set; }",
            "public int OperationBlockActionsCount { get; set; }",
            "public int OperationBlockEndActionsCount { get; set; }",
            "public int OperationBlockStartActionsCount { get; set; }",
            "public int SemanticModelActionsCount { get; set; }",
            "public int SymbolActionsCount { get; set; }",
            "public int SyntaxNodeActionsCount { get; set; }",
            "public int SyntaxTreeActionsCount { get; set; }"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.Differencing.EditScript<TNode>",
          "members": [
            "public ImmutableArray<Edit<TNode>> Edits { get; }",
            "public Match<TNode> Match { get; }"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.Differencing.Match<TNode>",
          "members": [
            "public TreeComparer<TNode> Comparer { get; }",
            "public IReadOnlyDictionary<TNode, TNode> Matches { get; }",
            "public TNode NewRoot { get; }",
            "public TNode OldRoot { get; }",
            "public IReadOnlyDictionary<TNode, TNode> ReverseMatches { get; }",
            "public IEnumerable<Edit<TNode>> GetSequenceEdits(IEnumerable<TNode> oldNodes, IEnumerable<TNode> newNodes)",
            "public EditScript<TNode> GetTreeEdits()",
            "public bool TryGetNewNode(TNode oldNode, out TNode newNode)",
            "public bool TryGetOldNode(TNode newNode, out TNode oldNode)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Differencing.TreeComparer<TNode>",
          "members": [
            "protected TreeComparer()",
            "protected internal abstract int LabelCount { get; }",
            "public EditScript<TNode> ComputeEditScript(TNode oldRoot, TNode newRoot)",
            "public Match<TNode> ComputeMatch(TNode oldRoot, TNode newRoot, IEnumerable<KeyValuePair<TNode, TNode>> knownMatches = null)",
            "protected internal abstract IEnumerable<TNode> GetChildren(TNode node)",
            "protected internal abstract IEnumerable<TNode> GetDescendants(TNode node)",
            "public abstract double GetDistance(TNode oldNode, TNode newNode)",
            "protected internal abstract int GetLabel(TNode node)",
            "protected internal abstract TextSpan GetSpan(TNode node)",
            "protected internal abstract int TiedToAncestor(int label)",
            "protected internal abstract bool TreesEqual(TNode oldNode, TNode newNode)",
            "protected internal abstract bool TryGetParent(TNode node, out TNode parent)",
            "public abstract bool ValuesEqual(TNode oldNode, TNode newNode)"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.Editing.SolutionEditor",
          "members": [
            "public SolutionEditor(Solution solution)",
            "public Solution OriginalSolution { get; }",
            "public Solution GetChangedSolution()",
            "public Task<DocumentEditor> GetDocumentEditorAsync(DocumentId id, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.Editing.SymbolEditor",
          "members": [
            "public Solution ChangedSolution { get; }",
            "public Solution OriginalSolution { get; }",
            "public static SymbolEditor Create(Document document)",
            "public static SymbolEditor Create(Solution solution)",
            "public Task<ISymbol> EditAllDeclarationsAsync(ISymbol symbol, SymbolEditor.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default)",
            "public Task<ISymbol> EditAllDeclarationsAsync(ISymbol symbol, SymbolEditor.DeclarationEditAction editAction, CancellationToken cancellationToken = default)",
            "public Task<ISymbol> EditOneDeclarationAsync(ISymbol symbol, SymbolEditor.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default)",
            "public Task<ISymbol> EditOneDeclarationAsync(ISymbol symbol, SymbolEditor.DeclarationEditAction editAction, CancellationToken cancellationToken = default)",
            "public Task<ISymbol> EditOneDeclarationAsync(ISymbol symbol, Location location, SymbolEditor.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default)",
            "public Task<ISymbol> EditOneDeclarationAsync(ISymbol symbol, Location location, SymbolEditor.DeclarationEditAction editAction, CancellationToken cancellationToken = default)",
            "public Task<ISymbol> EditOneDeclarationAsync(ISymbol symbol, ISymbol member, SymbolEditor.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default)",
            "public Task<ISymbol> EditOneDeclarationAsync(ISymbol symbol, ISymbol member, SymbolEditor.DeclarationEditAction editAction, CancellationToken cancellationToken = default)",
            "public IEnumerable<Document> GetChangedDocuments()",
            "public Task<IReadOnlyList<SyntaxNode>> GetCurrentDeclarationsAsync(ISymbol symbol, CancellationToken cancellationToken = default)",
            "public Task<ISymbol> GetCurrentSymbolAsync(ISymbol symbol, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.Editing.SyntaxEditor",
          "members": [
            "public SyntaxEditor(SyntaxNode root, Workspace workspace)",
            "public SyntaxGenerator Generator { get; }",
            "public SyntaxNode OriginalRoot { get; }",
            "public SyntaxNode GetChangedRoot()",
            "public void InsertAfter(SyntaxNode node, SyntaxNode newNode)",
            "public void InsertAfter(SyntaxNode node, IEnumerable<SyntaxNode> newNodes)",
            "public void InsertBefore(SyntaxNode node, SyntaxNode newNode)",
            "public void InsertBefore(SyntaxNode node, IEnumerable<SyntaxNode> newNodes)",
            "public void RemoveNode(SyntaxNode node)",
            "public void RemoveNode(SyntaxNode node, SyntaxRemoveOptions options)",
            "public void ReplaceNode(SyntaxNode node, Func<SyntaxNode, SyntaxGenerator, SyntaxNode> computeReplacement)",
            "public void ReplaceNode(SyntaxNode node, SyntaxNode newNode)",
            "public void TrackNode(SyntaxNode node)"
          ],
          "types": [
            {
              "type": "public class Microsoft.CodeAnalysis.Editing.DocumentEditor : SyntaxEditor",
              "members": [
                "public Document OriginalDocument { get; }",
                "public SemanticModel SemanticModel { get; }",
                "public static Task<DocumentEditor> CreateAsync(Document document, CancellationToken cancellationToken = default)",
                "public Document GetChangedDocument()"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Editing.SyntaxGenerator : ILanguageService",
          "members": [
            "public static SyntaxRemoveOptions DefaultRemoveOptions",
            "protected SyntaxGenerator()",
            "public SyntaxNode AddAccessors(SyntaxNode declaration, IEnumerable<SyntaxNode> accessors)",
            "public SyntaxNode AddAttributeArguments(SyntaxNode attributeDeclaration, IEnumerable<SyntaxNode> attributeArguments)",
            "public SyntaxNode AddAttributes(SyntaxNode declaration, IEnumerable<SyntaxNode> attributes)",
            "public SyntaxNode AddAttributes(SyntaxNode declaration, params SyntaxNode[] attributes)",
            "public abstract SyntaxNode AddBaseType(SyntaxNode declaration, SyntaxNode baseType)",
            "public abstract SyntaxNode AddEventHandler(SyntaxNode @event, SyntaxNode handler)",
            "public abstract SyntaxNode AddExpression(SyntaxNode left, SyntaxNode right)",
            "public abstract SyntaxNode AddInterfaceType(SyntaxNode declaration, SyntaxNode interfaceType)",
            "public SyntaxNode AddMembers(SyntaxNode declaration, IEnumerable<SyntaxNode> members)",
            "public SyntaxNode AddMembers(SyntaxNode declaration, params SyntaxNode[] members)",
            "public SyntaxNode AddNamespaceImports(SyntaxNode declaration, IEnumerable<SyntaxNode> imports)",
            "public SyntaxNode AddNamespaceImports(SyntaxNode declaration, params SyntaxNode[] imports)",
            "public SyntaxNode AddParameters(SyntaxNode declaration, IEnumerable<SyntaxNode> parameters)",
            "public SyntaxNode AddReturnAttributes(SyntaxNode declaration, IEnumerable<SyntaxNode> attributes)",
            "public SyntaxNode AddReturnAttributes(SyntaxNode declaration, params SyntaxNode[] attributes)",
            "public SyntaxNode AddSwitchSections(SyntaxNode switchStatement, IEnumerable<SyntaxNode> switchSections)",
            "public SyntaxNode Argument(SyntaxNode expression)",
            "public SyntaxNode Argument(RefKind refKind, SyntaxNode expression)",
            "public abstract SyntaxNode Argument(string name, RefKind refKind, SyntaxNode expression)",
            "public abstract SyntaxNode ArrayCreationExpression(SyntaxNode elementType, IEnumerable<SyntaxNode> elements)",
            "public abstract SyntaxNode ArrayCreationExpression(SyntaxNode elementType, SyntaxNode size)",
            "public abstract SyntaxNode ArrayTypeExpression(SyntaxNode type)",
            "public SyntaxNode AsPrivateInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType)",
            "public abstract SyntaxNode AsPrivateInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType, string interfaceMemberName)",
            "public SyntaxNode AsPublicInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType)",
            "public abstract SyntaxNode AsPublicInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType, string interfaceMemberName)",
            "public abstract SyntaxNode AssignmentStatement(SyntaxNode left, SyntaxNode right)",
            "public SyntaxNode Attribute(AttributeData attribute)",
            "public abstract SyntaxNode Attribute(SyntaxNode name, IEnumerable<SyntaxNode> attributeArguments = null)",
            "public SyntaxNode Attribute(string name, IEnumerable<SyntaxNode> attributeArguments = null)",
            "public SyntaxNode Attribute(string name, params SyntaxNode[] attributeArguments)",
            "public SyntaxNode AttributeArgument(SyntaxNode expression)",
            "public abstract SyntaxNode AttributeArgument(string name, SyntaxNode expression)",
            "public abstract SyntaxNode AwaitExpression(SyntaxNode expression)",
            "public abstract SyntaxNode BaseExpression()",
            "public abstract SyntaxNode BitwiseAndExpression(SyntaxNode left, SyntaxNode right)",
            "public abstract SyntaxNode BitwiseNotExpression(SyntaxNode operand)",
            "public abstract SyntaxNode BitwiseOrExpression(SyntaxNode left, SyntaxNode right)",
            "public abstract SyntaxNode CastExpression(SyntaxNode type, SyntaxNode expression)",
            "public SyntaxNode CastExpression(ITypeSymbol type, SyntaxNode expression)",
            "public abstract SyntaxNode CatchClause(SyntaxNode type, string identifier, IEnumerable<SyntaxNode> statements)",
            "public SyntaxNode CatchClause(ITypeSymbol type, string identifier, IEnumerable<SyntaxNode> statements)",
            "public abstract SyntaxNode ClassDeclaration(string name, IEnumerable<string> typeParameters = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, SyntaxNode baseType = null, IEnumerable<SyntaxNode> interfaceTypes = null, IEnumerable<SyntaxNode> members = null)",
            "public abstract TNode ClearTrivia<TNode>(TNode node) where TNode : SyntaxNode",
            "public abstract SyntaxNode CoalesceExpression(SyntaxNode left, SyntaxNode right)",
            "public abstract SyntaxNode CompilationUnit(IEnumerable<SyntaxNode> declarations)",
            "public SyntaxNode CompilationUnit(params SyntaxNode[] declarations)",
            "public abstract SyntaxNode ConditionalExpression(SyntaxNode condition, SyntaxNode whenTrue, SyntaxNode whenFalse)",
            "public SyntaxNode ConstructorDeclaration(IMethodSymbol constructorMethod, IEnumerable<SyntaxNode> baseConstructorArguments = null, IEnumerable<SyntaxNode> statements = null)",
            "public abstract SyntaxNode ConstructorDeclaration(string containingTypeName = null, IEnumerable<SyntaxNode> parameters = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> baseConstructorArguments = null, IEnumerable<SyntaxNode> statements = null)",
            "public abstract SyntaxNode ConvertExpression(SyntaxNode type, SyntaxNode expression)",
            "public SyntaxNode ConvertExpression(ITypeSymbol type, SyntaxNode expression)",
            "public SyntaxNode CustomEventDeclaration(IEventSymbol symbol, IEnumerable<SyntaxNode> addAccessorStatements = null, IEnumerable<SyntaxNode> removeAccessorStatements = null)",
            "public abstract SyntaxNode CustomEventDeclaration(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> parameters = null, IEnumerable<SyntaxNode> addAccessorStatements = null, IEnumerable<SyntaxNode> removeAccessorStatements = null)",
            "public SyntaxNode Declaration(ISymbol symbol)",
            "public abstract SyntaxNode DefaultExpression(SyntaxNode type)",
            "public abstract SyntaxNode DefaultExpression(ITypeSymbol type)",
            "public abstract SyntaxNode DefaultSwitchSection(IEnumerable<SyntaxNode> statements)",
            "public abstract SyntaxNode DelegateDeclaration(string name, IEnumerable<SyntaxNode> parameters = null, IEnumerable<string> typeParameters = null, SyntaxNode returnType = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default)",
            "public abstract SyntaxNode DivideExpression(SyntaxNode left, SyntaxNode right)",
            "public SyntaxNode DottedName(string dottedName)",
            "public abstract SyntaxNode ElementAccessExpression(SyntaxNode expression, IEnumerable<SyntaxNode> arguments)",
            "public SyntaxNode ElementAccessExpression(SyntaxNode expression, params SyntaxNode[] arguments)",
            "public abstract SyntaxNode EnumDeclaration(string name, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> members = null)",
            "public abstract SyntaxNode EnumMember(string name, SyntaxNode expression = null)",
            "public SyntaxNode EventDeclaration(IEventSymbol symbol)",
            "public abstract SyntaxNode EventDeclaration(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default)",
            "public abstract SyntaxNode ExitSwitchStatement()",
            "public abstract SyntaxNode ExpressionStatement(SyntaxNode expression)",
            "public SyntaxNode FalseLiteralExpression()",
            "public SyntaxNode FieldDeclaration(IFieldSymbol field)",
            "public SyntaxNode FieldDeclaration(IFieldSymbol field, SyntaxNode initializer)",
            "public abstract SyntaxNode FieldDeclaration(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, SyntaxNode initializer = null)",
            "public abstract SyntaxNode GenericName(string identifier, IEnumerable<SyntaxNode> typeArguments)",
            "public SyntaxNode GenericName(string identifier, IEnumerable<ITypeSymbol> typeArguments)",
            "public SyntaxNode GenericName(string identifier, params SyntaxNode[] typeArguments)",
            "public SyntaxNode GenericName(string identifier, params ITypeSymbol[] typeArguments)",
            "public abstract Accessibility GetAccessibility(SyntaxNode declaration)",
            "public SyntaxNode GetAccessor(SyntaxNode declaration, DeclarationKind kind)",
            "public abstract IReadOnlyList<SyntaxNode> GetAccessors(SyntaxNode declaration)",
            "public abstract IReadOnlyList<SyntaxNode> GetAttributeArguments(SyntaxNode attributeDeclaration)",
            "public abstract IReadOnlyList<SyntaxNode> GetAttributes(SyntaxNode declaration)",
            "public abstract IReadOnlyList<SyntaxNode> GetBaseAndInterfaceTypes(SyntaxNode declaration)",
            "public SyntaxNode GetDeclaration(SyntaxNode node)",
            "public SyntaxNode GetDeclaration(SyntaxNode node, DeclarationKind kind)",
            "public abstract DeclarationKind GetDeclarationKind(SyntaxNode declaration)",
            "public abstract SyntaxNode GetExpression(SyntaxNode declaration)",
            "public static SyntaxGenerator GetGenerator(Document document)",
            "public static SyntaxGenerator GetGenerator(Project project)",
            "public static SyntaxGenerator GetGenerator(Workspace workspace, string language)",
            "public abstract IReadOnlyList<SyntaxNode> GetGetAccessorStatements(SyntaxNode declaration)",
            "public abstract IReadOnlyList<SyntaxNode> GetMembers(SyntaxNode declaration)",
            "public abstract DeclarationModifiers GetModifiers(SyntaxNode declaration)",
            "public abstract string GetName(SyntaxNode declaration)",
            "public abstract IReadOnlyList<SyntaxNode> GetNamespaceImports(SyntaxNode declaration)",
            "public abstract IReadOnlyList<SyntaxNode> GetParameters(SyntaxNode declaration)",
            "public abstract IReadOnlyList<SyntaxNode> GetReturnAttributes(SyntaxNode declaration)",
            "public abstract IReadOnlyList<SyntaxNode> GetSetAccessorStatements(SyntaxNode declaration)",
            "public abstract IReadOnlyList<SyntaxNode> GetStatements(SyntaxNode declaration)",
            "public abstract IReadOnlyList<SyntaxNode> GetSwitchSections(SyntaxNode switchStatement)",
            "public abstract SyntaxNode GetType(SyntaxNode declaration)",
            "public abstract SyntaxNode GreaterThanExpression(SyntaxNode left, SyntaxNode right)",
            "public abstract SyntaxNode GreaterThanOrEqualExpression(SyntaxNode left, SyntaxNode right)",
            "public abstract SyntaxNode IdentifierName(string identifier)",
            "public SyntaxNode IfStatement(SyntaxNode condition, IEnumerable<SyntaxNode> trueStatements, SyntaxNode falseStatement)",
            "public abstract SyntaxNode IfStatement(SyntaxNode condition, IEnumerable<SyntaxNode> trueStatements, IEnumerable<SyntaxNode> falseStatements = null)",
            "protected int IndexOf<T>(IReadOnlyList<T> list, T element)",
            "public SyntaxNode IndexerDeclaration(IPropertySymbol indexer, IEnumerable<SyntaxNode> getAccessorStatements = null, IEnumerable<SyntaxNode> setAccessorStatements = null)",
            "public abstract SyntaxNode IndexerDeclaration(IEnumerable<SyntaxNode> parameters, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> getAccessorStatements = null, IEnumerable<SyntaxNode> setAccessorStatements = null)",
            "public abstract SyntaxNode InsertAccessors(SyntaxNode declaration, int index, IEnumerable<SyntaxNode> accessors)",
            "public abstract SyntaxNode InsertAttributeArguments(SyntaxNode attributeDeclaration, int index, IEnumerable<SyntaxNode> attributeArguments)",
            "public abstract SyntaxNode InsertAttributes(SyntaxNode declaration, int index, IEnumerable<SyntaxNode> attributes)",
            "public SyntaxNode InsertAttributes(SyntaxNode declaration, int index, params SyntaxNode[] attributes)",
            "public abstract SyntaxNode InsertMembers(SyntaxNode declaration, int index, IEnumerable<SyntaxNode> members)",
            "public SyntaxNode InsertMembers(SyntaxNode declaration, int index, params SyntaxNode[] members)",
            "public abstract SyntaxNode InsertNamespaceImports(SyntaxNode declaration, int index, IEnumerable<SyntaxNode> imports)",
            "public SyntaxNode InsertNamespaceImports(SyntaxNode declaration, int index, params SyntaxNode[] imports)",
            "public virtual SyntaxNode InsertNodesAfter(SyntaxNode root, SyntaxNode node, IEnumerable<SyntaxNode> newDeclarations)",
            "public virtual SyntaxNode InsertNodesBefore(SyntaxNode root, SyntaxNode node, IEnumerable<SyntaxNode> newDeclarations)",
            "public abstract SyntaxNode InsertParameters(SyntaxNode declaration, int index, IEnumerable<SyntaxNode> parameters)",
            "public abstract SyntaxNode InsertReturnAttributes(SyntaxNode declaration, int index, IEnumerable<SyntaxNode> attributes)",
            "public SyntaxNode InsertReturnAttributes(SyntaxNode declaration, int index, params SyntaxNode[] attributes)",
            "public abstract SyntaxNode InsertSwitchSections(SyntaxNode switchStatement, int index, IEnumerable<SyntaxNode> switchSections)",
            "public abstract SyntaxNode InterfaceDeclaration(string name, IEnumerable<string> typeParameters = null, Accessibility accessibility = NotApplicable, IEnumerable<SyntaxNode> interfaceTypes = null, IEnumerable<SyntaxNode> members = null)",
            "public abstract SyntaxNode InvocationExpression(SyntaxNode expression, IEnumerable<SyntaxNode> arguments)",
            "public SyntaxNode InvocationExpression(SyntaxNode expression, params SyntaxNode[] arguments)",
            "public abstract SyntaxNode IsTypeExpression(SyntaxNode expression, SyntaxNode type)",
            "public SyntaxNode IsTypeExpression(SyntaxNode expression, ITypeSymbol type)",
            "public abstract SyntaxNode LambdaParameter(string identifier, SyntaxNode type = null)",
            "public SyntaxNode LambdaParameter(string identifier, ITypeSymbol type)",
            "public abstract SyntaxNode LessThanExpression(SyntaxNode left, SyntaxNode right)",
            "public abstract SyntaxNode LessThanOrEqualExpression(SyntaxNode left, SyntaxNode right)",
            "public abstract SyntaxNode LiteralExpression(object value)",
            "public SyntaxNode LocalDeclarationStatement(string name, SyntaxNode initializer)",
            "public abstract SyntaxNode LocalDeclarationStatement(SyntaxNode type, string identifier, SyntaxNode initializer = null, bool isConst = false)",
            "public SyntaxNode LocalDeclarationStatement(ITypeSymbol type, string name, SyntaxNode initializer = null, bool isConst = false)",
            "public abstract SyntaxNode LockStatement(SyntaxNode expression, IEnumerable<SyntaxNode> statements)",
            "public abstract SyntaxNode LogicalAndExpression(SyntaxNode left, SyntaxNode right)",
            "public abstract SyntaxNode LogicalNotExpression(SyntaxNode expression)",
            "public abstract SyntaxNode LogicalOrExpression(SyntaxNode left, SyntaxNode right)",
            "public virtual SyntaxNode MemberAccessExpression(SyntaxNode expression, SyntaxNode memberName)",
            "public SyntaxNode MemberAccessExpression(SyntaxNode expression, string memberName)",
            "public SyntaxNode MethodDeclaration(IMethodSymbol method, IEnumerable<SyntaxNode> statements = null)",
            "public abstract SyntaxNode MethodDeclaration(string name, IEnumerable<SyntaxNode> parameters = null, IEnumerable<string> typeParameters = null, SyntaxNode returnType = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> statements = null)",
            "public abstract SyntaxNode ModuloExpression(SyntaxNode left, SyntaxNode right)",
            "public abstract SyntaxNode MultiplyExpression(SyntaxNode left, SyntaxNode right)",
            "public abstract SyntaxNode NameOfExpression(SyntaxNode expression)",
            "public abstract SyntaxNode NamespaceDeclaration(SyntaxNode name, IEnumerable<SyntaxNode> declarations)",
            "public SyntaxNode NamespaceDeclaration(SyntaxNode name, params SyntaxNode[] declarations)",
            "public SyntaxNode NamespaceDeclaration(string name, IEnumerable<SyntaxNode> declarations)",
            "public SyntaxNode NamespaceDeclaration(string name, params SyntaxNode[] declarations)",
            "public abstract SyntaxNode NamespaceImportDeclaration(SyntaxNode name)",
            "public SyntaxNode NamespaceImportDeclaration(string name)",
            "public abstract SyntaxNode NegateExpression(SyntaxNode expression)",
            "public SyntaxNode NullLiteralExpression()",
            "public abstract SyntaxNode NullableTypeExpression(SyntaxNode type)",
            "public abstract SyntaxNode ObjectCreationExpression(SyntaxNode namedType, IEnumerable<SyntaxNode> arguments)",
            "public SyntaxNode ObjectCreationExpression(ITypeSymbol type, IEnumerable<SyntaxNode> arguments)",
            "public SyntaxNode ObjectCreationExpression(SyntaxNode type, params SyntaxNode[] arguments)",
            "public SyntaxNode ObjectCreationExpression(ITypeSymbol type, params SyntaxNode[] arguments)",
            "public SyntaxNode OperatorDeclaration(IMethodSymbol method, IEnumerable<SyntaxNode> statements = null)",
            "public virtual SyntaxNode OperatorDeclaration(OperatorKind kind, IEnumerable<SyntaxNode> parameters = null, SyntaxNode returnType = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> statements = null)",
            "public SyntaxNode ParameterDeclaration(IParameterSymbol symbol, SyntaxNode initializer = null)",
            "public abstract SyntaxNode ParameterDeclaration(string name, SyntaxNode type = null, SyntaxNode initializer = null, RefKind refKind = None)",
            "protected static SyntaxNode PreserveTrivia<TNode>(TNode node, Func<TNode, SyntaxNode> nodeChanger) where TNode : SyntaxNode",
            "public SyntaxNode PropertyDeclaration(IPropertySymbol property, IEnumerable<SyntaxNode> getAccessorStatements = null, IEnumerable<SyntaxNode> setAccessorStatements = null)",
            "public abstract SyntaxNode PropertyDeclaration(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> getAccessorStatements = null, IEnumerable<SyntaxNode> setAccessorStatements = null)",
            "public abstract SyntaxNode QualifiedName(SyntaxNode left, SyntaxNode right)",
            "public abstract SyntaxNode ReferenceEqualsExpression(SyntaxNode left, SyntaxNode right)",
            "public abstract SyntaxNode ReferenceNotEqualsExpression(SyntaxNode left, SyntaxNode right)",
            "public SyntaxNode RemoveAllAttributes(SyntaxNode declaration)",
            "public abstract SyntaxNode RemoveEventHandler(SyntaxNode @event, SyntaxNode handler)",
            "public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode node)",
            "public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode node, SyntaxRemoveOptions options)",
            "public SyntaxNode RemoveNodes(SyntaxNode root, IEnumerable<SyntaxNode> declarations)",
            "protected static SeparatedSyntaxList<TNode> RemoveRange<TNode>(SeparatedSyntaxList<TNode> list, int offset, int count) where TNode : SyntaxNode",
            "protected static SyntaxList<TNode> RemoveRange<TNode>(SyntaxList<TNode> list, int offset, int count) where TNode : SyntaxNode",
            "public virtual SyntaxNode ReplaceNode(SyntaxNode root, SyntaxNode node, SyntaxNode newDeclaration)",
            "protected static SyntaxNode ReplaceRange(SyntaxNode root, SyntaxNode node, IEnumerable<SyntaxNode> replacements)",
            "protected static SyntaxNode ReplaceWithTrivia(SyntaxNode root, SyntaxNode original, SyntaxNode replacement)",
            "protected static SyntaxNode ReplaceWithTrivia(SyntaxNode root, SyntaxToken original, SyntaxToken replacement)",
            "protected static SyntaxNode ReplaceWithTrivia<TNode>(SyntaxNode root, TNode original, Func<TNode, SyntaxNode> replacer) where TNode : SyntaxNode",
            "public abstract SyntaxNode ReturnStatement(SyntaxNode expression = null)",
            "public abstract SyntaxNode StructDeclaration(string name, IEnumerable<string> typeParameters = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> interfaceTypes = null, IEnumerable<SyntaxNode> members = null)",
            "public abstract SyntaxNode SubtractExpression(SyntaxNode left, SyntaxNode right)",
            "public SyntaxNode SwitchSection(SyntaxNode caseExpression, IEnumerable<SyntaxNode> statements)",
            "public abstract SyntaxNode SwitchSection(IEnumerable<SyntaxNode> caseExpressions, IEnumerable<SyntaxNode> statements)",
            "public abstract SyntaxNode SwitchStatement(SyntaxNode expression, IEnumerable<SyntaxNode> sections)",
            "public SyntaxNode SwitchStatement(SyntaxNode expression, params SyntaxNode[] sections)",
            "public abstract SyntaxNode ThisExpression()",
            "public abstract SyntaxNode ThrowExpression(SyntaxNode expression)",
            "public abstract SyntaxNode ThrowStatement(SyntaxNode expression = null)",
            "public SyntaxNode TrueLiteralExpression()",
            "public abstract SyntaxNode TryCastExpression(SyntaxNode expression, SyntaxNode type)",
            "public SyntaxNode TryCastExpression(SyntaxNode expression, ITypeSymbol type)",
            "public SyntaxNode TryCatchStatement(IEnumerable<SyntaxNode> tryStatements, params SyntaxNode[] catchClauses)",
            "public abstract SyntaxNode TryCatchStatement(IEnumerable<SyntaxNode> tryStatements, IEnumerable<SyntaxNode> catchClauses, IEnumerable<SyntaxNode> finallyStatements = null)",
            "public SyntaxNode TryFinallyStatement(IEnumerable<SyntaxNode> tryStatements, IEnumerable<SyntaxNode> finallyStatements)",
            "public abstract SyntaxNode TypeExpression(SpecialType specialType)",
            "public abstract SyntaxNode TypeExpression(ITypeSymbol typeSymbol)",
            "public SyntaxNode TypeExpression(ITypeSymbol typeSymbol, bool addImport)",
            "public abstract SyntaxNode TypeOfExpression(SyntaxNode type)",
            "public abstract SyntaxNode TypedConstantExpression(TypedConstant value)",
            "public abstract SyntaxNode UsingStatement(SyntaxNode expression, IEnumerable<SyntaxNode> statements)",
            "public SyntaxNode UsingStatement(string name, SyntaxNode expression, IEnumerable<SyntaxNode> statements)",
            "public abstract SyntaxNode UsingStatement(SyntaxNode type, string name, SyntaxNode expression, IEnumerable<SyntaxNode> statements)",
            "public abstract SyntaxNode ValueEqualsExpression(SyntaxNode left, SyntaxNode right)",
            "public abstract SyntaxNode ValueNotEqualsExpression(SyntaxNode left, SyntaxNode right)",
            "public SyntaxNode ValueReturningLambdaExpression(SyntaxNode expression)",
            "public SyntaxNode ValueReturningLambdaExpression(IEnumerable<SyntaxNode> statements)",
            "public abstract SyntaxNode ValueReturningLambdaExpression(IEnumerable<SyntaxNode> lambdaParameters, SyntaxNode expression)",
            "public abstract SyntaxNode ValueReturningLambdaExpression(IEnumerable<SyntaxNode> lambdaParameters, IEnumerable<SyntaxNode> statements)",
            "public SyntaxNode ValueReturningLambdaExpression(string parameterName, SyntaxNode expression)",
            "public SyntaxNode ValueReturningLambdaExpression(string parameterName, IEnumerable<SyntaxNode> statements)",
            "public SyntaxNode VoidReturningLambdaExpression(SyntaxNode expression)",
            "public SyntaxNode VoidReturningLambdaExpression(IEnumerable<SyntaxNode> statements)",
            "public abstract SyntaxNode VoidReturningLambdaExpression(IEnumerable<SyntaxNode> lambdaParameters, SyntaxNode expression)",
            "public abstract SyntaxNode VoidReturningLambdaExpression(IEnumerable<SyntaxNode> lambdaParameters, IEnumerable<SyntaxNode> statements)",
            "public SyntaxNode VoidReturningLambdaExpression(string parameterName, SyntaxNode expression)",
            "public SyntaxNode VoidReturningLambdaExpression(string parameterName, IEnumerable<SyntaxNode> statements)",
            "public abstract SyntaxNode WhileStatement(SyntaxNode condition, IEnumerable<SyntaxNode> statements)",
            "public abstract SyntaxNode WithAccessibility(SyntaxNode declaration, Accessibility accessibility)",
            "public abstract SyntaxNode WithExpression(SyntaxNode declaration, SyntaxNode expression)",
            "public abstract SyntaxNode WithGetAccessorStatements(SyntaxNode declaration, IEnumerable<SyntaxNode> statements)",
            "public abstract SyntaxNode WithModifiers(SyntaxNode declaration, DeclarationModifiers modifiers)",
            "public abstract SyntaxNode WithName(SyntaxNode declaration, string name)",
            "public abstract SyntaxNode WithSetAccessorStatements(SyntaxNode declaration, IEnumerable<SyntaxNode> statements)",
            "public abstract SyntaxNode WithStatements(SyntaxNode declaration, IEnumerable<SyntaxNode> statements)",
            "public abstract SyntaxNode WithType(SyntaxNode declaration, SyntaxNode type)",
            "public abstract SyntaxNode WithTypeArguments(SyntaxNode expression, IEnumerable<SyntaxNode> typeArguments)",
            "public SyntaxNode WithTypeArguments(SyntaxNode expression, params SyntaxNode[] typeArguments)",
            "public SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, params SyntaxNode[] types)",
            "public abstract SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, IEnumerable<SyntaxNode> types = null)",
            "public SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, params SyntaxNode[] types)",
            "public abstract SyntaxNode WithTypeParameters(SyntaxNode declaration, IEnumerable<string> typeParameters)",
            "public SyntaxNode WithTypeParameters(SyntaxNode declaration, params string[] typeParameters)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.Emit.EmitBaseline",
          "members": [
            "public ModuleMetadata OriginalMetadata { get; }",
            "public static EmitBaseline CreateInitialBaseline(ModuleMetadata module, Func<MethodDefinitionHandle, EditAndContinueMethodDebugInformation> debugInformationProvider)"
          ]
        },
        {
          "type": "public sealed class Microsoft.CodeAnalysis.Emit.EmitOptions : IEquatable<EmitOptions>",
          "members": [
            "public EmitOptions(bool metadataOnly, DebugInformationFormat debugInformationFormat, string pdbFilePath, string outputNameOverride, int fileAlignment, ulong baseAddress, bool highEntropyVirtualAddressSpace, SubsystemVersion subsystemVersion, string runtimeMetadataVersion, bool tolerateErrors, bool includePrivateMembers)",
            "public EmitOptions(bool metadataOnly = false, DebugInformationFormat debugInformationFormat = (DebugInformationFormat)0, string pdbFilePath = null, string outputNameOverride = null, int fileAlignment = 0, ulong baseAddress = 0, bool highEntropyVirtualAddressSpace = false, SubsystemVersion subsystemVersion = default, string runtimeMetadataVersion = null, bool tolerateErrors = false, bool includePrivateMembers = true, ImmutableArray<InstrumentationKind> instrumentationKinds = default)",
            "public ulong BaseAddress { get; }",
            "public DebugInformationFormat DebugInformationFormat { get; }",
            "public bool EmitMetadataOnly { get; }",
            "public int FileAlignment { get; }",
            "public bool HighEntropyVirtualAddressSpace { get; }",
            "public bool IncludePrivateMembers { get; }",
            "public ImmutableArray<InstrumentationKind> InstrumentationKinds { get; }",
            "public string OutputNameOverride { get; }",
            "public string PdbFilePath { get; }",
            "public string RuntimeMetadataVersion { get; }",
            "public SubsystemVersion SubsystemVersion { get; }",
            "public bool TolerateErrors { get; }",
            "public override bool Equals(object obj)",
            "public bool Equals(EmitOptions other)",
            "public override int GetHashCode()",
            "public EmitOptions WithBaseAddress(ulong value)",
            "public EmitOptions WithDebugInformationFormat(DebugInformationFormat format)",
            "public EmitOptions WithEmitMetadataOnly(bool value)",
            "public EmitOptions WithFileAlignment(int value)",
            "public EmitOptions WithHighEntropyVirtualAddressSpace(bool value)",
            "public EmitOptions WithIncludePrivateMembers(bool value)",
            "public EmitOptions WithInstrumentationKinds(ImmutableArray<InstrumentationKind> instrumentationKinds)",
            "public EmitOptions WithOutputNameOverride(string outputName)",
            "public EmitOptions WithPdbFilePath(string path)",
            "public EmitOptions WithRuntimeMetadataVersion(string version)",
            "public EmitOptions WithSubsystemVersion(SubsystemVersion subsystemVersion)",
            "public EmitOptions WithTolerateErrors(bool value)",
            "public static bool operator ==(EmitOptions left, EmitOptions right)",
            "public static bool operator !=(EmitOptions left, EmitOptions right)"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.Emit.EmitResult",
          "members": [
            "public ImmutableArray<Diagnostic> Diagnostics { get; }",
            "public bool Success { get; }",
            "protected virtual string GetDebuggerDisplay()"
          ],
          "types": [
            {
              "type": "public sealed class Microsoft.CodeAnalysis.Emit.EmitDifferenceResult : EmitResult",
              "members": [
                "public EmitBaseline Baseline { get; }"
              ]
            }
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol",
          "members": [
            "public ISymbol Definition { get; }",
            "public IEnumerable<ReferenceLocation> Locations { get; }"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Host.HostLanguageServices",
          "members": [
            "protected HostLanguageServices()",
            "public abstract string Language { get; }",
            "public abstract HostWorkspaceServices WorkspaceServices { get; }",
            "public TLanguageService GetRequiredService<TLanguageService>() where TLanguageService : ILanguageService",
            "public abstract TLanguageService GetService<TLanguageService>() where TLanguageService : ILanguageService"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Host.HostServices",
          "members": [
            "protected HostServices()",
            "protected internal abstract HostWorkspaceServices CreateWorkspaceServices(Workspace workspace)"
          ],
          "types": [
            {
              "type": "public class Microsoft.CodeAnalysis.Host.Mef.MefHostServices : HostServices, IMefHostExportProvider",
              "members": [
                "public MefHostServices(CompositionContext compositionContext)",
                "public static ImmutableArray<Assembly> DefaultAssemblies { get; }",
                "public static MefHostServices DefaultHost { get; }",
                "public static MefHostServices Create(IEnumerable<Assembly> assemblies)",
                "public static MefHostServices Create(CompositionContext compositionContext)",
                "protected internal override HostWorkspaceServices CreateWorkspaceServices(Workspace workspace)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Host.HostWorkspaceServices",
          "members": [
            "protected HostWorkspaceServices()",
            "public abstract HostServices HostServices { get; }",
            "public virtual IPersistentStorageService PersistentStorage { get; }",
            "public virtual IEnumerable<string> SupportedLanguages { get; }",
            "public virtual ITemporaryStorageService TemporaryStorage { get; }",
            "public abstract Workspace Workspace { get; }",
            "public abstract IEnumerable<TLanguageService> FindLanguageServices<TLanguageService>(HostWorkspaceServices.MetadataFilter filter)",
            "public virtual HostLanguageServices GetLanguageServices(string languageName)",
            "public TWorkspaceService GetRequiredService<TWorkspaceService>() where TWorkspaceService : IWorkspaceService",
            "public abstract TWorkspaceService GetService<TWorkspaceService>() where TWorkspaceService : IWorkspaceService",
            "public virtual bool IsSupported(string languageName)"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.Options.Option<T> : IOption",
          "members": [
            "public Option(string feature, string name)",
            "public Option(string feature, string name, T defaultValue)",
            "public Option(string feature, string name, T defaultValue, params OptionStorageLocation[] storageLocations)",
            "public T DefaultValue { get; }",
            "public string Feature { get; }",
            "public string Name { get; }",
            "public ImmutableArray<OptionStorageLocation> StorageLocations { get; }",
            "public Type Type { get; }",
            "public override string ToString()",
            "public static implicit operator OptionKey(Option<T> option)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Options.OptionSet",
          "members": [
            "protected OptionSet()",
            "public abstract object GetOption(OptionKey optionKey)",
            "public T GetOption<T>(Option<T> option)",
            "public T GetOption<T>(PerLanguageOption<T> option, string language)",
            "public abstract OptionSet WithChangedOption(OptionKey optionAndLanguage, object value)",
            "public OptionSet WithChangedOption<T>(Option<T> option, T value)",
            "public OptionSet WithChangedOption<T>(PerLanguageOption<T> option, string language, T value)"
          ],
          "types": [
            {
              "type": "public sealed class Microsoft.CodeAnalysis.Options.DocumentOptionSet : OptionSet",
              "members": [
                "public override object GetOption(OptionKey optionKey)",
                "public T GetOption<T>(PerLanguageOption<T> option)",
                "public override OptionSet WithChangedOption(OptionKey optionAndLanguage, object value)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Options.OptionStorageLocation",
          "members": [
            "protected OptionStorageLocation()"
          ]
        },
        {
          "type": "public class Microsoft.CodeAnalysis.Options.PerLanguageOption<T> : IOption",
          "members": [
            "public PerLanguageOption(string feature, string name, T defaultValue)",
            "public PerLanguageOption(string feature, string name, T defaultValue, params OptionStorageLocation[] storageLocations)",
            "public T DefaultValue { get; }",
            "public string Feature { get; }",
            "public string Name { get; }",
            "public ImmutableArray<OptionStorageLocation> StorageLocations { get; }",
            "public Type Type { get; }",
            "public override string ToString()"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Semantics.OperationVisitor",
          "members": [
            "protected OperationVisitor()",
            "public virtual void DefaultVisit(IOperation operation)",
            "public virtual void Visit(IOperation operation)",
            "public virtual void VisitAddressOfExpression(IAddressOfExpression operation)",
            "public virtual void VisitArgument(IArgument operation)",
            "public virtual void VisitArrayCreationExpression(IArrayCreationExpression operation)",
            "public virtual void VisitArrayElementReferenceExpression(IArrayElementReferenceExpression operation)",
            "public virtual void VisitArrayInitializer(IArrayInitializer operation)",
            "public virtual void VisitAssignmentExpression(IAssignmentExpression operation)",
            "public virtual void VisitAwaitExpression(IAwaitExpression operation)",
            "public virtual void VisitBinaryOperatorExpression(IBinaryOperatorExpression operation)",
            "public virtual void VisitBlockStatement(IBlockStatement operation)",
            "public virtual void VisitBranchStatement(IBranchStatement operation)",
            "public virtual void VisitCatchClause(ICatchClause operation)",
            "public virtual void VisitCompoundAssignmentExpression(ICompoundAssignmentExpression operation)",
            "public virtual void VisitConditionalAccessExpression(IConditionalAccessExpression operation)",
            "public virtual void VisitConditionalAccessInstanceExpression(IConditionalAccessInstanceExpression operation)",
            "public virtual void VisitConditionalChoiceExpression(IConditionalChoiceExpression operation)",
            "public virtual void VisitConversionExpression(IConversionExpression operation)",
            "public virtual void VisitDefaultValueExpression(IDefaultValueExpression operation)",
            "public virtual void VisitEmptyStatement(IEmptyStatement operation)",
            "public virtual void VisitEndStatement(IEndStatement operation)",
            "public virtual void VisitEventAssignmentExpression(IEventAssignmentExpression operation)",
            "public virtual void VisitEventReferenceExpression(IEventReferenceExpression operation)",
            "public virtual void VisitExpressionStatement(IExpressionStatement operation)",
            "public virtual void VisitFieldInitializer(IFieldInitializer operation)",
            "public virtual void VisitFieldReferenceExpression(IFieldReferenceExpression operation)",
            "public virtual void VisitFixedStatement(IFixedStatement operation)",
            "public virtual void VisitForEachLoopStatement(IForEachLoopStatement operation)",
            "public virtual void VisitForLoopStatement(IForLoopStatement operation)",
            "public virtual void VisitIfStatement(IIfStatement operation)",
            "public virtual void VisitIncrementExpression(IIncrementExpression operation)",
            "public virtual void VisitIndexedPropertyReferenceExpression(IIndexedPropertyReferenceExpression operation)",
            "public virtual void VisitInstanceReferenceExpression(IInstanceReferenceExpression operation)",
            "public virtual void VisitInvalidExpression(IInvalidExpression operation)",
            "public virtual void VisitInvalidStatement(IInvalidStatement operation)",
            "public virtual void VisitInvocationExpression(IInvocationExpression operation)",
            "public virtual void VisitIsTypeExpression(IIsTypeExpression operation)",
            "public virtual void VisitLabelStatement(ILabelStatement operation)",
            "public virtual void VisitLambdaExpression(ILambdaExpression operation)",
            "public virtual void VisitLateBoundMemberReferenceExpression(ILateBoundMemberReferenceExpression operation)",
            "public virtual void VisitLiteralExpression(ILiteralExpression operation)",
            "public virtual void VisitLocalReferenceExpression(ILocalReferenceExpression operation)",
            "public virtual void VisitLockStatement(ILockStatement operation)",
            "public virtual void VisitMethodBindingExpression(IMethodBindingExpression operation)",
            "public virtual void VisitNullCoalescingExpression(INullCoalescingExpression operation)",
            "public virtual void VisitObjectCreationExpression(IObjectCreationExpression operation)",
            "public virtual void VisitOmittedArgumentExpression(IOmittedArgumentExpression operation)",
            "public virtual void VisitParameterInitializer(IParameterInitializer operation)",
            "public virtual void VisitParameterReferenceExpression(IParameterReferenceExpression operation)",
            "public virtual void VisitParenthesizedExpression(IParenthesizedExpression operation)",
            "public virtual void VisitPlaceholderExpression(IPlaceholderExpression operation)",
            "public virtual void VisitPointerIndirectionReferenceExpression(IPointerIndirectionReferenceExpression operation)",
            "public virtual void VisitPropertyInitializer(IPropertyInitializer operation)",
            "public virtual void VisitPropertyReferenceExpression(IPropertyReferenceExpression operation)",
            "public virtual void VisitRangeCaseClause(IRangeCaseClause operation)",
            "public virtual void VisitRelationalCaseClause(IRelationalCaseClause operation)",
            "public virtual void VisitReturnStatement(IReturnStatement operation)",
            "public virtual void VisitSingleValueCaseClause(ISingleValueCaseClause operation)",
            "public virtual void VisitSizeOfExpression(ISizeOfExpression operation)",
            "public virtual void VisitStopStatement(IStopStatement operation)",
            "public virtual void VisitSwitchCase(ISwitchCase operation)",
            "public virtual void VisitSwitchStatement(ISwitchStatement operation)",
            "public virtual void VisitSyntheticLocalReferenceExpression(ISyntheticLocalReferenceExpression operation)",
            "public virtual void VisitThrowStatement(IThrowStatement operation)",
            "public virtual void VisitTryStatement(ITryStatement operation)",
            "public virtual void VisitTypeOfExpression(ITypeOfExpression operation)",
            "public virtual void VisitTypeParameterObjectCreationExpression(ITypeParameterObjectCreationExpression operation)",
            "public virtual void VisitUnaryOperatorExpression(IUnaryOperatorExpression operation)",
            "public virtual void VisitUnboundLambdaExpression(IUnboundLambdaExpression operation)",
            "public virtual void VisitUsingStatement(IUsingStatement operation)",
            "public virtual void VisitVariableDeclaration(IVariableDeclaration operation)",
            "public virtual void VisitVariableDeclarationStatement(IVariableDeclarationStatement operation)",
            "public virtual void VisitWhileUntilLoopStatement(IWhileUntilLoopStatement operation)",
            "public virtual void VisitWithStatement(IWithStatement operation)",
            "public virtual void VisitYieldBreakStatement(IReturnStatement operation)"
          ],
          "types": [
            {
              "type": "public abstract class Microsoft.CodeAnalysis.Semantics.OperationWalker : OperationVisitor",
              "members": [
                "protected OperationWalker()",
                "public override void Visit(IOperation operation)",
                "public override void VisitAddressOfExpression(IAddressOfExpression operation)",
                "public override void VisitArgument(IArgument operation)",
                "public override void VisitArrayCreationExpression(IArrayCreationExpression operation)",
                "public override void VisitArrayElementReferenceExpression(IArrayElementReferenceExpression operation)",
                "public override void VisitArrayInitializer(IArrayInitializer operation)",
                "public override void VisitAssignmentExpression(IAssignmentExpression operation)",
                "public override void VisitAwaitExpression(IAwaitExpression operation)",
                "public override void VisitBinaryOperatorExpression(IBinaryOperatorExpression operation)",
                "public override void VisitBlockStatement(IBlockStatement operation)",
                "public override void VisitBranchStatement(IBranchStatement operation)",
                "public override void VisitCatchClause(ICatchClause operation)",
                "public override void VisitCompoundAssignmentExpression(ICompoundAssignmentExpression operation)",
                "public override void VisitConditionalAccessExpression(IConditionalAccessExpression operation)",
                "public override void VisitConditionalAccessInstanceExpression(IConditionalAccessInstanceExpression operation)",
                "public override void VisitConditionalChoiceExpression(IConditionalChoiceExpression operation)",
                "public override void VisitConversionExpression(IConversionExpression operation)",
                "public override void VisitDefaultValueExpression(IDefaultValueExpression operation)",
                "public override void VisitEmptyStatement(IEmptyStatement operation)",
                "public override void VisitEndStatement(IEndStatement operation)",
                "public override void VisitEventAssignmentExpression(IEventAssignmentExpression operation)",
                "public override void VisitEventReferenceExpression(IEventReferenceExpression operation)",
                "public override void VisitExpressionStatement(IExpressionStatement operation)",
                "public override void VisitFieldInitializer(IFieldInitializer operation)",
                "public override void VisitFieldReferenceExpression(IFieldReferenceExpression operation)",
                "public override void VisitFixedStatement(IFixedStatement operation)",
                "public override void VisitForEachLoopStatement(IForEachLoopStatement operation)",
                "public override void VisitForLoopStatement(IForLoopStatement operation)",
                "public override void VisitIfStatement(IIfStatement operation)",
                "public override void VisitIncrementExpression(IIncrementExpression operation)",
                "public override void VisitIndexedPropertyReferenceExpression(IIndexedPropertyReferenceExpression operation)",
                "public override void VisitInstanceReferenceExpression(IInstanceReferenceExpression operation)",
                "public override void VisitInvalidExpression(IInvalidExpression operation)",
                "public override void VisitInvalidStatement(IInvalidStatement operation)",
                "public override void VisitInvocationExpression(IInvocationExpression operation)",
                "public override void VisitIsTypeExpression(IIsTypeExpression operation)",
                "public override void VisitLabelStatement(ILabelStatement operation)",
                "public override void VisitLambdaExpression(ILambdaExpression operation)",
                "public override void VisitLateBoundMemberReferenceExpression(ILateBoundMemberReferenceExpression operation)",
                "public override void VisitLiteralExpression(ILiteralExpression operation)",
                "public override void VisitLocalReferenceExpression(ILocalReferenceExpression operation)",
                "public override void VisitLockStatement(ILockStatement operation)",
                "public override void VisitMethodBindingExpression(IMethodBindingExpression operation)",
                "public override void VisitNullCoalescingExpression(INullCoalescingExpression operation)",
                "public override void VisitObjectCreationExpression(IObjectCreationExpression operation)",
                "public override void VisitOmittedArgumentExpression(IOmittedArgumentExpression operation)",
                "public override void VisitParameterInitializer(IParameterInitializer operation)",
                "public override void VisitParameterReferenceExpression(IParameterReferenceExpression operation)",
                "public override void VisitParenthesizedExpression(IParenthesizedExpression operation)",
                "public override void VisitPlaceholderExpression(IPlaceholderExpression operation)",
                "public override void VisitPointerIndirectionReferenceExpression(IPointerIndirectionReferenceExpression operation)",
                "public override void VisitPropertyInitializer(IPropertyInitializer operation)",
                "public override void VisitPropertyReferenceExpression(IPropertyReferenceExpression operation)",
                "public override void VisitRangeCaseClause(IRangeCaseClause operation)",
                "public override void VisitRelationalCaseClause(IRelationalCaseClause operation)",
                "public override void VisitReturnStatement(IReturnStatement operation)",
                "public override void VisitSingleValueCaseClause(ISingleValueCaseClause operation)",
                "public override void VisitSizeOfExpression(ISizeOfExpression operation)",
                "public override void VisitStopStatement(IStopStatement operation)",
                "public override void VisitSwitchCase(ISwitchCase operation)",
                "public override void VisitSwitchStatement(ISwitchStatement operation)",
                "public override void VisitSyntheticLocalReferenceExpression(ISyntheticLocalReferenceExpression operation)",
                "public override void VisitThrowStatement(IThrowStatement operation)",
                "public override void VisitTryStatement(ITryStatement operation)",
                "public override void VisitTypeOfExpression(ITypeOfExpression operation)",
                "public override void VisitTypeParameterObjectCreationExpression(ITypeParameterObjectCreationExpression operation)",
                "public override void VisitUnaryOperatorExpression(IUnaryOperatorExpression operation)",
                "public override void VisitUnboundLambdaExpression(IUnboundLambdaExpression operation)",
                "public override void VisitUsingStatement(IUsingStatement operation)",
                "public override void VisitVariableDeclaration(IVariableDeclaration operation)",
                "public override void VisitVariableDeclarationStatement(IVariableDeclarationStatement operation)",
                "public override void VisitWhileUntilLoopStatement(IWhileUntilLoopStatement operation)",
                "public override void VisitWithStatement(IWithStatement operation)",
                "public override void VisitYieldBreakStatement(IReturnStatement operation)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Semantics.OperationVisitor<TArgument, TResult>",
          "members": [
            "protected OperationVisitor()",
            "public virtual TResult DefaultVisit(IOperation operation, TArgument argument)",
            "public virtual TResult Visit(IOperation operation, TArgument argument)",
            "public virtual TResult VisitAddressOfExpression(IAddressOfExpression operation, TArgument argument)",
            "public virtual TResult VisitArgument(IArgument operation, TArgument argument)",
            "public virtual TResult VisitArrayCreationExpression(IArrayCreationExpression operation, TArgument argument)",
            "public virtual TResult VisitArrayElementReferenceExpression(IArrayElementReferenceExpression operation, TArgument argument)",
            "public virtual TResult VisitArrayInitializer(IArrayInitializer operation, TArgument argument)",
            "public virtual TResult VisitAssignmentExpression(IAssignmentExpression operation, TArgument argument)",
            "public virtual TResult VisitAwaitExpression(IAwaitExpression operation, TArgument argument)",
            "public virtual TResult VisitBinaryOperatorExpression(IBinaryOperatorExpression operation, TArgument argument)",
            "public virtual TResult VisitBlockStatement(IBlockStatement operation, TArgument argument)",
            "public virtual TResult VisitBranchStatement(IBranchStatement operation, TArgument argument)",
            "public virtual TResult VisitCatchClause(ICatchClause operation, TArgument argument)",
            "public virtual TResult VisitCompoundAssignmentExpression(ICompoundAssignmentExpression operation, TArgument argument)",
            "public virtual TResult VisitConditionalAccessExpression(IConditionalAccessExpression operation, TArgument argument)",
            "public virtual TResult VisitConditionalAccessInstanceExpression(IConditionalAccessInstanceExpression operation, TArgument argument)",
            "public virtual TResult VisitConditionalChoiceExpression(IConditionalChoiceExpression operation, TArgument argument)",
            "public virtual TResult VisitConversionExpression(IConversionExpression operation, TArgument argument)",
            "public virtual TResult VisitDefaultValueExpression(IDefaultValueExpression operation, TArgument argument)",
            "public virtual TResult VisitEmptyStatement(IEmptyStatement operation, TArgument argument)",
            "public virtual TResult VisitEndStatement(IEndStatement operation, TArgument argument)",
            "public virtual TResult VisitEventAssignmentExpression(IEventAssignmentExpression operation, TArgument argument)",
            "public virtual TResult VisitEventReferenceExpression(IEventReferenceExpression operation, TArgument argument)",
            "public virtual TResult VisitExpressionStatement(IExpressionStatement operation, TArgument argument)",
            "public virtual TResult VisitFieldInitializer(IFieldInitializer operation, TArgument argument)",
            "public virtual TResult VisitFieldReferenceExpression(IFieldReferenceExpression operation, TArgument argument)",
            "public virtual TResult VisitFixedStatement(IFixedStatement operation, TArgument argument)",
            "public virtual TResult VisitForEachLoopStatement(IForEachLoopStatement operation, TArgument argument)",
            "public virtual TResult VisitForLoopStatement(IForLoopStatement operation, TArgument argument)",
            "public virtual TResult VisitIfStatement(IIfStatement operation, TArgument argument)",
            "public virtual TResult VisitIncrementExpression(IIncrementExpression operation, TArgument argument)",
            "public virtual TResult VisitIndexedPropertyReferenceExpression(IIndexedPropertyReferenceExpression operation, TArgument argument)",
            "public virtual TResult VisitInstanceReferenceExpression(IInstanceReferenceExpression operation, TArgument argument)",
            "public virtual TResult VisitInvalidExpression(IInvalidExpression operation, TArgument argument)",
            "public virtual TResult VisitInvalidStatement(IInvalidStatement operation, TArgument argument)",
            "public virtual TResult VisitInvocationExpression(IInvocationExpression operation, TArgument argument)",
            "public virtual TResult VisitIsTypeExpression(IIsTypeExpression operation, TArgument argument)",
            "public virtual TResult VisitLabelStatement(ILabelStatement operation, TArgument argument)",
            "public virtual TResult VisitLambdaExpression(ILambdaExpression operation, TArgument argument)",
            "public virtual TResult VisitLateBoundMemberReferenceExpression(ILateBoundMemberReferenceExpression operation, TArgument argument)",
            "public virtual TResult VisitLiteralExpression(ILiteralExpression operation, TArgument argument)",
            "public virtual TResult VisitLocalReferenceExpression(ILocalReferenceExpression operation, TArgument argument)",
            "public virtual TResult VisitLockStatement(ILockStatement operation, TArgument argument)",
            "public virtual TResult VisitMethodBindingExpression(IMethodBindingExpression operation, TArgument argument)",
            "public virtual TResult VisitNullCoalescingExpression(INullCoalescingExpression operation, TArgument argument)",
            "public virtual TResult VisitObjectCreationExpression(IObjectCreationExpression operation, TArgument argument)",
            "public virtual TResult VisitOmittedArgumentExpression(IOmittedArgumentExpression operation, TArgument argument)",
            "public virtual TResult VisitParameterInitializer(IParameterInitializer operation, TArgument argument)",
            "public virtual TResult VisitParameterReferenceExpression(IParameterReferenceExpression operation, TArgument argument)",
            "public virtual TResult VisitParenthesizedExpression(IParenthesizedExpression operation, TArgument argument)",
            "public virtual TResult VisitPlaceholderExpression(IPlaceholderExpression operation, TArgument argument)",
            "public virtual TResult VisitPointerIndirectionReferenceExpression(IPointerIndirectionReferenceExpression operation, TArgument argument)",
            "public virtual TResult VisitPropertyInitializer(IPropertyInitializer operation, TArgument argument)",
            "public virtual TResult VisitPropertyReferenceExpression(IPropertyReferenceExpression operation, TArgument argument)",
            "public virtual TResult VisitRangeCaseClause(IRangeCaseClause operation, TArgument argument)",
            "public virtual TResult VisitRelationalCaseClause(IRelationalCaseClause operation, TArgument argument)",
            "public virtual TResult VisitReturnStatement(IReturnStatement operation, TArgument argument)",
            "public virtual TResult VisitSingleValueCaseClause(ISingleValueCaseClause operation, TArgument argument)",
            "public virtual TResult VisitSizeOfExpression(ISizeOfExpression operation, TArgument argument)",
            "public virtual TResult VisitStopStatement(IStopStatement operation, TArgument argument)",
            "public virtual TResult VisitSwitchCase(ISwitchCase operation, TArgument argument)",
            "public virtual TResult VisitSwitchStatement(ISwitchStatement operation, TArgument argument)",
            "public virtual TResult VisitSyntheticLocalReferenceExpression(ISyntheticLocalReferenceExpression operation, TArgument argument)",
            "public virtual TResult VisitThrowStatement(IThrowStatement operation, TArgument argument)",
            "public virtual TResult VisitTryStatement(ITryStatement operation, TArgument argument)",
            "public virtual TResult VisitTypeOfExpression(ITypeOfExpression operation, TArgument argument)",
            "public virtual TResult VisitTypeParameterObjectCreationExpression(ITypeParameterObjectCreationExpression operation, TArgument argument)",
            "public virtual TResult VisitUnaryOperatorExpression(IUnaryOperatorExpression operation, TArgument argument)",
            "public virtual TResult VisitUnboundLambdaExpression(IUnboundLambdaExpression operation, TArgument argument)",
            "public virtual TResult VisitUsingStatement(IUsingStatement operation, TArgument argument)",
            "public virtual TResult VisitVariableDeclaration(IVariableDeclaration operation, TArgument argument)",
            "public virtual TResult VisitVariableDeclarationStatement(IVariableDeclarationStatement operation, TArgument argument)",
            "public virtual TResult VisitWhileUntilLoopStatement(IWhileUntilLoopStatement operation, TArgument argument)",
            "public virtual TResult VisitWithStatement(IWithStatement operation, TArgument argument)",
            "public virtual TResult VisitYieldBreakStatement(IReturnStatement operation, TArgument argument)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Text.SourceText",
          "members": [
            "protected SourceText(ImmutableArray<byte> checksum = default, SourceHashAlgorithm checksumAlgorithm = Sha1, SourceTextContainer container = null)",
            "public bool CanBeEmbedded { get; }",
            "public SourceHashAlgorithm ChecksumAlgorithm { get; }",
            "public virtual SourceTextContainer Container { get; }",
            "public abstract Encoding Encoding { get; }",
            "public abstract int Length { get; }",
            "public TextLineCollection Lines { get; }",
            "public abstract char this[int position] { get; }",
            "public bool ContentEquals(SourceText other)",
            "protected virtual bool ContentEqualsImpl(SourceText other)",
            "public abstract void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count)",
            "public static SourceText From(string text, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1)",
            "public static SourceText From(TextReader reader, int length, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1)",
            "public static SourceText From(Stream stream, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected)",
            "public static SourceText From(byte[] buffer, int length, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected)",
            "public static SourceText From(Stream stream, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1, bool throwIfBinaryDetected = false, bool canBeEmbedded = false)",
            "public static SourceText From(byte[] buffer, int length, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1, bool throwIfBinaryDetected = false, bool canBeEmbedded = false)",
            "public virtual IReadOnlyList<TextChangeRange> GetChangeRanges(SourceText oldText)",
            "public ImmutableArray<byte> GetChecksum()",
            "protected virtual TextLineCollection GetLinesCore()",
            "public virtual SourceText GetSubText(TextSpan span)",
            "public SourceText GetSubText(int start)",
            "public virtual IReadOnlyList<TextChange> GetTextChanges(SourceText oldText)",
            "public SourceText Replace(TextSpan span, string newText)",
            "public SourceText Replace(int start, int length, string newText)",
            "public override string ToString()",
            "public virtual string ToString(TextSpan span)",
            "public virtual SourceText WithChanges(IEnumerable<TextChange> changes)",
            "public SourceText WithChanges(params TextChange[] changes)",
            "public void Write(TextWriter textWriter, CancellationToken cancellationToken = default)",
            "public virtual void Write(TextWriter writer, TextSpan span, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Text.SourceTextContainer",
          "members": [
            "protected SourceTextContainer()",
            "public abstract event EventHandler<TextChangeEventArgs> TextChanged",
            "public abstract SourceText CurrentText { get; }"
          ]
        },
        {
          "type": "public abstract class Microsoft.CodeAnalysis.Text.TextLineCollection : IEnumerable<TextLine>, IReadOnlyCollection<TextLine>, IReadOnlyList<TextLine>",
          "members": [
            "protected TextLineCollection()",
            "public abstract int Count { get; }",
            "public abstract TextLine this[int index] { get; }",
            "public TextLineCollection.Enumerator GetEnumerator()",
            "public virtual TextLine GetLineFromPosition(int position)",
            "public virtual LinePosition GetLinePosition(int position)",
            "public LinePositionSpan GetLinePositionSpan(TextSpan span)",
            "public int GetPosition(LinePosition position)",
            "public TextSpan GetTextSpan(LinePositionSpan span)",
            "public abstract int IndexOf(int position)"
          ]
        },
        {
          "type": "public abstract class Roslynator.NameGenerator",
          "members": [
            "protected NameGenerator()",
            "public static NameGenerator Default { get; }",
            "public static string CreateName(ITypeSymbol typeSymbol, bool firstCharToLower = false)",
            "public string EnsureUniqueEnumMemberName(string baseName, INamedTypeSymbol enumType, bool isCaseSensitive = true)",
            "public string EnsureUniqueLocalName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true, CancellationToken cancellationToken = default)",
            "public string EnsureUniqueMemberName(string baseName, INamedTypeSymbol typeSymbol, bool isCaseSensitive = true)",
            "public string EnsureUniqueMemberName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true, CancellationToken cancellationToken = default)",
            "public abstract string EnsureUniqueName(string baseName, IEnumerable<string> reservedNames, bool isCaseSensitive = true)",
            "public abstract string EnsureUniqueName(string baseName, ImmutableArray<ISymbol> symbols, bool isCaseSensitive = true)",
            "public string EnsureUniqueName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true)",
            "public static bool IsUniqueName(string name, IEnumerable<string> reservedNames, bool isCaseSensitive = true)",
            "public static bool IsUniqueName(string name, ImmutableArray<ISymbol> symbols, bool isCaseSensitive = true)"
          ]
        },
        {
          "type": "public class Roslynator.SeparatedSyntaxListSelection<TNode> : ISelection<TNode> where TNode : SyntaxNode",
          "members": [
            "protected SeparatedSyntaxListSelection(SeparatedSyntaxList<TNode> list, TextSpan span, int firstIndex, int lastIndex)",
            "public int Count { get; }",
            "public int FirstIndex { get; }",
            "public int LastIndex { get; }",
            "public TextSpan OriginalSpan { get; }",
            "public SeparatedSyntaxList<TNode> UnderlyingList { get; }",
            "public TNode this[int index] { get; }",
            "public static SeparatedSyntaxListSelection<TNode> Create(SeparatedSyntaxList<TNode> list, TextSpan span)",
            "public TNode First()",
            "public SeparatedSyntaxListSelection<TNode>.Enumerator GetEnumerator()",
            "public TNode Last()",
            "public static bool TryCreate(SeparatedSyntaxList<TNode> list, TextSpan span, out SeparatedSyntaxListSelection<TNode> selection)"
          ]
        },
        {
          "type": "public class Roslynator.SyntaxListSelection<TNode> : ISelection<TNode> where TNode : SyntaxNode",
          "members": [
            "protected SyntaxListSelection(SyntaxList<TNode> list, TextSpan span, int firstIndex, int lastIndex)",
            "public int Count { get; }",
            "public int FirstIndex { get; }",
            "public int LastIndex { get; }",
            "public TextSpan OriginalSpan { get; }",
            "public SyntaxList<TNode> UnderlyingList { get; }",
            "public TNode this[int index] { get; }",
            "public static SyntaxListSelection<TNode> Create(SyntaxList<TNode> list, TextSpan span)",
            "public TNode First()",
            "public SyntaxListSelection<TNode>.Enumerator GetEnumerator()",
            "public TNode Last()",
            "public static bool TryCreate(SyntaxList<TNode> list, TextSpan span, out SyntaxListSelection<TNode> selection)"
          ],
          "types": [
            {
              "type": "public sealed class Roslynator.CSharp.MemberDeclarationListSelection : SyntaxListSelection<MemberDeclarationSyntax>",
              "members": [
                "public SyntaxNode Parent { get; }",
                "public static MemberDeclarationListSelection Create(CompilationUnitSyntax compilationUnit, TextSpan span)",
                "public static MemberDeclarationListSelection Create(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span)",
                "public static MemberDeclarationListSelection Create(TypeDeclarationSyntax typeDeclaration, TextSpan span)",
                "public static bool TryCreate(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span, out MemberDeclarationListSelection selectedMembers)",
                "public static bool TryCreate(TypeDeclarationSyntax typeDeclaration, TextSpan span, out MemberDeclarationListSelection selectedMembers)"
              ]
            },
            {
              "type": "public sealed class Roslynator.CSharp.StatementListSelection : SyntaxListSelection<StatementSyntax>",
              "members": [
                "public static StatementListSelection Create(BlockSyntax block, TextSpan span)",
                "public static StatementListSelection Create(SwitchSectionSyntax switchSection, TextSpan span)",
                "public static StatementListSelection Create(in StatementListInfo statementsInfo, TextSpan span)",
                "public static bool TryCreate(BlockSyntax block, TextSpan span, out StatementListSelection selectedStatements)",
                "public static bool TryCreate(SwitchSectionSyntax switchSection, TextSpan span, out StatementListSelection selectedStatements)"
              ]
            }
          ]
        },
        {
          "type": "public abstract class Roslynator.CSharp.ModifierList<TNode> where TNode : SyntaxNode",
          "members": [
            "public static ModifierList<TNode> Instance { get; }",
            "public TNode Insert(TNode node, SyntaxKind kind, IComparer<SyntaxKind> comparer = null)",
            "public TNode Insert(TNode node, SyntaxToken modifier, IComparer<SyntaxToken> comparer = null)",
            "public TNode Remove(TNode node, SyntaxKind kind)",
            "public TNode Remove(TNode node, SyntaxToken modifier)",
            "public TNode RemoveAll(TNode node)",
            "public TNode RemoveAll(TNode node, Func<SyntaxToken, bool> predicate)",
            "public TNode RemoveAt(TNode node, int index)"
          ]
        },
        {
          "type": "public class Roslynator.Text.TextLineCollectionSelection : ISelection<TextLine>",
          "members": [
            "protected TextLineCollectionSelection(TextLineCollection lines, TextSpan span, int firstIndex, int lastIndex)",
            "public int Count { get; }",
            "public int FirstIndex { get; }",
            "public int LastIndex { get; }",
            "public TextSpan OriginalSpan { get; }",
            "public TextLineCollection UnderlyingLines { get; }",
            "public TextLine this[int index] { get; }",
            "public static TextLineCollectionSelection Create(TextLineCollection lines, TextSpan span)",
            "public TextLine First()",
            "public TextLineCollectionSelection.Enumerator GetEnumerator()",
            "public TextLine Last()",
            "public static bool TryCreate(TextLineCollection lines, TextSpan span, out TextLineCollectionSelection selectedLines)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.AnnotationExtensions",
          "members": [
            "public static TNode WithAdditionalAnnotations<TNode>(this TNode node, params SyntaxAnnotation[] annotations) where TNode : SyntaxNode",
            "public static TNode WithAdditionalAnnotations<TNode>(this TNode node, IEnumerable<SyntaxAnnotation> annotations) where TNode : SyntaxNode",
            "public static TNode WithoutAnnotations<TNode>(this TNode node, string annotationKind) where TNode : SyntaxNode",
            "public static TNode WithoutAnnotations<TNode>(this TNode node, params SyntaxAnnotation[] annotations) where TNode : SyntaxNode",
            "public static TNode WithoutAnnotations<TNode>(this TNode node, IEnumerable<SyntaxAnnotation> annotations) where TNode : SyntaxNode"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.CSharpExtensions",
          "members": [
            "public static bool Any(this SyntaxTriviaList list, SyntaxKind kind)",
            "public static bool Any(this SyntaxTokenList list, SyntaxKind kind)",
            "public static bool Any<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode",
            "public static bool Any<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode",
            "public static int IndexOf(this SyntaxTriviaList list, SyntaxKind kind)",
            "public static int IndexOf(this SyntaxTokenList list, SyntaxKind kind)",
            "public static int IndexOf<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode",
            "public static int IndexOf<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode",
            "public static bool IsKind(this SyntaxNode node, SyntaxKind kind)",
            "public static bool IsKind(this SyntaxNodeOrToken nodeOrToken, SyntaxKind kind)",
            "public static bool IsKind(this SyntaxToken token, SyntaxKind kind)",
            "public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.CaseInsensitiveComparison",
          "members": [
            "public static StringComparer Comparer { get; }",
            "public static int Compare(string left, string right)",
            "public static bool EndsWith(string value, string possibleEnd)",
            "public static bool Equals(string left, string right)",
            "public static int GetHashCode(string value)",
            "public static bool StartsWith(string value, string possibleStart)",
            "public static void ToLower(StringBuilder builder)",
            "public static char ToLower(char c)",
            "public static string ToLower(string value)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.DocumentationCommentId",
          "members": [
            "public static string CreateDeclarationId(ISymbol symbol)",
            "public static string CreateReferenceId(ISymbol symbol)",
            "public static ISymbol GetFirstSymbolForDeclarationId(string id, Compilation compilation)",
            "public static ISymbol GetFirstSymbolForReferenceId(string id, Compilation compilation)",
            "public static ImmutableArray<ISymbol> GetSymbolsForDeclarationId(string id, Compilation compilation)",
            "public static ImmutableArray<ISymbol> GetSymbolsForReferenceId(string id, Compilation compilation)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.FileSystemExtensions",
          "members": [
            "public static EmitResult Emit(this Compilation compilation, string outputPath, string pdbPath = null, string xmlDocPath = null, string win32ResourcesPath = null, IEnumerable<ResourceDescription> manifestResources = null, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.ISymbolExtensions",
          "members": [
            "public static IMethodSymbol GetConstructedReducedFrom(this IMethodSymbol method)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.LanguageNames",
          "members": [
            "public const string CSharp = \"C#\"",
            "public const string FSharp = \"F#\"",
            "public const string VisualBasic = \"Visual Basic\""
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.ModelExtensions",
          "members": [
            "public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, SyntaxNode statement)",
            "public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement)",
            "public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, SyntaxNode statementOrExpression)",
            "public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement)",
            "public static IAliasSymbol GetAliasInfo(this SemanticModel semanticModel, SyntaxNode nameSyntax, CancellationToken cancellationToken = default)",
            "public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, SyntaxNode declaration, CancellationToken cancellationToken = default)",
            "public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default)",
            "public static IAliasSymbol GetSpeculativeAliasInfo(this SemanticModel semanticModel, int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption)",
            "public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, SyntaxNode expression, SpeculativeBindingOption bindingOption)",
            "public static TypeInfo GetSpeculativeTypeInfo(this SemanticModel semanticModel, int position, SyntaxNode expression, SpeculativeBindingOption bindingOption)",
            "public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default)",
            "public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.SymbolDisplayExtensions",
          "members": [
            "public static string ToDisplayString(this ImmutableArray<SymbolDisplayPart> parts)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.SyntaxNodeExtensions",
          "members": [
            "public static TNode GetCurrentNode<TNode>(this SyntaxNode root, TNode node) where TNode : SyntaxNode",
            "public static IEnumerable<TNode> GetCurrentNodes<TNode>(this SyntaxNode root, TNode node) where TNode : SyntaxNode",
            "public static IEnumerable<TNode> GetCurrentNodes<TNode>(this SyntaxNode root, IEnumerable<TNode> nodes) where TNode : SyntaxNode",
            "public static TRoot InsertNodesAfter<TRoot>(this TRoot root, SyntaxNode nodeInList, IEnumerable<SyntaxNode> newNodes) where TRoot : SyntaxNode",
            "public static TRoot InsertNodesBefore<TRoot>(this TRoot root, SyntaxNode nodeInList, IEnumerable<SyntaxNode> newNodes) where TRoot : SyntaxNode",
            "public static TRoot InsertTokensAfter<TRoot>(this TRoot root, SyntaxToken tokenInList, IEnumerable<SyntaxToken> newTokens) where TRoot : SyntaxNode",
            "public static TRoot InsertTokensBefore<TRoot>(this TRoot root, SyntaxToken tokenInList, IEnumerable<SyntaxToken> newTokens) where TRoot : SyntaxNode",
            "public static TRoot InsertTriviaAfter<TRoot>(this TRoot root, SyntaxTrivia trivia, IEnumerable<SyntaxTrivia> newTrivia) where TRoot : SyntaxNode",
            "public static TRoot InsertTriviaBefore<TRoot>(this TRoot root, SyntaxTrivia trivia, IEnumerable<SyntaxTrivia> newTrivia) where TRoot : SyntaxNode",
            "public static TNode NormalizeWhitespace<TNode>(this TNode node, string indentation, bool elasticTrivia) where TNode : SyntaxNode",
            "public static TNode NormalizeWhitespace<TNode>(this TNode node, string indentation = \"    \", string eol = \"\\r\\n\", bool elasticTrivia = false) where TNode : SyntaxNode",
            "public static TRoot RemoveNode<TRoot>(this TRoot root, SyntaxNode node, SyntaxRemoveOptions options) where TRoot : SyntaxNode",
            "public static TRoot RemoveNodes<TRoot>(this TRoot root, IEnumerable<SyntaxNode> nodes, SyntaxRemoveOptions options) where TRoot : SyntaxNode",
            "public static TRoot ReplaceNode<TRoot>(this TRoot root, SyntaxNode oldNode, SyntaxNode newNode) where TRoot : SyntaxNode",
            "public static TRoot ReplaceNode<TRoot>(this TRoot root, SyntaxNode oldNode, IEnumerable<SyntaxNode> newNodes) where TRoot : SyntaxNode",
            "public static TRoot ReplaceNodes<TRoot, TNode>(this TRoot root, IEnumerable<TNode> nodes, Func<TNode, TNode, SyntaxNode> computeReplacementNode) where TRoot : SyntaxNode where TNode : SyntaxNode",
            "public static TRoot ReplaceSyntax<TRoot>(this TRoot root, IEnumerable<SyntaxNode> nodes, Func<SyntaxNode, SyntaxNode, SyntaxNode> computeReplacementNode, IEnumerable<SyntaxToken> tokens, Func<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia) where TRoot : SyntaxNode",
            "public static TRoot ReplaceToken<TRoot>(this TRoot root, SyntaxToken oldToken, SyntaxToken newToken) where TRoot : SyntaxNode",
            "public static TRoot ReplaceToken<TRoot>(this TRoot root, SyntaxToken tokenInList, IEnumerable<SyntaxToken> newTokens) where TRoot : SyntaxNode",
            "public static TRoot ReplaceTokens<TRoot>(this TRoot root, IEnumerable<SyntaxToken> tokens, Func<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken) where TRoot : SyntaxNode",
            "public static TRoot ReplaceTrivia<TRoot>(this TRoot root, SyntaxTrivia oldTrivia, IEnumerable<SyntaxTrivia> newTrivia) where TRoot : SyntaxNode",
            "public static TRoot ReplaceTrivia<TRoot>(this TRoot root, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia) where TRoot : SyntaxNode",
            "public static TRoot ReplaceTrivia<TRoot>(this TRoot root, SyntaxTrivia trivia, SyntaxTrivia newTrivia) where TRoot : SyntaxNode",
            "public static TRoot TrackNodes<TRoot>(this TRoot root, IEnumerable<SyntaxNode> nodes) where TRoot : SyntaxNode",
            "public static TRoot TrackNodes<TRoot>(this TRoot root, params SyntaxNode[] nodes) where TRoot : SyntaxNode",
            "public static TSyntax WithLeadingTrivia<TSyntax>(this TSyntax node, SyntaxTriviaList trivia) where TSyntax : SyntaxNode",
            "public static TSyntax WithLeadingTrivia<TSyntax>(this TSyntax node, IEnumerable<SyntaxTrivia> trivia) where TSyntax : SyntaxNode",
            "public static TSyntax WithLeadingTrivia<TSyntax>(this TSyntax node, params SyntaxTrivia[] trivia) where TSyntax : SyntaxNode",
            "public static TSyntax WithTrailingTrivia<TSyntax>(this TSyntax node, SyntaxTriviaList trivia) where TSyntax : SyntaxNode",
            "public static TSyntax WithTrailingTrivia<TSyntax>(this TSyntax node, IEnumerable<SyntaxTrivia> trivia) where TSyntax : SyntaxNode",
            "public static TSyntax WithTrailingTrivia<TSyntax>(this TSyntax node, params SyntaxTrivia[] trivia) where TSyntax : SyntaxNode",
            "public static TSyntax WithTriviaFrom<TSyntax>(this TSyntax syntax, SyntaxNode node) where TSyntax : SyntaxNode",
            "public static TSyntax WithoutLeadingTrivia<TSyntax>(this TSyntax node) where TSyntax : SyntaxNode",
            "public static TSyntax WithoutTrailingTrivia<TSyntax>(this TSyntax node) where TSyntax : SyntaxNode",
            "public static SyntaxToken WithoutTrivia(this SyntaxToken token)",
            "public static TSyntax WithoutTrivia<TSyntax>(this TSyntax syntax) where TSyntax : SyntaxNode"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.WellKnownDiagnosticTags",
          "members": [
            "public const string AnalyzerException = \"AnalyzerException\"",
            "public const string Build = \"Build\"",
            "public const string Compiler = \"Compiler\"",
            "public const string EditAndContinue = \"EditAndContinue\"",
            "public const string NotConfigurable = \"NotConfigurable\"",
            "public const string Telemetry = \"Telemetry\"",
            "public const string Unnecessary = \"Unnecessary\""
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.WellKnownMemberNames",
          "members": [
            "public const string AdditionOperatorName = \"op_Addition\"",
            "public const string BitwiseAndOperatorName = \"op_BitwiseAnd\"",
            "public const string BitwiseOrOperatorName = \"op_BitwiseOr\"",
            "public const string CollectionInitializerAddMethodName = \"Add\"",
            "public const string ConcatenateOperatorName = \"op_Concatenate\"",
            "public const string CurrentPropertyName = \"Current\"",
            "public const string DecrementOperatorName = \"op_Decrement\"",
            "public const string DefaultScriptClassName = \"Script\"",
            "public const string DelegateBeginInvokeName = \"BeginInvoke\"",
            "public const string DelegateEndInvokeName = \"EndInvoke\"",
            "public const string DelegateInvokeName = \"Invoke\"",
            "public const string DestructorName = \"Finalize\"",
            "public const string DivisionOperatorName = \"op_Division\"",
            "public const string EntryPointMethodName = \"Main\"",
            "public const string EnumBackingFieldName = \"value__\"",
            "public const string EqualityOperatorName = \"op_Equality\"",
            "public const string ExclusiveOrOperatorName = \"op_ExclusiveOr\"",
            "public const string ExplicitConversionName = \"op_Explicit\"",
            "public const string ExponentOperatorName = \"op_Exponent\"",
            "public const string FalseOperatorName = \"op_False\"",
            "public const string GetAwaiter = \"GetAwaiter\"",
            "public const string GetEnumeratorMethodName = \"GetEnumerator\"",
            "public const string GetResult = \"GetResult\"",
            "public const string GreaterThanOperatorName = \"op_GreaterThan\"",
            "public const string GreaterThanOrEqualOperatorName = \"op_GreaterThanOrEqual\"",
            "public const string ImplicitConversionName = \"op_Implicit\"",
            "public const string IncrementOperatorName = \"op_Increment\"",
            "public const string Indexer = \"this[]\"",
            "public const string InequalityOperatorName = \"op_Inequality\"",
            "public const string InstanceConstructorName = \".ctor\"",
            "public const string IntegerDivisionOperatorName = \"op_IntegerDivision\"",
            "public const string IsCompleted = \"IsCompleted\"",
            "public const string LeftShiftOperatorName = \"op_LeftShift\"",
            "public const string LessThanOperatorName = \"op_LessThan\"",
            "public const string LessThanOrEqualOperatorName = \"op_LessThanOrEqual\"",
            "public const string LikeOperatorName = \"op_Like\"",
            "public const string LogicalAndOperatorName = \"op_LogicalAnd\"",
            "public const string LogicalNotOperatorName = \"op_LogicalNot\"",
            "public const string LogicalOrOperatorName = \"op_LogicalOr\"",
            "public const string ModulusOperatorName = \"op_Modulus\"",
            "public const string MoveNextMethodName = \"MoveNext\"",
            "public const string MultiplyOperatorName = \"op_Multiply\"",
            "public const string ObjectEquals = \"Equals\"",
            "public const string ObjectGetHashCode = \"GetHashCode\"",
            "public const string ObjectToString = \"ToString\"",
            "public const string OnCompleted = \"OnCompleted\"",
            "public const string OnesComplementOperatorName = \"op_OnesComplement\"",
            "public const string RightShiftOperatorName = \"op_RightShift\"",
            "public const string StaticConstructorName = \".cctor\"",
            "public const string SubtractionOperatorName = \"op_Subtraction\"",
            "public const string TrueOperatorName = \"op_True\"",
            "public const string UnaryNegationOperatorName = \"op_UnaryNegation\"",
            "public const string UnaryPlusOperatorName = \"op_UnaryPlus\"",
            "public const string UnsignedLeftShiftOperatorName = \"op_UnsignedLeftShift\"",
            "public const string UnsignedRightShiftOperatorName = \"op_UnsignedRightShift\"",
            "public const string ValuePropertyName = \"Value\""
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.WorkspaceKind",
          "members": [
            "public const string Debugger = \"Debugger\"",
            "public const string Host = \"Host\"",
            "public const string Interactive = \"Interactive\"",
            "public const string MetadataAsSource = \"MetadataAsSource\"",
            "public const string MiscellaneousFiles = \"MiscellaneousFiles\"",
            "public const string Preview = \"Preview\""
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.CSharp.CSharpExtensions",
          "members": [
            "public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax statement)",
            "public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)",
            "public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, ExpressionSyntax expression)",
            "public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax statement)",
            "public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)",
            "public static Conversion ClassifyConversion(this Compilation compilation, ITypeSymbol source, ITypeSymbol destination)",
            "public static Conversion ClassifyConversion(this SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)",
            "public static Conversion ClassifyConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)",
            "public static IAliasSymbol GetAliasInfo(this SemanticModel semanticModel, IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken = default)",
            "public static AwaitExpressionInfo GetAwaitExpressionInfo(this SemanticModel semanticModel, AwaitExpressionSyntax awaitExpression)",
            "public static SymbolInfo GetCollectionInitializerSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)",
            "public static CompilationUnitSyntax GetCompilationUnitRoot(this SyntaxTree tree, CancellationToken cancellationToken = default)",
            "public static Optional<object> GetConstantValue(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)",
            "public static Conversion GetConversion(this SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken = default)",
            "public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, CatchDeclarationSyntax catchDeclaration, CancellationToken cancellationToken = default)",
            "public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static INamespaceSymbol GetDeclaredSymbol(this SemanticModel semanticModel, NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static IFieldSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static IEventSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, TupleElementSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static IParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ParameterSyntax declarationSyntax, CancellationToken cancellationToken = default)",
            "public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken = default)",
            "public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = default)",
            "public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, TupleExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = default)",
            "public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, ArgumentSyntax declaratorSyntax, CancellationToken cancellationToken = default)",
            "public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, SingleVariableDesignationSyntax designationSyntax, CancellationToken cancellationToken = default)",
            "public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, CancellationToken cancellationToken = default)",
            "public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, JoinIntoClauseSyntax node, CancellationToken cancellationToken = default)",
            "public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryContinuationSyntax node, CancellationToken cancellationToken = default)",
            "public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryClauseSyntax queryClause, CancellationToken cancellationToken = default)",
            "public static ITypeParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, TypeParameterSyntax typeParameter, CancellationToken cancellationToken = default)",
            "public static DirectiveTriviaSyntax GetFirstDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)",
            "public static ForEachStatementInfo GetForEachStatementInfo(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement)",
            "public static ForEachStatementInfo GetForEachStatementInfo(this SemanticModel semanticModel, CommonForEachStatementSyntax forEachStatement)",
            "public static ImmutableArray<IPropertySymbol> GetIndexerGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)",
            "public static DirectiveTriviaSyntax GetLastDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)",
            "public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default)",
            "public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)",
            "public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ConstructorInitializerSyntax initializer, CancellationToken cancellationToken = default)",
            "public static QueryClauseInfo GetQueryClauseInfo(this SemanticModel semanticModel, QueryClauseSyntax node, CancellationToken cancellationToken = default)",
            "public static IAliasSymbol GetSpeculativeAliasInfo(this SemanticModel semanticModel, int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption)",
            "public static Conversion GetSpeculativeConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)",
            "public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, AttributeSyntax attribute)",
            "public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer)",
            "public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)",
            "public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, CrefSyntax expression, SpeculativeBindingOption bindingOption)",
            "public static TypeInfo GetSpeculativeTypeInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)",
            "public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default)",
            "public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default)",
            "public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, CrefSyntax crefSyntax, CancellationToken cancellationToken = default)",
            "public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)",
            "public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, OrderingSyntax node, CancellationToken cancellationToken = default)",
            "public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default)",
            "public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default)",
            "public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default)",
            "public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)",
            "public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default)",
            "public static SyntaxTokenList Insert(this SyntaxTokenList list, int index, params SyntaxToken[] items)",
            "public static bool IsContextualKeyword(this SyntaxToken token)",
            "public static bool IsKeyword(this SyntaxToken token)",
            "public static bool IsReservedKeyword(this SyntaxToken token)",
            "public static bool IsVerbatimIdentifier(this SyntaxToken token)",
            "public static bool IsVerbatimStringLiteral(this SyntaxToken token)",
            "public static SyntaxKind Kind(this SyntaxNode node)",
            "public static SyntaxKind Kind(this SyntaxNodeOrToken nodeOrToken)",
            "public static SyntaxKind Kind(this SyntaxToken token)",
            "public static SyntaxKind Kind(this SyntaxTrivia trivia)",
            "public static SyntaxToken ReplaceTrivia(this SyntaxToken token, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia)",
            "public static SyntaxToken ReplaceTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia)",
            "public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, AttributeSyntax attribute, out SemanticModel speculativeModel)",
            "public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer, out SemanticModel speculativeModel)",
            "public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, CrefSyntax crefSyntax, out SemanticModel speculativeModel)",
            "public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ArrowExpressionClauseSyntax expressionBody, out SemanticModel speculativeModel)",
            "public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, EqualsValueClauseSyntax initializer, out SemanticModel speculativeModel)",
            "public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, StatementSyntax statement, out SemanticModel speculativeModel)",
            "public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, TypeSyntax type, out SemanticModel speculativeModel, SpeculativeBindingOption bindingOption = BindAsExpression)",
            "public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, AccessorDeclarationSyntax accessor, out SemanticModel speculativeModel)",
            "public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, BaseMethodDeclarationSyntax method, out SemanticModel speculativeModel)",
            "public static VarianceKind VarianceKindFromToken(this SyntaxToken node)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.CSharp.CSharpFileSystemExtensions",
          "members": [
            "public static EmitResult Emit(this CSharpCompilation compilation, string outputPath, string pdbPath = null, string xmlDocumentationPath = null, string win32ResourcesPath = null, IEnumerable<ResourceDescription> manifestResources = null, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts",
          "members": [
            "public static LanguageVersion MapSpecifiedToEffectiveVersion(this LanguageVersion version)",
            "public static string ToDisplayString(this LanguageVersion version)",
            "public static bool TryParse(this string version, out LanguageVersion result)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.CSharp.SymbolDisplay",
          "members": [
            "public static string FormatLiteral(char c, bool quote)",
            "public static string FormatLiteral(string value, bool quote)",
            "public static string FormatPrimitive(object obj, bool quoteStrings, bool useHexadecimalNumbers)",
            "public static ImmutableArray<SymbolDisplayPart> ToDisplayParts(ISymbol symbol, SymbolDisplayFormat format = null)",
            "public static string ToDisplayString(ISymbol symbol, SymbolDisplayFormat format = null)",
            "public static ImmutableArray<SymbolDisplayPart> ToMinimalDisplayParts(ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)",
            "public static string ToMinimalDisplayString(ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.CSharp.SyntaxExtensions",
          "members": [
            "public static SyntaxTriviaList NormalizeWhitespace(this SyntaxTriviaList list, string indentation, bool elasticTrivia)",
            "public static SyntaxToken NormalizeWhitespace(this SyntaxToken token, string indentation, bool elasticTrivia)",
            "public static SyntaxTriviaList NormalizeWhitespace(this SyntaxTriviaList list, string indentation = \"    \", string eol = \"\\r\\n\", bool elasticTrivia = false)",
            "public static SyntaxToken NormalizeWhitespace(this SyntaxToken token, string indentation = \"    \", string eol = \"\\r\\n\", bool elasticTrivia = false)",
            "public static SyntaxTriviaList ToSyntaxTriviaList(this IEnumerable<SyntaxTrivia> sequence)",
            "public static IndexerDeclarationSyntax Update(this IndexerDeclarationSyntax syntax, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList)",
            "public static OperatorDeclarationSyntax Update(this OperatorDeclarationSyntax syntax, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax block, SyntaxToken semicolonToken)",
            "public static MethodDeclarationSyntax Update(this MethodDeclarationSyntax syntax, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax block, SyntaxToken semicolonToken)",
            "public static SimpleNameSyntax WithIdentifier(this SimpleNameSyntax simpleName, SyntaxToken identifier)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.CSharp.SyntaxFactory",
          "members": [
            "public static SyntaxTrivia CarriageReturn { get; }",
            "public static SyntaxTrivia CarriageReturnLineFeed { get; }",
            "public static SyntaxTrivia ElasticCarriageReturn { get; }",
            "public static SyntaxTrivia ElasticCarriageReturnLineFeed { get; }",
            "public static SyntaxTrivia ElasticLineFeed { get; }",
            "public static SyntaxTrivia ElasticMarker { get; }",
            "public static SyntaxTrivia ElasticSpace { get; }",
            "public static SyntaxTrivia ElasticTab { get; }",
            "public static SyntaxTrivia LineFeed { get; }",
            "public static SyntaxTrivia Space { get; }",
            "public static SyntaxTrivia Tab { get; }",
            "public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind)",
            "public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, BlockSyntax body)",
            "public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, BlockSyntax body)",
            "public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody)",
            "public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)",
            "public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken)",
            "public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
            "public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
            "public static AccessorListSyntax AccessorList(SyntaxList<AccessorDeclarationSyntax> accessors = default)",
            "public static AccessorListSyntax AccessorList(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)",
            "public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SimpleNameSyntax name)",
            "public static AliasQualifiedNameSyntax AliasQualifiedName(string alias, SimpleNameSyntax name)",
            "public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)",
            "public static AnonymousMethodExpressionSyntax AnonymousMethodExpression()",
            "public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(CSharpSyntaxNode body)",
            "public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(ParameterListSyntax parameterList, CSharpSyntaxNode body)",
            "public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)",
            "public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers = default)",
            "public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)",
            "public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(ExpressionSyntax expression)",
            "public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression)",
            "public static bool AreEquivalent(SyntaxTokenList oldList, SyntaxTokenList newList)",
            "public static bool AreEquivalent(SyntaxToken oldToken, SyntaxToken newToken)",
            "public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, Func<SyntaxKind, bool> ignoreChildNode = null)",
            "public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, bool topLevel)",
            "public static bool AreEquivalent(SyntaxTree oldTree, SyntaxTree newTree, bool topLevel)",
            "public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null) where TNode : SyntaxNode",
            "public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null) where TNode : SyntaxNode",
            "public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, bool topLevel) where TNode : CSharpSyntaxNode",
            "public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, bool topLevel) where TNode : SyntaxNode",
            "public static ArgumentSyntax Argument(ExpressionSyntax expression)",
            "public static ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)",
            "public static ArgumentListSyntax ArgumentList(SeparatedSyntaxList<ArgumentSyntax> arguments = default)",
            "public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)",
            "public static ArrayCreationExpressionSyntax ArrayCreationExpression(ArrayTypeSyntax type)",
            "public static ArrayCreationExpressionSyntax ArrayCreationExpression(ArrayTypeSyntax type, InitializerExpressionSyntax initializer)",
            "public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)",
            "public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SeparatedSyntaxList<ExpressionSyntax> sizes = default)",
            "public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)",
            "public static ArrayTypeSyntax ArrayType(TypeSyntax elementType)",
            "public static ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)",
            "public static ArrowExpressionClauseSyntax ArrowExpressionClause(ExpressionSyntax expression)",
            "public static ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, ExpressionSyntax expression)",
            "public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right)",
            "public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static AttributeSyntax Attribute(NameSyntax name)",
            "public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList)",
            "public static AttributeArgumentSyntax AttributeArgument(ExpressionSyntax expression)",
            "public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)",
            "public static AttributeArgumentListSyntax AttributeArgumentList(SeparatedSyntaxList<AttributeArgumentSyntax> arguments = default)",
            "public static AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)",
            "public static AttributeListSyntax AttributeList(SeparatedSyntaxList<AttributeSyntax> attributes = default)",
            "public static AttributeListSyntax AttributeList(AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes)",
            "public static AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)",
            "public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier)",
            "public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)",
            "public static AwaitExpressionSyntax AwaitExpression(ExpressionSyntax expression)",
            "public static AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression)",
            "public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken identifier, bool isActive)",
            "public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)",
            "public static SyntaxToken BadToken(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing)",
            "public static BaseExpressionSyntax BaseExpression()",
            "public static BaseExpressionSyntax BaseExpression(SyntaxToken token)",
            "public static BaseListSyntax BaseList(SeparatedSyntaxList<BaseTypeSyntax> types = default)",
            "public static BaseListSyntax BaseList(SyntaxToken colonToken, SeparatedSyntaxList<BaseTypeSyntax> types)",
            "public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static BlockSyntax Block(params StatementSyntax[] statements)",
            "public static BlockSyntax Block(IEnumerable<StatementSyntax> statements)",
            "public static BlockSyntax Block(SyntaxList<StatementSyntax> statements = default)",
            "public static BlockSyntax Block(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)",
            "public static BracketedArgumentListSyntax BracketedArgumentList(SeparatedSyntaxList<ArgumentSyntax> arguments = default)",
            "public static BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)",
            "public static BracketedParameterListSyntax BracketedParameterList(SeparatedSyntaxList<ParameterSyntax> parameters = default)",
            "public static BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)",
            "public static BreakStatementSyntax BreakStatement()",
            "public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken)",
            "public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(PatternSyntax pattern, SyntaxToken colonToken)",
            "public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)",
            "public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)",
            "public static CaseSwitchLabelSyntax CaseSwitchLabel(ExpressionSyntax value)",
            "public static CaseSwitchLabelSyntax CaseSwitchLabel(ExpressionSyntax value, SyntaxToken colonToken)",
            "public static CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)",
            "public static CastExpressionSyntax CastExpression(TypeSyntax type, ExpressionSyntax expression)",
            "public static CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)",
            "public static CatchClauseSyntax CatchClause()",
            "public static CatchClauseSyntax CatchClause(CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)",
            "public static CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)",
            "public static CatchDeclarationSyntax CatchDeclaration(TypeSyntax type)",
            "public static CatchDeclarationSyntax CatchDeclaration(TypeSyntax type, SyntaxToken identifier)",
            "public static CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)",
            "public static CatchFilterClauseSyntax CatchFilterClause(ExpressionSyntax filterExpression)",
            "public static CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)",
            "public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, ExpressionSyntax expression)",
            "public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)",
            "public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, BlockSyntax block = null)",
            "public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)",
            "public static ClassDeclarationSyntax ClassDeclaration(SyntaxToken identifier)",
            "public static ClassDeclarationSyntax ClassDeclaration(string identifier)",
            "public static ClassDeclarationSyntax ClassDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<MemberDeclarationSyntax> members)",
            "public static ClassDeclarationSyntax ClassDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)",
            "public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind)",
            "public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword)",
            "public static SyntaxTrivia Comment(string text)",
            "public static CompilationUnitSyntax CompilationUnit()",
            "public static CompilationUnitSyntax CompilationUnit(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members)",
            "public static CompilationUnitSyntax CompilationUnit(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)",
            "public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, ExpressionSyntax whenNotNull)",
            "public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)",
            "public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse)",
            "public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)",
            "public static ConstantPatternSyntax ConstantPattern(ExpressionSyntax expression)",
            "public static ConstructorConstraintSyntax ConstructorConstraint()",
            "public static ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)",
            "public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxToken identifier)",
            "public static ConstructorDeclarationSyntax ConstructorDeclaration(string identifier)",
            "public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body)",
            "public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, ArrowExpressionClauseSyntax expressionBody)",
            "public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)",
            "public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken)",
            "public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
            "public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
            "public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, ArgumentListSyntax argumentList = null)",
            "public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)",
            "public static ContinueStatementSyntax ContinueStatement()",
            "public static ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken)",
            "public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type)",
            "public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)",
            "public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)",
            "public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
            "public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type)",
            "public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type, CrefParameterListSyntax parameters)",
            "public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)",
            "public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SeparatedSyntaxList<CrefParameterSyntax> parameters = default)",
            "public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)",
            "public static CrefParameterSyntax CrefParameter(TypeSyntax type)",
            "public static CrefParameterSyntax CrefParameter(SyntaxToken refOrOutKeyword, TypeSyntax type)",
            "public static CrefParameterListSyntax CrefParameterList(SeparatedSyntaxList<CrefParameterSyntax> parameters = default)",
            "public static CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)",
            "public static DeclarationExpressionSyntax DeclarationExpression(TypeSyntax type, VariableDesignationSyntax designation)",
            "public static DeclarationPatternSyntax DeclarationPattern(TypeSyntax type, VariableDesignationSyntax designation)",
            "public static DefaultExpressionSyntax DefaultExpression(TypeSyntax type)",
            "public static DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)",
            "public static DefaultSwitchLabelSyntax DefaultSwitchLabel()",
            "public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken colonToken)",
            "public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken)",
            "public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken name, bool isActive)",
            "public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(string name, bool isActive)",
            "public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)",
            "public static DelegateDeclarationSyntax DelegateDeclaration(TypeSyntax returnType, SyntaxToken identifier)",
            "public static DelegateDeclarationSyntax DelegateDeclaration(TypeSyntax returnType, string identifier)",
            "public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)",
            "public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)",
            "public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxToken identifier)",
            "public static DestructorDeclarationSyntax DestructorDeclaration(string identifier)",
            "public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body)",
            "public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)",
            "public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)",
            "public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)",
            "public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
            "public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
            "public static SyntaxTrivia DisabledText(string text)",
            "public static DiscardDesignationSyntax DiscardDesignation()",
            "public static DiscardDesignationSyntax DiscardDesignation(SyntaxToken underscoreToken)",
            "public static DoStatementSyntax DoStatement(StatementSyntax statement, ExpressionSyntax condition)",
            "public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)",
            "public static DocumentationCommentTriviaSyntax DocumentationComment(params XmlNodeSyntax[] content)",
            "public static SyntaxTrivia DocumentationCommentExterior(string text)",
            "public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList<XmlNodeSyntax> content = default)",
            "public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)",
            "public static SyntaxTrivia ElasticEndOfLine(string text)",
            "public static SyntaxTrivia ElasticWhitespace(string text)",
            "public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression)",
            "public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)",
            "public static ElementBindingExpressionSyntax ElementBindingExpression()",
            "public static ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList)",
            "public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue)",
            "public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)",
            "public static ElseClauseSyntax ElseClause(StatementSyntax statement)",
            "public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)",
            "public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(bool isActive, bool branchTaken)",
            "public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)",
            "public static EmptyStatementSyntax EmptyStatement()",
            "public static EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)",
            "public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(bool isActive)",
            "public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)",
            "public static SyntaxTrivia EndOfLine(string text)",
            "public static SyntaxTrivia EndOfLine(string text, bool elastic)",
            "public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(bool isActive)",
            "public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)",
            "public static EnumDeclarationSyntax EnumDeclaration(SyntaxToken identifier)",
            "public static EnumDeclarationSyntax EnumDeclaration(string identifier)",
            "public static EnumDeclarationSyntax EnumDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, BaseListSyntax baseList, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members)",
            "public static EnumDeclarationSyntax EnumDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)",
            "public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier)",
            "public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string identifier)",
            "public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)",
            "public static EqualsValueClauseSyntax EqualsValueClause(ExpressionSyntax value)",
            "public static EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value)",
            "public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(bool isActive)",
            "public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)",
            "public static EventDeclarationSyntax EventDeclaration(TypeSyntax type, SyntaxToken identifier)",
            "public static EventDeclarationSyntax EventDeclaration(TypeSyntax type, string identifier)",
            "public static EventDeclarationSyntax EventDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)",
            "public static EventDeclarationSyntax EventDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)",
            "public static EventFieldDeclarationSyntax EventFieldDeclaration(VariableDeclarationSyntax declaration)",
            "public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration)",
            "public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)",
            "public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name)",
            "public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)",
            "public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression)",
            "public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken)",
            "public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken identifier)",
            "public static ExternAliasDirectiveSyntax ExternAliasDirective(string identifier)",
            "public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)",
            "public static FieldDeclarationSyntax FieldDeclaration(VariableDeclarationSyntax declaration)",
            "public static FieldDeclarationSyntax FieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration)",
            "public static FieldDeclarationSyntax FieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)",
            "public static FinallyClauseSyntax FinallyClause(BlockSyntax block = null)",
            "public static FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)",
            "public static FixedStatementSyntax FixedStatement(VariableDeclarationSyntax declaration, StatementSyntax statement)",
            "public static FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)",
            "public static ForEachStatementSyntax ForEachStatement(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax expression, StatementSyntax statement)",
            "public static ForEachStatementSyntax ForEachStatement(TypeSyntax type, string identifier, ExpressionSyntax expression, StatementSyntax statement)",
            "public static ForEachStatementSyntax ForEachStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)",
            "public static ForEachVariableStatementSyntax ForEachVariableStatement(ExpressionSyntax variable, ExpressionSyntax expression, StatementSyntax statement)",
            "public static ForEachVariableStatementSyntax ForEachVariableStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)",
            "public static ForStatementSyntax ForStatement(StatementSyntax statement)",
            "public static ForStatementSyntax ForStatement(VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, ExpressionSyntax condition, SeparatedSyntaxList<ExpressionSyntax> incrementors, StatementSyntax statement)",
            "public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)",
            "public static FromClauseSyntax FromClause(SyntaxToken identifier, ExpressionSyntax expression)",
            "public static FromClauseSyntax FromClause(string identifier, ExpressionSyntax expression)",
            "public static FromClauseSyntax FromClause(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax expression)",
            "public static FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)",
            "public static GenericNameSyntax GenericName(SyntaxToken identifier)",
            "public static GenericNameSyntax GenericName(string identifier)",
            "public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)",
            "public static ExpressionSyntax GetNonGenericExpression(ExpressionSyntax expression)",
            "public static ExpressionSyntax GetStandaloneExpression(ExpressionSyntax expression)",
            "public static GlobalStatementSyntax GlobalStatement(StatementSyntax statement)",
            "public static GotoStatementSyntax GotoStatement(SyntaxKind kind, ExpressionSyntax expression = null)",
            "public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression)",
            "public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)",
            "public static GroupClauseSyntax GroupClause(ExpressionSyntax groupExpression, ExpressionSyntax byExpression)",
            "public static GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)",
            "public static SyntaxToken Identifier(string text)",
            "public static SyntaxToken Identifier(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing)",
            "public static SyntaxToken Identifier(SyntaxTriviaList leading, SyntaxKind contextualKind, string text, string valueText, SyntaxTriviaList trailing)",
            "public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)",
            "public static IdentifierNameSyntax IdentifierName(string name)",
            "public static IfDirectiveTriviaSyntax IfDirectiveTrivia(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue)",
            "public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)",
            "public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementSyntax statement)",
            "public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementSyntax statement, ElseClauseSyntax @else)",
            "public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)",
            "public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(InitializerExpressionSyntax initializer)",
            "public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxTokenList commas, InitializerExpressionSyntax initializer)",
            "public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)",
            "public static ImplicitElementAccessSyntax ImplicitElementAccess()",
            "public static ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList)",
            "public static IncompleteMemberSyntax IncompleteMember(TypeSyntax type = null)",
            "public static IncompleteMemberSyntax IncompleteMember(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type)",
            "public static IndexerDeclarationSyntax IndexerDeclaration(TypeSyntax type)",
            "public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList)",
            "public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody)",
            "public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
            "public static IndexerMemberCrefSyntax IndexerMemberCref(CrefBracketedParameterListSyntax parameters = null)",
            "public static IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)",
            "public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SeparatedSyntaxList<ExpressionSyntax> expressions = default)",
            "public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)",
            "public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxToken identifier)",
            "public static InterfaceDeclarationSyntax InterfaceDeclaration(string identifier)",
            "public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<MemberDeclarationSyntax> members)",
            "public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)",
            "public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken)",
            "public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents)",
            "public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)",
            "public static InterpolatedStringTextSyntax InterpolatedStringText()",
            "public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)",
            "public static InterpolationSyntax Interpolation(ExpressionSyntax expression)",
            "public static InterpolationSyntax Interpolation(ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause)",
            "public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)",
            "public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value)",
            "public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken)",
            "public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)",
            "public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression)",
            "public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)",
            "public static bool IsCompleteSubmission(SyntaxTree tree)",
            "public static IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, PatternSyntax pattern)",
            "public static IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)",
            "public static JoinClauseSyntax JoinClause(SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression)",
            "public static JoinClauseSyntax JoinClause(string identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression)",
            "public static JoinClauseSyntax JoinClause(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)",
            "public static JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)",
            "public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken identifier)",
            "public static JoinIntoClauseSyntax JoinIntoClause(string identifier)",
            "public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)",
            "public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, StatementSyntax statement)",
            "public static LabeledStatementSyntax LabeledStatement(string identifier, StatementSyntax statement)",
            "public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)",
            "public static LetClauseSyntax LetClause(SyntaxToken identifier, ExpressionSyntax expression)",
            "public static LetClauseSyntax LetClause(string identifier, ExpressionSyntax expression)",
            "public static LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)",
            "public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken line, bool isActive)",
            "public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken line, SyntaxToken file, bool isActive)",
            "public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)",
            "public static SyntaxList<TNode> List<TNode>() where TNode : SyntaxNode",
            "public static SyntaxList<TNode> List<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode",
            "public static SyntaxToken Literal(int value)",
            "public static SyntaxToken Literal(uint value)",
            "public static SyntaxToken Literal(long value)",
            "public static SyntaxToken Literal(ulong value)",
            "public static SyntaxToken Literal(float value)",
            "public static SyntaxToken Literal(double value)",
            "public static SyntaxToken Literal(decimal value)",
            "public static SyntaxToken Literal(string value)",
            "public static SyntaxToken Literal(char value)",
            "public static SyntaxToken Literal(string text, int value)",
            "public static SyntaxToken Literal(string text, uint value)",
            "public static SyntaxToken Literal(string text, long value)",
            "public static SyntaxToken Literal(string text, ulong value)",
            "public static SyntaxToken Literal(string text, float value)",
            "public static SyntaxToken Literal(string text, double value)",
            "public static SyntaxToken Literal(string text, decimal value)",
            "public static SyntaxToken Literal(string text, string value)",
            "public static SyntaxToken Literal(string text, char value)",
            "public static SyntaxToken Literal(SyntaxTriviaList leading, string text, int value, SyntaxTriviaList trailing)",
            "public static SyntaxToken Literal(SyntaxTriviaList leading, string text, uint value, SyntaxTriviaList trailing)",
            "public static SyntaxToken Literal(SyntaxTriviaList leading, string text, long value, SyntaxTriviaList trailing)",
            "public static SyntaxToken Literal(SyntaxTriviaList leading, string text, ulong value, SyntaxTriviaList trailing)",
            "public static SyntaxToken Literal(SyntaxTriviaList leading, string text, float value, SyntaxTriviaList trailing)",
            "public static SyntaxToken Literal(SyntaxTriviaList leading, string text, double value, SyntaxTriviaList trailing)",
            "public static SyntaxToken Literal(SyntaxTriviaList leading, string text, decimal value, SyntaxTriviaList trailing)",
            "public static SyntaxToken Literal(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)",
            "public static SyntaxToken Literal(SyntaxTriviaList leading, string text, char value, SyntaxTriviaList trailing)",
            "public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind)",
            "public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)",
            "public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken file, bool isActive)",
            "public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)",
            "public static LocalDeclarationStatementSyntax LocalDeclarationStatement(VariableDeclarationSyntax declaration)",
            "public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration)",
            "public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)",
            "public static LocalFunctionStatementSyntax LocalFunctionStatement(TypeSyntax returnType, SyntaxToken identifier)",
            "public static LocalFunctionStatementSyntax LocalFunctionStatement(TypeSyntax returnType, string identifier)",
            "public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)",
            "public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
            "public static LockStatementSyntax LockStatement(ExpressionSyntax expression, StatementSyntax statement)",
            "public static LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)",
            "public static MakeRefExpressionSyntax MakeRefExpression(ExpressionSyntax expression)",
            "public static MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)",
            "public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SimpleNameSyntax name)",
            "public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)",
            "public static MemberBindingExpressionSyntax MemberBindingExpression(SimpleNameSyntax name)",
            "public static MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name)",
            "public static MethodDeclarationSyntax MethodDeclaration(TypeSyntax returnType, SyntaxToken identifier)",
            "public static MethodDeclarationSyntax MethodDeclaration(TypeSyntax returnType, string identifier)",
            "public static MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)",
            "public static MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, SyntaxToken semicolonToken)",
            "public static MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
            "public static SyntaxToken MissingToken(SyntaxKind kind)",
            "public static SyntaxToken MissingToken(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing)",
            "public static NameColonSyntax NameColon(IdentifierNameSyntax name)",
            "public static NameColonSyntax NameColon(string name)",
            "public static NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)",
            "public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name)",
            "public static NameEqualsSyntax NameEquals(string name)",
            "public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken)",
            "public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name)",
            "public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters)",
            "public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name)",
            "public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members)",
            "public static NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)",
            "public static SyntaxNodeOrTokenList NodeOrTokenList()",
            "public static SyntaxNodeOrTokenList NodeOrTokenList(IEnumerable<SyntaxNodeOrToken> nodesAndTokens)",
            "public static SyntaxNodeOrTokenList NodeOrTokenList(params SyntaxNodeOrToken[] nodesAndTokens)",
            "public static NullableTypeSyntax NullableType(TypeSyntax elementType)",
            "public static NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)",
            "public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type)",
            "public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)",
            "public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)",
            "public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression()",
            "public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)",
            "public static OmittedTypeArgumentSyntax OmittedTypeArgument()",
            "public static OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)",
            "public static OperatorDeclarationSyntax OperatorDeclaration(TypeSyntax returnType, SyntaxToken operatorToken)",
            "public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)",
            "public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)",
            "public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)",
            "public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorToken)",
            "public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorToken, CrefParameterListSyntax parameters)",
            "public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)",
            "public static OrderByClauseSyntax OrderByClause(SeparatedSyntaxList<OrderingSyntax> orderings = default)",
            "public static OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings)",
            "public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression)",
            "public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)",
            "public static ParameterSyntax Parameter(SyntaxToken identifier)",
            "public static ParameterSyntax Parameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)",
            "public static ParameterListSyntax ParameterList(SeparatedSyntaxList<ParameterSyntax> parameters = default)",
            "public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)",
            "public static ParenthesizedExpressionSyntax ParenthesizedExpression(ExpressionSyntax expression)",
            "public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)",
            "public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(CSharpSyntaxNode body)",
            "public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(ParameterListSyntax parameterList, CSharpSyntaxNode body)",
            "public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body)",
            "public static ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SeparatedSyntaxList<VariableDesignationSyntax> variables = default)",
            "public static ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SyntaxToken openParenToken, SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken)",
            "public static ArgumentListSyntax ParseArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)",
            "public static AttributeArgumentListSyntax ParseAttributeArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)",
            "public static BracketedArgumentListSyntax ParseBracketedArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)",
            "public static BracketedParameterListSyntax ParseBracketedParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)",
            "public static CompilationUnitSyntax ParseCompilationUnit(string text, int offset = 0, CSharpParseOptions options = null)",
            "public static ExpressionSyntax ParseExpression(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)",
            "public static SyntaxTriviaList ParseLeadingTrivia(string text, int offset = 0)",
            "public static NameSyntax ParseName(string text, int offset = 0, bool consumeFullText = true)",
            "public static ParameterListSyntax ParseParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)",
            "public static StatementSyntax ParseStatement(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true)",
            "public static SyntaxTree ParseSyntaxTree(SourceText text, ParseOptions options = null, string path = \"\", CancellationToken cancellationToken = default)",
            "public static SyntaxTree ParseSyntaxTree(string text, ParseOptions options = null, string path = \"\", Encoding encoding = null, CancellationToken cancellationToken = default)",
            "public static SyntaxToken ParseToken(string text, int offset = 0)",
            "public static IEnumerable<SyntaxToken> ParseTokens(string text, int offset = 0, int initialTokenPosition = 0, CSharpParseOptions options = null)",
            "public static SyntaxTriviaList ParseTrailingTrivia(string text, int offset = 0)",
            "public static TypeSyntax ParseTypeName(string text, int offset = 0, bool consumeFullText = true)",
            "public static PointerTypeSyntax PointerType(TypeSyntax elementType)",
            "public static PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)",
            "public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand)",
            "public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)",
            "public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, bool isActive)",
            "public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)",
            "public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, bool isActive)",
            "public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, bool isActive)",
            "public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)",
            "public static PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)",
            "public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand)",
            "public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)",
            "public static SyntaxTrivia PreprocessingMessage(string text)",
            "public static PropertyDeclarationSyntax PropertyDeclaration(TypeSyntax type, SyntaxToken identifier)",
            "public static PropertyDeclarationSyntax PropertyDeclaration(TypeSyntax type, string identifier)",
            "public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)",
            "public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer)",
            "public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)",
            "public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, MemberCrefSyntax member)",
            "public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)",
            "public static QualifiedNameSyntax QualifiedName(NameSyntax left, SimpleNameSyntax right)",
            "public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)",
            "public static QueryBodySyntax QueryBody(SelectOrGroupClauseSyntax selectOrGroup)",
            "public static QueryBodySyntax QueryBody(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)",
            "public static QueryContinuationSyntax QueryContinuation(SyntaxToken identifier, QueryBodySyntax body)",
            "public static QueryContinuationSyntax QueryContinuation(string identifier, QueryBodySyntax body)",
            "public static QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)",
            "public static QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)",
            "public static RefExpressionSyntax RefExpression(ExpressionSyntax expression)",
            "public static RefExpressionSyntax RefExpression(SyntaxToken refKeyword, ExpressionSyntax expression)",
            "public static RefTypeSyntax RefType(TypeSyntax type)",
            "public static RefTypeSyntax RefType(SyntaxToken refKeyword, TypeSyntax type)",
            "public static RefTypeExpressionSyntax RefTypeExpression(ExpressionSyntax expression)",
            "public static RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)",
            "public static RefValueExpressionSyntax RefValueExpression(ExpressionSyntax expression, TypeSyntax type)",
            "public static RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)",
            "public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken file, bool isActive)",
            "public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)",
            "public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(bool isActive)",
            "public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)",
            "public static ReturnStatementSyntax ReturnStatement(ExpressionSyntax expression = null)",
            "public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)",
            "public static SelectClauseSyntax SelectClause(ExpressionSyntax expression)",
            "public static SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)",
            "public static SeparatedSyntaxList<TNode> SeparatedList<TNode>() where TNode : SyntaxNode",
            "public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode",
            "public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<SyntaxNodeOrToken> nodesAndTokens) where TNode : SyntaxNode",
            "public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(SyntaxNodeOrTokenList nodesAndTokens) where TNode : SyntaxNode",
            "public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes, IEnumerable<SyntaxToken> separators) where TNode : SyntaxNode",
            "public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(bool isActive)",
            "public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)",
            "public static SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type)",
            "public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(ParameterSyntax parameter, CSharpSyntaxNode body)",
            "public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body)",
            "public static SingleVariableDesignationSyntax SingleVariableDesignation(SyntaxToken identifier)",
            "public static SyntaxList<TNode> SingletonList<TNode>(TNode node) where TNode : SyntaxNode",
            "public static SeparatedSyntaxList<TNode> SingletonSeparatedList<TNode>(TNode node) where TNode : SyntaxNode",
            "public static SizeOfExpressionSyntax SizeOfExpression(TypeSyntax type)",
            "public static SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)",
            "public static SkippedTokensTriviaSyntax SkippedTokensTrivia()",
            "public static SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxTokenList tokens)",
            "public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(TypeSyntax type)",
            "public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type)",
            "public static StructDeclarationSyntax StructDeclaration(SyntaxToken identifier)",
            "public static StructDeclarationSyntax StructDeclaration(string identifier)",
            "public static StructDeclarationSyntax StructDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<MemberDeclarationSyntax> members)",
            "public static StructDeclarationSyntax StructDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)",
            "public static SwitchSectionSyntax SwitchSection()",
            "public static SwitchSectionSyntax SwitchSection(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements)",
            "public static SwitchStatementSyntax SwitchStatement(ExpressionSyntax expression)",
            "public static SwitchStatementSyntax SwitchStatement(ExpressionSyntax expression, SyntaxList<SwitchSectionSyntax> sections)",
            "public static SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)",
            "public static SyntaxTree SyntaxTree(SyntaxNode root, ParseOptions options = null, string path = \"\", Encoding encoding = null)",
            "public static SyntaxTrivia SyntaxTrivia(SyntaxKind kind, string text)",
            "public static ThisExpressionSyntax ThisExpression()",
            "public static ThisExpressionSyntax ThisExpression(SyntaxToken token)",
            "public static ThrowExpressionSyntax ThrowExpression(ExpressionSyntax expression)",
            "public static ThrowExpressionSyntax ThrowExpression(SyntaxToken throwKeyword, ExpressionSyntax expression)",
            "public static ThrowStatementSyntax ThrowStatement(ExpressionSyntax expression = null)",
            "public static ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)",
            "public static SyntaxToken Token(SyntaxKind kind)",
            "public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing)",
            "public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, string text, string valueText, SyntaxTriviaList trailing)",
            "public static SyntaxTokenList TokenList()",
            "public static SyntaxTokenList TokenList(SyntaxToken token)",
            "public static SyntaxTokenList TokenList(params SyntaxToken[] tokens)",
            "public static SyntaxTokenList TokenList(IEnumerable<SyntaxToken> tokens)",
            "public static SyntaxTrivia Trivia(StructuredTriviaSyntax node)",
            "public static SyntaxTriviaList TriviaList()",
            "public static SyntaxTriviaList TriviaList(SyntaxTrivia trivia)",
            "public static SyntaxTriviaList TriviaList(params SyntaxTrivia[] trivias)",
            "public static SyntaxTriviaList TriviaList(IEnumerable<SyntaxTrivia> trivias)",
            "public static TryStatementSyntax TryStatement(SyntaxList<CatchClauseSyntax> catches = default)",
            "public static TryStatementSyntax TryStatement(BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)",
            "public static TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)",
            "public static TupleElementSyntax TupleElement(TypeSyntax type)",
            "public static TupleElementSyntax TupleElement(TypeSyntax type, SyntaxToken identifier)",
            "public static TupleExpressionSyntax TupleExpression(SeparatedSyntaxList<ArgumentSyntax> arguments = default)",
            "public static TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)",
            "public static TupleTypeSyntax TupleType(SeparatedSyntaxList<TupleElementSyntax> elements = default)",
            "public static TupleTypeSyntax TupleType(SyntaxToken openParenToken, SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)",
            "public static TypeArgumentListSyntax TypeArgumentList(SeparatedSyntaxList<TypeSyntax> arguments = default)",
            "public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)",
            "public static TypeConstraintSyntax TypeConstraint(TypeSyntax type)",
            "public static TypeCrefSyntax TypeCref(TypeSyntax type)",
            "public static TypeDeclarationSyntax TypeDeclaration(SyntaxKind kind, SyntaxToken identifier)",
            "public static TypeDeclarationSyntax TypeDeclaration(SyntaxKind kind, string identifier)",
            "public static TypeDeclarationSyntax TypeDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)",
            "public static TypeOfExpressionSyntax TypeOfExpression(TypeSyntax type)",
            "public static TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)",
            "public static TypeParameterSyntax TypeParameter(SyntaxToken identifier)",
            "public static TypeParameterSyntax TypeParameter(string identifier)",
            "public static TypeParameterSyntax TypeParameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)",
            "public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax name)",
            "public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string name)",
            "public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax name, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)",
            "public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)",
            "public static TypeParameterListSyntax TypeParameterList(SeparatedSyntaxList<TypeParameterSyntax> parameters = default)",
            "public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)",
            "public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken name, bool isActive)",
            "public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(string name, bool isActive)",
            "public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)",
            "public static UnsafeStatementSyntax UnsafeStatement(BlockSyntax block = null)",
            "public static UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block)",
            "public static UsingDirectiveSyntax UsingDirective(NameSyntax name)",
            "public static UsingDirectiveSyntax UsingDirective(NameEqualsSyntax alias, NameSyntax name)",
            "public static UsingDirectiveSyntax UsingDirective(SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name)",
            "public static UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)",
            "public static UsingStatementSyntax UsingStatement(StatementSyntax statement)",
            "public static UsingStatementSyntax UsingStatement(VariableDeclarationSyntax declaration, ExpressionSyntax expression, StatementSyntax statement)",
            "public static UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)",
            "public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type)",
            "public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables)",
            "public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier)",
            "public static VariableDeclaratorSyntax VariableDeclarator(string identifier)",
            "public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)",
            "public static SyntaxToken VerbatimIdentifier(SyntaxTriviaList leading, string text, string valueText, SyntaxTriviaList trailing)",
            "public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(bool isActive)",
            "public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)",
            "public static WhenClauseSyntax WhenClause(ExpressionSyntax condition)",
            "public static WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionSyntax condition)",
            "public static WhereClauseSyntax WhereClause(ExpressionSyntax condition)",
            "public static WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)",
            "public static WhileStatementSyntax WhileStatement(ExpressionSyntax condition, StatementSyntax statement)",
            "public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)",
            "public static SyntaxTrivia Whitespace(string text)",
            "public static SyntaxTrivia Whitespace(string text, bool elastic)",
            "public static XmlCDataSectionSyntax XmlCDataSection(SyntaxTokenList textTokens = default)",
            "public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken)",
            "public static XmlCommentSyntax XmlComment(SyntaxTokenList textTokens = default)",
            "public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken)",
            "public static XmlCrefAttributeSyntax XmlCrefAttribute(CrefSyntax cref)",
            "public static XmlCrefAttributeSyntax XmlCrefAttribute(CrefSyntax cref, SyntaxKind quoteKind)",
            "public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)",
            "public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)",
            "public static XmlElementSyntax XmlElement(string localName, SyntaxList<XmlNodeSyntax> content)",
            "public static XmlElementSyntax XmlElement(XmlNameSyntax name, SyntaxList<XmlNodeSyntax> content)",
            "public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, XmlElementEndTagSyntax endTag)",
            "public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)",
            "public static XmlElementEndTagSyntax XmlElementEndTag(XmlNameSyntax name)",
            "public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)",
            "public static XmlElementStartTagSyntax XmlElementStartTag(XmlNameSyntax name)",
            "public static XmlElementStartTagSyntax XmlElementStartTag(XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes)",
            "public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)",
            "public static XmlEmptyElementSyntax XmlEmptyElement(string localName)",
            "public static XmlEmptyElementSyntax XmlEmptyElement(XmlNameSyntax name)",
            "public static XmlEmptyElementSyntax XmlEmptyElement(XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes)",
            "public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)",
            "public static SyntaxToken XmlEntity(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)",
            "public static XmlElementSyntax XmlExampleElement(params XmlNodeSyntax[] content)",
            "public static XmlElementSyntax XmlExampleElement(SyntaxList<XmlNodeSyntax> content)",
            "public static XmlElementSyntax XmlExceptionElement(CrefSyntax cref, params XmlNodeSyntax[] content)",
            "public static XmlElementSyntax XmlExceptionElement(CrefSyntax cref, SyntaxList<XmlNodeSyntax> content)",
            "public static XmlElementSyntax XmlMultiLineElement(string localName, SyntaxList<XmlNodeSyntax> content)",
            "public static XmlElementSyntax XmlMultiLineElement(XmlNameSyntax name, SyntaxList<XmlNodeSyntax> content)",
            "public static XmlNameSyntax XmlName(SyntaxToken localName)",
            "public static XmlNameSyntax XmlName(string localName)",
            "public static XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName)",
            "public static XmlNameAttributeSyntax XmlNameAttribute(string parameterName)",
            "public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)",
            "public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, string identifier, SyntaxToken endQuoteToken)",
            "public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)",
            "public static XmlTextSyntax XmlNewLine(string text)",
            "public static XmlEmptyElementSyntax XmlNullKeywordElement()",
            "public static XmlElementSyntax XmlParaElement(params XmlNodeSyntax[] content)",
            "public static XmlElementSyntax XmlParaElement(SyntaxList<XmlNodeSyntax> content)",
            "public static XmlElementSyntax XmlParamElement(string parameterName, params XmlNodeSyntax[] content)",
            "public static XmlElementSyntax XmlParamElement(string parameterName, SyntaxList<XmlNodeSyntax> content)",
            "public static XmlEmptyElementSyntax XmlParamRefElement(string parameterName)",
            "public static XmlElementSyntax XmlPermissionElement(CrefSyntax cref, params XmlNodeSyntax[] content)",
            "public static XmlElementSyntax XmlPermissionElement(CrefSyntax cref, SyntaxList<XmlNodeSyntax> content)",
            "public static XmlElementSyntax XmlPlaceholderElement(params XmlNodeSyntax[] content)",
            "public static XmlElementSyntax XmlPlaceholderElement(SyntaxList<XmlNodeSyntax> content)",
            "public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix)",
            "public static XmlPrefixSyntax XmlPrefix(string prefix)",
            "public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)",
            "public static XmlEmptyElementSyntax XmlPreliminaryElement()",
            "public static XmlProcessingInstructionSyntax XmlProcessingInstruction(XmlNameSyntax name)",
            "public static XmlProcessingInstructionSyntax XmlProcessingInstruction(XmlNameSyntax name, SyntaxTokenList textTokens)",
            "public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken)",
            "public static XmlElementSyntax XmlRemarksElement(params XmlNodeSyntax[] content)",
            "public static XmlElementSyntax XmlRemarksElement(SyntaxList<XmlNodeSyntax> content)",
            "public static XmlElementSyntax XmlReturnsElement(params XmlNodeSyntax[] content)",
            "public static XmlElementSyntax XmlReturnsElement(SyntaxList<XmlNodeSyntax> content)",
            "public static XmlEmptyElementSyntax XmlSeeAlsoElement(CrefSyntax cref)",
            "public static XmlElementSyntax XmlSeeAlsoElement(Uri linkAddress, SyntaxList<XmlNodeSyntax> linkText)",
            "public static XmlEmptyElementSyntax XmlSeeElement(CrefSyntax cref)",
            "public static XmlElementSyntax XmlSummaryElement(params XmlNodeSyntax[] content)",
            "public static XmlElementSyntax XmlSummaryElement(SyntaxList<XmlNodeSyntax> content)",
            "public static XmlTextSyntax XmlText()",
            "public static XmlTextSyntax XmlText(params SyntaxToken[] textTokens)",
            "public static XmlTextSyntax XmlText(SyntaxTokenList textTokens)",
            "public static XmlTextSyntax XmlText(string value)",
            "public static XmlTextAttributeSyntax XmlTextAttribute(string name, params SyntaxToken[] textTokens)",
            "public static XmlTextAttributeSyntax XmlTextAttribute(string name, string value)",
            "public static XmlTextAttributeSyntax XmlTextAttribute(string name, SyntaxKind quoteKind, SyntaxTokenList textTokens)",
            "public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxKind quoteKind, SyntaxTokenList textTokens)",
            "public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxToken endQuoteToken)",
            "public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)",
            "public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)",
            "public static SyntaxToken XmlTextLiteral(string value)",
            "public static SyntaxToken XmlTextLiteral(string text, string value)",
            "public static SyntaxToken XmlTextLiteral(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)",
            "public static SyntaxToken XmlTextNewLine(string text)",
            "public static SyntaxToken XmlTextNewLine(string text, bool continueXmlDocumentationComment)",
            "public static SyntaxToken XmlTextNewLine(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing)",
            "public static XmlEmptyElementSyntax XmlThreadSafetyElement()",
            "public static XmlEmptyElementSyntax XmlThreadSafetyElement(bool isStatic, bool isInstance)",
            "public static XmlElementSyntax XmlValueElement(params XmlNodeSyntax[] content)",
            "public static XmlElementSyntax XmlValueElement(SyntaxList<XmlNodeSyntax> content)",
            "public static YieldStatementSyntax YieldStatement(SyntaxKind kind, ExpressionSyntax expression = null)",
            "public static YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.CSharp.SyntaxFacts",
          "members": [
            "public static IEqualityComparer<SyntaxKind> EqualityComparer { get; }",
            "public static SyntaxKind GetAccessorDeclarationKind(SyntaxKind keyword)",
            "public static SyntaxKind GetAssignmentExpression(SyntaxKind token)",
            "public static SyntaxKind GetBaseTypeDeclarationKind(SyntaxKind kind)",
            "public static SyntaxKind GetBinaryExpression(SyntaxKind token)",
            "public static SyntaxKind GetCheckStatement(SyntaxKind keyword)",
            "public static SyntaxKind GetContextualKeywordKind(string text)",
            "public static IEnumerable<SyntaxKind> GetContextualKeywordKinds()",
            "public static SyntaxKind GetInstanceExpression(SyntaxKind token)",
            "public static SyntaxKind GetKeywordKind(string text)",
            "public static IEnumerable<SyntaxKind> GetKeywordKinds()",
            "public static SyntaxKind GetLiteralExpression(SyntaxKind token)",
            "public static SyntaxKind GetOperatorKind(string operatorMetadataName)",
            "public static SyntaxKind GetPostfixUnaryExpression(SyntaxKind token)",
            "public static SyntaxKind GetPrefixUnaryExpression(SyntaxKind token)",
            "public static SyntaxKind GetPreprocessorKeywordKind(string text)",
            "public static IEnumerable<SyntaxKind> GetPreprocessorKeywordKinds()",
            "public static SyntaxKind GetPrimaryFunction(SyntaxKind keyword)",
            "public static IEnumerable<SyntaxKind> GetPunctuationKinds()",
            "public static IEnumerable<SyntaxKind> GetReservedKeywordKinds()",
            "public static SyntaxKind GetSwitchLabelKind(SyntaxKind keyword)",
            "public static string GetText(Accessibility accessibility)",
            "public static string GetText(SyntaxKind kind)",
            "public static SyntaxKind GetTypeDeclarationKind(SyntaxKind kind)",
            "public static bool IsAccessibilityModifier(SyntaxKind kind)",
            "public static bool IsAccessorDeclaration(SyntaxKind kind)",
            "public static bool IsAccessorDeclarationKeyword(SyntaxKind keyword)",
            "public static bool IsAliasQualifier(SyntaxNode node)",
            "public static bool IsAnyOverloadableOperator(SyntaxKind kind)",
            "public static bool IsAnyToken(SyntaxKind kind)",
            "public static bool IsAnyUnaryExpression(SyntaxKind token)",
            "public static bool IsAssignmentExpression(SyntaxKind kind)",
            "public static bool IsAssignmentExpressionOperatorToken(SyntaxKind token)",
            "public static bool IsAttributeName(SyntaxNode node)",
            "public static bool IsAttributeTargetSpecifier(SyntaxKind kind)",
            "public static bool IsBinaryExpression(SyntaxKind token)",
            "public static bool IsBinaryExpressionOperatorToken(SyntaxKind token)",
            "public static bool IsContextualKeyword(SyntaxKind kind)",
            "public static bool IsDocumentationCommentTrivia(SyntaxKind kind)",
            "public static bool IsFixedStatementExpression(SyntaxNode node)",
            "public static bool IsGlobalMemberDeclaration(SyntaxKind kind)",
            "public static bool IsIdentifierPartCharacter(char ch)",
            "public static bool IsIdentifierStartCharacter(char ch)",
            "public static bool IsInNamespaceOrTypeContext(ExpressionSyntax node)",
            "public static bool IsInTypeOnlyContext(ExpressionSyntax node)",
            "public static bool IsIndexed(ExpressionSyntax node)",
            "public static bool IsInstanceExpression(SyntaxKind token)",
            "public static bool IsInvoked(ExpressionSyntax node)",
            "public static bool IsKeywordKind(SyntaxKind kind)",
            "public static bool IsLambdaBody(SyntaxNode node)",
            "public static bool IsLanguagePunctuation(SyntaxKind kind)",
            "public static bool IsLiteralExpression(SyntaxKind token)",
            "public static bool IsName(SyntaxKind kind)",
            "public static bool IsNamedArgumentName(SyntaxNode node)",
            "public static bool IsNamespaceAliasQualifier(ExpressionSyntax node)",
            "public static bool IsNamespaceMemberDeclaration(SyntaxKind kind)",
            "public static bool IsNewLine(char ch)",
            "public static bool IsOverloadableBinaryOperator(SyntaxKind kind)",
            "public static bool IsOverloadableUnaryOperator(SyntaxKind kind)",
            "public static bool IsPostfixUnaryExpression(SyntaxKind token)",
            "public static bool IsPostfixUnaryExpressionToken(SyntaxKind token)",
            "public static bool IsPredefinedType(SyntaxKind kind)",
            "public static bool IsPrefixUnaryExpression(SyntaxKind token)",
            "public static bool IsPrefixUnaryExpressionOperatorToken(SyntaxKind token)",
            "public static bool IsPreprocessorDirective(SyntaxKind kind)",
            "public static bool IsPreprocessorKeyword(SyntaxKind kind)",
            "public static bool IsPreprocessorPunctuation(SyntaxKind kind)",
            "public static bool IsPrimaryFunction(SyntaxKind keyword)",
            "public static bool IsPunctuation(SyntaxKind kind)",
            "public static bool IsPunctuationOrKeyword(SyntaxKind kind)",
            "public static bool IsQueryContextualKeyword(SyntaxKind kind)",
            "public static bool IsReservedKeyword(SyntaxKind kind)",
            "public static bool IsReservedTupleElementName(string elementName)",
            "public static bool IsTrivia(SyntaxKind kind)",
            "public static bool IsTypeDeclaration(SyntaxKind kind)",
            "public static bool IsTypeParameterVarianceKeyword(SyntaxKind kind)",
            "public static bool IsTypeSyntax(SyntaxKind kind)",
            "public static bool IsUnaryOperatorDeclarationToken(SyntaxKind token)",
            "public static bool IsValidIdentifier(string name)",
            "public static bool IsWhitespace(char ch)",
            "public static string TryGetInferredMemberName(this SyntaxNode syntax)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.CSharp.TypedConstantExtensions",
          "members": [
            "public static string ToCSharpString(this TypedConstant constant)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptions",
          "members": [
            "public static Option<bool> IndentBlock { get; }",
            "public static Option<bool> IndentBraces { get; }",
            "public static Option<bool> IndentSwitchCaseSection { get; }",
            "public static Option<bool> IndentSwitchSection { get; }",
            "public static Option<LabelPositionOptions> LabelPositioning { get; }",
            "public static Option<bool> NewLineForCatch { get; }",
            "public static Option<bool> NewLineForClausesInQuery { get; }",
            "public static Option<bool> NewLineForElse { get; }",
            "public static Option<bool> NewLineForFinally { get; }",
            "public static Option<bool> NewLineForMembersInAnonymousTypes { get; }",
            "public static Option<bool> NewLineForMembersInObjectInit { get; }",
            "public static Option<bool> NewLinesForBracesInAccessors { get; }",
            "public static Option<bool> NewLinesForBracesInAnonymousMethods { get; }",
            "public static Option<bool> NewLinesForBracesInAnonymousTypes { get; }",
            "public static Option<bool> NewLinesForBracesInControlBlocks { get; }",
            "public static Option<bool> NewLinesForBracesInLambdaExpressionBody { get; }",
            "public static Option<bool> NewLinesForBracesInMethods { get; }",
            "public static Option<bool> NewLinesForBracesInObjectCollectionArrayInitializers { get; }",
            "public static Option<bool> NewLinesForBracesInProperties { get; }",
            "public static Option<bool> NewLinesForBracesInTypes { get; }",
            "public static Option<bool> SpaceAfterCast { get; }",
            "public static Option<bool> SpaceAfterColonInBaseTypeDeclaration { get; }",
            "public static Option<bool> SpaceAfterComma { get; }",
            "public static Option<bool> SpaceAfterControlFlowStatementKeyword { get; }",
            "public static Option<bool> SpaceAfterDot { get; }",
            "public static Option<bool> SpaceAfterMethodCallName { get; }",
            "public static Option<bool> SpaceAfterSemicolonsInForStatement { get; }",
            "public static Option<bool> SpaceBeforeColonInBaseTypeDeclaration { get; }",
            "public static Option<bool> SpaceBeforeComma { get; }",
            "public static Option<bool> SpaceBeforeDot { get; }",
            "public static Option<bool> SpaceBeforeOpenSquareBracket { get; }",
            "public static Option<bool> SpaceBeforeSemicolonsInForStatement { get; }",
            "public static Option<bool> SpaceBetweenEmptyMethodCallParentheses { get; }",
            "public static Option<bool> SpaceBetweenEmptyMethodDeclarationParentheses { get; }",
            "public static Option<bool> SpaceBetweenEmptySquareBrackets { get; }",
            "public static Option<bool> SpaceWithinCastParentheses { get; }",
            "public static Option<bool> SpaceWithinExpressionParentheses { get; }",
            "public static Option<bool> SpaceWithinMethodCallParentheses { get; }",
            "public static Option<bool> SpaceWithinMethodDeclarationParenthesis { get; }",
            "public static Option<bool> SpaceWithinOtherParentheses { get; }",
            "public static Option<bool> SpaceWithinSquareBrackets { get; }",
            "public static Option<bool> SpacesIgnoreAroundVariableDeclaration { get; }",
            "public static Option<bool> SpacingAfterMethodDeclarationName { get; }",
            "public static Option<BinaryOperatorSpacingOptions> SpacingAroundBinaryOperator { get; }",
            "public static Option<bool> WrappingKeepStatementsOnSingleLine { get; }",
            "public static Option<bool> WrappingPreserveSingleLine { get; }"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Classification.ClassificationTypeNames",
          "members": [
            "public const string ClassName = \"class name\"",
            "public const string Comment = \"comment\"",
            "public const string DelegateName = \"delegate name\"",
            "public const string EnumName = \"enum name\"",
            "public const string ExcludedCode = \"excluded code\"",
            "public const string Identifier = \"identifier\"",
            "public const string InterfaceName = \"interface name\"",
            "public const string Keyword = \"keyword\"",
            "public const string ModuleName = \"module name\"",
            "public const string NumericLiteral = \"number\"",
            "public const string Operator = \"operator\"",
            "public const string PreprocessorKeyword = \"preprocessor keyword\"",
            "public const string PreprocessorText = \"preprocessor text\"",
            "public const string Punctuation = \"punctuation\"",
            "public const string StringLiteral = \"string\"",
            "public const string StructName = \"struct name\"",
            "public const string Text = \"text\"",
            "public const string TypeParameterName = \"type parameter name\"",
            "public const string VerbatimStringLiteral = \"string - verbatim\"",
            "public const string WhiteSpace = \"whitespace\"",
            "public const string XmlDocCommentAttributeName = \"xml doc comment - attribute name\"",
            "public const string XmlDocCommentAttributeQuotes = \"xml doc comment - attribute quotes\"",
            "public const string XmlDocCommentAttributeValue = \"xml doc comment - attribute value\"",
            "public const string XmlDocCommentCDataSection = \"xml doc comment - cdata section\"",
            "public const string XmlDocCommentComment = \"xml doc comment - comment\"",
            "public const string XmlDocCommentDelimiter = \"xml doc comment - delimiter\"",
            "public const string XmlDocCommentEntityReference = \"xml doc comment - entity reference\"",
            "public const string XmlDocCommentName = \"xml doc comment - name\"",
            "public const string XmlDocCommentProcessingInstruction = \"xml doc comment - processing instruction\"",
            "public const string XmlDocCommentText = \"xml doc comment - text\"",
            "public const string XmlLiteralAttributeName = \"xml literal - attribute name\"",
            "public const string XmlLiteralAttributeQuotes = \"xml literal - attribute quotes\"",
            "public const string XmlLiteralAttributeValue = \"xml literal - attribute value\"",
            "public const string XmlLiteralCDataSection = \"xml literal - cdata section\"",
            "public const string XmlLiteralComment = \"xml literal - comment\"",
            "public const string XmlLiteralDelimiter = \"xml literal - delimiter\"",
            "public const string XmlLiteralEmbeddedExpression = \"xml literal - embedded expression\"",
            "public const string XmlLiteralEntityReference = \"xml literal - entity reference\"",
            "public const string XmlLiteralName = \"xml literal - name\"",
            "public const string XmlLiteralProcessingInstruction = \"xml literal - processing instruction\"",
            "public const string XmlLiteralText = \"xml literal - text\""
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Classification.Classifier",
          "members": [
            "public static IEnumerable<ClassifiedSpan> GetClassifiedSpans(SemanticModel semanticModel, TextSpan textSpan, Workspace workspace, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ClassifiedSpan>> GetClassifiedSpansAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.CodeActions.ConflictAnnotation",
          "members": [
            "public const string Kind = \"CodeAction_Conflict\"",
            "public static SyntaxAnnotation Create(string description)",
            "public static string GetDescription(SyntaxAnnotation annotation)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.CodeActions.RenameAnnotation",
          "members": [
            "public const string Kind = \"CodeAction_Rename\"",
            "public static SyntaxAnnotation Create()"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.CodeActions.WarningAnnotation",
          "members": [
            "public const string Kind = \"CodeAction_Warning\"",
            "public static SyntaxAnnotation Create(string description)",
            "public static string GetDescription(SyntaxAnnotation annotation)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders",
          "members": [
            "public static FixAllProvider BatchFixer { get; }"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions",
          "members": [
            "public static CompilationWithAnalyzers WithAnalyzers(this Compilation compilation, ImmutableArray<DiagnosticAnalyzer> analyzers, CompilationWithAnalyzersOptions analysisOptions)",
            "public static CompilationWithAnalyzers WithAnalyzers(this Compilation compilation, ImmutableArray<DiagnosticAnalyzer> analyzers, AnalyzerOptions options = null, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Editing.ImportAdder",
          "members": [
            "public static Task<Document> AddImportsAsync(Document document, OptionSet options = null, CancellationToken cancellationToken = default)",
            "public static Task<Document> AddImportsAsync(Document document, SyntaxAnnotation annotation, OptionSet options = null, CancellationToken cancellationToken = default)",
            "public static Task<Document> AddImportsAsync(Document document, TextSpan span, OptionSet options = null, CancellationToken cancellationToken = default)",
            "public static Task<Document> AddImportsAsync(Document document, IEnumerable<TextSpan> spans, OptionSet options = null, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions",
          "members": [
            "public static Task<SyntaxNode> GetBaseOrInterfaceDeclarationReferenceAsync(this SymbolEditor editor, ISymbol symbol, ITypeSymbol baseOrInterfaceType, CancellationToken cancellationToken = default)",
            "public static Task<ISymbol> SetBaseTypeAsync(this SymbolEditor editor, INamedTypeSymbol symbol, Func<SyntaxGenerator, SyntaxNode> getNewBaseType, CancellationToken cancellationToken = default)",
            "public static Task<ISymbol> SetBaseTypeAsync(this SymbolEditor editor, INamedTypeSymbol symbol, ITypeSymbol newBaseType, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions",
          "members": [
            "public static void AddAttribute(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode attribute)",
            "public static void AddAttributeArgument(this SyntaxEditor editor, SyntaxNode attributeDeclaration, SyntaxNode attributeArgument)",
            "public static void AddBaseType(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode baseType)",
            "public static void AddInterfaceType(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode interfaceType)",
            "public static void AddMember(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode member)",
            "public static void AddParameter(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode parameter)",
            "public static void AddReturnAttribute(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode attribute)",
            "public static void InsertMembers(this SyntaxEditor editor, SyntaxNode declaration, int index, IEnumerable<SyntaxNode> members)",
            "public static void SetAccessibility(this SyntaxEditor editor, SyntaxNode declaration, Accessibility accessibility)",
            "public static void SetExpression(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode expression)",
            "public static void SetGetAccessorStatements(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable<SyntaxNode> statements)",
            "public static void SetModifiers(this SyntaxEditor editor, SyntaxNode declaration, DeclarationModifiers modifiers)",
            "public static void SetName(this SyntaxEditor editor, SyntaxNode declaration, string name)",
            "public static void SetSetAccessorStatements(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable<SyntaxNode> statements)",
            "public static void SetStatements(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable<SyntaxNode> statements)",
            "public static void SetType(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode type)",
            "public static void SetTypeConstraint(this SyntaxEditor editor, SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kind, IEnumerable<SyntaxNode> types)",
            "public static void SetTypeParameters(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable<string> typeParameters)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.FindSymbols.SymbolFinder",
          "members": [
            "public static Task<IEnumerable<SymbolCallerInfo>> FindCallersAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<SymbolCallerInfo>> FindCallersAsync(ISymbol symbol, Solution solution, IImmutableSet<Document> documents, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ISymbol>> FindDeclarationsAsync(Project project, string name, bool ignoreCase, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ISymbol>> FindDeclarationsAsync(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<INamedTypeSymbol>> FindDerivedClassesAsync(INamedTypeSymbol type, Solution solution, IImmutableSet<Project> projects = null, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ISymbol>> FindImplementationsAsync(ISymbol symbol, Solution solution, IImmutableSet<Project> projects = null, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ISymbol>> FindImplementedInterfaceMembersAsync(ISymbol symbol, Solution solution, IImmutableSet<Project> projects = null, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ISymbol>> FindOverridesAsync(ISymbol symbol, Solution solution, IImmutableSet<Project> projects = null, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, IImmutableSet<Document> documents, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, IFindReferencesProgress progress, IImmutableSet<Document> documents, CancellationToken cancellationToken = default)",
            "public static IEnumerable<TSymbol> FindSimilarSymbols<TSymbol>(TSymbol symbol, Compilation compilation, CancellationToken cancellationToken = default) where TSymbol : ISymbol",
            "public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Project project, Func<string, bool> predicate, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Solution solution, Func<string, bool> predicate, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Project project, string name, bool ignoreCase, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Project project, Func<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Solution solution, string name, bool ignoreCase, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Solution solution, Func<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Solution solution, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken = default)",
            "public static Task<ISymbol> FindSourceDefinitionAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken = default)",
            "public static ISymbol FindSymbolAtPosition(SemanticModel semanticModel, int position, Workspace workspace, CancellationToken cancellationToken = default)",
            "public static Task<ISymbol> FindSymbolAtPositionAsync(Document document, int position, CancellationToken cancellationToken = default)",
            "public static Task<ISymbol> FindSymbolAtPositionAsync(SemanticModel semanticModel, int position, Workspace workspace, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Formatting.Formatter",
          "members": [
            "public static SyntaxAnnotation Annotation { get; }",
            "public static SyntaxNode Format(SyntaxNode node, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)",
            "public static SyntaxNode Format(SyntaxNode node, SyntaxAnnotation annotation, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)",
            "public static SyntaxNode Format(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)",
            "public static SyntaxNode Format(SyntaxNode node, IEnumerable<TextSpan> spans, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)",
            "public static Task<Document> FormatAsync(Document document, OptionSet options = null, CancellationToken cancellationToken = default)",
            "public static Task<Document> FormatAsync(Document document, SyntaxAnnotation annotation, OptionSet options = null, CancellationToken cancellationToken = default)",
            "public static Task<Document> FormatAsync(Document document, TextSpan span, OptionSet options = null, CancellationToken cancellationToken = default)",
            "public static Task<Document> FormatAsync(Document document, IEnumerable<TextSpan> spans, OptionSet options = null, CancellationToken cancellationToken = default)",
            "public static IList<TextChange> GetFormattedTextChanges(SyntaxNode node, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)",
            "public static IList<TextChange> GetFormattedTextChanges(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)",
            "public static IList<TextChange> GetFormattedTextChanges(SyntaxNode node, IEnumerable<TextSpan> spans, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Formatting.FormattingOptions",
          "members": [
            "public static PerLanguageOption<int> IndentationSize { get; }",
            "public static PerLanguageOption<string> NewLine { get; }",
            "public static PerLanguageOption<FormattingOptions.IndentStyle> SmartIndent { get; }",
            "public static PerLanguageOption<int> TabSize { get; }",
            "public static PerLanguageOption<bool> UseTabs { get; }"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Host.Mef.ServiceLayer",
          "members": [
            "public const string Default = \"Default\"",
            "public const string Desktop = \"Desktop\"",
            "public const string Editor = \"Editor\"",
            "public const string Host = \"Host\""
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Recommendations.RecommendationOptions",
          "members": [
            "public static PerLanguageOption<bool> FilterOutOfScopeLocals { get; }",
            "public static PerLanguageOption<bool> HideAdvancedMembers { get; }"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Recommendations.Recommender",
          "members": [
            "public static IEnumerable<ISymbol> GetRecommendedSymbolsAtPosition(SemanticModel semanticModel, int position, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)",
            "public static Task<IEnumerable<ISymbol>> GetRecommendedSymbolsAtPositionAsync(SemanticModel semanticModel, int position, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Rename.RenameOptions",
          "members": [
            "public static Option<bool> PreviewChanges { get; }",
            "public static Option<bool> RenameInComments { get; }",
            "public static Option<bool> RenameInStrings { get; }",
            "public static Option<bool> RenameOverloads { get; }"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Rename.Renamer",
          "members": [
            "public static Task<Solution> RenameSymbolAsync(Solution solution, ISymbol symbol, string newName, OptionSet optionSet, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Semantics.OperationExtensions",
          "members": [
            "public static IEnumerable<IOperation> Descendants(this IOperation operation)",
            "public static IEnumerable<IOperation> DescendantsAndSelf(this IOperation operation)",
            "public static ImmutableArray<ILocalSymbol> GetDeclaredVariables(this IVariableDeclarationStatement declarationStatement)",
            "public static IOperation GetRootOperation(this ISymbol symbol, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Semantics.UnaryAndBinaryOperationExtensions",
          "members": [
            "public static BinaryOperandsKind GetBinaryOperandsKind(this IBinaryOperatorExpression binary)",
            "public static BinaryOperandsKind GetBinaryOperandsKind(this ICompoundAssignmentExpression compoundAssignment)",
            "public static BinaryOperandsKind GetBinaryOperandsKind(BinaryOperationKind kind)",
            "public static SimpleBinaryOperationKind GetSimpleBinaryOperationKind(this IBinaryOperatorExpression binary)",
            "public static SimpleBinaryOperationKind GetSimpleBinaryOperationKind(this ICompoundAssignmentExpression compoundAssignment)",
            "public static SimpleBinaryOperationKind GetSimpleBinaryOperationKind(BinaryOperationKind kind)",
            "public static SimpleUnaryOperationKind GetSimpleUnaryOperationKind(this IIncrementExpression increment)",
            "public static SimpleUnaryOperationKind GetSimpleUnaryOperationKind(UnaryOperationKind kind)",
            "public static SimpleUnaryOperationKind GetSimpleUnaryOperationKind(this IUnaryOperatorExpression unary)",
            "public static UnaryOperandKind GetUnaryOperandKind(this IIncrementExpression increment)",
            "public static UnaryOperandKind GetUnaryOperandKind(UnaryOperationKind kind)",
            "public static UnaryOperandKind GetUnaryOperandKind(this IUnaryOperatorExpression unary)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Simplification.SimplificationOptions",
          "members": [
            "public static Option<bool> AllowSimplificationToBaseType { get; }",
            "public static Option<bool> AllowSimplificationToGenericType { get; }",
            "public static Option<bool> PreferAliasToQualification { get; }",
            "public static Option<bool> PreferImplicitTypeInLocalDeclaration { get; }",
            "public static Option<bool> PreferImplicitTypeInference { get; }",
            "public static PerLanguageOption<bool> PreferIntrinsicPredefinedTypeKeywordInDeclaration { get; }",
            "public static PerLanguageOption<bool> PreferIntrinsicPredefinedTypeKeywordInMemberAccess { get; }",
            "public static Option<bool> PreferOmittingModuleNamesInQualification { get; }",
            "public static PerLanguageOption<bool> QualifyEventAccess { get; }",
            "public static PerLanguageOption<bool> QualifyFieldAccess { get; }",
            "public static PerLanguageOption<bool> QualifyMemberAccessWithThisOrMe { get; }",
            "public static PerLanguageOption<bool> QualifyMethodAccess { get; }",
            "public static PerLanguageOption<bool> QualifyPropertyAccess { get; }"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Simplification.Simplifier",
          "members": [
            "public static SyntaxAnnotation Annotation { get; }",
            "public static SyntaxAnnotation SpecialTypeAnnotation { get; }",
            "public static SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, Workspace workspace, Func<SyntaxNode, bool> expandInsideNode = null, CancellationToken cancellationToken = default)",
            "public static TNode Expand<TNode>(TNode node, SemanticModel semanticModel, Workspace workspace, Func<SyntaxNode, bool> expandInsideNode = null, bool expandParameter = false, CancellationToken cancellationToken = default) where TNode : SyntaxNode",
            "public static Task<SyntaxToken> ExpandAsync(SyntaxToken token, Document document, Func<SyntaxNode, bool> expandInsideNode = null, CancellationToken cancellationToken = default)",
            "public static Task<TNode> ExpandAsync<TNode>(TNode node, Document document, Func<SyntaxNode, bool> expandInsideNode = null, bool expandParameter = false, CancellationToken cancellationToken = default) where TNode : SyntaxNode",
            "public static Task<Document> ReduceAsync(Document document, OptionSet optionSet = null, CancellationToken cancellationToken = default)",
            "public static Task<Document> ReduceAsync(Document document, SyntaxAnnotation annotation, OptionSet optionSet = null, CancellationToken cancellationToken = default)",
            "public static Task<Document> ReduceAsync(Document document, TextSpan span, OptionSet optionSet = null, CancellationToken cancellationToken = default)",
            "public static Task<Document> ReduceAsync(Document document, IEnumerable<TextSpan> spans, OptionSet optionSet = null, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Microsoft.CodeAnalysis.Tags.WellKnownTags",
          "members": [
            "public const string Assembly = \"Assembly\"",
            "public const string Class = \"Class\"",
            "public const string Constant = \"Constant\"",
            "public const string Delegate = \"Delegate\"",
            "public const string Enum = \"Enum\"",
            "public const string EnumMember = \"EnumMember\"",
            "public const string Error = \"Error\"",
            "public const string Event = \"Event\"",
            "public const string ExtensionMethod = \"ExtensionMethod\"",
            "public const string Field = \"Field\"",
            "public const string File = \"File\"",
            "public const string Folder = \"Folder\"",
            "public const string Interface = \"Interface\"",
            "public const string Internal = \"Internal\"",
            "public const string Intrinsic = \"Intrinsic\"",
            "public const string Keyword = \"Keyword\"",
            "public const string Label = \"Label\"",
            "public const string Local = \"Local\"",
            "public const string Method = \"Method\"",
            "public const string Module = \"Module\"",
            "public const string Namespace = \"Namespace\"",
            "public const string Operator = \"Operator\"",
            "public const string Parameter = \"Parameter\"",
            "public const string Private = \"Private\"",
            "public const string Project = \"Project\"",
            "public const string Property = \"Property\"",
            "public const string Protected = \"Protected\"",
            "public const string Public = \"Public\"",
            "public const string RangeVariable = \"RangeVariable\"",
            "public const string Reference = \"Reference\"",
            "public const string Snippet = \"Snippet\"",
            "public const string Structure = \"Structure\"",
            "public const string TypeParameter = \"TypeParameter\"",
            "public const string Warning = \"Warning\""
          ]
        },
        {
          "type": "public static class Roslynator.DiagnosticsExtensions",
          "members": [
            "public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary<string, string> properties, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary<string, string> properties, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary<string, string> properties, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, ImmutableDictionary<string, string> properties, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, ImmutableDictionary<string, string> properties, params object[] messageArgs)",
            "public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, ImmutableDictionary<string, string> properties, params object[] messageArgs)"
          ]
        },
        {
          "type": "public static class Roslynator.EnumExtensions",
          "members": [
            "public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2)",
            "public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2)",
            "public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2)",
            "public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2)",
            "public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3)",
            "public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3)",
            "public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3)",
            "public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3)",
            "public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3, Accessibility accessibility4)",
            "public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3, MethodKind methodKind4)",
            "public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3, SpecialType specialType4)",
            "public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3, TypeKind typeKind4)",
            "public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3, Accessibility accessibility4, Accessibility accessibility5)",
            "public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3, MethodKind methodKind4, MethodKind methodKind5)",
            "public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3, SpecialType specialType4, SpecialType specialType5)",
            "public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3, TypeKind typeKind4, TypeKind typeKind5)",
            "public static bool IsMoreRestrictiveThan(this Accessibility accessibility, Accessibility other)"
          ]
        },
        {
          "type": "public static class Roslynator.FileLinePositionSpanExtensions",
          "members": [
            "public static int EndLine(this FileLinePositionSpan fileLinePositionSpan)",
            "public static bool IsMultiLine(this FileLinePositionSpan fileLinePositionSpan)",
            "public static bool IsSingleLine(this FileLinePositionSpan fileLinePositionSpan)",
            "public static int StartLine(this FileLinePositionSpan fileLinePositionSpan)"
          ]
        },
        {
          "type": "public static class Roslynator.SemanticModelExtensions",
          "members": [
            "public static INamedTypeSymbol GetEnclosingNamedType(this SemanticModel semanticModel, int position, CancellationToken cancellationToken = default)",
            "public static TSymbol GetEnclosingSymbol<TSymbol>(this SemanticModel semanticModel, int position, CancellationToken cancellationToken = default) where TSymbol : ISymbol",
            "public static ISymbol GetSymbol(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default)",
            "public static INamedTypeSymbol GetTypeByMetadataName(this SemanticModel semanticModel, string fullyQualifiedMetadataName)",
            "public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Roslynator.SymbolExtensions",
          "members": [
            "public static IEnumerable<INamedTypeSymbol> BaseTypes(this ITypeSymbol type)",
            "public static IEnumerable<ITypeSymbol> BaseTypesAndSelf(this ITypeSymbol typeSymbol)",
            "public static bool EqualsOrInheritsFrom(this ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces = false)",
            "public static bool EqualsOrInheritsFrom(this ITypeSymbol type, in MetadataName baseTypeName, bool includeInterfaces = false)",
            "public static TSymbol FindMember<TSymbol>(this ITypeSymbol typeSymbol, Func<TSymbol, bool> predicate = null) where TSymbol : ISymbol",
            "public static TSymbol FindMember<TSymbol>(this ITypeSymbol typeSymbol, string name, Func<TSymbol, bool> predicate = null) where TSymbol : ISymbol",
            "public static TSymbol FindMember<TSymbol>(this INamedTypeSymbol typeSymbol, Func<TSymbol, bool> predicate, bool includeBaseTypes = false) where TSymbol : ISymbol",
            "public static TSymbol FindMember<TSymbol>(this INamedTypeSymbol typeSymbol, string name, Func<TSymbol, bool> predicate = null, bool includeBaseTypes = false) where TSymbol : ISymbol",
            "public static INamedTypeSymbol FindTypeMember(this INamedTypeSymbol typeSymbol, Func<INamedTypeSymbol, bool> predicate, bool includeBaseTypes = false)",
            "public static INamedTypeSymbol FindTypeMember(this INamedTypeSymbol typeSymbol, string name, Func<INamedTypeSymbol, bool> predicate = null, bool includeBaseTypes = false)",
            "public static INamedTypeSymbol FindTypeMember(this INamedTypeSymbol typeSymbol, string name, int arity, Func<INamedTypeSymbol, bool> predicate = null, bool includeBaseTypes = false)",
            "public static AttributeData GetAttribute(this ISymbol symbol, INamedTypeSymbol attributeClass)",
            "public static AttributeData GetAttribute(this ISymbol symbol, in MetadataName attributeName)",
            "public static bool HasAttribute(this ISymbol symbol, INamedTypeSymbol attributeClass)",
            "public static bool HasAttribute(this ISymbol symbol, in MetadataName attributeName)",
            "public static bool HasAttribute(this ITypeSymbol typeSymbol, INamedTypeSymbol attributeClass, bool includeBaseTypes)",
            "public static bool HasAttribute(this ITypeSymbol typeSymbol, in MetadataName attributeName, bool includeBaseTypes)",
            "public static bool HasConstantValue(this IFieldSymbol fieldSymbol, bool value)",
            "public static bool HasConstantValue(this IFieldSymbol fieldSymbol, char value)",
            "public static bool HasConstantValue(this IFieldSymbol fieldSymbol, sbyte value)",
            "public static bool HasConstantValue(this IFieldSymbol fieldSymbol, byte value)",
            "public static bool HasConstantValue(this IFieldSymbol fieldSymbol, short value)",
            "public static bool HasConstantValue(this IFieldSymbol fieldSymbol, ushort value)",
            "public static bool HasConstantValue(this IFieldSymbol fieldSymbol, int value)",
            "public static bool HasConstantValue(this IFieldSymbol fieldSymbol, uint value)",
            "public static bool HasConstantValue(this IFieldSymbol fieldSymbol, long value)",
            "public static bool HasConstantValue(this IFieldSymbol fieldSymbol, ulong value)",
            "public static bool HasConstantValue(this IFieldSymbol fieldSymbol, decimal value)",
            "public static bool HasConstantValue(this IFieldSymbol fieldSymbol, float value)",
            "public static bool HasConstantValue(this IFieldSymbol fieldSymbol, double value)",
            "public static bool HasConstantValue(this IFieldSymbol fieldSymbol, string value)",
            "public static bool HasMetadataName(this ISymbol symbol, in MetadataName metadataName)",
            "public static bool Implements(this ITypeSymbol typeSymbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false)",
            "public static bool Implements(this ITypeSymbol typeSymbol, SpecialType interfaceType, bool allInterfaces = false)",
            "public static bool Implements(this ITypeSymbol typeSymbol, in MetadataName interfaceName, bool allInterfaces = false)",
            "public static bool ImplementsAny(this ITypeSymbol typeSymbol, SpecialType interfaceType1, SpecialType interfaceType2, bool allInterfaces = false)",
            "public static bool ImplementsAny(this ITypeSymbol typeSymbol, SpecialType interfaceType1, SpecialType interfaceType2, SpecialType interfaceType3, bool allInterfaces = false)",
            "public static bool ImplementsInterfaceMember(this ISymbol symbol, bool allInterfaces = false)",
            "public static bool ImplementsInterfaceMember(this ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false)",
            "public static bool ImplementsInterfaceMember<TSymbol>(this ISymbol symbol, bool allInterfaces = false) where TSymbol : ISymbol",
            "public static bool ImplementsInterfaceMember<TSymbol>(this ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false) where TSymbol : ISymbol",
            "public static bool InheritsFrom(this ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces = false)",
            "public static bool InheritsFrom(this ITypeSymbol type, in MetadataName baseTypeName, bool includeInterfaces = false)",
            "public static bool IsAsyncMethod(this ISymbol symbol)",
            "public static bool IsErrorType(this ISymbol symbol)",
            "public static bool IsIEnumerableOfT(this ITypeSymbol typeSymbol)",
            "public static bool IsIEnumerableOrIEnumerableOfT(this ITypeSymbol typeSymbol)",
            "public static bool IsKind(this ISymbol symbol, SymbolKind kind)",
            "public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2)",
            "public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3)",
            "public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3, SymbolKind kind4)",
            "public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3, SymbolKind kind4, SymbolKind kind5)",
            "public static bool IsNullableOf(this INamedTypeSymbol namedTypeSymbol, SpecialType specialType)",
            "public static bool IsNullableOf(this INamedTypeSymbol namedTypeSymbol, ITypeSymbol typeArgument)",
            "public static bool IsNullableOf(this ITypeSymbol typeSymbol, SpecialType specialType)",
            "public static bool IsNullableOf(this ITypeSymbol typeSymbol, ITypeSymbol typeArgument)",
            "public static bool IsNullableType(this ITypeSymbol typeSymbol)",
            "public static bool IsObject(this ITypeSymbol typeSymbol)",
            "public static bool IsOrdinaryExtensionMethod(this IMethodSymbol methodSymbol)",
            "public static bool IsParameterArrayOf(this IParameterSymbol parameterSymbol, SpecialType elementType)",
            "public static bool IsParameterArrayOf(this IParameterSymbol parameterSymbol, SpecialType elementType1, SpecialType elementType2)",
            "public static bool IsParameterArrayOf(this IParameterSymbol parameterSymbol, SpecialType elementType1, SpecialType elementType2, SpecialType elementType3)",
            "public static bool IsPubliclyVisible(this ISymbol symbol)",
            "public static bool IsReducedExtensionMethod(this IMethodSymbol methodSymbol)",
            "public static bool IsRefOrOut(this IParameterSymbol parameterSymbol)",
            "public static bool IsReferenceTypeOrNullableType(this ITypeSymbol typeSymbol)",
            "public static bool IsString(this ITypeSymbol typeSymbol)",
            "public static bool IsVoid(this ITypeSymbol typeSymbol)",
            "public static IMethodSymbol ReducedFromOrSelf(this IMethodSymbol methodSymbol)",
            "public static bool SupportsExplicitDeclaration(this ITypeSymbol typeSymbol)"
          ]
        },
        {
          "type": "public static class Roslynator.SyntaxExtensions",
          "members": [
            "public static bool All(this SyntaxTokenList list, Func<SyntaxToken, bool> predicate)",
            "public static bool All(this SyntaxTriviaList list, Func<SyntaxTrivia, bool> predicate)",
            "public static bool All<TNode>(this SeparatedSyntaxList<TNode> list, Func<TNode, bool> predicate) where TNode : SyntaxNode",
            "public static bool All<TNode>(this SyntaxList<TNode> list, Func<TNode, bool> predicate) where TNode : SyntaxNode",
            "public static bool Any(this SyntaxTokenList list, Func<SyntaxToken, bool> predicate)",
            "public static bool Any(this SyntaxTriviaList list, Func<SyntaxTrivia, bool> predicate)",
            "public static bool Any<TNode>(this SeparatedSyntaxList<TNode> list, Func<TNode, bool> predicate) where TNode : SyntaxNode",
            "public static bool Any<TNode>(this SyntaxList<TNode> list, Func<TNode, bool> predicate) where TNode : SyntaxNode",
            "public static SyntaxToken AppendToLeadingTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia)",
            "public static SyntaxToken AppendToLeadingTrivia(this SyntaxToken token, SyntaxTrivia trivia)",
            "public static TNode AppendToLeadingTrivia<TNode>(this TNode node, IEnumerable<SyntaxTrivia> trivia) where TNode : SyntaxNode",
            "public static TNode AppendToLeadingTrivia<TNode>(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode",
            "public static SyntaxToken AppendToTrailingTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia)",
            "public static SyntaxToken AppendToTrailingTrivia(this SyntaxToken token, SyntaxTrivia trivia)",
            "public static TNode AppendToTrailingTrivia<TNode>(this TNode node, IEnumerable<SyntaxTrivia> trivia) where TNode : SyntaxNode",
            "public static TNode AppendToTrailingTrivia<TNode>(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode",
            "public static bool Contains(this SyntaxTokenList tokens, SyntaxToken token)",
            "public static bool Contains<TNode>(this SeparatedSyntaxList<TNode> list, TNode node) where TNode : SyntaxNode",
            "public static bool Contains<TNode>(this SyntaxList<TNode> list, TNode node) where TNode : SyntaxNode",
            "public static bool ContainsDirectives(this SyntaxNode node, TextSpan span)",
            "public static IEnumerable<SyntaxTrivia> DescendantTrivia<TNode>(this SyntaxList<TNode> list, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode",
            "public static IEnumerable<SyntaxTrivia> DescendantTrivia<TNode>(this SyntaxList<TNode> list, TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode",
            "public static TNode FirstAncestor<TNode>(this SyntaxNode node, Func<TNode, bool> predicate = null, bool ascendOutOfTrivia = true) where TNode : SyntaxNode",
            "public static TNode FirstDescendant<TNode>(this SyntaxNode node, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode",
            "public static TNode FirstDescendant<TNode>(this SyntaxNode node, TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode",
            "public static TNode FirstDescendantOrSelf<TNode>(this SyntaxNode node, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode",
            "public static TNode FirstDescendantOrSelf<TNode>(this SyntaxNode node, TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode",
            "public static SyntaxTriviaList GetLeadingAndTrailingTrivia(this SyntaxNode node)",
            "public static SyntaxToken GetTrailingSeparator<TNode>(this SeparatedSyntaxList<TNode> list) where TNode : SyntaxNode",
            "public static bool HasTrailingSeparator<TNode>(this SeparatedSyntaxList<TNode> list) where TNode : SyntaxNode",
            "public static int IndexOf(this SyntaxTokenList tokens, Func<SyntaxToken, bool> predicate)",
            "public static int IndexOf(this SyntaxTriviaList triviaList, Func<SyntaxTrivia, bool> predicate)",
            "public static bool IsFirst<TNode>(this SeparatedSyntaxList<TNode> list, TNode node) where TNode : SyntaxNode",
            "public static bool IsFirst<TNode>(this SyntaxList<TNode> list, TNode node) where TNode : SyntaxNode",
            "public static bool IsLast<TNode>(this SeparatedSyntaxList<TNode> list, TNode node) where TNode : SyntaxNode",
            "public static bool IsLast<TNode>(this SyntaxList<TNode> list, TNode node) where TNode : SyntaxNode",
            "public static SyntaxTriviaList LeadingAndTrailingTrivia(this SyntaxToken token)",
            "public static SyntaxToken PrependToLeadingTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia)",
            "public static SyntaxToken PrependToLeadingTrivia(this SyntaxToken token, SyntaxTrivia trivia)",
            "public static TNode PrependToLeadingTrivia<TNode>(this TNode node, IEnumerable<SyntaxTrivia> trivia) where TNode : SyntaxNode",
            "public static TNode PrependToLeadingTrivia<TNode>(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode",
            "public static SyntaxToken PrependToTrailingTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia)",
            "public static SyntaxToken PrependToTrailingTrivia(this SyntaxToken token, SyntaxTrivia trivia)",
            "public static TNode PrependToTrailingTrivia<TNode>(this TNode node, IEnumerable<SyntaxTrivia> trivia) where TNode : SyntaxNode",
            "public static TNode PrependToTrailingTrivia<TNode>(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode",
            "public static SyntaxTokenList ReplaceAt(this SyntaxTokenList tokenList, int index, SyntaxToken newToken)",
            "public static SyntaxTriviaList ReplaceAt(this SyntaxTriviaList triviaList, int index, SyntaxTrivia newTrivia)",
            "public static SeparatedSyntaxList<TNode> ReplaceAt<TNode>(this SeparatedSyntaxList<TNode> list, int index, TNode newNode) where TNode : SyntaxNode",
            "public static SyntaxList<TNode> ReplaceAt<TNode>(this SyntaxList<TNode> list, int index, TNode newNode) where TNode : SyntaxNode",
            "public static bool SpanContainsDirectives(this SyntaxNode node)",
            "public static bool TryGetContainingList(this SyntaxTrivia trivia, out SyntaxTriviaList triviaList, bool allowLeading = true, bool allowTrailing = true)",
            "public static SyntaxToken WithTriviaFrom(this SyntaxToken token, SyntaxNode node)",
            "public static SeparatedSyntaxList<TNode> WithTriviaFrom<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxNode node) where TNode : SyntaxNode",
            "public static SyntaxList<TNode> WithTriviaFrom<TNode>(this SyntaxList<TNode> list, SyntaxNode node) where TNode : SyntaxNode",
            "public static TNode WithTriviaFrom<TNode>(this TNode node, SyntaxToken token) where TNode : SyntaxNode",
            "public static SyntaxNodeOrToken WithoutLeadingTrivia(this SyntaxNodeOrToken nodeOrToken)",
            "public static SyntaxToken WithoutLeadingTrivia(this SyntaxToken token)",
            "public static SyntaxNodeOrToken WithoutTrailingTrivia(this SyntaxNodeOrToken nodeOrToken)",
            "public static SyntaxToken WithoutTrailingTrivia(this SyntaxToken token)",
            "public static SyntaxNodeOrToken WithoutTrivia(this SyntaxNodeOrToken nodeOrToken)"
          ]
        },
        {
          "type": "public static class Roslynator.SyntaxTreeExtensions",
          "members": [
            "public static int GetEndLine(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default)",
            "public static int GetStartLine(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default)",
            "public static bool IsMultiLineSpan(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default)",
            "public static bool IsSingleLineSpan(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Roslynator.WorkspaceExtensions",
          "members": [
            "public static Task<Document> InsertNodeAfterAsync(this Document document, SyntaxNode nodeInList, SyntaxNode newNode, CancellationToken cancellationToken = default)",
            "public static Task<Document> InsertNodeBeforeAsync(this Document document, SyntaxNode nodeInList, SyntaxNode newNode, CancellationToken cancellationToken = default)",
            "public static Task<Document> InsertNodesAfterAsync(this Document document, SyntaxNode nodeInList, IEnumerable<SyntaxNode> newNodes, CancellationToken cancellationToken = default)",
            "public static Task<Document> InsertNodesBeforeAsync(this Document document, SyntaxNode nodeInList, IEnumerable<SyntaxNode> newNodes, CancellationToken cancellationToken = default)",
            "public static Task<Document> RemoveNodeAsync(this Document document, SyntaxNode node, SyntaxRemoveOptions options, CancellationToken cancellationToken = default)",
            "public static Task<Document> RemoveNodesAsync(this Document document, IEnumerable<SyntaxNode> nodes, SyntaxRemoveOptions options, CancellationToken cancellationToken = default)",
            "public static Task<Document> ReplaceNodeAsync(this Document document, SyntaxNode oldNode, SyntaxNode newNode, CancellationToken cancellationToken = default)",
            "public static Task<Document> ReplaceNodeAsync(this Document document, SyntaxNode oldNode, IEnumerable<SyntaxNode> newNodes, CancellationToken cancellationToken = default)",
            "public static Task<Solution> ReplaceNodeAsync<TNode>(this Solution solution, TNode oldNode, TNode newNode, CancellationToken cancellationToken = default) where TNode : SyntaxNode",
            "public static Task<Document> ReplaceNodesAsync<TNode>(this Document document, IEnumerable<TNode> nodes, Func<TNode, TNode, SyntaxNode> computeReplacementNode, CancellationToken cancellationToken = default) where TNode : SyntaxNode",
            "public static Task<Solution> ReplaceNodesAsync<TNode>(this Solution solution, IEnumerable<TNode> nodes, Func<TNode, TNode, SyntaxNode> computeReplacementNodes, CancellationToken cancellationToken = default) where TNode : SyntaxNode",
            "public static Task<Document> ReplaceTokenAsync(this Document document, SyntaxToken oldToken, SyntaxToken newToken, CancellationToken cancellationToken = default)",
            "public static Task<Document> ReplaceTokenAsync(this Document document, SyntaxToken oldToken, IEnumerable<SyntaxToken> newTokens, CancellationToken cancellationToken = default)",
            "public static Task<Document> ReplaceTriviaAsync(this Document document, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia, CancellationToken cancellationToken = default)",
            "public static Task<Document> ReplaceTriviaAsync(this Document document, SyntaxTrivia oldTrivia, IEnumerable<SyntaxTrivia> newTrivia, CancellationToken cancellationToken = default)",
            "public static Task<Document> WithTextChangeAsync(this Document document, TextChange textChange, CancellationToken cancellationToken = default)",
            "public static Task<Document> WithTextChangesAsync(this Document document, TextChange[] textChanges, CancellationToken cancellationToken = default)",
            "public static Task<Document> WithTextChangesAsync(this Document document, IEnumerable<TextChange> textChanges, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Roslynator.CSharp.CSharpExtensions",
          "members": [
            "public static IParameterSymbol DetermineParameter(this SemanticModel semanticModel, ArgumentSyntax argument, bool allowParams = false, bool allowCandidate = false, CancellationToken cancellationToken = default)",
            "public static IParameterSymbol DetermineParameter(this SemanticModel semanticModel, AttributeArgumentSyntax attributeArgument, bool allowParams = false, bool allowCandidate = false, CancellationToken cancellationToken = default)",
            "public static ExtensionMethodSymbolInfo GetExtensionMethodInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)",
            "public static IMethodSymbol GetMethodSymbol(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)",
            "public static ExtensionMethodSymbolInfo GetReducedExtensionMethodInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)",
            "public static ISymbol GetSymbol(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default)",
            "public static ISymbol GetSymbol(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default)",
            "public static ISymbol GetSymbol(this SemanticModel semanticModel, CrefSyntax cref, CancellationToken cancellationToken = default)",
            "public static ISymbol GetSymbol(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)",
            "public static ISymbol GetSymbol(this SemanticModel semanticModel, OrderingSyntax ordering, CancellationToken cancellationToken = default)",
            "public static ISymbol GetSymbol(this SemanticModel semanticModel, SelectOrGroupClauseSyntax selectOrGroupClause, CancellationToken cancellationToken = default)",
            "public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default)",
            "public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default)",
            "public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)",
            "public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, SelectOrGroupClauseSyntax selectOrGroupClause, CancellationToken cancellationToken = default)",
            "public static bool HasConstantValue(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)",
            "public static bool IsDefaultValue(this SemanticModel semanticModel, ITypeSymbol typeSymbol, ExpressionSyntax expression, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Roslynator.CSharp.CSharpFactory",
          "members": [
            "public static AccessorListSyntax AccessorList(AccessorDeclarationSyntax accessor)",
            "public static AccessorListSyntax AccessorList(params AccessorDeclarationSyntax[] accessors)",
            "public static AccessorDeclarationSyntax AddAccessorDeclaration(BlockSyntax body)",
            "public static AccessorDeclarationSyntax AddAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody)",
            "public static AccessorDeclarationSyntax AddAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body)",
            "public static AccessorDeclarationSyntax AddAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody)",
            "public static AssignmentExpressionSyntax AddAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static AssignmentExpressionSyntax AddAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax AddExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax AddExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static PrefixUnaryExpressionSyntax AddressOfExpression(ExpressionSyntax operand)",
            "public static PrefixUnaryExpressionSyntax AddressOfExpression(ExpressionSyntax operand, SyntaxToken operatorToken)",
            "public static AssignmentExpressionSyntax AndAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static AssignmentExpressionSyntax AndAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static ArgumentSyntax Argument(NameColonSyntax nameColon, ExpressionSyntax expression)",
            "public static ArgumentListSyntax ArgumentList(ArgumentSyntax argument)",
            "public static ArgumentListSyntax ArgumentList(params ArgumentSyntax[] arguments)",
            "public static InitializerExpressionSyntax ArrayInitializerExpression(SeparatedSyntaxList<ExpressionSyntax> expressions = default)",
            "public static InitializerExpressionSyntax ArrayInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)",
            "public static BinaryExpressionSyntax AsExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax AsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentSyntax argument)",
            "public static AttributeArgumentSyntax AttributeArgument(NameColonSyntax nameColon, ExpressionSyntax expression)",
            "public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, ExpressionSyntax expression)",
            "public static AttributeArgumentListSyntax AttributeArgumentList(AttributeArgumentSyntax attributeArgument)",
            "public static AttributeArgumentListSyntax AttributeArgumentList(params AttributeArgumentSyntax[] attributeArguments)",
            "public static AttributeListSyntax AttributeList(AttributeSyntax attribute)",
            "public static AttributeListSyntax AttributeList(params AttributeSyntax[] attributes)",
            "public static AccessorDeclarationSyntax AutoGetAccessorDeclaration(SyntaxTokenList modifiers = default)",
            "public static AccessorDeclarationSyntax AutoSetAccessorDeclaration(SyntaxTokenList modifiers = default)",
            "public static ConstructorInitializerSyntax BaseConstructorInitializer(ArgumentListSyntax argumentList = null)",
            "public static ConstructorInitializerSyntax BaseConstructorInitializer(SyntaxToken semicolonToken, ArgumentListSyntax argumentList)",
            "public static BaseListSyntax BaseList(BaseTypeSyntax type)",
            "public static BaseListSyntax BaseList(params BaseTypeSyntax[] types)",
            "public static BaseListSyntax BaseList(SyntaxToken colonToken, BaseTypeSyntax baseType)",
            "public static BaseListSyntax BaseList(SyntaxToken colonToken, params BaseTypeSyntax[] types)",
            "public static BinaryExpressionSyntax BitwiseAndExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax BitwiseAndExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static PrefixUnaryExpressionSyntax BitwiseNotExpression(ExpressionSyntax operand)",
            "public static PrefixUnaryExpressionSyntax BitwiseNotExpression(ExpressionSyntax operand, SyntaxToken operatorToken)",
            "public static BinaryExpressionSyntax BitwiseOrExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax BitwiseOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static BlockSyntax Block(StatementSyntax statement)",
            "public static BlockSyntax Block(SyntaxToken openBrace, StatementSyntax statement, SyntaxToken closeBrace)",
            "public static LiteralExpressionSyntax BooleanLiteralExpression(bool value)",
            "public static BracketedArgumentListSyntax BracketedArgumentList(ArgumentSyntax argument)",
            "public static BracketedArgumentListSyntax BracketedArgumentList(params ArgumentSyntax[] arguments)",
            "public static BracketedParameterListSyntax BracketedParameterList(ParameterSyntax parameter)",
            "public static BracketedParameterListSyntax BracketedParameterList(params ParameterSyntax[] parameters)",
            "public static LiteralExpressionSyntax CharacterLiteralExpression(char value)",
            "public static CheckedExpressionSyntax CheckedExpression(ExpressionSyntax expression)",
            "public static CheckedExpressionSyntax CheckedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)",
            "public static ClassOrStructConstraintSyntax ClassConstraint()",
            "public static ClassDeclarationSyntax ClassDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList<MemberDeclarationSyntax> members = default)",
            "public static ClassDeclarationSyntax ClassDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList<MemberDeclarationSyntax> members = default)",
            "public static BinaryExpressionSyntax CoalesceExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax CoalesceExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static InitializerExpressionSyntax CollectionInitializerExpression(SeparatedSyntaxList<ExpressionSyntax> expressions = default)",
            "public static InitializerExpressionSyntax CollectionInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)",
            "public static CompilationUnitSyntax CompilationUnit(MemberDeclarationSyntax member)",
            "public static CompilationUnitSyntax CompilationUnit(SyntaxList<UsingDirectiveSyntax> usings, MemberDeclarationSyntax member)",
            "public static CompilationUnitSyntax CompilationUnit(SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members)",
            "public static InitializerExpressionSyntax ComplexElementInitializerExpression(SeparatedSyntaxList<ExpressionSyntax> expressions = default)",
            "public static InitializerExpressionSyntax ComplexElementInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)",
            "public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body)",
            "public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)",
            "public static LiteralExpressionSyntax DefaultLiteralExpression()",
            "public static SwitchSectionSyntax DefaultSwitchSection(StatementSyntax statement)",
            "public static SwitchSectionSyntax DefaultSwitchSection(SyntaxList<StatementSyntax> statements)",
            "public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, string identifier, ParameterListSyntax parameterList)",
            "public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList)",
            "public static AssignmentExpressionSyntax DivideAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static AssignmentExpressionSyntax DivideAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static SyntaxTrivia EmptyWhitespace()",
            "public static EnumDeclarationSyntax EnumDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members)",
            "public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier, ExpressionSyntax value)",
            "public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier, EqualsValueClauseSyntax value)",
            "public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string name, ExpressionSyntax value)",
            "public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string name, EqualsValueClauseSyntax value)",
            "public static BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static EventDeclarationSyntax EventDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, AccessorListSyntax accessorList)",
            "public static EventDeclarationSyntax EventDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, AccessorListSyntax accessorList)",
            "public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier)",
            "public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier)",
            "public static AssignmentExpressionSyntax ExclusiveOrAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static AssignmentExpressionSyntax ExclusiveOrAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static ConversionOperatorDeclarationSyntax ExplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body)",
            "public static ConversionOperatorDeclarationSyntax ExplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)",
            "public static LiteralExpressionSyntax FalseLiteralExpression()",
            "public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, EqualsValueClauseSyntax initializer)",
            "public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer)",
            "public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, ExpressionSyntax value = null)",
            "public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null)",
            "public static GenericNameSyntax GenericName(string identifier, TypeSyntax typeArgument)",
            "public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeSyntax typeArgument)",
            "public static AccessorDeclarationSyntax GetAccessorDeclaration(BlockSyntax body)",
            "public static AccessorDeclarationSyntax GetAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody)",
            "public static AccessorDeclarationSyntax GetAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body)",
            "public static AccessorDeclarationSyntax GetAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody)",
            "public static BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static ConversionOperatorDeclarationSyntax ImplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body)",
            "public static ConversionOperatorDeclarationSyntax ImplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)",
            "public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxTokenList modifiers, TypeSyntax type, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList)",
            "public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxTokenList modifiers, TypeSyntax type, BracketedParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)",
            "public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList<MemberDeclarationSyntax> members = default)",
            "public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList<MemberDeclarationSyntax> members = default)",
            "public static BinaryExpressionSyntax IsExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax IsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static AssignmentExpressionSyntax LeftShiftAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static AssignmentExpressionSyntax LeftShiftAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static LiteralExpressionSyntax LiteralExpression(object value)",
            "public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, string identifier, EqualsValueClauseSyntax initializer)",
            "public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer)",
            "public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, string identifier, ExpressionSyntax value = null)",
            "public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null)",
            "public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body)",
            "public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)",
            "public static BinaryExpressionSyntax LogicalAndExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax LogicalAndExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static PrefixUnaryExpressionSyntax LogicalNotExpression(ExpressionSyntax operand)",
            "public static PrefixUnaryExpressionSyntax LogicalNotExpression(ExpressionSyntax operand, SyntaxToken operatorToken)",
            "public static BinaryExpressionSyntax LogicalOrExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax LogicalOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static MethodDeclarationSyntax MethodDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body)",
            "public static MethodDeclarationSyntax MethodDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)",
            "public static AssignmentExpressionSyntax ModuloAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static AssignmentExpressionSyntax ModuloAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static AssignmentExpressionSyntax MultiplyAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static AssignmentExpressionSyntax MultiplyAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static InvocationExpressionSyntax NameOfExpression(ExpressionSyntax expression)",
            "public static InvocationExpressionSyntax NameOfExpression(string identifier)",
            "public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, MemberDeclarationSyntax member)",
            "public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, SyntaxList<MemberDeclarationSyntax> members)",
            "public static SyntaxTrivia NewLine()",
            "public static BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static LiteralExpressionSyntax NullLiteralExpression()",
            "public static LiteralExpressionSyntax NumericLiteralExpression(int value)",
            "public static LiteralExpressionSyntax NumericLiteralExpression(uint value)",
            "public static LiteralExpressionSyntax NumericLiteralExpression(sbyte value)",
            "public static LiteralExpressionSyntax NumericLiteralExpression(decimal value)",
            "public static LiteralExpressionSyntax NumericLiteralExpression(double value)",
            "public static LiteralExpressionSyntax NumericLiteralExpression(float value)",
            "public static LiteralExpressionSyntax NumericLiteralExpression(long value)",
            "public static LiteralExpressionSyntax NumericLiteralExpression(ulong value)",
            "public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type, ArgumentListSyntax argumentList)",
            "public static InitializerExpressionSyntax ObjectInitializerExpression(SeparatedSyntaxList<ExpressionSyntax> expressions = default)",
            "public static InitializerExpressionSyntax ObjectInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)",
            "public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body)",
            "public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)",
            "public static AssignmentExpressionSyntax OrAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static AssignmentExpressionSyntax OrAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static ParameterSyntax Parameter(TypeSyntax type, string identifier, ExpressionSyntax @default = null)",
            "public static ParameterSyntax Parameter(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax @default = null)",
            "public static ParameterSyntax Parameter(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)",
            "public static ParameterListSyntax ParameterList(ParameterSyntax parameter)",
            "public static ParameterListSyntax ParameterList(params ParameterSyntax[] parameters)",
            "public static PrefixUnaryExpressionSyntax PointerIndirectionExpression(ExpressionSyntax operand)",
            "public static PrefixUnaryExpressionSyntax PointerIndirectionExpression(ExpressionSyntax operand, SyntaxToken operatorToken)",
            "public static PostfixUnaryExpressionSyntax PostDecrementExpression(ExpressionSyntax operand)",
            "public static PostfixUnaryExpressionSyntax PostDecrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken)",
            "public static PostfixUnaryExpressionSyntax PostIncrementExpression(ExpressionSyntax operand)",
            "public static PostfixUnaryExpressionSyntax PostIncrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken)",
            "public static PrefixUnaryExpressionSyntax PreDecrementExpression(ExpressionSyntax operand)",
            "public static PrefixUnaryExpressionSyntax PreDecrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken)",
            "public static PrefixUnaryExpressionSyntax PreIncrementExpression(ExpressionSyntax operand)",
            "public static PrefixUnaryExpressionSyntax PreIncrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken)",
            "public static PredefinedTypeSyntax PredefinedBoolType()",
            "public static PredefinedTypeSyntax PredefinedByteType()",
            "public static PredefinedTypeSyntax PredefinedCharType()",
            "public static PredefinedTypeSyntax PredefinedDecimalType()",
            "public static PredefinedTypeSyntax PredefinedDoubleType()",
            "public static PredefinedTypeSyntax PredefinedFloatType()",
            "public static PredefinedTypeSyntax PredefinedIntType()",
            "public static PredefinedTypeSyntax PredefinedLongType()",
            "public static PredefinedTypeSyntax PredefinedObjectType()",
            "public static PredefinedTypeSyntax PredefinedSByteType()",
            "public static PredefinedTypeSyntax PredefinedShortType()",
            "public static PredefinedTypeSyntax PredefinedStringType()",
            "public static PredefinedTypeSyntax PredefinedUIntType()",
            "public static PredefinedTypeSyntax PredefinedULongType()",
            "public static PredefinedTypeSyntax PredefinedUShortType()",
            "public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, ArrowExpressionClauseSyntax expressionBody)",
            "public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, AccessorListSyntax accessorList, ExpressionSyntax value = null)",
            "public static AccessorDeclarationSyntax RemoveAccessorDeclaration(BlockSyntax body)",
            "public static AccessorDeclarationSyntax RemoveAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody)",
            "public static AccessorDeclarationSyntax RemoveAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body)",
            "public static AccessorDeclarationSyntax RemoveAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody)",
            "public static AssignmentExpressionSyntax RightShiftAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static AssignmentExpressionSyntax RightShiftAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static AccessorDeclarationSyntax SetAccessorDeclaration(BlockSyntax body)",
            "public static AccessorDeclarationSyntax SetAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody)",
            "public static AccessorDeclarationSyntax SetAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body)",
            "public static AccessorDeclarationSyntax SetAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody)",
            "public static AssignmentExpressionSyntax SimpleAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static AssignmentExpressionSyntax SimpleAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static ExpressionStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right)",
            "public static ExpressionStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, SimpleNameSyntax name)",
            "public static MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)",
            "public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name)",
            "public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name, ArgumentSyntax argument)",
            "public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name, ArgumentListSyntax argumentList)",
            "public static LiteralExpressionSyntax StringLiteralExpression(string value)",
            "public static ClassOrStructConstraintSyntax StructConstraint()",
            "public static StructDeclarationSyntax StructDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList<MemberDeclarationSyntax> members = default)",
            "public static StructDeclarationSyntax StructDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList<MemberDeclarationSyntax> members = default)",
            "public static AssignmentExpressionSyntax SubtractAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static AssignmentExpressionSyntax SubtractAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, ExpressionSyntax right)",
            "public static BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)",
            "public static SwitchSectionSyntax SwitchSection(SwitchLabelSyntax switchLabel, StatementSyntax statement)",
            "public static SwitchSectionSyntax SwitchSection(SwitchLabelSyntax switchLabel, SyntaxList<StatementSyntax> statements)",
            "public static SwitchSectionSyntax SwitchSection(SyntaxList<SwitchLabelSyntax> switchLabels, StatementSyntax statement)",
            "public static ConstructorInitializerSyntax ThisConstructorInitializer(ArgumentListSyntax argumentList = null)",
            "public static ConstructorInitializerSyntax ThisConstructorInitializer(SyntaxToken semicolonToken, ArgumentListSyntax argumentList)",
            "public static SyntaxTokenList TokenList(Accessibility accessibility)",
            "public static SyntaxTokenList TokenList(SyntaxKind kind)",
            "public static SyntaxTokenList TokenList(SyntaxKind kind1, SyntaxKind kind2)",
            "public static SyntaxTokenList TokenList(SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)",
            "public static LiteralExpressionSyntax TrueLiteralExpression()",
            "public static TryStatementSyntax TryStatement(BlockSyntax block, CatchClauseSyntax @catch, FinallyClauseSyntax @finally = null)",
            "public static TypeArgumentListSyntax TypeArgumentList(TypeSyntax argument)",
            "public static TypeArgumentListSyntax TypeArgumentList(params TypeSyntax[] arguments)",
            "public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax identifierName, TypeParameterConstraintSyntax typeParameterConstraint)",
            "public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string name, TypeParameterConstraintSyntax typeParameterConstraint)",
            "public static TypeParameterListSyntax TypeParameterList(TypeParameterSyntax parameter)",
            "public static TypeParameterListSyntax TypeParameterList(params TypeParameterSyntax[] parameters)",
            "public static PrefixUnaryExpressionSyntax UnaryMinusExpression(ExpressionSyntax operand)",
            "public static PrefixUnaryExpressionSyntax UnaryMinusExpression(ExpressionSyntax operand, SyntaxToken operatorToken)",
            "public static PrefixUnaryExpressionSyntax UnaryPlusExpression(ExpressionSyntax operand)",
            "public static PrefixUnaryExpressionSyntax UnaryPlusExpression(ExpressionSyntax operand, SyntaxToken operatorToken)",
            "public static CheckedExpressionSyntax UncheckedExpression(ExpressionSyntax expression)",
            "public static CheckedExpressionSyntax UncheckedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)",
            "public static UsingDirectiveSyntax UsingStaticDirective(NameSyntax name)",
            "public static UsingDirectiveSyntax UsingStaticDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameSyntax name, SyntaxToken semicolonToken)",
            "public static IdentifierNameSyntax VarType()",
            "public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, VariableDeclaratorSyntax variable)",
            "public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer)",
            "public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, string identifier, ExpressionSyntax value = null)",
            "public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null)",
            "public static VariableDeclaratorSyntax VariableDeclarator(string identifier, EqualsValueClauseSyntax initializer)",
            "public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, EqualsValueClauseSyntax initializer)",
            "public static PredefinedTypeSyntax VoidType()",
            "public static YieldStatementSyntax YieldBreakStatement()",
            "public static YieldStatementSyntax YieldReturnStatement(ExpressionSyntax expression)"
          ]
        },
        {
          "type": "public static class Roslynator.CSharp.CSharpFacts",
          "members": [
            "public static bool CanBeEmbeddedStatement(SyntaxKind kind)",
            "public static bool CanHaveEmbeddedStatement(SyntaxKind kind)",
            "public static bool CanHaveExpressionBody(SyntaxKind kind)",
            "public static bool CanHaveMembers(SyntaxKind kind)",
            "public static bool CanHaveModifiers(SyntaxKind kind)",
            "public static bool CanHaveStatements(SyntaxKind kind)",
            "public static bool IsAnonymousFunctionExpression(SyntaxKind kind)",
            "public static bool IsBooleanExpression(SyntaxKind kind)",
            "public static bool IsBooleanLiteralExpression(SyntaxKind kind)",
            "public static bool IsCommentTrivia(SyntaxKind kind)",
            "public static bool IsCompoundAssignmentExpression(SyntaxKind kind)",
            "public static bool IsConstraint(SyntaxKind kind)",
            "public static bool IsFunction(SyntaxKind kind)",
            "public static bool IsIfElseDirective(SyntaxKind kind)",
            "public static bool IsIncrementOrDecrementExpression(SyntaxKind kind)",
            "public static bool IsIterationStatement(SyntaxKind kind)",
            "public static bool IsJumpStatement(SyntaxKind kind)",
            "public static bool IsLambdaExpression(SyntaxKind kind)",
            "public static bool IsLiteralExpression(SyntaxKind kind)",
            "public static bool IsPredefinedType(SpecialType specialType)",
            "public static bool IsSimpleType(SpecialType specialType)",
            "public static bool IsSwitchLabel(SyntaxKind kind)",
            "public static bool SupportsPrefixOrPostfixUnaryOperator(SpecialType specialType)"
          ]
        },
        {
          "type": "public static class Roslynator.CSharp.EnumExtensions",
          "members": [
            "public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2)",
            "public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)",
            "public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)",
            "public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)",
            "public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)"
          ]
        },
        {
          "type": "public static class Roslynator.CSharp.ModifierList",
          "members": [
            "public static int GetInsertIndex(SyntaxTokenList tokens, SyntaxKind kind, IComparer<SyntaxKind> comparer = null)",
            "public static int GetInsertIndex(SyntaxTokenList tokens, SyntaxToken token, IComparer<SyntaxToken> comparer = null)",
            "public static SyntaxTokenList Insert(SyntaxTokenList modifiers, SyntaxKind kind, IComparer<SyntaxKind> comparer = null)",
            "public static SyntaxTokenList Insert(SyntaxTokenList modifiers, SyntaxToken modifier, IComparer<SyntaxToken> comparer = null)",
            "public static TNode Insert<TNode>(TNode node, SyntaxKind kind, IComparer<SyntaxKind> comparer = null) where TNode : SyntaxNode",
            "public static TNode Insert<TNode>(TNode node, SyntaxToken modifier, IComparer<SyntaxToken> comparer = null) where TNode : SyntaxNode",
            "public static TNode Remove<TNode>(TNode node, SyntaxKind kind) where TNode : SyntaxNode",
            "public static TNode Remove<TNode>(TNode node, SyntaxToken modifier) where TNode : SyntaxNode",
            "public static TNode RemoveAll<TNode>(TNode node) where TNode : SyntaxNode",
            "public static TNode RemoveAll<TNode>(TNode node, Func<SyntaxToken, bool> predicate) where TNode : SyntaxNode",
            "public static TNode RemoveAt<TNode>(TNode node, int index) where TNode : SyntaxNode"
          ]
        },
        {
          "type": "public static class Roslynator.CSharp.Modifiers",
          "members": [
            "public static SyntaxTokenList Const()",
            "public static SyntaxTokenList Internal()",
            "public static SyntaxTokenList Internal_Abstract()",
            "public static SyntaxTokenList Internal_Const()",
            "public static SyntaxTokenList Internal_Override()",
            "public static SyntaxTokenList Internal_Partial()",
            "public static SyntaxTokenList Internal_ReadOnly()",
            "public static SyntaxTokenList Internal_Static()",
            "public static SyntaxTokenList Internal_Static_Partial()",
            "public static SyntaxTokenList Internal_Static_ReadOnly()",
            "public static SyntaxTokenList Internal_Virtual()",
            "public static SyntaxTokenList Partial()",
            "public static SyntaxTokenList Private()",
            "public static SyntaxTokenList Private_Const()",
            "public static SyntaxTokenList Private_Partial()",
            "public static SyntaxTokenList Private_Protected()",
            "public static SyntaxTokenList Private_ReadOnly()",
            "public static SyntaxTokenList Private_Static()",
            "public static SyntaxTokenList Private_Static_Partial()",
            "public static SyntaxTokenList Private_Static_ReadOnly()",
            "public static SyntaxTokenList Protected()",
            "public static SyntaxTokenList Protected_Abstract()",
            "public static SyntaxTokenList Protected_Const()",
            "public static SyntaxTokenList Protected_Internal()",
            "public static SyntaxTokenList Protected_Override()",
            "public static SyntaxTokenList Protected_ReadOnly()",
            "public static SyntaxTokenList Protected_Static()",
            "public static SyntaxTokenList Protected_Static_ReadOnly()",
            "public static SyntaxTokenList Protected_Virtual()",
            "public static SyntaxTokenList Public()",
            "public static SyntaxTokenList Public_Abstract()",
            "public static SyntaxTokenList Public_Const()",
            "public static SyntaxTokenList Public_Override()",
            "public static SyntaxTokenList Public_Partial()",
            "public static SyntaxTokenList Public_ReadOnly()",
            "public static SyntaxTokenList Public_Static()",
            "public static SyntaxTokenList Public_Static_Partial()",
            "public static SyntaxTokenList Public_Static_ReadOnly()",
            "public static SyntaxTokenList Public_Virtual()",
            "public static SyntaxTokenList ReadOnly()",
            "public static SyntaxTokenList Ref_ReadOnly()",
            "public static SyntaxTokenList Static()",
            "public static SyntaxTokenList Static_ReadOnly()",
            "public static SyntaxTokenList Virtual()"
          ]
        },
        {
          "type": "public static class Roslynator.CSharp.SymbolExtensions",
          "members": [
            "public static bool SupportsConstantValue(this ITypeSymbol typeSymbol)",
            "public static TypeSyntax ToMinimalTypeSyntax(this INamespaceOrTypeSymbol namespaceOrTypeSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)",
            "public static TypeSyntax ToMinimalTypeSyntax(this INamespaceSymbol namespaceSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)",
            "public static TypeSyntax ToMinimalTypeSyntax(this ITypeSymbol typeSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)",
            "public static TypeSyntax ToTypeSyntax(this INamespaceOrTypeSymbol namespaceOrTypeSymbol, SymbolDisplayFormat format = null)",
            "public static TypeSyntax ToTypeSyntax(this INamespaceSymbol namespaceSymbol, SymbolDisplayFormat format = null)",
            "public static TypeSyntax ToTypeSyntax(this ITypeSymbol typeSymbol, SymbolDisplayFormat format = null)"
          ]
        },
        {
          "type": "public static class Roslynator.CSharp.SyntaxAccessibility",
          "members": [
            "public static Accessibility GetAccessibility(SyntaxNode declaration)",
            "public static Accessibility GetDefaultAccessibility(SyntaxNode declaration)",
            "public static Accessibility GetDefaultExplicitAccessibility(SyntaxNode declaration)",
            "public static Accessibility GetExplicitAccessibility(SyntaxNode declaration)",
            "public static Accessibility GetExplicitAccessibility(SyntaxTokenList modifiers)",
            "public static bool IsPubliclyVisible(MemberDeclarationSyntax declaration)",
            "public static bool IsValidAccessibility(SyntaxNode node, Accessibility accessibility, bool ignoreOverride = false)",
            "public static TNode WithExplicitAccessibility<TNode>(TNode node, Accessibility newAccessibility, IComparer<SyntaxKind> comparer = null) where TNode : SyntaxNode",
            "public static TNode WithoutExplicitAccessibility<TNode>(TNode node) where TNode : SyntaxNode"
          ]
        },
        {
          "type": "public static class Roslynator.CSharp.SyntaxExtensions",
          "members": [
            "public static SyntaxList<StatementSyntax> Add(this SyntaxList<StatementSyntax> statements, StatementSyntax statement, bool ignoreLocalFunctions)",
            "public static ClassDeclarationSyntax AddAttributeLists(this ClassDeclarationSyntax classDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax[] attributeLists)",
            "public static InterfaceDeclarationSyntax AddAttributeLists(this InterfaceDeclarationSyntax interfaceDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax[] attributeLists)",
            "public static StructDeclarationSyntax AddAttributeLists(this StructDeclarationSyntax structDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax[] attributeLists)",
            "public static CompilationUnitSyntax AddUsings(this CompilationUnitSyntax compilationUnit, bool keepSingleLineCommentsOnTop, params UsingDirectiveSyntax[] usings)",
            "public static IfStatementCascade AsCascade(this IfStatementSyntax ifStatement)",
            "public static ExpressionChain AsChain(this BinaryExpressionSyntax binaryExpression, TextSpan? span = null)",
            "public static CSharpSyntaxNode BodyOrExpressionBody(this AccessorDeclarationSyntax accessorDeclaration)",
            "public static CSharpSyntaxNode BodyOrExpressionBody(this ConstructorDeclarationSyntax constructorDeclaration)",
            "public static CSharpSyntaxNode BodyOrExpressionBody(this ConversionOperatorDeclarationSyntax conversionOperatorDeclaration)",
            "public static CSharpSyntaxNode BodyOrExpressionBody(this DestructorDeclarationSyntax destructorDeclaration)",
            "public static CSharpSyntaxNode BodyOrExpressionBody(this LocalFunctionStatementSyntax localFunctionStatement)",
            "public static CSharpSyntaxNode BodyOrExpressionBody(this MethodDeclarationSyntax methodDeclaration)",
            "public static CSharpSyntaxNode BodyOrExpressionBody(this OperatorDeclarationSyntax operatorDeclaration)",
            "public static TextSpan BracesSpan(this ClassDeclarationSyntax classDeclaration)",
            "public static TextSpan BracesSpan(this EnumDeclarationSyntax enumDeclaration)",
            "public static TextSpan BracesSpan(this InterfaceDeclarationSyntax interfaceDeclaration)",
            "public static TextSpan BracesSpan(this NamespaceDeclarationSyntax namespaceDeclaration)",
            "public static TextSpan BracesSpan(this StructDeclarationSyntax structDeclaration)",
            "public static bool Contains(this SyntaxTokenList tokenList, SyntaxKind kind)",
            "public static bool Contains(this SyntaxTriviaList triviaList, SyntaxKind kind)",
            "public static bool Contains<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode",
            "public static bool Contains<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode",
            "public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2)",
            "public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)",
            "public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)",
            "public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)",
            "public static bool ContainsDefaultLabel(this SwitchSectionSyntax switchSection)",
            "public static bool ContainsYield(this LocalFunctionStatementSyntax localFunctionStatement)",
            "public static bool ContainsYield(this MethodDeclarationSyntax methodDeclaration)",
            "public static CSharpSyntaxNode DeclarationOrExpression(this UsingStatementSyntax usingStatement)",
            "public static SwitchSectionSyntax DefaultSection(this SwitchStatementSyntax switchStatement)",
            "public static IEnumerable<XmlElementSyntax> Elements(this DocumentationCommentTriviaSyntax documentationComment, string localName)",
            "public static SyntaxToken Find(this SyntaxTokenList tokenList, SyntaxKind kind)",
            "public static SyntaxTrivia Find(this SyntaxTriviaList triviaList, SyntaxKind kind)",
            "public static TNode Find<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode",
            "public static TNode Find<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode",
            "public static SyntaxNode FirstAncestor(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true)",
            "public static SyntaxNode FirstAncestor(this SyntaxNode node, Func<SyntaxNode, bool> predicate, bool ascendOutOfTrivia = true)",
            "public static SyntaxNode FirstAncestor(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, bool ascendOutOfTrivia = true)",
            "public static SyntaxNode FirstAncestor(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, bool ascendOutOfTrivia = true)",
            "public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true)",
            "public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, Func<SyntaxNode, bool> predicate, bool ascendOutOfTrivia = true)",
            "public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, bool ascendOutOfTrivia = true)",
            "public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, bool ascendOutOfTrivia = true)",
            "public static IfStatementCascadeInfo GetCascadeInfo(this IfStatementSyntax ifStatement)",
            "public static DocumentationCommentTriviaSyntax GetDocumentationComment(this MemberDeclarationSyntax member)",
            "public static SyntaxTrivia GetDocumentationCommentTrivia(this MemberDeclarationSyntax member)",
            "public static EndRegionDirectiveTriviaSyntax GetEndRegionDirective(this RegionDirectiveTriviaSyntax regionDirective)",
            "public static DirectiveTriviaSyntax GetFirstDirective(this SyntaxNode node, TextSpan span, Func<DirectiveTriviaSyntax, bool> predicate = null)",
            "public static DirectiveTriviaSyntax GetNextRelatedDirective(this DirectiveTriviaSyntax directiveTrivia)",
            "public static SyntaxTrivia GetPreprocessingMessageTrivia(this EndRegionDirectiveTriviaSyntax endRegionDirective)",
            "public static SyntaxTrivia GetPreprocessingMessageTrivia(this RegionDirectiveTriviaSyntax regionDirective)",
            "public static RegionDirectiveTriviaSyntax GetRegionDirective(this EndRegionDirectiveTriviaSyntax endRegionDirective)",
            "public static DocumentationCommentTriviaSyntax GetSingleLineDocumentationComment(this MemberDeclarationSyntax member)",
            "public static SyntaxTrivia GetSingleLineDocumentationCommentTrivia(this MemberDeclarationSyntax member)",
            "public static IfStatementSyntax GetTopmostIf(this ElseClauseSyntax elseClause)",
            "public static IfStatementSyntax GetTopmostIf(this IfStatementSyntax ifStatement)",
            "public static AccessorDeclarationSyntax Getter(this AccessorListSyntax accessorList)",
            "public static AccessorDeclarationSyntax Getter(this IndexerDeclarationSyntax indexerDeclaration)",
            "public static AccessorDeclarationSyntax Getter(this PropertyDeclarationSyntax propertyDeclaration)",
            "public static bool HasDocumentationComment(this MemberDeclarationSyntax member)",
            "public static bool HasSingleLineDocumentationComment(this MemberDeclarationSyntax member)",
            "public static bool IsAutoImplemented(this AccessorDeclarationSyntax accessorDeclaration)",
            "public static bool IsDescendantOf(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true)",
            "public static bool IsEmbedded(this StatementSyntax statement, bool canBeBlock = false, bool canBeIfInsideElse = true, bool canBeUsingInsideUsing = true)",
            "public static bool IsEmptyOrWhitespace(this SyntaxTriviaList triviaList)",
            "public static bool IsEndOfLineTrivia(this SyntaxTrivia trivia)",
            "public static bool IsHexNumericLiteral(this LiteralExpressionSyntax literalExpression)",
            "public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2)",
            "public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2)",
            "public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2)",
            "public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)",
            "public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)",
            "public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)",
            "public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)",
            "public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)",
            "public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)",
            "public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)",
            "public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)",
            "public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)",
            "public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)",
            "public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)",
            "public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)",
            "public static bool IsLast(this SyntaxList<StatementSyntax> statements, StatementSyntax statement, bool ignoreLocalFunctions)",
            "public static bool IsParams(this ParameterSyntax parameter)",
            "public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind)",
            "public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind)",
            "public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2)",
            "public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2)",
            "public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)",
            "public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)",
            "public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)",
            "public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)",
            "public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)",
            "public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)",
            "public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)",
            "public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)",
            "public static bool IsSimpleIf(this IfStatementSyntax ifStatement)",
            "public static bool IsTopmostIf(this IfStatementSyntax ifStatement)",
            "public static bool IsVerbatim(this InterpolatedStringExpressionSyntax interpolatedString)",
            "public static bool IsVoid(this TypeSyntax type)",
            "public static bool IsWhitespaceOrEndOfLineTrivia(this SyntaxTrivia trivia)",
            "public static bool IsWhitespaceTrivia(this SyntaxTrivia trivia)",
            "public static bool IsYieldBreak(this YieldStatementSyntax yieldStatement)",
            "public static bool IsYieldReturn(this YieldStatementSyntax yieldStatement)",
            "public static int LastIndexOf(this SyntaxTriviaList triviaList, SyntaxKind kind)",
            "public static int LastIndexOf<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode",
            "public static int LastIndexOf<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode",
            "public static StatementSyntax NextStatement(this StatementSyntax statement)",
            "public static TextSpan ParenthesesSpan(this CastExpressionSyntax castExpression)",
            "public static TextSpan ParenthesesSpan(this CommonForEachStatementSyntax forEachStatement)",
            "public static TextSpan ParenthesesSpan(this ForStatementSyntax forStatement)",
            "public static StatementSyntax PreviousStatement(this StatementSyntax statement)",
            "public static SyntaxTokenList RemoveRange(this SyntaxTokenList list, int index, int count)",
            "public static SyntaxTriviaList RemoveRange(this SyntaxTriviaList list, int index, int count)",
            "public static SeparatedSyntaxList<TNode> RemoveRange<TNode>(this SeparatedSyntaxList<TNode> list, int index, int count) where TNode : SyntaxNode",
            "public static SyntaxList<TNode> RemoveRange<TNode>(this SyntaxList<TNode> list, int index, int count) where TNode : SyntaxNode",
            "public static TNode RemoveTrivia<TNode>(this TNode node, TextSpan? span = null) where TNode : SyntaxNode",
            "public static TNode RemoveWhitespace<TNode>(this TNode node, TextSpan? span = null) where TNode : SyntaxNode",
            "public static SyntaxTokenList ReplaceRange(this SyntaxTokenList list, int index, int count, IEnumerable<SyntaxToken> newTokens)",
            "public static SyntaxTriviaList ReplaceRange(this SyntaxTriviaList list, int index, int count, IEnumerable<SyntaxTrivia> newTrivia)",
            "public static SeparatedSyntaxList<TNode> ReplaceRange<TNode>(this SeparatedSyntaxList<TNode> list, int index, int count, IEnumerable<TNode> newNodes) where TNode : SyntaxNode",
            "public static SyntaxList<TNode> ReplaceRange<TNode>(this SyntaxList<TNode> list, int index, int count, IEnumerable<TNode> newNodes) where TNode : SyntaxNode",
            "public static TNode ReplaceWhitespace<TNode>(this TNode node, SyntaxTrivia replacement, TextSpan? span = null) where TNode : SyntaxNode",
            "public static bool ReturnsVoid(this DelegateDeclarationSyntax delegateDeclaration)",
            "public static bool ReturnsVoid(this LocalFunctionStatementSyntax localFunctionStatement)",
            "public static bool ReturnsVoid(this MethodDeclarationSyntax methodDeclaration)",
            "public static AccessorDeclarationSyntax Setter(this AccessorListSyntax accessorList)",
            "public static AccessorDeclarationSyntax Setter(this IndexerDeclarationSyntax indexerDeclaration)",
            "public static AccessorDeclarationSyntax Setter(this PropertyDeclarationSyntax propertyDeclaration)",
            "public static SeparatedSyntaxList<TNode> ToSeparatedSyntaxList<TNode>(this IEnumerable<TNode> nodes) where TNode : SyntaxNode",
            "public static SeparatedSyntaxList<TNode> ToSeparatedSyntaxList<TNode>(this IEnumerable<SyntaxNodeOrToken> nodesAndTokens) where TNode : SyntaxNode",
            "public static SyntaxList<TNode> ToSyntaxList<TNode>(this IEnumerable<TNode> nodes) where TNode : SyntaxNode",
            "public static SyntaxTokenList ToSyntaxTokenList(this IEnumerable<SyntaxToken> tokens)",
            "public static SyntaxToken TrimLeadingTrivia(this SyntaxToken token)",
            "public static TNode TrimLeadingTrivia<TNode>(this TNode node) where TNode : SyntaxNode",
            "public static SyntaxToken TrimTrailingTrivia(this SyntaxToken token)",
            "public static TNode TrimTrailingTrivia<TNode>(this TNode node) where TNode : SyntaxNode",
            "public static SyntaxToken TrimTrivia(this SyntaxToken token)",
            "public static TNode TrimTrivia<TNode>(this TNode node) where TNode : SyntaxNode",
            "public static bool TryGetContainingList(this StatementSyntax statement, out SyntaxList<StatementSyntax> statements)",
            "public static ExpressionSyntax WalkDownParentheses(this ExpressionSyntax expression)",
            "public static ExpressionSyntax WalkUpParentheses(this ExpressionSyntax expression)",
            "public static ClassDeclarationSyntax WithMembers(this ClassDeclarationSyntax classDeclaration, MemberDeclarationSyntax member)",
            "public static ClassDeclarationSyntax WithMembers(this ClassDeclarationSyntax classDeclaration, IEnumerable<MemberDeclarationSyntax> members)",
            "public static CompilationUnitSyntax WithMembers(this CompilationUnitSyntax compilationUnit, MemberDeclarationSyntax member)",
            "public static CompilationUnitSyntax WithMembers(this CompilationUnitSyntax compilationUnit, IEnumerable<MemberDeclarationSyntax> members)",
            "public static InterfaceDeclarationSyntax WithMembers(this InterfaceDeclarationSyntax interfaceDeclaration, MemberDeclarationSyntax member)",
            "public static InterfaceDeclarationSyntax WithMembers(this InterfaceDeclarationSyntax interfaceDeclaration, IEnumerable<MemberDeclarationSyntax> members)",
            "public static NamespaceDeclarationSyntax WithMembers(this NamespaceDeclarationSyntax namespaceDeclaration, MemberDeclarationSyntax member)",
            "public static NamespaceDeclarationSyntax WithMembers(this NamespaceDeclarationSyntax namespaceDeclaration, IEnumerable<MemberDeclarationSyntax> members)",
            "public static StructDeclarationSyntax WithMembers(this StructDeclarationSyntax structDeclaration, MemberDeclarationSyntax member)",
            "public static StructDeclarationSyntax WithMembers(this StructDeclarationSyntax structDeclaration, IEnumerable<MemberDeclarationSyntax> members)"
          ]
        },
        {
          "type": "public static class Roslynator.CSharp.SyntaxInfo",
          "members": [
            "public static AsExpressionInfo AsExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static AsExpressionInfo AsExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static AssignmentExpressionInfo AssignmentExpressionInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static AssignmentExpressionInfo AssignmentExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static BinaryExpressionInfo BinaryExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static BinaryExpressionInfo BinaryExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static ConditionalExpressionInfo ConditionalExpressionInfo(ConditionalExpressionSyntax conditionalExpression, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static ConditionalExpressionInfo ConditionalExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static GenericInfo GenericInfo(TypeParameterConstraintClauseSyntax constraintClause)",
            "public static GenericInfo GenericInfo(DelegateDeclarationSyntax delegateDeclaration)",
            "public static GenericInfo GenericInfo(LocalFunctionStatementSyntax localFunctionStatement)",
            "public static GenericInfo GenericInfo(MethodDeclarationSyntax methodDeclaration)",
            "public static GenericInfo GenericInfo(SyntaxNode node)",
            "public static GenericInfo GenericInfo(TypeDeclarationSyntax typeDeclaration)",
            "public static GenericInfo GenericInfo(TypeParameterSyntax typeParameter)",
            "public static GenericInfo GenericInfo(TypeParameterConstraintSyntax typeParameterConstraint)",
            "public static GenericInfo GenericInfo(TypeParameterListSyntax typeParameterList)",
            "public static IsExpressionInfo IsExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static IsExpressionInfo IsExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static LocalDeclarationStatementInfo LocalDeclarationStatementInfo(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing = false)",
            "public static LocalDeclarationStatementInfo LocalDeclarationStatementInfo(ExpressionSyntax value, bool allowMissing = false)",
            "public static MemberDeclarationListInfo MemberDeclarationListInfo(CompilationUnitSyntax compilationUnit)",
            "public static MemberDeclarationListInfo MemberDeclarationListInfo(NamespaceDeclarationSyntax declaration)",
            "public static MemberDeclarationListInfo MemberDeclarationListInfo(TypeDeclarationSyntax declaration)",
            "public static MemberDeclarationListInfo MemberDeclarationListInfo(ClassDeclarationSyntax declaration)",
            "public static MemberDeclarationListInfo MemberDeclarationListInfo(StructDeclarationSyntax declaration)",
            "public static MemberDeclarationListInfo MemberDeclarationListInfo(InterfaceDeclarationSyntax declaration)",
            "public static MemberDeclarationListInfo MemberDeclarationListInfo(SyntaxNode node)",
            "public static ModifierListInfo ModifierListInfo(AccessorDeclarationSyntax accessorDeclaration)",
            "public static ModifierListInfo ModifierListInfo(ClassDeclarationSyntax classDeclaration)",
            "public static ModifierListInfo ModifierListInfo(ConstructorDeclarationSyntax constructorDeclaration)",
            "public static ModifierListInfo ModifierListInfo(ConversionOperatorDeclarationSyntax conversionOperatorDeclaration)",
            "public static ModifierListInfo ModifierListInfo(DelegateDeclarationSyntax delegateDeclaration)",
            "public static ModifierListInfo ModifierListInfo(DestructorDeclarationSyntax destructorDeclaration)",
            "public static ModifierListInfo ModifierListInfo(EnumDeclarationSyntax enumDeclaration)",
            "public static ModifierListInfo ModifierListInfo(EventDeclarationSyntax eventDeclaration)",
            "public static ModifierListInfo ModifierListInfo(EventFieldDeclarationSyntax eventFieldDeclaration)",
            "public static ModifierListInfo ModifierListInfo(FieldDeclarationSyntax fieldDeclaration)",
            "public static ModifierListInfo ModifierListInfo(IncompleteMemberSyntax incompleteMember)",
            "public static ModifierListInfo ModifierListInfo(IndexerDeclarationSyntax indexerDeclaration)",
            "public static ModifierListInfo ModifierListInfo(InterfaceDeclarationSyntax interfaceDeclaration)",
            "public static ModifierListInfo ModifierListInfo(LocalDeclarationStatementSyntax localDeclarationStatement)",
            "public static ModifierListInfo ModifierListInfo(LocalFunctionStatementSyntax localFunctionStatement)",
            "public static ModifierListInfo ModifierListInfo(MethodDeclarationSyntax methodDeclaration)",
            "public static ModifierListInfo ModifierListInfo(SyntaxNode node)",
            "public static ModifierListInfo ModifierListInfo(OperatorDeclarationSyntax operatorDeclaration)",
            "public static ModifierListInfo ModifierListInfo(ParameterSyntax parameter)",
            "public static ModifierListInfo ModifierListInfo(PropertyDeclarationSyntax propertyDeclaration)",
            "public static ModifierListInfo ModifierListInfo(StructDeclarationSyntax structDeclaration)",
            "public static NullCheckExpressionInfo NullCheckExpressionInfo(SyntaxNode node, NullCheckStyles allowedStyles = ComparisonToNull | IsPattern, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static NullCheckExpressionInfo NullCheckExpressionInfo(SyntaxNode node, SemanticModel semanticModel, NullCheckStyles allowedStyles = All, bool walkDownParentheses = true, bool allowMissing = false, CancellationToken cancellationToken = default)",
            "public static RegionInfo RegionInfo(EndRegionDirectiveTriviaSyntax endRegionDirective)",
            "public static RegionInfo RegionInfo(RegionDirectiveTriviaSyntax regionDirective)",
            "public static SimpleAssignmentExpressionInfo SimpleAssignmentExpressionInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static SimpleAssignmentExpressionInfo SimpleAssignmentExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(ExpressionStatementSyntax expressionStatement, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(StatementSyntax statement, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static SimpleIfElseInfo SimpleIfElseInfo(IfStatementSyntax ifStatement, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static SimpleIfStatementInfo SimpleIfStatementInfo(IfStatementSyntax ifStatement, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static SimpleIfStatementInfo SimpleIfStatementInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static SimpleMemberInvocationExpressionInfo SimpleMemberInvocationExpressionInfo(InvocationExpressionSyntax invocationExpression, bool allowMissing = false)",
            "public static SimpleMemberInvocationExpressionInfo SimpleMemberInvocationExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(ExpressionStatementSyntax expressionStatement, bool allowMissing = false)",
            "public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(InvocationExpressionSyntax invocationExpression, bool allowMissing = false)",
            "public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(SyntaxNode node, bool allowMissing = false)",
            "public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(ExpressionSyntax value)",
            "public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing = false)",
            "public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(VariableDeclarationSyntax variableDeclaration, bool allowMissing = false)",
            "public static SingleParameterLambdaExpressionInfo SingleParameterLambdaExpressionInfo(LambdaExpressionSyntax lambdaExpression, bool allowMissing = false)",
            "public static SingleParameterLambdaExpressionInfo SingleParameterLambdaExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)",
            "public static StatementListInfo StatementListInfo(StatementSyntax statement)",
            "public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(BinaryExpressionSyntax binaryExpression, SemanticModel semanticModel, CancellationToken cancellationToken = default)",
            "public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(in ExpressionChain expressionChain, SemanticModel semanticModel, CancellationToken cancellationToken = default)",
            "public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(SyntaxNode node, SemanticModel semanticModel, bool walkDownParentheses = true, CancellationToken cancellationToken = default)",
            "public static StringLiteralExpressionInfo StringLiteralExpressionInfo(LiteralExpressionSyntax literalExpression)",
            "public static StringLiteralExpressionInfo StringLiteralExpressionInfo(SyntaxNode node, bool walkDownParentheses = true)",
            "public static UsingDirectiveListInfo UsingDirectiveListInfo(CompilationUnitSyntax compilationUnit)",
            "public static UsingDirectiveListInfo UsingDirectiveListInfo(NamespaceDeclarationSyntax declaration)",
            "public static UsingDirectiveListInfo UsingDirectiveListInfo(SyntaxNode node)",
            "public static XmlElementInfo XmlElementInfo(XmlNodeSyntax xmlNode)"
          ]
        },
        {
          "type": "public static class Roslynator.CSharp.SyntaxInverter",
          "members": [
            "public static ExpressionSyntax LogicallyInvert(ExpressionSyntax expression, CancellationToken cancellationToken = default)",
            "public static ExpressionSyntax LogicallyInvert(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Roslynator.CSharp.WorkspaceExtensions",
          "members": [
            "public static Task<Document> RemoveCommentsAsync(this Document document, CommentKinds kinds, CancellationToken cancellationToken = default)",
            "public static Task<Document> RemoveCommentsAsync(this Document document, TextSpan span, CommentKinds kinds, CancellationToken cancellationToken = default)",
            "public static Task<Document> RemovePreprocessorDirectivesAsync(this Document document, PreprocessorDirectiveKinds directiveKinds, CancellationToken cancellationToken = default)",
            "public static Task<Document> RemovePreprocessorDirectivesAsync(this Document document, TextSpan span, PreprocessorDirectiveKinds directiveKinds, CancellationToken cancellationToken = default)",
            "public static Task<Document> RemoveRegionAsync(this Document document, RegionInfo region, CancellationToken cancellationToken = default)",
            "public static Task<Document> RemoveTriviaAsync(this Document document, TextSpan span, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public static class Roslynator.CSharp.WorkspaceSyntaxExtensions",
          "members": [
            "public static ParenthesizedExpressionSyntax Parenthesize(this ExpressionSyntax expression, bool includeElasticTrivia = true, bool simplifiable = true)",
            "public static SyntaxToken WithFormatterAnnotation(this SyntaxToken token)",
            "public static TNode WithFormatterAnnotation<TNode>(this TNode node) where TNode : SyntaxNode",
            "public static SyntaxToken WithRenameAnnotation(this SyntaxToken token)",
            "public static SyntaxToken WithSimplifierAnnotation(this SyntaxToken token)",
            "public static TNode WithSimplifierAnnotation<TNode>(this TNode node) where TNode : SyntaxNode"
          ]
        }
      ]
    },
    {
      "type": "",
      "types": [
        {
          "type": "public interface Microsoft.CodeAnalysis.IAliasSymbol : IEquatable<ISymbol>, ISymbol",
          "members": [
            "INamespaceOrTypeSymbol Target { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader",
          "members": [
            "void AddDependencyLocation(string fullPath)",
            "Assembly LoadFromPath(string fullPath)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.IArrayTypeSymbol : IEquatable<ISymbol>, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol",
          "members": [
            "ImmutableArray<CustomModifier> CustomModifiers { get; }",
            "ITypeSymbol ElementType { get; }",
            "bool IsSZArray { get; }",
            "ImmutableArray<int> LowerBounds { get; }",
            "int Rank { get; }",
            "ImmutableArray<int> Sizes { get; }",
            "bool Equals(IArrayTypeSymbol other)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.IAssemblySymbol : IEquatable<ISymbol>, ISymbol",
          "members": [
            "INamespaceSymbol GlobalNamespace { get; }",
            "AssemblyIdentity Identity { get; }",
            "bool IsInteractive { get; }",
            "bool MightContainExtensionMethods { get; }",
            "IEnumerable<IModuleSymbol> Modules { get; }",
            "ICollection<string> NamespaceNames { get; }",
            "ICollection<string> TypeNames { get; }",
            "AssemblyMetadata GetMetadata()",
            "INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName)",
            "bool GivesAccessTo(IAssemblySymbol toAssembly)",
            "INamedTypeSymbol ResolveForwardedType(string fullyQualifiedMetadataName)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.ICompilationUnitSyntax",
          "members": [
            "SyntaxToken EndOfFileToken { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.IDiscardSymbol : IEquatable<ISymbol>, ISymbol",
          "members": [
            "ITypeSymbol Type { get; }"
          ]
        },
        "public interface Microsoft.CodeAnalysis.IDynamicTypeSymbol : IEquatable<ISymbol>, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol",
        {
          "type": "public interface Microsoft.CodeAnalysis.IErrorTypeSymbol : IEquatable<ISymbol>, INamedTypeSymbol, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol",
          "members": [
            "CandidateReason CandidateReason { get; }",
            "ImmutableArray<ISymbol> CandidateSymbols { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.IEventSymbol : IEquatable<ISymbol>, ISymbol",
          "members": [
            "IMethodSymbol AddMethod { get; }",
            "ImmutableArray<IEventSymbol> ExplicitInterfaceImplementations { get; }",
            "bool IsWindowsRuntimeEvent { get; }",
            "IEventSymbol OriginalDefinition { get; }",
            "IEventSymbol OverriddenEvent { get; }",
            "IMethodSymbol RaiseMethod { get; }",
            "IMethodSymbol RemoveMethod { get; }",
            "ITypeSymbol Type { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.IFieldSymbol : IEquatable<ISymbol>, ISymbol",
          "members": [
            "ISymbol AssociatedSymbol { get; }",
            "object ConstantValue { get; }",
            "IFieldSymbol CorrespondingTupleField { get; }",
            "ImmutableArray<CustomModifier> CustomModifiers { get; }",
            "bool HasConstantValue { get; }",
            "bool IsConst { get; }",
            "bool IsReadOnly { get; }",
            "bool IsVolatile { get; }",
            "IFieldSymbol OriginalDefinition { get; }",
            "ITypeSymbol Type { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.ILabelSymbol : IEquatable<ISymbol>, ISymbol",
          "members": [
            "IMethodSymbol ContainingMethod { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.ILocalSymbol : IEquatable<ISymbol>, ISymbol",
          "members": [
            "object ConstantValue { get; }",
            "bool HasConstantValue { get; }",
            "bool IsConst { get; }",
            "bool IsFunctionValue { get; }",
            "bool IsRef { get; }",
            "ITypeSymbol Type { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.IMethodSymbol : IEquatable<ISymbol>, ISymbol",
          "members": [
            "int Arity { get; }",
            "INamedTypeSymbol AssociatedAnonymousDelegate { get; }",
            "ISymbol AssociatedSymbol { get; }",
            "IMethodSymbol ConstructedFrom { get; }",
            "ImmutableArray<IMethodSymbol> ExplicitInterfaceImplementations { get; }",
            "bool HidesBaseMethodsByName { get; }",
            "bool IsAsync { get; }",
            "bool IsCheckedBuiltin { get; }",
            "bool IsExtensionMethod { get; }",
            "bool IsGenericMethod { get; }",
            "bool IsVararg { get; }",
            "MethodKind MethodKind { get; }",
            "IMethodSymbol OriginalDefinition { get; }",
            "IMethodSymbol OverriddenMethod { get; }",
            "ImmutableArray<IParameterSymbol> Parameters { get; }",
            "IMethodSymbol PartialDefinitionPart { get; }",
            "IMethodSymbol PartialImplementationPart { get; }",
            "ITypeSymbol ReceiverType { get; }",
            "IMethodSymbol ReducedFrom { get; }",
            "ImmutableArray<CustomModifier> RefCustomModifiers { get; }",
            "ITypeSymbol ReturnType { get; }",
            "ImmutableArray<CustomModifier> ReturnTypeCustomModifiers { get; }",
            "bool ReturnsByRef { get; }",
            "bool ReturnsVoid { get; }",
            "ImmutableArray<ITypeSymbol> TypeArguments { get; }",
            "ImmutableArray<ITypeParameterSymbol> TypeParameters { get; }",
            "IMethodSymbol Construct(params ITypeSymbol[] typeArguments)",
            "DllImportData GetDllImportData()",
            "ImmutableArray<AttributeData> GetReturnTypeAttributes()",
            "ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter)",
            "IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.IModuleSymbol : IEquatable<ISymbol>, ISymbol",
          "members": [
            "INamespaceSymbol GlobalNamespace { get; }",
            "ImmutableArray<AssemblyIdentity> ReferencedAssemblies { get; }",
            "ImmutableArray<IAssemblySymbol> ReferencedAssemblySymbols { get; }",
            "ModuleMetadata GetMetadata()",
            "INamespaceSymbol GetModuleNamespace(INamespaceSymbol namespaceSymbol)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.INamedTypeSymbol : IEquatable<ISymbol>, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol",
          "members": [
            "int Arity { get; }",
            "ISymbol AssociatedSymbol { get; }",
            "INamedTypeSymbol ConstructedFrom { get; }",
            "ImmutableArray<IMethodSymbol> Constructors { get; }",
            "IMethodSymbol DelegateInvokeMethod { get; }",
            "INamedTypeSymbol EnumUnderlyingType { get; }",
            "ImmutableArray<IMethodSymbol> InstanceConstructors { get; }",
            "bool IsComImport { get; }",
            "bool IsGenericType { get; }",
            "bool IsImplicitClass { get; }",
            "bool IsScriptClass { get; }",
            "bool IsUnboundGenericType { get; }",
            "IEnumerable<string> MemberNames { get; }",
            "bool MightContainExtensionMethods { get; }",
            "INamedTypeSymbol OriginalDefinition { get; }",
            "ImmutableArray<IMethodSymbol> StaticConstructors { get; }",
            "ImmutableArray<IFieldSymbol> TupleElements { get; }",
            "INamedTypeSymbol TupleUnderlyingType { get; }",
            "ImmutableArray<ITypeSymbol> TypeArguments { get; }",
            "ImmutableArray<ITypeParameterSymbol> TypeParameters { get; }",
            "INamedTypeSymbol Construct(params ITypeSymbol[] typeArguments)",
            "INamedTypeSymbol ConstructUnboundGenericType()",
            "ImmutableArray<CustomModifier> GetTypeArgumentCustomModifiers(int ordinal)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.INamespaceOrTypeSymbol : IEquatable<ISymbol>, ISymbol",
          "members": [
            "bool IsNamespace { get; }",
            "bool IsType { get; }",
            "ImmutableArray<ISymbol> GetMembers()",
            "ImmutableArray<ISymbol> GetMembers(string name)",
            "ImmutableArray<INamedTypeSymbol> GetTypeMembers()",
            "ImmutableArray<INamedTypeSymbol> GetTypeMembers(string name)",
            "ImmutableArray<INamedTypeSymbol> GetTypeMembers(string name, int arity)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.INamespaceSymbol : IEquatable<ISymbol>, INamespaceOrTypeSymbol, ISymbol",
          "members": [
            "ImmutableArray<INamespaceSymbol> ConstituentNamespaces { get; }",
            "Compilation ContainingCompilation { get; }",
            "bool IsGlobalNamespace { get; }",
            "NamespaceKind NamespaceKind { get; }",
            "IEnumerable<INamespaceOrTypeSymbol> GetMembers()",
            "IEnumerable<INamespaceOrTypeSymbol> GetMembers(string name)",
            "IEnumerable<INamespaceSymbol> GetNamespaceMembers()"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.IOperation",
          "members": [
            "Optional<object> ConstantValue { get; }",
            "bool IsInvalid { get; }",
            "OperationKind Kind { get; }",
            "SyntaxNode Syntax { get; }",
            "ITypeSymbol Type { get; }",
            "void Accept(OperationVisitor visitor)",
            "TResult Accept<TArgument, TResult>(OperationVisitor<TArgument, TResult> visitor, TArgument argument)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.IParameterSymbol : IEquatable<ISymbol>, ISymbol",
          "members": [
            "ImmutableArray<CustomModifier> CustomModifiers { get; }",
            "object ExplicitDefaultValue { get; }",
            "bool HasExplicitDefaultValue { get; }",
            "bool IsOptional { get; }",
            "bool IsParams { get; }",
            "bool IsThis { get; }",
            "int Ordinal { get; }",
            "IParameterSymbol OriginalDefinition { get; }",
            "ImmutableArray<CustomModifier> RefCustomModifiers { get; }",
            "RefKind RefKind { get; }",
            "ITypeSymbol Type { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.IPointerTypeSymbol : IEquatable<ISymbol>, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol",
          "members": [
            "ImmutableArray<CustomModifier> CustomModifiers { get; }",
            "ITypeSymbol PointedAtType { get; }"
          ]
        },
        "public interface Microsoft.CodeAnalysis.IPreprocessingSymbol : IEquatable<ISymbol>, ISymbol",
        {
          "type": "public interface Microsoft.CodeAnalysis.IPropertySymbol : IEquatable<ISymbol>, ISymbol",
          "members": [
            "ImmutableArray<IPropertySymbol> ExplicitInterfaceImplementations { get; }",
            "IMethodSymbol GetMethod { get; }",
            "bool IsIndexer { get; }",
            "bool IsReadOnly { get; }",
            "bool IsWithEvents { get; }",
            "bool IsWriteOnly { get; }",
            "IPropertySymbol OriginalDefinition { get; }",
            "IPropertySymbol OverriddenProperty { get; }",
            "ImmutableArray<IParameterSymbol> Parameters { get; }",
            "ImmutableArray<CustomModifier> RefCustomModifiers { get; }",
            "bool ReturnsByRef { get; }",
            "IMethodSymbol SetMethod { get; }",
            "ITypeSymbol Type { get; }",
            "ImmutableArray<CustomModifier> TypeCustomModifiers { get; }"
          ]
        },
        "public interface Microsoft.CodeAnalysis.IRangeVariableSymbol : IEquatable<ISymbol>, ISymbol",
        {
          "type": "public interface Microsoft.CodeAnalysis.ISkippedTokensTriviaSyntax",
          "members": [
            "SyntaxTokenList Tokens { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.ISourceAssemblySymbol : IEquatable<ISymbol>, IAssemblySymbol, ISymbol",
          "members": [
            "Compilation Compilation { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.IStructuredTriviaSyntax",
          "members": [
            "SyntaxTrivia ParentTrivia { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.ISymbol : IEquatable<ISymbol>",
          "members": [
            "bool CanBeReferencedByName { get; }",
            "IAssemblySymbol ContainingAssembly { get; }",
            "IModuleSymbol ContainingModule { get; }",
            "INamespaceSymbol ContainingNamespace { get; }",
            "ISymbol ContainingSymbol { get; }",
            "INamedTypeSymbol ContainingType { get; }",
            "Accessibility DeclaredAccessibility { get; }",
            "ImmutableArray<SyntaxReference> DeclaringSyntaxReferences { get; }",
            "bool HasUnsupportedMetadata { get; }",
            "bool IsAbstract { get; }",
            "bool IsDefinition { get; }",
            "bool IsExtern { get; }",
            "bool IsImplicitlyDeclared { get; }",
            "bool IsOverride { get; }",
            "bool IsSealed { get; }",
            "bool IsStatic { get; }",
            "bool IsVirtual { get; }",
            "SymbolKind Kind { get; }",
            "string Language { get; }",
            "ImmutableArray<Location> Locations { get; }",
            "string MetadataName { get; }",
            "string Name { get; }",
            "ISymbol OriginalDefinition { get; }",
            "void Accept(SymbolVisitor visitor)",
            "TResult Accept<TResult>(SymbolVisitor<TResult> visitor)",
            "ImmutableArray<AttributeData> GetAttributes()",
            "string GetDocumentationCommentId()",
            "string GetDocumentationCommentXml(CultureInfo preferredCulture = null, bool expandIncludes = false, CancellationToken cancellationToken = default)",
            "ImmutableArray<SymbolDisplayPart> ToDisplayParts(SymbolDisplayFormat format = null)",
            "string ToDisplayString(SymbolDisplayFormat format = null)",
            "ImmutableArray<SymbolDisplayPart> ToMinimalDisplayParts(SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)",
            "string ToMinimalDisplayString(SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.ITypeParameterSymbol : IEquatable<ISymbol>, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol",
          "members": [
            "ImmutableArray<ITypeSymbol> ConstraintTypes { get; }",
            "IMethodSymbol DeclaringMethod { get; }",
            "INamedTypeSymbol DeclaringType { get; }",
            "bool HasConstructorConstraint { get; }",
            "bool HasReferenceTypeConstraint { get; }",
            "bool HasValueTypeConstraint { get; }",
            "int Ordinal { get; }",
            "ITypeParameterSymbol OriginalDefinition { get; }",
            "ITypeParameterSymbol ReducedFrom { get; }",
            "TypeParameterKind TypeParameterKind { get; }",
            "VarianceKind Variance { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.ITypeSymbol : IEquatable<ISymbol>, INamespaceOrTypeSymbol, ISymbol",
          "members": [
            "ImmutableArray<INamedTypeSymbol> AllInterfaces { get; }",
            "INamedTypeSymbol BaseType { get; }",
            "ImmutableArray<INamedTypeSymbol> Interfaces { get; }",
            "bool IsAnonymousType { get; }",
            "bool IsReferenceType { get; }",
            "bool IsTupleType { get; }",
            "bool IsValueType { get; }",
            "ITypeSymbol OriginalDefinition { get; }",
            "SpecialType SpecialType { get; }",
            "TypeKind TypeKind { get; }",
            "ISymbol FindImplementationForInterfaceMember(ISymbol interfaceMember)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.FindSymbols.IFindReferencesProgress",
          "members": [
            "void OnCompleted()",
            "void OnDefinitionFound(ISymbol symbol)",
            "void OnFindInDocumentCompleted(Document document)",
            "void OnFindInDocumentStarted(Document document)",
            "void OnReferenceFound(ISymbol symbol, ReferenceLocation location)",
            "void OnStarted()",
            "void ReportProgress(int current, int maximum)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Host.IAnalyzerService : IWorkspaceService",
          "members": [
            "IAnalyzerAssemblyLoader GetLoader()"
          ]
        },
        "public interface Microsoft.CodeAnalysis.Host.ILanguageService",
        {
          "type": "public interface Microsoft.CodeAnalysis.Host.IPersistentStorage : IDisposable",
          "members": [
            "Task<Stream> ReadStreamAsync(string name, CancellationToken cancellationToken = default)",
            "Task<Stream> ReadStreamAsync(Document document, string name, CancellationToken cancellationToken = default)",
            "Task<Stream> ReadStreamAsync(Project project, string name, CancellationToken cancellationToken = default)",
            "Task<bool> WriteStreamAsync(string name, Stream stream, CancellationToken cancellationToken = default)",
            "Task<bool> WriteStreamAsync(Document document, string name, Stream stream, CancellationToken cancellationToken = default)",
            "Task<bool> WriteStreamAsync(Project project, string name, Stream stream, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Host.IPersistentStorageService : IWorkspaceService",
          "members": [
            "IPersistentStorage GetStorage(Solution solution)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Host.ITemporaryStorageService : IWorkspaceService",
          "members": [
            "ITemporaryStreamStorage CreateTemporaryStreamStorage(CancellationToken cancellationToken = default)",
            "ITemporaryTextStorage CreateTemporaryTextStorage(CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Host.ITemporaryStreamStorage : IDisposable",
          "members": [
            "Stream ReadStream(CancellationToken cancellationToken = default)",
            "Task<Stream> ReadStreamAsync(CancellationToken cancellationToken = default)",
            "void WriteStream(Stream stream, CancellationToken cancellationToken = default)",
            "Task WriteStreamAsync(Stream stream, CancellationToken cancellationToken = default)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Host.ITemporaryTextStorage : IDisposable",
          "members": [
            "SourceText ReadText(CancellationToken cancellationToken = default)",
            "Task<SourceText> ReadTextAsync(CancellationToken cancellationToken = default)",
            "void WriteText(SourceText text, CancellationToken cancellationToken = default)",
            "Task WriteTextAsync(SourceText text, CancellationToken cancellationToken = default)"
          ]
        },
        "public interface Microsoft.CodeAnalysis.Host.IWorkspaceService",
        {
          "type": "public interface Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory",
          "members": [
            "ILanguageService CreateLanguageService(HostLanguageServices languageServices)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory",
          "members": [
            "IWorkspaceService CreateService(HostWorkspaceServices workspaceServices)"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Options.IOption",
          "members": [
            "object DefaultValue { get; }",
            "string Feature { get; }",
            "bool IsPerLanguage { get; }",
            "string Name { get; }",
            "ImmutableArray<OptionStorageLocation> StorageLocations { get; }",
            "Type Type { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IAddressOfExpression : IOperation",
          "members": [
            "IOperation Reference { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IArgument : IOperation",
          "members": [
            "ArgumentKind ArgumentKind { get; }",
            "IOperation InConversion { get; }",
            "IOperation OutConversion { get; }",
            "IParameterSymbol Parameter { get; }",
            "IOperation Value { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IArrayCreationExpression : IOperation",
          "members": [
            "ImmutableArray<IOperation> DimensionSizes { get; }",
            "ITypeSymbol ElementType { get; }",
            "IArrayInitializer Initializer { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IArrayElementReferenceExpression : IOperation",
          "members": [
            "IOperation ArrayReference { get; }",
            "ImmutableArray<IOperation> Indices { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IArrayInitializer : IOperation",
          "members": [
            "ImmutableArray<IOperation> ElementValues { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IAssignmentExpression : IOperation",
          "members": [
            "IOperation Target { get; }",
            "IOperation Value { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IAwaitExpression : IOperation",
          "members": [
            "IOperation AwaitedValue { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IBinaryOperatorExpression : IOperation, IHasOperatorMethodExpression",
          "members": [
            "BinaryOperationKind BinaryOperationKind { get; }",
            "IOperation LeftOperand { get; }",
            "IOperation RightOperand { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IBlockStatement : IOperation",
          "members": [
            "ImmutableArray<ILocalSymbol> Locals { get; }",
            "ImmutableArray<IOperation> Statements { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IBranchStatement : IOperation",
          "members": [
            "BranchKind BranchKind { get; }",
            "ILabelSymbol Target { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ICaseClause : IOperation",
          "members": [
            "CaseKind CaseKind { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ICatchClause : IOperation",
          "members": [
            "ITypeSymbol CaughtType { get; }",
            "ILocalSymbol ExceptionLocal { get; }",
            "IOperation Filter { get; }",
            "IBlockStatement Handler { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ICompoundAssignmentExpression : IOperation, IAssignmentExpression, IHasOperatorMethodExpression",
          "members": [
            "BinaryOperationKind BinaryOperationKind { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IConditionalAccessExpression : IOperation",
          "members": [
            "IOperation ConditionalInstance { get; }",
            "IOperation ConditionalValue { get; }"
          ]
        },
        "public interface Microsoft.CodeAnalysis.Semantics.IConditionalAccessInstanceExpression : IOperation",
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IConditionalChoiceExpression : IOperation",
          "members": [
            "IOperation Condition { get; }",
            "IOperation IfFalseValue { get; }",
            "IOperation IfTrueValue { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IConversionExpression : IOperation, IHasOperatorMethodExpression",
          "members": [
            "ConversionKind ConversionKind { get; }",
            "bool IsExplicit { get; }",
            "IOperation Operand { get; }"
          ]
        },
        "public interface Microsoft.CodeAnalysis.Semantics.IDefaultValueExpression : IOperation",
        "public interface Microsoft.CodeAnalysis.Semantics.IEmptyStatement : IOperation",
        "public interface Microsoft.CodeAnalysis.Semantics.IEndStatement : IOperation",
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IEventAssignmentExpression : IOperation",
          "members": [
            "bool Adds { get; }",
            "IEventSymbol Event { get; }",
            "IOperation EventInstance { get; }",
            "IOperation HandlerValue { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IEventReferenceExpression : IOperation, IMemberReferenceExpression",
          "members": [
            "IEventSymbol Event { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IExpressionStatement : IOperation",
          "members": [
            "IOperation Expression { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IFieldInitializer : IOperation, ISymbolInitializer",
          "members": [
            "ImmutableArray<IFieldSymbol> InitializedFields { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IFieldReferenceExpression : IOperation, IMemberReferenceExpression",
          "members": [
            "IFieldSymbol Field { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IFixedStatement : IOperation",
          "members": [
            "IOperation Body { get; }",
            "IVariableDeclarationStatement Variables { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IForEachLoopStatement : IOperation, ILoopStatement",
          "members": [
            "IOperation Collection { get; }",
            "ILocalSymbol IterationVariable { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IForLoopStatement : IOperation, IForWhileUntilLoopStatement, ILoopStatement",
          "members": [
            "ImmutableArray<IOperation> AtLoopBottom { get; }",
            "ImmutableArray<IOperation> Before { get; }",
            "ImmutableArray<ILocalSymbol> Locals { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IForWhileUntilLoopStatement : IOperation, ILoopStatement",
          "members": [
            "IOperation Condition { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression : IOperation",
          "members": [
            "ImmutableArray<IArgument> ArgumentsInEvaluationOrder { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression : IOperation",
          "members": [
            "IMethodSymbol OperatorMethod { get; }",
            "bool UsesOperatorMethod { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IIfStatement : IOperation",
          "members": [
            "IOperation Condition { get; }",
            "IOperation IfFalseStatement { get; }",
            "IOperation IfTrueStatement { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IIncrementExpression : IOperation, IAssignmentExpression, ICompoundAssignmentExpression, IHasOperatorMethodExpression",
          "members": [
            "UnaryOperationKind IncrementOperationKind { get; }"
          ]
        },
        "public interface Microsoft.CodeAnalysis.Semantics.IIndexedPropertyReferenceExpression : IOperation, IHasArgumentsExpression, IMemberReferenceExpression, IPropertyReferenceExpression",
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IInstanceReferenceExpression : IOperation",
          "members": [
            "InstanceReferenceKind InstanceReferenceKind { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IInvalidExpression : IOperation",
          "members": [
            "ImmutableArray<IOperation> Children { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IInvalidStatement : IOperation",
          "members": [
            "ImmutableArray<IOperation> Children { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IInvocationExpression : IOperation, IHasArgumentsExpression",
          "members": [
            "IOperation Instance { get; }",
            "bool IsVirtual { get; }",
            "IMethodSymbol TargetMethod { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IIsTypeExpression : IOperation",
          "members": [
            "ITypeSymbol IsType { get; }",
            "IOperation Operand { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ILabelStatement : IOperation",
          "members": [
            "ILabelSymbol Label { get; }",
            "IOperation LabeledStatement { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ILambdaExpression : IOperation",
          "members": [
            "IBlockStatement Body { get; }",
            "IMethodSymbol Signature { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ILateBoundMemberReferenceExpression : IOperation",
          "members": [
            "IOperation Instance { get; }",
            "string MemberName { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ILiteralExpression : IOperation",
          "members": [
            "string Text { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ILocalReferenceExpression : IOperation",
          "members": [
            "ILocalSymbol Local { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ILockStatement : IOperation",
          "members": [
            "IOperation Body { get; }",
            "IOperation LockedObject { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ILoopStatement : IOperation",
          "members": [
            "IOperation Body { get; }",
            "LoopKind LoopKind { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression : IOperation",
          "members": [
            "IOperation Instance { get; }",
            "ISymbol Member { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IMethodBindingExpression : IOperation, IMemberReferenceExpression",
          "members": [
            "bool IsVirtual { get; }",
            "IMethodSymbol Method { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.INullCoalescingExpression : IOperation",
          "members": [
            "IOperation PrimaryOperand { get; }",
            "IOperation SecondaryOperand { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IObjectCreationExpression : IOperation, IHasArgumentsExpression",
          "members": [
            "IMethodSymbol Constructor { get; }",
            "ImmutableArray<IOperation> Initializers { get; }"
          ]
        },
        "public interface Microsoft.CodeAnalysis.Semantics.IOmittedArgumentExpression : IOperation",
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IParameterInitializer : IOperation, ISymbolInitializer",
          "members": [
            "IParameterSymbol Parameter { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IParameterReferenceExpression : IOperation",
          "members": [
            "IParameterSymbol Parameter { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IParenthesizedExpression : IOperation",
          "members": [
            "IOperation Operand { get; }"
          ]
        },
        "public interface Microsoft.CodeAnalysis.Semantics.IPlaceholderExpression : IOperation",
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IPointerIndirectionReferenceExpression : IOperation",
          "members": [
            "IOperation Pointer { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IPropertyInitializer : IOperation, ISymbolInitializer",
          "members": [
            "IPropertySymbol InitializedProperty { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IPropertyReferenceExpression : IOperation, IMemberReferenceExpression",
          "members": [
            "IPropertySymbol Property { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IRangeCaseClause : IOperation, ICaseClause",
          "members": [
            "IOperation MaximumValue { get; }",
            "IOperation MinimumValue { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IRelationalCaseClause : IOperation, ICaseClause",
          "members": [
            "BinaryOperationKind Relation { get; }",
            "IOperation Value { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IReturnStatement : IOperation",
          "members": [
            "IOperation ReturnedValue { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ISingleValueCaseClause : IOperation, ICaseClause",
          "members": [
            "BinaryOperationKind Equality { get; }",
            "IOperation Value { get; }"
          ]
        },
        "public interface Microsoft.CodeAnalysis.Semantics.ISizeOfExpression : IOperation, ITypeOperationExpression",
        "public interface Microsoft.CodeAnalysis.Semantics.IStopStatement : IOperation",
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ISwitchCase : IOperation",
          "members": [
            "ImmutableArray<IOperation> Body { get; }",
            "ImmutableArray<ICaseClause> Clauses { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ISwitchStatement : IOperation",
          "members": [
            "ImmutableArray<ISwitchCase> Cases { get; }",
            "IOperation Value { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ISymbolInitializer : IOperation",
          "members": [
            "IOperation Value { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ISyntheticLocalReferenceExpression : IOperation",
          "members": [
            "IOperation ContainingStatement { get; }",
            "SyntheticLocalKind SyntheticLocalKind { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IThrowStatement : IOperation",
          "members": [
            "IOperation ThrownObject { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ITryStatement : IOperation",
          "members": [
            "IBlockStatement Body { get; }",
            "ImmutableArray<ICatchClause> Catches { get; }",
            "IBlockStatement FinallyHandler { get; }"
          ]
        },
        "public interface Microsoft.CodeAnalysis.Semantics.ITypeOfExpression : IOperation, ITypeOperationExpression",
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.ITypeOperationExpression : IOperation",
          "members": [
            "ITypeSymbol TypeOperand { get; }"
          ]
        },
        "public interface Microsoft.CodeAnalysis.Semantics.ITypeParameterObjectCreationExpression : IOperation",
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IUnaryOperatorExpression : IOperation, IHasOperatorMethodExpression",
          "members": [
            "IOperation Operand { get; }",
            "UnaryOperationKind UnaryOperationKind { get; }"
          ]
        },
        "public interface Microsoft.CodeAnalysis.Semantics.IUnboundLambdaExpression : IOperation",
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IUsingStatement : IOperation",
          "members": [
            "IOperation Body { get; }",
            "IVariableDeclarationStatement Declaration { get; }",
            "IOperation Value { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IVariableDeclaration : IOperation",
          "members": [
            "IOperation Initializer { get; }",
            "ImmutableArray<ILocalSymbol> Variables { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IVariableDeclarationStatement : IOperation",
          "members": [
            "ImmutableArray<IVariableDeclaration> Declarations { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IWhileUntilLoopStatement : IOperation, IForWhileUntilLoopStatement, ILoopStatement",
          "members": [
            "bool IsTopTest { get; }",
            "bool IsWhile { get; }"
          ]
        },
        {
          "type": "public interface Microsoft.CodeAnalysis.Semantics.IWithStatement : IOperation",
          "members": [
            "IOperation Body { get; }",
            "IOperation Value { get; }"
          ]
        },
        {
          "type": "public interface Roslynator.ISelection<T> : IReadOnlyList<T>",
          "members": [
            "int FirstIndex { get; }",
            "int LastIndex { get; }",
            "T First()",
            "T Last()"
          ]
        }
      ]
    }
  ]
}